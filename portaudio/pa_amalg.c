#include "portaudio.h"

#ifndef PA_TYPES_H
#define PA_TYPES_H

/* 
 * Portable Audio I/O Library
 * integer type definitions
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2006 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Definition of 16 and 32 bit integer types (PaInt16, PaInt32 etc)

 SIZEOF_SHORT, SIZEOF_INT and SIZEOF_LONG are set by the configure script
 when it is used. Otherwise we default to the common 32 bit values, if your
 platform doesn't use configure, and doesn't use the default values below
 you will need to explicitly define these symbols in your make file.

 A PA_VALIDATE_SIZES macro is provided to assert that the values set in this
 file are correct.
*/

#ifndef SIZEOF_SHORT
#define SIZEOF_SHORT 2
#endif

#ifndef SIZEOF_INT
#define SIZEOF_INT 4
#endif

#ifndef SIZEOF_LONG
#define SIZEOF_LONG 4
#endif


#if SIZEOF_SHORT == 2
typedef signed short PaInt16;
typedef unsigned short PaUint16;
#elif SIZEOF_INT == 2
typedef signed int PaInt16;
typedef unsigned int PaUint16;
#else
#error pa_types.h was unable to determine which type to use for 16bit integers on the target platform
#endif

#if SIZEOF_SHORT == 4
typedef signed short PaInt32;
typedef unsigned short PaUint32;
#elif SIZEOF_INT == 4
typedef signed int PaInt32;
typedef unsigned int PaUint32;
#elif SIZEOF_LONG == 4
typedef signed long PaInt32;
typedef unsigned long PaUint32;
#else
#error pa_types.h was unable to determine which type to use for 32bit integers on the target platform
#endif


/* PA_VALIDATE_TYPE_SIZES compares the size of the integer types at runtime to
 ensure that PortAudio was configured correctly, and raises an assertion if
 they don't match the expected values. <assert.h> must be included in the
 context in which this macro is used.
*/
#define PA_VALIDATE_TYPE_SIZES \
    { \
        assert( "PortAudio: type sizes are not correct in pa_types.h" && sizeof( PaUint16 ) == 2 ); \
        assert( "PortAudio: type sizes are not correct in pa_types.h" && sizeof( PaInt16 ) == 2 ); \
        assert( "PortAudio: type sizes are not correct in pa_types.h" && sizeof( PaUint32 ) == 4 ); \
        assert( "PortAudio: type sizes are not correct in pa_types.h" && sizeof( PaInt32 ) == 4 ); \
    }


#endif /* PA_TYPES_H */

#ifndef PA_ALLOCATION_H
#define PA_ALLOCATION_H
/*
 * $Id$
 * Portable Audio I/O Library allocation context header
 * memory allocation context for tracking allocation groups
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Allocation Group prototypes. An Allocation Group makes it easy to
 allocate multiple blocks of memory and free them all at once.
 
 An allocation group is useful for keeping track of multiple blocks
 of memory which are allocated at the same time (such as during initialization)
 and need to be deallocated at the same time. The allocation group maintains
 a list of allocated blocks, and can free all allocations at once. This
 can be usefull for cleaning up after a partially initialized object fails.

 The allocation group implementation is built on top of the lower
 level allocation functions defined in pa_util.h
*/


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


typedef struct
{
    long linkCount;
    struct PaUtilAllocationGroupLink *linkBlocks;
    struct PaUtilAllocationGroupLink *spareLinks;
    struct PaUtilAllocationGroupLink *allocations;
}PaUtilAllocationGroup;



/** Create an allocation group.
*/
PaUtilAllocationGroup* PaUtil_CreateAllocationGroup( void );

/** Destroy an allocation group, but not the memory allocated through the group.
*/
void PaUtil_DestroyAllocationGroup( PaUtilAllocationGroup* group );

/** Allocate a block of memory though an allocation group.
*/
void* PaUtil_GroupAllocateMemory( PaUtilAllocationGroup* group, long size );

/** Free a block of memory that was previously allocated though an allocation
 group. Calling this function is a relatively time consuming operation.
 Under normal circumstances clients should call PaUtil_FreeAllAllocations to
 free all allocated blocks simultaneously.
 @see PaUtil_FreeAllAllocations
*/
void PaUtil_GroupFreeMemory( PaUtilAllocationGroup* group, void *buffer );

/** Free all blocks of memory which have been allocated through the allocation
 group. This function doesn't destroy the group itself.
*/
void PaUtil_FreeAllAllocations( PaUtilAllocationGroup* group );


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_ALLOCATION_H */
#ifndef PA_CONVERTERS_H
#define PA_CONVERTERS_H
/*
 * $Id$
 * Portable Audio I/O Library sample conversion mechanism
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Conversion functions used to convert buffers of samples from one
 format to another.
*/


// (amalg) #include "portaudio.h"  /* for PaSampleFormat */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


struct PaUtilTriangularDitherGenerator;


/** Choose an available sample format which is most appropriate for
 representing the requested format. If the requested format is not available
 higher quality formats are considered before lower quality formates.
 @param availableFormats A variable containing the logical OR of all available
 formats.
 @param format The desired format.
 @return The most appropriate available format for representing the requested
 format.
*/
PaSampleFormat PaUtil_SelectClosestAvailableFormat(
        PaSampleFormat availableFormats, PaSampleFormat format );


/* high level conversions functions for use by implementations */


/** The generic sample converter prototype. Sample converters convert count
    samples from sourceBuffer to destinationBuffer. The actual type of the data
    pointed to by these parameters varys for different converter functions.
    @param destinationBuffer A pointer to the first sample of the destination.
    @param destinationStride An offset between successive destination samples
    expressed in samples (not bytes.) It may be negative.
    @param sourceBuffer A pointer to the first sample of the source.
    @param sourceStride An offset between successive source samples
    expressed in samples (not bytes.) It may be negative.
    @param count The number of samples to convert.
    @param ditherState State information used to calculate dither. Converters
    that do not perform dithering will ignore this parameter, in which case
    NULL or invalid dither state may be passed.
*/
typedef void PaUtilConverter(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator );


/** Find a sample converter function for the given source and destinations
    formats and flags (clip and dither.)
    @return
    A pointer to a PaUtilConverter which will perform the requested
    conversion, or NULL if the given format conversion is not supported.
    For conversions where clipping or dithering is not necessary, the
    clip and dither flags are ignored and a non-clipping or dithering
    version is returned.
    If the source and destination formats are the same, a function which
    copies data of the appropriate size will be returned.
*/
PaUtilConverter* PaUtil_SelectConverter( PaSampleFormat sourceFormat,
        PaSampleFormat destinationFormat, PaStreamFlags flags );


/** The generic buffer zeroer prototype. Buffer zeroers copy count zeros to
    destinationBuffer. The actual type of the data pointed to varys for
    different zeroer functions.
    @param destinationBuffer A pointer to the first sample of the destination.
    @param destinationStride An offset between successive destination samples
    expressed in samples (not bytes.) It may be negative.
    @param count The number of samples to zero.
*/
typedef void PaUtilZeroer(
    void *destinationBuffer, signed int destinationStride, unsigned int count );

    
/** Find a buffer zeroer function for the given destination format.
    @return
    A pointer to a PaUtilZeroer which will perform the requested
    zeroing.
*/
PaUtilZeroer* PaUtil_SelectZeroer( PaSampleFormat destinationFormat );

/*----------------------------------------------------------------------------*/
/* low level functions and data structures which may be used for
    substituting conversion functions */


/** The type used to store all sample conversion functions.
    @see paConverters;
*/
typedef struct{
    PaUtilConverter *Float32_To_Int32;
    PaUtilConverter *Float32_To_Int32_Dither;
    PaUtilConverter *Float32_To_Int32_Clip;
    PaUtilConverter *Float32_To_Int32_DitherClip;

    PaUtilConverter *Float32_To_Int24;
    PaUtilConverter *Float32_To_Int24_Dither;
    PaUtilConverter *Float32_To_Int24_Clip;
    PaUtilConverter *Float32_To_Int24_DitherClip;
    
    PaUtilConverter *Float32_To_Int16;
    PaUtilConverter *Float32_To_Int16_Dither;
    PaUtilConverter *Float32_To_Int16_Clip;
    PaUtilConverter *Float32_To_Int16_DitherClip;

    PaUtilConverter *Float32_To_Int8;
    PaUtilConverter *Float32_To_Int8_Dither;
    PaUtilConverter *Float32_To_Int8_Clip;
    PaUtilConverter *Float32_To_Int8_DitherClip;

    PaUtilConverter *Float32_To_UInt8;
    PaUtilConverter *Float32_To_UInt8_Dither;
    PaUtilConverter *Float32_To_UInt8_Clip;
    PaUtilConverter *Float32_To_UInt8_DitherClip;

    PaUtilConverter *Int32_To_Float32;
    PaUtilConverter *Int32_To_Int24;
    PaUtilConverter *Int32_To_Int24_Dither;
    PaUtilConverter *Int32_To_Int16;
    PaUtilConverter *Int32_To_Int16_Dither;
    PaUtilConverter *Int32_To_Int8;
    PaUtilConverter *Int32_To_Int8_Dither;
    PaUtilConverter *Int32_To_UInt8;
    PaUtilConverter *Int32_To_UInt8_Dither;

    PaUtilConverter *Int24_To_Float32;
    PaUtilConverter *Int24_To_Int32;
    PaUtilConverter *Int24_To_Int16;
    PaUtilConverter *Int24_To_Int16_Dither;
    PaUtilConverter *Int24_To_Int8;
    PaUtilConverter *Int24_To_Int8_Dither;
    PaUtilConverter *Int24_To_UInt8;
    PaUtilConverter *Int24_To_UInt8_Dither;

    PaUtilConverter *Int16_To_Float32;
    PaUtilConverter *Int16_To_Int32;
    PaUtilConverter *Int16_To_Int24;
    PaUtilConverter *Int16_To_Int8;
    PaUtilConverter *Int16_To_Int8_Dither;
    PaUtilConverter *Int16_To_UInt8;
    PaUtilConverter *Int16_To_UInt8_Dither;

    PaUtilConverter *Int8_To_Float32;
    PaUtilConverter *Int8_To_Int32;
    PaUtilConverter *Int8_To_Int24;
    PaUtilConverter *Int8_To_Int16;
    PaUtilConverter *Int8_To_UInt8;
    
    PaUtilConverter *UInt8_To_Float32;
    PaUtilConverter *UInt8_To_Int32;
    PaUtilConverter *UInt8_To_Int24;
    PaUtilConverter *UInt8_To_Int16;
    PaUtilConverter *UInt8_To_Int8;

    PaUtilConverter *Copy_8_To_8;       /* copy without any conversion */
    PaUtilConverter *Copy_16_To_16;     /* copy without any conversion */
    PaUtilConverter *Copy_24_To_24;     /* copy without any conversion */
    PaUtilConverter *Copy_32_To_32;     /* copy without any conversion */
} PaUtilConverterTable;


/** A table of pointers to all required converter functions.
    PaUtil_SelectConverter() uses this table to lookup the appropriate
    conversion functions. The fields of this structure are initialized
    with default conversion functions. Fields may be NULL, indicating that
    no conversion function is available. User code may substitue optimised
    conversion functions by assigning different function pointers to
    these fields.

    @note
    If the PA_NO_STANDARD_CONVERTERS preprocessor variable is defined,
    PortAudio's standard converters will not be compiled, and all fields
    of this structure will be initialized to NULL. In such cases, users
    should supply their own conversion functions if the require PortAudio
    to open a stream that requires sample conversion.

    @see PaUtilConverterTable, PaUtilConverter, PaUtil_SelectConverter
*/
extern PaUtilConverterTable paConverters;


/** The type used to store all buffer zeroing functions.
    @see paZeroers;
*/
typedef struct{
    PaUtilZeroer *ZeroU8; /* unsigned 8 bit, zero == 128 */
    PaUtilZeroer *Zero8;
    PaUtilZeroer *Zero16;
    PaUtilZeroer *Zero24;
    PaUtilZeroer *Zero32;
} PaUtilZeroerTable;


/** A table of pointers to all required zeroer functions.
    PaUtil_SelectZeroer() uses this table to lookup the appropriate
    conversion functions. The fields of this structure are initialized
    with default conversion functions. User code may substitue optimised
    conversion functions by assigning different function pointers to
    these fields.

    @note
    If the PA_NO_STANDARD_ZEROERS preprocessor variable is defined,
    PortAudio's standard zeroers will not be compiled, and all fields
    of this structure will be initialized to NULL. In such cases, users
    should supply their own zeroing functions for the sample sizes which
    they intend to use.

    @see PaUtilZeroerTable, PaUtilZeroer, PaUtil_SelectZeroer
*/
extern PaUtilZeroerTable paZeroers;

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_CONVERTERS_H */
#ifndef PA_CPULOAD_H
#define PA_CPULOAD_H
/*
 * $Id$
 * Portable Audio I/O Library CPU Load measurement functions
 * Portable CPU load measurement facility.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 2002 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Functions to assist in measuring the CPU utilization of a callback
 stream. Used to implement the Pa_GetStreamCpuLoad() function.
*/


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


typedef struct {
    double samplingPeriod;
    double measurementStartTime;
    double averageLoad;
} PaUtilCpuLoadMeasurer; /**< @todo need better name than measurer */

void PaUtil_InitializeCpuLoadMeasurer( PaUtilCpuLoadMeasurer* measurer, double sampleRate );
void PaUtil_BeginCpuLoadMeasurement( PaUtilCpuLoadMeasurer* measurer );
void PaUtil_EndCpuLoadMeasurement( PaUtilCpuLoadMeasurer* measurer, unsigned long framesProcessed );
void PaUtil_ResetCpuLoadMeasurer( PaUtilCpuLoadMeasurer* measurer );
double PaUtil_GetCpuLoad( PaUtilCpuLoadMeasurer* measurer );


#ifdef __cplusplus
}
#endif /* __cplusplus */     
#endif /* PA_CPULOAD_H */
#ifndef PA_LOG_H
#define PA_LOG_H
/*
 * Log file redirector function
 * Copyright (c) 1999-2006 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/** @file
 @ingroup common_src
*/


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */



void PaUtil_DebugPrint( const char *format, ... );


/*
    The basic format for log messages is described below. If you need to
    add any log messages, please follow this format.

    Function entry (void function):

        "FunctionName called.\n"

    Function entry (non void function):

        "FunctionName called:\n"
        "\tParam1Type param1: param1Value\n"
        "\tParam2Type param2: param2Value\n"      (etc...)


    Function exit (no return value):

        "FunctionName returned.\n"

    Function exit (simple return value):

        "FunctionName returned:\n"
        "\tReturnType: returnValue\n"

    If the return type is an error code, the error text is displayed in ()

    If the return type is not an error code, but has taken a special value
    because an error occurred, then the reason for the error is shown in []

    If the return type is a struct ptr, the struct is dumped.

    See the code below for examples
*/

/** PA_DEBUG() provides a simple debug message printing facility. The macro
 passes it's argument to a printf-like function called PaUtil_DebugPrint()
 which prints to stderr and always flushes the stream after printing.
 Because preprocessor macros cannot directly accept variable length argument
 lists, calls to the macro must include an additional set of parenthesis, eg:
 PA_DEBUG(("errorno: %d", 1001 ));
*/


#ifdef PA_ENABLE_DEBUG_OUTPUT
#define PA_DEBUG(x) PaUtil_DebugPrint x ;
#else
#define PA_DEBUG(x)
#endif


#ifdef PA_LOG_API_CALLS
#define PA_LOGAPI(x) PaUtil_DebugPrint x 

#define PA_LOGAPI_ENTER(functionName) PaUtil_DebugPrint( functionName " called.\n" )

#define PA_LOGAPI_ENTER_PARAMS(functionName) PaUtil_DebugPrint( functionName " called:\n" )

#define PA_LOGAPI_EXIT(functionName) PaUtil_DebugPrint( functionName " returned.\n" )

#define PA_LOGAPI_EXIT_PAERROR( functionName, result ) \
	PaUtil_DebugPrint( functionName " returned:\n" ); \
	PaUtil_DebugPrint("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) )

#define PA_LOGAPI_EXIT_T( functionName, resultFormatString, result ) \
	PaUtil_DebugPrint( functionName " returned:\n" ); \
	PaUtil_DebugPrint("\t" resultFormatString "\n", result )

#define PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( functionName, positiveResultFormatString, result ) \
	PaUtil_DebugPrint( functionName " returned:\n" ); \
	if( result > 0 ) \
        PaUtil_DebugPrint("\t" positiveResultFormatString "\n", result ); \
    else \
        PaUtil_DebugPrint("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) )
#else
#define PA_LOGAPI(x)
#define PA_LOGAPI_ENTER(functionName)
#define PA_LOGAPI_ENTER_PARAMS(functionName)
#define PA_LOGAPI_EXIT(functionName)
#define PA_LOGAPI_EXIT_PAERROR( functionName, result )
#define PA_LOGAPI_EXIT_T( functionName, resultFormatString, result )
#define PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( functionName, positiveResultFormatString, result )
#endif

    
typedef void (*PaUtilLogCallback ) (const char *log);

/**
    Install user provided log function
*/
void PaUtil_SetDebugPrintFunction(PaUtilLogCallback  cb);



#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_LOG_H */
#ifndef PA_DITHER_H
#define PA_DITHER_H
/*
 * $Id$
 * Portable Audio I/O Library triangular dither generator
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Functions for generating dither noise
*/

// (amalg) #include "pa_types.h"


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

/* Note that the linear congruential algorithm requires 32 bit integers
 * because it uses arithmetic overflow. So use PaUint32 instead of
 * unsigned long so it will work on 64 bit systems.
 */

/** @brief State needed to generate a dither signal */
typedef struct PaUtilTriangularDitherGenerator{
    PaUint32 previous;
    PaUint32 randSeed1;
    PaUint32 randSeed2;
} PaUtilTriangularDitherGenerator;


/** @brief Initialize dither state */
void PaUtil_InitializeTriangularDitherState( PaUtilTriangularDitherGenerator *ditherState );


/**
 @brief Calculate 2 LSB dither signal with a triangular distribution.
 Ranged for adding to a 1 bit right-shifted 32 bit integer
 prior to >>15. eg:
<pre>
    signed long in = *
    signed long dither = PaUtil_Generate16BitTriangularDither( ditherState );
    signed short out = (signed short)(((in>>1) + dither) >> 15);
</pre>
 @return
 A signed 32-bit integer with a range of +32767 to -32768
*/
PaInt32 PaUtil_Generate16BitTriangularDither( PaUtilTriangularDitherGenerator *ditherState );


/**
 @brief Calculate 2 LSB dither signal with a triangular distribution.
 Ranged for adding to a pre-scaled float.
<pre>
    float in = *
    float dither = PaUtil_GenerateFloatTriangularDither( ditherState );
    // use smaller scaler to prevent overflow when we add the dither
    signed short out = (signed short)(in*(32766.0f) + dither );
</pre>
 @return
 A float with a range of -2.0 to +1.99999.
*/
float PaUtil_GenerateFloatTriangularDither( PaUtilTriangularDitherGenerator *ditherState );



#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_DITHER_H */
#ifndef PA_ENDIANNESS_H
#define PA_ENDIANNESS_H
/*
 * $Id$
 * Portable Audio I/O Library current platform endianness macros
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Configure endianness symbols for the target processor.

 Arrange for either the PA_LITTLE_ENDIAN or PA_BIG_ENDIAN preprocessor symbols
 to be defined. The one that is defined reflects the endianness of the target
 platform and may be used to implement conditional compilation of byte-order
 dependent code.

 If either PA_LITTLE_ENDIAN or PA_BIG_ENDIAN is defined already, then no attempt
 is made to override that setting. This may be useful if you have a better way
 of determining the platform's endianness. The autoconf mechanism uses this for
 example.

 A PA_VALIDATE_ENDIANNESS macro is provided to compare the compile time
 and runtime endiannes and raise an assertion if they don't match.
*/


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

/* If this is an apple, we need to do detect endianness this way */
#if defined(__APPLE__)
    /* we need to do some endian detection that is sensitive to harware arch */
    #if defined(__LITTLE_ENDIAN__)
       #if !defined( PA_LITTLE_ENDIAN )
          #define PA_LITTLE_ENDIAN
       #endif
       #if defined( PA_BIG_ENDIAN )
          #undef PA_BIG_ENDIAN
       #endif
    #else
       #if !defined( PA_BIG_ENDIAN )
          #define PA_BIG_ENDIAN
       #endif
       #if defined( PA_LITTLE_ENDIAN )
          #undef PA_LITTLE_ENDIAN
       #endif
    #endif
#else
    /* this is not an apple, so first check the existing defines, and, failing that,
       detect well-known architechtures. */

    #if defined(PA_LITTLE_ENDIAN) || defined(PA_BIG_ENDIAN)
        /* endianness define has been set externally, such as by autoconf */

        #if defined(PA_LITTLE_ENDIAN) && defined(PA_BIG_ENDIAN)
        #error both PA_LITTLE_ENDIAN and PA_BIG_ENDIAN have been defined externally to pa_endianness.h - only one endianness at a time please
        #endif

    #else
        /* endianness define has not been set externally */

        /* set PA_LITTLE_ENDIAN or PA_BIG_ENDIAN by testing well known platform specific defines */

        #if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || defined(LITTLE_ENDIAN) || defined(__i386) || defined(_M_IX86) || defined(__x86_64__)
            #define PA_LITTLE_ENDIAN /* win32, assume intel byte order */
        #else
            #define PA_BIG_ENDIAN
        #endif
    #endif

    #if !defined(PA_LITTLE_ENDIAN) && !defined(PA_BIG_ENDIAN)
        /*
         If the following error is raised, you either need to modify the code above
         to automatically determine the endianness from other symbols defined on your
         platform, or define either PA_LITTLE_ENDIAN or PA_BIG_ENDIAN externally.
        */
        #error pa_endianness.h was unable to automatically determine the endianness of the target platform
    #endif

#endif


/* PA_VALIDATE_ENDIANNESS compares the compile time and runtime endianness,
 and raises an assertion if they don't match. <assert.h> must be included in
 the context in which this macro is used.
*/
#if defined(NDEBUG)
    #define PA_VALIDATE_ENDIANNESS
#else
    #if defined(PA_LITTLE_ENDIAN)
        #define PA_VALIDATE_ENDIANNESS \
        { \
            const long nativeOne = 1; \
            assert( "PortAudio: compile time and runtime endianness don't match" && (((char *)&nativeOne)[0]) == 1 ); \
        }
    #elif defined(PA_BIG_ENDIAN)
        #define PA_VALIDATE_ENDIANNESS \
        { \
            const long nativeOne = 1; \
            assert( "PortAudio: compile time and runtime endianness don't match" && (((char *)&nativeOne)[0]) == 0 ); \
        }
    #endif
#endif


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_ENDIANNESS_H */
#define PA_GIT_REVISION unknown
#ifndef PA_HOSTAPI_H
#define PA_HOSTAPI_H
/*
 * $Id$
 * Portable Audio I/O Library
 * host api representation
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Interfaces and representation structures used by pa_front.c 
 to manage and communicate with host API implementations.
*/

// (amalg) #include "portaudio.h"

/**
The PA_NO_* host API macros are now deprecated in favor of PA_USE_* macros.
PA_USE_* indicates whether a particular host API will be initialized by PortAudio.
An undefined or 0 value indicates that the host API will not be used. A value of 1 
indicates that the host API will be used. PA_USE_* macros should be left undefined 
or defined to either 0 or 1.

The code below ensures that PA_USE_* macros are always defined and have value
0 or 1. Undefined symbols are defaulted to 0. Symbols that are neither 0 nor 1 
are defaulted to 1.
*/

#ifndef PA_USE_SKELETON
#define PA_USE_SKELETON 0
#elif (PA_USE_SKELETON != 0) && (PA_USE_SKELETON != 1)
#undef PA_USE_SKELETON
#define PA_USE_SKELETON 1
#endif 

#if defined(PA_NO_ASIO) || defined(PA_NO_DS) || defined(PA_NO_WMME) || defined(PA_NO_WASAPI) || defined(PA_NO_WDMKS)
#error "Portaudio: PA_NO_<APINAME> is no longer supported, please remove definition and use PA_USE_<APINAME> instead"
#endif

#ifndef PA_USE_ASIO
#define PA_USE_ASIO 0
#elif (PA_USE_ASIO != 0) && (PA_USE_ASIO != 1)
#undef PA_USE_ASIO
#define PA_USE_ASIO 1
#endif 

#ifndef PA_USE_DS
#define PA_USE_DS 0
#elif (PA_USE_DS != 0) && (PA_USE_DS != 1)
#undef PA_USE_DS
#define PA_USE_DS 1
#endif 

#ifndef PA_USE_WMME
#define PA_USE_WMME 0
#elif (PA_USE_WMME != 0) && (PA_USE_WMME != 1)
#undef PA_USE_WMME
#define PA_USE_WMME 1
#endif 

#ifndef PA_USE_WASAPI
#define PA_USE_WASAPI 0
#elif (PA_USE_WASAPI != 0) && (PA_USE_WASAPI != 1)
#undef PA_USE_WASAPI
#define PA_USE_WASAPI 1
#endif 

#ifndef PA_USE_WDMKS
#define PA_USE_WDMKS 0
#elif (PA_USE_WDMKS != 0) && (PA_USE_WDMKS != 1)
#undef PA_USE_WDMKS
#define PA_USE_WDMKS 1
#endif 

/* Set default values for Unix based APIs. */
#if defined(PA_NO_OSS) || defined(PA_NO_ALSA) || defined(PA_NO_JACK) || defined(PA_NO_COREAUDIO) || defined(PA_NO_SGI) || defined(PA_NO_ASIHPI)
#error "Portaudio: PA_NO_<APINAME> is no longer supported, please remove definition and use PA_USE_<APINAME> instead"
#endif

#ifndef PA_USE_OSS
#define PA_USE_OSS 0
#elif (PA_USE_OSS != 0) && (PA_USE_OSS != 1)
#undef PA_USE_OSS
#define PA_USE_OSS 1
#endif 

#ifndef PA_USE_ALSA
#define PA_USE_ALSA 0
#elif (PA_USE_ALSA != 0) && (PA_USE_ALSA != 1)
#undef PA_USE_ALSA
#define PA_USE_ALSA 1
#endif 

#ifndef PA_USE_JACK
#define PA_USE_JACK 0
#elif (PA_USE_JACK != 0) && (PA_USE_JACK != 1)
#undef PA_USE_JACK
#define PA_USE_JACK 1
#endif 

#ifndef PA_USE_SGI
#define PA_USE_SGI 0
#elif (PA_USE_SGI != 0) && (PA_USE_SGI != 1)
#undef PA_USE_SGI
#define PA_USE_SGI 1
#endif 

#ifndef PA_USE_COREAUDIO
#define PA_USE_COREAUDIO 0
#elif (PA_USE_COREAUDIO != 0) && (PA_USE_COREAUDIO != 1)
#undef PA_USE_COREAUDIO
#define PA_USE_COREAUDIO 1
#endif 

#ifndef PA_USE_ASIHPI
#define PA_USE_ASIHPI 0
#elif (PA_USE_ASIHPI != 0) && (PA_USE_ASIHPI != 1)
#undef PA_USE_ASIHPI
#define PA_USE_ASIHPI 1
#endif 

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/** **FOR THE USE OF pa_front.c ONLY**
    Do NOT use fields in this structure, they my change at any time.
    Use functions defined in pa_util.h if you think you need functionality
    which can be derived from here.
*/
typedef struct PaUtilPrivatePaFrontHostApiInfo {


    unsigned long baseDeviceIndex;
}PaUtilPrivatePaFrontHostApiInfo;


/** The common header for all data structures whose pointers are passed through
 the hostApiSpecificStreamInfo field of the PaStreamParameters structure.
 Note that in order to keep the public PortAudio interface clean, this structure
 is not used explicitly when declaring hostApiSpecificStreamInfo data structures.
 However, some code in pa_front depends on the first 3 members being equivalent
 with this structure.
 @see PaStreamParameters
*/
typedef struct PaUtilHostApiSpecificStreamInfoHeader
{
    unsigned long size;             /**< size of whole structure including this header */
    PaHostApiTypeId hostApiType;    /**< host API for which this data is intended */
    unsigned long version;          /**< structure version */
} PaUtilHostApiSpecificStreamInfoHeader;



/** A structure representing the interface to a host API. Contains both
 concrete data and pointers to functions which implement the interface.
*/
typedef struct PaUtilHostApiRepresentation {
    PaUtilPrivatePaFrontHostApiInfo privatePaFrontInfo;

    /** The host api implementation should populate the info field. In the
        case of info.defaultInputDevice and info.defaultOutputDevice the
        values stored should be 0 based indices within the host api's own
        device index range (0 to deviceCount). These values will be converted
        to global device indices by pa_front after PaUtilHostApiInitializer()
        returns.
    */
    PaHostApiInfo info;

    PaDeviceInfo** deviceInfos;

    /**
        (*Terminate)() is guaranteed to be called with a valid <hostApi>
        parameter, which was previously returned from the same implementation's
        initializer.
    */
    void (*Terminate)( struct PaUtilHostApiRepresentation *hostApi );

    /**
        The inputParameters and outputParameters pointers should not be saved
        as they will not remain valid after OpenStream is called.

        
        The following guarantees are made about parameters to (*OpenStream)():

            [NOTE: the following list up to *END PA FRONT VALIDATIONS* should be
                kept in sync with the one for ValidateOpenStreamParameters and
                Pa_OpenStream in pa_front.c]
                
            PaHostApiRepresentation *hostApi
                - is valid for this implementation

            PaStream** stream
                - is non-null

            - at least one of inputParameters & outputParmeters is valid (not NULL)

            - if inputParameters & outputParmeters are both valid, that
                inputParameters->device & outputParmeters->device  both use the same host api
 
            PaDeviceIndex inputParameters->device
                - is within range (0 to Pa_CountDevices-1) Or:
                - is paUseHostApiSpecificDeviceSpecification and
                    inputParameters->hostApiSpecificStreamInfo is non-NULL and refers
                    to a valid host api

            int inputParameters->numChannels
                - if inputParameters->device is not paUseHostApiSpecificDeviceSpecification, numInputChannels is > 0
                - upper bound is NOT validated against device capabilities
 
            PaSampleFormat inputParameters->sampleFormat
                - is one of the sample formats defined in portaudio.h

            void *inputParameters->hostApiSpecificStreamInfo
                - if supplied its hostApi field matches the input device's host Api
 
            PaDeviceIndex outputParmeters->device
                - is within range (0 to Pa_CountDevices-1)
 
            int outputParmeters->numChannels
                - if inputDevice is valid, numInputChannels is > 0
                - upper bound is NOT validated against device capabilities
 
            PaSampleFormat outputParmeters->sampleFormat
                - is one of the sample formats defined in portaudio.h
        
            void *outputParmeters->hostApiSpecificStreamInfo
                - if supplied its hostApi field matches the output device's host Api
 
            double sampleRate
                - is not an 'absurd' rate (less than 1000. or greater than 384000.)
                - sampleRate is NOT validated against device capabilities
 
            PaStreamFlags streamFlags
                - unused platform neutral flags are zero
                - paNeverDropInput is only used for full-duplex callback streams
                    with variable buffer size (paFramesPerBufferUnspecified)

            [*END PA FRONT VALIDATIONS*]


        The following validations MUST be performed by (*OpenStream)():

            - check that input device can support numInputChannels
            
            - check that input device can support inputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - if inputStreamInfo is supplied, validate its contents,
                or return an error if no inputStreamInfo is expected

            - check that output device can support numOutputChannels
            
            - check that output device can support outputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - if outputStreamInfo is supplied, validate its contents,
                or return an error if no outputStreamInfo is expected

            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported

            - check that the device supports sampleRate

            - alter sampleRate to a close allowable rate if necessary

            - validate inputLatency and outputLatency

            - validate any platform specific flags, if flags are supplied they
                must be valid.
    */
    PaError (*OpenStream)( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** stream,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerCallback,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );


    PaError (*IsFormatSupported)( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
} PaUtilHostApiRepresentation;


/** Prototype for the initialization function which must be implemented by every
 host API.
 
 This function should only return an error other than paNoError if it encounters 
 an unexpected and fatal error (memory allocation error for example). In general, 
 there may be conditions under which it returns a NULL interface pointer and also 
 returns paNoError. For example, if the ASIO implementation detects that ASIO is 
 not installed, it should return a NULL interface, and paNoError.

 @see paHostApiInitializers
*/
typedef PaError PaUtilHostApiInitializer( PaUtilHostApiRepresentation**, PaHostApiIndex );


/** paHostApiInitializers is a NULL-terminated array of host API initialization
 functions. These functions are called by pa_front.c to initialize the host APIs
 when the client calls Pa_Initialize(). 
 
 The initialization functions are invoked in order.

 The first successfully initialized host API that has a default input *or* output 
 device is used as the default PortAudio host API. This is based on the logic that
 there is only one default host API, and it must contain the default input and output
 devices (if defined).

 There is a platform specific file that defines paHostApiInitializers for that
 platform, pa_win/pa_win_hostapis.c contains the Win32 definitions for example.
*/
extern PaUtilHostApiInitializer *paHostApiInitializers[];


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_HOSTAPI_H */
/*
 * $Id: pa_memorybarrier.h 1240 2007-07-17 13:05:07Z bjornroche $
 * Portable Audio I/O Library
 * Memory barrier utilities
 *
 * Author: Bjorn Roche, XO Audio, LLC
 *
 * This program uses the PortAudio Portable Audio Library.
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file pa_memorybarrier.h
 @ingroup common_src
*/

/****************
 * Some memory barrier primitives based on the system.
 * right now only OS X, FreeBSD, and Linux are supported. In addition to providing
 * memory barriers, these functions should ensure that data cached in registers
 * is written out to cache where it can be snooped by other CPUs. (ie, the volatile
 * keyword should not be required)
 *
 * the primitives that must be defined are:
 *
 * PaUtil_FullMemoryBarrier()
 * PaUtil_ReadMemoryBarrier()
 * PaUtil_WriteMemoryBarrier()
 *
 ****************/

#if defined(__APPLE__)
#   include <libkern/OSAtomic.h>
    /* Here are the memory barrier functions. Mac OS X only provides
       full memory barriers, so the three types of barriers are the same,
       however, these barriers are superior to compiler-based ones. */
#   define PaUtil_FullMemoryBarrier()  OSMemoryBarrier()
#   define PaUtil_ReadMemoryBarrier()  OSMemoryBarrier()
#   define PaUtil_WriteMemoryBarrier() OSMemoryBarrier()
#elif defined(__GNUC__)
    /* GCC >= 4.1 has built-in intrinsics. We'll use those */
#   if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)
#      define PaUtil_FullMemoryBarrier()  __sync_synchronize()
#      define PaUtil_ReadMemoryBarrier()  __sync_synchronize()
#      define PaUtil_WriteMemoryBarrier() __sync_synchronize()
    /* as a fallback, GCC understands volatile asm and "memory" to mean it
     * should not reorder memory read/writes */
    /* Note that it is not clear that any compiler actually defines __PPC__,
     * it can probably removed safely. */
#   elif defined( __ppc__ ) || defined( __powerpc__) || defined( __PPC__ )
#      define PaUtil_FullMemoryBarrier()  asm volatile("sync":::"memory")
#      define PaUtil_ReadMemoryBarrier()  asm volatile("sync":::"memory")
#      define PaUtil_WriteMemoryBarrier() asm volatile("sync":::"memory")
#   elif defined( __i386__ ) || defined( __i486__ ) || defined( __i586__ ) || \
         defined( __i686__ ) || defined( __x86_64__ )
#      define PaUtil_FullMemoryBarrier()  asm volatile("mfence":::"memory")
#      define PaUtil_ReadMemoryBarrier()  asm volatile("lfence":::"memory")
#      define PaUtil_WriteMemoryBarrier() asm volatile("sfence":::"memory")
#   else
#      ifdef ALLOW_SMP_DANGERS
#         warning Memory barriers not defined on this system or system unknown
#         warning For SMP safety, you should fix this.
#         define PaUtil_FullMemoryBarrier()
#         define PaUtil_ReadMemoryBarrier()
#         define PaUtil_WriteMemoryBarrier()
#      else
#         error Memory barriers are not defined on this system. You can still compile by defining ALLOW_SMP_DANGERS, but SMP safety will not be guaranteed.
#      endif
#   endif
#elif (_MSC_VER >= 1400) && !defined(_WIN32_WCE)
#   include <intrin.h>
#   pragma intrinsic(_ReadWriteBarrier)
#   pragma intrinsic(_ReadBarrier)
#   pragma intrinsic(_WriteBarrier)
/* note that MSVC intrinsics _ReadWriteBarrier(), _ReadBarrier(), _WriteBarrier() are just compiler barriers *not* memory barriers */
#   define PaUtil_FullMemoryBarrier()  _ReadWriteBarrier()
#   define PaUtil_ReadMemoryBarrier()  _ReadBarrier()
#   define PaUtil_WriteMemoryBarrier() _WriteBarrier()
#elif defined(_WIN32_WCE)
#   define PaUtil_FullMemoryBarrier()
#   define PaUtil_ReadMemoryBarrier()
#   define PaUtil_WriteMemoryBarrier()
#elif defined(_MSC_VER) || defined(__BORLANDC__)
#   define PaUtil_FullMemoryBarrier()  _asm { lock add    [esp], 0 }
#   define PaUtil_ReadMemoryBarrier()  _asm { lock add    [esp], 0 }
#   define PaUtil_WriteMemoryBarrier() _asm { lock add    [esp], 0 }
#else
#   ifdef ALLOW_SMP_DANGERS
#      warning Memory barriers not defined on this system or system unknown
#      warning For SMP safety, you should fix this.
#      define PaUtil_FullMemoryBarrier()
#      define PaUtil_ReadMemoryBarrier()
#      define PaUtil_WriteMemoryBarrier()
#   else
#      error Memory barriers are not defined on this system. You can still compile by defining ALLOW_SMP_DANGERS, but SMP safety will not be guaranteed.
#   endif
#endif
#ifndef PA_PROCESS_H
#define PA_PROCESS_H
/*
 * $Id$
 * Portable Audio I/O Library callback buffer processing adapters
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */
 
/** @file
 @ingroup common_src

 @brief Buffer Processor prototypes. A Buffer Processor performs buffer length
 adaption, coordinates sample format conversion, and interleaves/deinterleaves
 channels.

 <h3>Overview</h3>

 The "Buffer Processor" (PaUtilBufferProcessor) manages conversion of audio
 data from host buffers to user buffers and back again. Where required, the
 buffer processor takes care of converting between host and user sample formats,
 interleaving and deinterleaving multichannel buffers, and adapting between host
 and user buffers with different lengths. The buffer processor may be used with
 full and half duplex streams, for both callback streams and blocking read/write
 streams.

 One of the important capabilities provided by the buffer processor is
 the ability to adapt between user and host buffer sizes of different lengths
 with minimum latency. Although this task is relatively easy to perform when
 the host buffer size is an integer multiple of the user buffer size, the
 problem is more complicated when this is not the case - especially for
 full-duplex callback streams. Where necessary the adaption is implemented by
 internally buffering some input and/or output data. The buffer adation
 algorithm used by the buffer processor was originally implemented by
 Stephan Letz for the ASIO version of PortAudio, and is described in his
 Callback_adaption_.pdf which is included in the distribution.

 The buffer processor performs sample conversion using the functions provided
 by pa_converters.c.

 The following sections provide an overview of how to use the buffer processor.
 Interested readers are advised to consult the host API implementations for
 examples of buffer processor usage.
 

 <h4>Initialization, resetting and termination</h4>

 When a stream is opened, the buffer processor should be initialized using
 PaUtil_InitializeBufferProcessor. This function initializes internal state
 and allocates temporary buffers as neccesary according to the supplied
 configuration parameters. Some of the parameters correspond to those requested
 by the user in their call to Pa_OpenStream(), others reflect the requirements
 of the host API implementation - they indicate host buffer sizes, formats,
 and the type of buffering which the Host API uses. The buffer processor should
 be initialized for callback streams and blocking read/write streams.

 Call PaUtil_ResetBufferProcessor to clear any sample data which is present
 in the buffer processor before starting to use it (for example when
 Pa_StartStream is called).

 When the buffer processor is no longer used call
 PaUtil_TerminateBufferProcessor.

 
 <h4>Using the buffer processor for a callback stream</h4>

 The buffer processor's role in a callback stream is to take host input buffers
 process them with the stream callback, and fill host output buffers. For a
 full duplex stream, the buffer processor handles input and output simultaneously
 due to the requirements of the minimum-latency buffer adation algorithm.

 When a host buffer becomes available, the implementation should call
 the buffer processor to process the buffer. The buffer processor calls the
 stream callback to consume and/or produce audio data as necessary. The buffer
 processor will convert sample formats, interleave/deinterleave channels,
 and slice or chunk the data to the appropriate buffer lengths according to
 the requirements of the stream callback and the host API.

 To process a host buffer (or a pair of host buffers for a full-duplex stream)
 use the following calling sequence:

 -# Call PaUtil_BeginBufferProcessing
 -# For a stream which takes input:
    - Call PaUtil_SetInputFrameCount with the number of frames in the host input
        buffer.
    - Call one of the following functions one or more times to tell the
        buffer processor about the host input buffer(s): PaUtil_SetInputChannel,
        PaUtil_SetInterleavedInputChannels, PaUtil_SetNonInterleavedInputChannel.
        Which function you call will depend on whether the host buffer(s) are
        interleaved or not.
    - If the available host data is split accross two buffers (for example a
        data range at the end of a circular buffer and another range at the
        beginning of the circular buffer), also call
        PaUtil_Set2ndInputFrameCount, PaUtil_Set2ndInputChannel,
        PaUtil_Set2ndInterleavedInputChannels,
        PaUtil_Set2ndNonInterleavedInputChannel as necessary to tell the buffer
        processor about the second buffer.
 -# For a stream which generates output:
    - Call PaUtil_SetOutputFrameCount with the number of frames in the host
        output buffer.
    - Call one of the following functions one or more times to tell the
        buffer processor about the host output buffer(s): PaUtil_SetOutputChannel,
        PaUtil_SetInterleavedOutputChannels, PaUtil_SetNonInterleavedOutputChannel.
        Which function you call will depend on whether the host buffer(s) are
        interleaved or not.
    - If the available host output buffer space is split accross two buffers
        (for example a data range at the end of a circular buffer and another
        range at the beginning of the circular buffer), call
        PaUtil_Set2ndOutputFrameCount, PaUtil_Set2ndOutputChannel,
        PaUtil_Set2ndInterleavedOutputChannels,
        PaUtil_Set2ndNonInterleavedOutputChannel as necessary to tell the buffer
        processor about the second buffer.
 -# Call PaUtil_EndBufferProcessing, this function performs the actual data
    conversion and processing.


 <h4>Using the buffer processor for a blocking read/write stream</h4>

 Blocking read/write streams use the buffer processor to convert and copy user
 output data to a host buffer, and to convert and copy host input data to
 the user's buffer. The buffer processor does not perform any buffer adaption.
 When using the buffer processor in a blocking read/write stream the input and
 output conversion are performed separately by the PaUtil_CopyInput and
 PaUtil_CopyOutput functions.

 To copy data from a host input buffer to the buffer(s) which the user supplies
 to Pa_ReadStream, use the following calling sequence.

 - Repeat the following three steps until the user buffer(s) have been filled
    with samples from the host input buffers:
     -# Call PaUtil_SetInputFrameCount with the number of frames in the host
        input buffer.
     -# Call one of the following functions one or more times to tell the
        buffer processor about the host input buffer(s): PaUtil_SetInputChannel,
        PaUtil_SetInterleavedInputChannels, PaUtil_SetNonInterleavedInputChannel.
        Which function you call will depend on whether the host buffer(s) are
        interleaved or not.
     -# Call PaUtil_CopyInput with the user buffer pointer (or a copy of the
        array of buffer pointers for a non-interleaved stream) passed to
        Pa_ReadStream, along with the number of frames in the user buffer(s).
        Be careful to pass a <i>copy</i> of the user buffer pointers to
        PaUtil_CopyInput because PaUtil_CopyInput advances the pointers to
        the start of the next region to copy.
 - PaUtil_CopyInput will not copy more data than is available in the
    host buffer(s), so the above steps need to be repeated until the user
    buffer(s) are full.

 
 To copy data to the host output buffer from the user buffers(s) supplied
 to Pa_WriteStream use the following calling sequence.

 - Repeat the following three steps until all frames from the user buffer(s)
    have been copied to the host API:
     -# Call PaUtil_SetOutputFrameCount with the number of frames in the host
        output buffer.
     -# Call one of the following functions one or more times to tell the
        buffer processor about the host output buffer(s): PaUtil_SetOutputChannel,
        PaUtil_SetInterleavedOutputChannels, PaUtil_SetNonInterleavedOutputChannel.
        Which function you call will depend on whether the host buffer(s) are
        interleaved or not.
     -# Call PaUtil_CopyOutput with the user buffer pointer (or a copy of the
        array of buffer pointers for a non-interleaved stream) passed to
        Pa_WriteStream, along with the number of frames in the user buffer(s).
        Be careful to pass a <i>copy</i> of the user buffer pointers to 
        PaUtil_CopyOutput because PaUtil_CopyOutput advances the pointers to
        the start of the next region to copy.
 - PaUtil_CopyOutput will not copy more data than fits in the host buffer(s),
    so the above steps need to be repeated until all user data is copied.
*/


// (amalg) #include "portaudio.h"
// (amalg) #include "pa_converters.h"
// (amalg) #include "pa_dither.h"

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/** @brief Mode flag passed to PaUtil_InitializeBufferProcessor indicating the type
 of buffering that the host API uses.

 The mode used depends on whether the host API or the implementation manages
 the buffers, and how these buffers are used (scatter gather, circular buffer).
*/
typedef enum {
/** The host buffer size is a fixed known size. */
    paUtilFixedHostBufferSize,

/** The host buffer size may vary, but has a known maximum size. */
    paUtilBoundedHostBufferSize,

/** Nothing is known about the host buffer size. */
    paUtilUnknownHostBufferSize,

/** The host buffer size varies, and the client does not require the buffer
 processor to consume all of the input and fill all of the output buffer. This
 is useful when the implementation has access to the host API's circular buffer
 and only needs to consume/fill some of it, not necessarily all of it, with each
 call to the buffer processor. This is the only mode where
 PaUtil_EndBufferProcessing() may not consume the whole buffer.
*/
    paUtilVariableHostBufferSizePartialUsageAllowed
}PaUtilHostBufferSizeMode;


/** @brief An auxilliary data structure used internally by the buffer processor
 to represent host input and output buffers. */
typedef struct PaUtilChannelDescriptor{
    void *data;
    unsigned int stride;  /**< stride in samples, not bytes */
}PaUtilChannelDescriptor;


/** @brief The main buffer processor data structure.

 Allocate one of these, initialize it with PaUtil_InitializeBufferProcessor
 and terminate it with PaUtil_TerminateBufferProcessor.
*/
typedef struct {
    unsigned long framesPerUserBuffer;
    unsigned long framesPerHostBuffer;

    PaUtilHostBufferSizeMode hostBufferSizeMode;
    int useNonAdaptingProcess;
    int userOutputSampleFormatIsEqualToHost;
    int userInputSampleFormatIsEqualToHost;
    unsigned long framesPerTempBuffer;

    unsigned int inputChannelCount;
    unsigned int bytesPerHostInputSample;
    unsigned int bytesPerUserInputSample;
    int userInputIsInterleaved;
    PaUtilConverter *inputConverter;
    PaUtilZeroer *inputZeroer;
    
    unsigned int outputChannelCount;
    unsigned int bytesPerHostOutputSample;
    unsigned int bytesPerUserOutputSample;
    int userOutputIsInterleaved;
    PaUtilConverter *outputConverter;
    PaUtilZeroer *outputZeroer;

    unsigned long initialFramesInTempInputBuffer;
    unsigned long initialFramesInTempOutputBuffer;

    void *tempInputBuffer;          /**< used for slips, block adaption, and conversion. */
    void **tempInputBufferPtrs;     /**< storage for non-interleaved buffer pointers, NULL for interleaved user input */
    unsigned long framesInTempInputBuffer; /**< frames remaining in input buffer from previous adaption iteration */

    void *tempOutputBuffer;         /**< used for slips, block adaption, and conversion. */
    void **tempOutputBufferPtrs;    /**< storage for non-interleaved buffer pointers, NULL for interleaved user output */
    unsigned long framesInTempOutputBuffer; /**< frames remaining in input buffer from previous adaption iteration */

    PaStreamCallbackTimeInfo *timeInfo;

    PaStreamCallbackFlags callbackStatusFlags;

    int hostInputIsInterleaved;
    unsigned long hostInputFrameCount[2];
    PaUtilChannelDescriptor *hostInputChannels[2]; /**< pointers to arrays of channel descriptors.
                                                        pointers are NULL for half-duplex output processing.
                                                        hostInputChannels[i].data is NULL when the caller
                                                        calls PaUtil_SetNoInput()
                                                        */
    int hostOutputIsInterleaved;
    unsigned long hostOutputFrameCount[2];
    PaUtilChannelDescriptor *hostOutputChannels[2]; /**< pointers to arrays of channel descriptors.
                                                         pointers are NULL for half-duplex input processing.
                                                         hostOutputChannels[i].data is NULL when the caller
                                                         calls PaUtil_SetNoOutput()
                                                         */

    PaUtilTriangularDitherGenerator ditherGenerator;

    double samplePeriod;

    PaStreamCallback *streamCallback;
    void *userData;
} PaUtilBufferProcessor;


/** @name Initialization, termination, resetting and info */
/*@{*/

/** Initialize a buffer processor's representation stored in a
 PaUtilBufferProcessor structure. Be sure to call
 PaUtil_TerminateBufferProcessor after finishing with a buffer processor.

 @param bufferProcessor The buffer processor structure to initialize.

 @param inputChannelCount The number of input channels as passed to
 Pa_OpenStream or 0 for an output-only stream.

 @param userInputSampleFormat Format of user input samples, as passed to
 Pa_OpenStream. This parameter is ignored for ouput-only streams.
 
 @param hostInputSampleFormat Format of host input samples. This parameter is
 ignored for output-only streams. See note about host buffer interleave below.

 @param outputChannelCount The number of output channels as passed to
 Pa_OpenStream or 0 for an input-only stream.

 @param userOutputSampleFormat Format of user output samples, as passed to
 Pa_OpenStream. This parameter is ignored for input-only streams.
 
 @param hostOutputSampleFormat Format of host output samples. This parameter is
 ignored for input-only streams. See note about host buffer interleave below.

 @param sampleRate Sample rate of the stream. The more accurate this is the
 better - it is used for updating time stamps when adapting buffers.
 
 @param streamFlags Stream flags as passed to Pa_OpenStream, this parameter is
 used for selecting special sample conversion options such as clipping and
 dithering.
 
 @param framesPerUserBuffer Number of frames per user buffer, as requested
 by the framesPerBuffer parameter to Pa_OpenStream. This parameter may be
 zero to indicate that the user will accept any (and varying) buffer sizes.

 @param framesPerHostBuffer Specifies the number of frames per host buffer
 for the fixed buffer size mode, and the maximum number of frames
 per host buffer for the bounded host buffer size mode. It is ignored for
 the other modes.

 @param hostBufferSizeMode A mode flag indicating the size variability of
 host buffers that will be passed to the buffer processor. See
 PaUtilHostBufferSizeMode for further details.
 
 @param streamCallback The user stream callback passed to Pa_OpenStream.

 @param userData The user data field passed to Pa_OpenStream.
    
 @note The interleave flag is ignored for host buffer formats. Host
 interleave is determined by the use of different SetInput and SetOutput
 functions.

 @return An error code indicating whether the initialization was successful.
 If the error code is not PaNoError, the buffer processor was not initialized
 and should not be used.
 
 @see Pa_OpenStream, PaUtilHostBufferSizeMode, PaUtil_TerminateBufferProcessor
*/
PaError PaUtil_InitializeBufferProcessor( PaUtilBufferProcessor* bufferProcessor,
            int inputChannelCount, PaSampleFormat userInputSampleFormat,
            PaSampleFormat hostInputSampleFormat,
            int outputChannelCount, PaSampleFormat userOutputSampleFormat,
            PaSampleFormat hostOutputSampleFormat,
            double sampleRate,
            PaStreamFlags streamFlags,
            unsigned long framesPerUserBuffer, /* 0 indicates don't care */
            unsigned long framesPerHostBuffer,
            PaUtilHostBufferSizeMode hostBufferSizeMode,
            PaStreamCallback *streamCallback, void *userData );


/** Terminate a buffer processor's representation. Deallocates any temporary
 buffers allocated by PaUtil_InitializeBufferProcessor.
 
 @param bufferProcessor The buffer processor structure to terminate.

 @see PaUtil_InitializeBufferProcessor.
*/
void PaUtil_TerminateBufferProcessor( PaUtilBufferProcessor* bufferProcessor );


/** Clear any internally buffered data. If you call
 PaUtil_InitializeBufferProcessor in your OpenStream routine, make sure you
 call PaUtil_ResetBufferProcessor in your StartStream call.

 @param bufferProcessor The buffer processor to reset.
*/
void PaUtil_ResetBufferProcessor( PaUtilBufferProcessor* bufferProcessor );


/** Retrieve the input latency of a buffer processor, in frames.

 @param bufferProcessor The buffer processor examine.

 @return The input latency introduced by the buffer processor, in frames.

 @see PaUtil_GetBufferProcessorOutputLatencyFrames
*/
unsigned long PaUtil_GetBufferProcessorInputLatencyFrames( PaUtilBufferProcessor* bufferProcessor );

/** Retrieve the output latency of a buffer processor, in frames.

 @param bufferProcessor The buffer processor examine.

 @return The output latency introduced by the buffer processor, in frames.

 @see PaUtil_GetBufferProcessorInputLatencyFrames
*/
unsigned long PaUtil_GetBufferProcessorOutputLatencyFrames( PaUtilBufferProcessor* bufferProcessor );

/*@}*/


/** @name Host buffer pointer configuration

 Functions to set host input and output buffers, used by both callback streams
 and blocking read/write streams.
*/
/*@{*/ 


/** Set the number of frames in the input host buffer(s) specified by the
 PaUtil_Set*InputChannel functions.

 @param bufferProcessor The buffer processor.

 @param frameCount The number of host input frames. A 0 frameCount indicates to
 use the framesPerHostBuffer value passed to PaUtil_InitializeBufferProcessor.

 @see PaUtil_SetNoInput, PaUtil_SetInputChannel,
 PaUtil_SetInterleavedInputChannels, PaUtil_SetNonInterleavedInputChannel
*/
void PaUtil_SetInputFrameCount( PaUtilBufferProcessor* bufferProcessor,
        unsigned long frameCount );

        
/** Indicate that no input is avalable. This function should be used when
 priming the output of a full-duplex stream opened with the
 paPrimeOutputBuffersUsingStreamCallback flag. Note that it is not necessary
 to call this or any othe PaUtil_Set*Input* functions for ouput-only streams.

 @param bufferProcessor The buffer processor.
*/
void PaUtil_SetNoInput( PaUtilBufferProcessor* bufferProcessor );


/** Provide the buffer processor with a pointer to a host input channel.

 @param bufferProcessor The buffer processor.
 @param channel The channel number.
 @param data The buffer.
 @param stride The stride from one sample to the next, in samples. For
 interleaved host buffers, the stride will usually be the same as the number of
 channels in the buffer.
*/
void PaUtil_SetInputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data, unsigned int stride );


/** Provide the buffer processor with a pointer to an number of interleaved
 host input channels.

 @param bufferProcessor The buffer processor.
 @param firstChannel The first channel number.
 @param data The buffer.
 @param channelCount The number of interleaved channels in the buffer. If
 channelCount is zero, the number of channels specified to
 PaUtil_InitializeBufferProcessor will be used.
*/
void PaUtil_SetInterleavedInputChannels( PaUtilBufferProcessor* bufferProcessor,
        unsigned int firstChannel, void *data, unsigned int channelCount );


/** Provide the buffer processor with a pointer to one non-interleaved host
 output channel.

 @param bufferProcessor The buffer processor.
 @param channel The channel number.
 @param data The buffer.
*/
void PaUtil_SetNonInterleavedInputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data );


/** Use for the second buffer half when the input buffer is split in two halves.
 @see PaUtil_SetInputFrameCount
*/
void PaUtil_Set2ndInputFrameCount( PaUtilBufferProcessor* bufferProcessor,
        unsigned long frameCount );

/** Use for the second buffer half when the input buffer is split in two halves.
 @see PaUtil_SetInputChannel
*/
void PaUtil_Set2ndInputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data, unsigned int stride );

/** Use for the second buffer half when the input buffer is split in two halves.
 @see PaUtil_SetInterleavedInputChannels
*/
void PaUtil_Set2ndInterleavedInputChannels( PaUtilBufferProcessor* bufferProcessor,
        unsigned int firstChannel, void *data, unsigned int channelCount );

/** Use for the second buffer half when the input buffer is split in two halves.
 @see PaUtil_SetNonInterleavedInputChannel
*/
void PaUtil_Set2ndNonInterleavedInputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data );

        
/** Set the number of frames in the output host buffer(s) specified by the
 PaUtil_Set*OutputChannel functions.

 @param bufferProcessor The buffer processor.

 @param frameCount The number of host output frames. A 0 frameCount indicates to
 use the framesPerHostBuffer value passed to PaUtil_InitializeBufferProcessor.

 @see PaUtil_SetOutputChannel, PaUtil_SetInterleavedOutputChannels,
 PaUtil_SetNonInterleavedOutputChannel
*/
void PaUtil_SetOutputFrameCount( PaUtilBufferProcessor* bufferProcessor,
        unsigned long frameCount );


/** Indicate that the output will be discarded. This function should be used
 when implementing the paNeverDropInput mode for full duplex streams.

 @param bufferProcessor The buffer processor.
*/
void PaUtil_SetNoOutput( PaUtilBufferProcessor* bufferProcessor );


/** Provide the buffer processor with a pointer to a host output channel.

 @param bufferProcessor The buffer processor.
 @param channel The channel number.
 @param data The buffer.
 @param stride The stride from one sample to the next, in samples. For
 interleaved host buffers, the stride will usually be the same as the number of
 channels in the buffer.
*/
void PaUtil_SetOutputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data, unsigned int stride );


/** Provide the buffer processor with a pointer to a number of interleaved
 host output channels.

 @param bufferProcessor The buffer processor.
 @param firstChannel The first channel number.
 @param data The buffer.
 @param channelCount The number of interleaved channels in the buffer. If
 channelCount is zero, the number of channels specified to
 PaUtil_InitializeBufferProcessor will be used.
*/
void PaUtil_SetInterleavedOutputChannels( PaUtilBufferProcessor* bufferProcessor,
        unsigned int firstChannel, void *data, unsigned int channelCount );

        
/** Provide the buffer processor with a pointer to one non-interleaved host
 output channel.

 @param bufferProcessor The buffer processor.
 @param channel The channel number.
 @param data The buffer.
*/
void PaUtil_SetNonInterleavedOutputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data );


/** Use for the second buffer half when the output buffer is split in two halves.
 @see PaUtil_SetOutputFrameCount
*/
void PaUtil_Set2ndOutputFrameCount( PaUtilBufferProcessor* bufferProcessor,
        unsigned long frameCount );

/** Use for the second buffer half when the output buffer is split in two halves.
 @see PaUtil_SetOutputChannel
*/
void PaUtil_Set2ndOutputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data, unsigned int stride );

/** Use for the second buffer half when the output buffer is split in two halves.
 @see PaUtil_SetInterleavedOutputChannels
*/
void PaUtil_Set2ndInterleavedOutputChannels( PaUtilBufferProcessor* bufferProcessor,
        unsigned int firstChannel, void *data, unsigned int channelCount );

/** Use for the second buffer half when the output buffer is split in two halves.
 @see PaUtil_SetNonInterleavedOutputChannel
*/
void PaUtil_Set2ndNonInterleavedOutputChannel( PaUtilBufferProcessor* bufferProcessor,
        unsigned int channel, void *data );

/*@}*/


/** @name Buffer processing functions for callback streams
*/
/*@{*/

/** Commence processing a host buffer (or a pair of host buffers in the
 full-duplex case) for a callback stream.

 @param bufferProcessor The buffer processor.

 @param timeInfo Timing information for the first sample of the host
 buffer(s). This information may be adjusted when buffer adaption is being
 performed.

 @param callbackStatusFlags Flags indicating whether underruns and overruns
 have occurred since the last time the buffer processor was called.
*/
void PaUtil_BeginBufferProcessing( PaUtilBufferProcessor* bufferProcessor,
        PaStreamCallbackTimeInfo* timeInfo, PaStreamCallbackFlags callbackStatusFlags );

        
/** Finish processing a host buffer (or a pair of host buffers in the
 full-duplex case) for a callback stream.

 @param bufferProcessor The buffer processor.
 
 @param callbackResult On input, indicates a previous callback result, and on
 exit, the result of the user stream callback, if it is called.
 On entry callbackResult should contain one of { paContinue, paComplete, or
 paAbort}. If paComplete is passed, the stream callback will not be called
 but any audio that was generated by previous stream callbacks will be copied
 to the output buffer(s). You can check whether the buffer processor's internal
 buffer is empty by calling PaUtil_IsBufferProcessorOutputEmpty.

 If the stream callback is called its result is stored in *callbackResult. If
 the stream callback returns paComplete or paAbort, all output buffers will be
 full of valid data - some of which may be zeros to acount for data that
 wasn't generated by the terminating callback.

 @return The number of frames processed. This usually corresponds to the
 number of frames specified by the PaUtil_Set*FrameCount functions, exept in
 the paUtilVariableHostBufferSizePartialUsageAllowed buffer size mode when a
 smaller value may be returned.
*/
unsigned long PaUtil_EndBufferProcessing( PaUtilBufferProcessor* bufferProcessor,
        int *callbackResult );


/** Determine whether any callback generated output remains in the bufffer
 processor's internal buffers. This method may be used to determine when to
 continue calling PaUtil_EndBufferProcessing() after the callback has returned
 a callbackResult of paComplete.

 @param bufferProcessor The buffer processor.
 
 @return Returns non-zero when callback generated output remains in the internal
 buffer and zero (0) when there internal buffer contains no callback generated
 data.
*/
int PaUtil_IsBufferProcessorOutputEmpty( PaUtilBufferProcessor* bufferProcessor );

/*@}*/


/** @name Buffer processing functions for blocking read/write streams
*/
/*@{*/

/** Copy samples from host input channels set up by the PaUtil_Set*InputChannels
 functions to a user supplied buffer. This function is intended for use with
 blocking read/write streams. Copies the minimum of the number of
 user frames (specified by the frameCount parameter) and the number of available
 host frames (specified in a previous call to SetInputFrameCount()).

 @param bufferProcessor The buffer processor.

 @param buffer A pointer to the user buffer pointer, or a pointer to a pointer
 to an array of user buffer pointers for a non-interleaved stream. It is
 important that this parameter points to a copy of the user buffer pointers,
 not to the actual user buffer pointers, because this function updates the
 pointers before returning.

 @param frameCount The number of frames of data in the buffer(s) pointed to by
 the buffer parameter.

 @return The number of frames copied. The buffer pointer(s) pointed to by the
 buffer parameter are advanced to point to the frame(s) following the last one
 filled.
*/
unsigned long PaUtil_CopyInput( PaUtilBufferProcessor* bufferProcessor,
        void **buffer, unsigned long frameCount );


/* Copy samples from a user supplied buffer to host output channels set up by
 the PaUtil_Set*OutputChannels functions. This function is intended for use with
 blocking read/write streams. Copies the minimum of the number of
 user frames (specified by the frameCount parameter) and the number of
 host frames (specified in a previous call to SetOutputFrameCount()).

 @param bufferProcessor The buffer processor.

 @param buffer A pointer to the user buffer pointer, or a pointer to a pointer
 to an array of user buffer pointers for a non-interleaved stream. It is
 important that this parameter points to a copy of the user buffer pointers,
 not to the actual user buffer pointers, because this function updates the
 pointers before returning.

 @param frameCount The number of frames of data in the buffer(s) pointed to by
 the buffer parameter.

 @return The number of frames copied. The buffer pointer(s) pointed to by the
 buffer parameter are advanced to point to the frame(s) following the last one
 copied.
*/
unsigned long PaUtil_CopyOutput( PaUtilBufferProcessor* bufferProcessor,
        const void ** buffer, unsigned long frameCount );


/* Zero samples in host output channels set up by the PaUtil_Set*OutputChannels
 functions. This function is useful for flushing streams.
 Zeros the minimum of frameCount and the number of host frames specified in a
 previous call to SetOutputFrameCount().

 @param bufferProcessor The buffer processor.

 @param frameCount The maximum number of frames to zero.
 
 @return The number of frames zeroed.
*/
unsigned long PaUtil_ZeroOutput( PaUtilBufferProcessor* bufferProcessor,
        unsigned long frameCount );


/*@}*/


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_PROCESS_H */
#ifndef PA_RINGBUFFER_H
#define PA_RINGBUFFER_H
/*
 * $Id$
 * Portable Audio I/O Library
 * Ring Buffer utility.
 *
 * Author: Phil Burk, http://www.softsynth.com
 * modified for SMP safety on OS X by Bjorn Roche.
 * also allowed for const where possible.
 * modified for multiple-byte-sized data elements by Sven Fischer 
 *
 * Note that this is safe only for a single-thread reader
 * and a single-thread writer.
 *
 * This program is distributed with the PortAudio Portable Audio Library.
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src
 @brief Single-reader single-writer lock-free ring buffer

 PaUtilRingBuffer is a ring buffer used to transport samples between
 different execution contexts (threads, OS callbacks, interrupt handlers)
 without requiring the use of any locks. This only works when there is
 a single reader and a single writer (ie. one thread or callback writes
 to the ring buffer, another thread or callback reads from it).

 The PaUtilRingBuffer structure manages a ring buffer containing N 
 elements, where N must be a power of two. An element may be any size 
 (specified in bytes).

 The memory area used to store the buffer elements must be allocated by 
 the client prior to calling PaUtil_InitializeRingBuffer() and must outlive
 the use of the ring buffer.
 
 @note The ring buffer functions are not normally exposed in the PortAudio libraries. 
 If you want to call them then you will need to add pa_ringbuffer.c to your application source code.
*/

#if defined(__APPLE__)
#include <sys/types.h>
typedef int32_t ring_buffer_size_t;
#elif defined( __GNUC__ )
typedef long ring_buffer_size_t;
#elif (_MSC_VER >= 1400)
typedef long ring_buffer_size_t;
#elif defined(_MSC_VER) || defined(__BORLANDC__)
typedef long ring_buffer_size_t;
#else
typedef long ring_buffer_size_t;
#endif



#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

typedef struct PaUtilRingBuffer
{
    ring_buffer_size_t  bufferSize; /**< Number of elements in FIFO. Power of 2. Set by PaUtil_InitRingBuffer. */
    volatile ring_buffer_size_t  writeIndex; /**< Index of next writable element. Set by PaUtil_AdvanceRingBufferWriteIndex. */
    volatile ring_buffer_size_t  readIndex;  /**< Index of next readable element. Set by PaUtil_AdvanceRingBufferReadIndex. */
    ring_buffer_size_t  bigMask;    /**< Used for wrapping indices with extra bit to distinguish full/empty. */
    ring_buffer_size_t  smallMask;  /**< Used for fitting indices to buffer. */
    ring_buffer_size_t  elementSizeBytes; /**< Number of bytes per element. */
    char  *buffer;    /**< Pointer to the buffer containing the actual data. */
}PaUtilRingBuffer;

/** Initialize Ring Buffer to empty state ready to have elements written to it.

 @param rbuf The ring buffer.

 @param elementSizeBytes The size of a single data element in bytes.

 @param elementCount The number of elements in the buffer (must be a power of 2).

 @param dataPtr A pointer to a previously allocated area where the data
 will be maintained.  It must be elementCount*elementSizeBytes long.

 @return -1 if elementCount is not a power of 2, otherwise 0.
*/
ring_buffer_size_t PaUtil_InitializeRingBuffer( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementSizeBytes, ring_buffer_size_t elementCount, void *dataPtr );

/** Reset buffer to empty. Should only be called when buffer is NOT being read or written.

 @param rbuf The ring buffer.
*/
void PaUtil_FlushRingBuffer( PaUtilRingBuffer *rbuf );

/** Retrieve the number of elements available in the ring buffer for writing.

 @param rbuf The ring buffer.

 @return The number of elements available for writing.
*/
ring_buffer_size_t PaUtil_GetRingBufferWriteAvailable( const PaUtilRingBuffer *rbuf );

/** Retrieve the number of elements available in the ring buffer for reading.

 @param rbuf The ring buffer.

 @return The number of elements available for reading.
*/
ring_buffer_size_t PaUtil_GetRingBufferReadAvailable( const PaUtilRingBuffer *rbuf );

/** Write data to the ring buffer.

 @param rbuf The ring buffer.

 @param data The address of new data to write to the buffer.

 @param elementCount The number of elements to be written.

 @return The number of elements written.
*/
ring_buffer_size_t PaUtil_WriteRingBuffer( PaUtilRingBuffer *rbuf, const void *data, ring_buffer_size_t elementCount );

/** Read data from the ring buffer.

 @param rbuf The ring buffer.

 @param data The address where the data should be stored.

 @param elementCount The number of elements to be read.

 @return The number of elements read.
*/
ring_buffer_size_t PaUtil_ReadRingBuffer( PaUtilRingBuffer *rbuf, void *data, ring_buffer_size_t elementCount );

/** Get address of region(s) to which we can write data.

 @param rbuf The ring buffer.

 @param elementCount The number of elements desired.

 @param dataPtr1 The address where the first (or only) region pointer will be
 stored.

 @param sizePtr1 The address where the first (or only) region length will be
 stored.

 @param dataPtr2 The address where the second region pointer will be stored if
 the first region is too small to satisfy elementCount.

 @param sizePtr2 The address where the second region length will be stored if
 the first region is too small to satisfy elementCount.

 @return The room available to be written or elementCount, whichever is smaller.
*/
ring_buffer_size_t PaUtil_GetRingBufferWriteRegions( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount,
                                       void **dataPtr1, ring_buffer_size_t *sizePtr1,
                                       void **dataPtr2, ring_buffer_size_t *sizePtr2 );

/** Advance the write index to the next location to be written.

 @param rbuf The ring buffer.

 @param elementCount The number of elements to advance.

 @return The new position.
*/
ring_buffer_size_t PaUtil_AdvanceRingBufferWriteIndex( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount );

/** Get address of region(s) from which we can read data.

 @param rbuf The ring buffer.

 @param elementCount The number of elements desired.

 @param dataPtr1 The address where the first (or only) region pointer will be
 stored.

 @param sizePtr1 The address where the first (or only) region length will be
 stored.

 @param dataPtr2 The address where the second region pointer will be stored if
 the first region is too small to satisfy elementCount.

 @param sizePtr2 The address where the second region length will be stored if
 the first region is too small to satisfy elementCount.

 @return The number of elements available for reading.
*/
ring_buffer_size_t PaUtil_GetRingBufferReadRegions( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount,
                                      void **dataPtr1, ring_buffer_size_t *sizePtr1,
                                      void **dataPtr2, ring_buffer_size_t *sizePtr2 );

/** Advance the read index to the next location to be read.

 @param rbuf The ring buffer.

 @param elementCount The number of elements to advance.

 @return The new position.
*/
ring_buffer_size_t PaUtil_AdvanceRingBufferReadIndex( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount );

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_RINGBUFFER_H */
#ifndef PA_STREAM_H
#define PA_STREAM_H
/*
 * $Id$
 * Portable Audio I/O Library
 * stream interface
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Stream interfaces, representation structures and helper functions
 used to interface between pa_front.c host API implementations.
*/


// (amalg) #include "portaudio.h"

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


#define PA_STREAM_MAGIC (0x18273645)


/** A structure representing an (abstract) interface to a host API. Contains
 pointers to functions which implement the interface.

 All PaStreamInterface functions are guaranteed to be called with a non-null,
 valid stream parameter.
*/
typedef struct {
    PaError (*Close)( PaStream* stream );
    PaError (*Start)( PaStream *stream );
    PaError (*Stop)( PaStream *stream );
    PaError (*Abort)( PaStream *stream );
    PaError (*IsStopped)( PaStream *stream );
    PaError (*IsActive)( PaStream *stream );
    PaTime (*GetTime)( PaStream *stream );
    double (*GetCpuLoad)( PaStream* stream );
    PaError (*Read)( PaStream* stream, void *buffer, unsigned long frames );
    PaError (*Write)( PaStream* stream, const void *buffer, unsigned long frames );
    signed long (*GetReadAvailable)( PaStream* stream );
    signed long (*GetWriteAvailable)( PaStream* stream );
} PaUtilStreamInterface;


/** Initialize the fields of a PaUtilStreamInterface structure.
*/
void PaUtil_InitializeStreamInterface( PaUtilStreamInterface *streamInterface,
    PaError (*Close)( PaStream* ),
    PaError (*Start)( PaStream* ),
    PaError (*Stop)( PaStream* ),
    PaError (*Abort)( PaStream* ),
    PaError (*IsStopped)( PaStream* ),
    PaError (*IsActive)( PaStream* ),
    PaTime (*GetTime)( PaStream* ),
    double (*GetCpuLoad)( PaStream* ),
    PaError (*Read)( PaStream* stream, void *buffer, unsigned long frames ),
    PaError (*Write)( PaStream* stream, const void *buffer, unsigned long frames ),
    signed long (*GetReadAvailable)( PaStream* stream ),
    signed long (*GetWriteAvailable)( PaStream* stream ) );


/** Dummy Read function for use in interfaces to a callback based streams.
 Pass to the Read parameter of PaUtil_InitializeStreamInterface.
 @return An error code indicating that the function has no effect
 because the stream is a callback stream.
*/
PaError PaUtil_DummyRead( PaStream* stream,
                       void *buffer,
                       unsigned long frames );


/** Dummy Write function for use in an interfaces to callback based streams.
 Pass to the Write parameter of PaUtil_InitializeStreamInterface.
 @return An error code indicating that the function has no effect
 because the stream is a callback stream.
*/
PaError PaUtil_DummyWrite( PaStream* stream,
                       const void *buffer,
                       unsigned long frames );


/** Dummy GetReadAvailable function for use in interfaces to callback based
 streams. Pass to the GetReadAvailable parameter of PaUtil_InitializeStreamInterface.
 @return An error code indicating that the function has no effect
 because the stream is a callback stream.
*/
signed long PaUtil_DummyGetReadAvailable( PaStream* stream );


/** Dummy GetWriteAvailable function for use in interfaces to callback based
 streams. Pass to the GetWriteAvailable parameter of PaUtil_InitializeStreamInterface.
 @return An error code indicating that the function has no effect
 because the stream is a callback stream.
*/
signed long PaUtil_DummyGetWriteAvailable( PaStream* stream );



/** Dummy GetCpuLoad function for use in an interface to a read/write stream.
 Pass to the GetCpuLoad parameter of PaUtil_InitializeStreamInterface.
 @return Returns 0.
*/
double PaUtil_DummyGetCpuLoad( PaStream* stream );


/** Non host specific data for a stream. This data is used by pa_front to
 forward to the appropriate functions in the streamInterface structure.
*/
typedef struct PaUtilStreamRepresentation {
    unsigned long magic;    /**< set to PA_STREAM_MAGIC */
    struct PaUtilStreamRepresentation *nextOpenStream; /**< field used by multi-api code */
    PaUtilStreamInterface *streamInterface;
    PaStreamCallback *streamCallback;
    PaStreamFinishedCallback *streamFinishedCallback;
    void *userData;
    PaStreamInfo streamInfo;
} PaUtilStreamRepresentation;


/** Initialize a PaUtilStreamRepresentation structure.

 @see PaUtil_InitializeStreamRepresentation
*/
void PaUtil_InitializeStreamRepresentation(
        PaUtilStreamRepresentation *streamRepresentation,
        PaUtilStreamInterface *streamInterface,
        PaStreamCallback *streamCallback,
        void *userData );
        

/** Clean up a PaUtilStreamRepresentation structure previously initialized
 by a call to PaUtil_InitializeStreamRepresentation.

 @see PaUtil_InitializeStreamRepresentation
*/
void PaUtil_TerminateStreamRepresentation( PaUtilStreamRepresentation *streamRepresentation );


/** Check that the stream pointer is valid.

 @return Returns paNoError if the stream pointer appears to be OK, otherwise
 returns an error indicating the cause of failure.
*/
PaError PaUtil_ValidateStreamPointer( PaStream *stream );


/** Cast an opaque stream pointer into a pointer to a PaUtilStreamRepresentation.

 @see PaUtilStreamRepresentation
*/
#define PA_STREAM_REP( stream )\
    ((PaUtilStreamRepresentation*) (stream) )


/** Cast an opaque stream pointer into a pointer to a PaUtilStreamInterface.

 @see PaUtilStreamRepresentation, PaUtilStreamInterface
*/
#define PA_STREAM_INTERFACE( stream )\
    PA_STREAM_REP( (stream) )->streamInterface


    
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_STREAM_H */
#ifndef PA_TRACE_H
#define PA_TRACE_H
/*
 * $Id$
 * Portable Audio I/O Library Trace Facility
 * Store trace information in real-time for later printing.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2000 Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Real-time safe event trace logging facility for debugging.

 Allows data to be logged to a fixed size trace buffer in a real-time
 execution context (such as at interrupt time). Each log entry consists 
 of a message comprising a string pointer and an int.  The trace buffer 
 may be dumped to stdout later.

 This facility is only active if PA_TRACE_REALTIME_EVENTS is set to 1,
 otherwise the trace functions expand to no-ops.

 @fn PaUtil_ResetTraceMessages
 @brief Clear the trace buffer.

 @fn PaUtil_AddTraceMessage
 @brief Add a message to the trace buffer. A message consists of string and an int.
 @param msg The string pointer must remain valid until PaUtil_DumpTraceMessages 
    is called. As a result, usually only string literals should be passed as 
    the msg parameter.

 @fn PaUtil_DumpTraceMessages
 @brief Print all messages in the trace buffer to stdout and clear the trace buffer.
*/

#ifndef PA_TRACE_REALTIME_EVENTS
#define PA_TRACE_REALTIME_EVENTS     (0)   /**< Set to 1 to enable logging using the trace functions defined below */
#endif

#ifndef PA_MAX_TRACE_RECORDS
#define PA_MAX_TRACE_RECORDS      (2048)   /**< Maximum number of records stored in trace buffer */   
#endif

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


#if PA_TRACE_REALTIME_EVENTS

void PaUtil_ResetTraceMessages();
void PaUtil_AddTraceMessage( const char *msg, int data );
void PaUtil_DumpTraceMessages();

/* Alternative interface */

typedef void* LogHandle;

int PaUtil_InitializeHighSpeedLog(LogHandle* phLog, unsigned maxSizeInBytes);
void PaUtil_ResetHighSpeedLogTimeRef(LogHandle hLog);
int PaUtil_AddHighSpeedLogMessage(LogHandle hLog, const char* fmt, ...);
void PaUtil_DumpHighSpeedLog(LogHandle hLog, const char* fileName);
void PaUtil_DiscardHighSpeedLog(LogHandle hLog);

#else

#define PaUtil_ResetTraceMessages() /* noop */
#define PaUtil_AddTraceMessage(msg,data) /* noop */
#define PaUtil_DumpTraceMessages() /* noop */

#define PaUtil_InitializeHighSpeedLog(phLog, maxSizeInBytes)  (0)
#define PaUtil_ResetHighSpeedLogTimeRef(hLog)
#define PaUtil_AddHighSpeedLogMessage(...)   (0)
#define PaUtil_DumpHighSpeedLog(hLog, fileName)
#define PaUtil_DiscardHighSpeedLog(hLog)

#endif


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* PA_TRACE_H */
#ifndef PA_UTIL_H
#define PA_UTIL_H
/*
 * $Id$
 * Portable Audio I/O Library implementation utilities header
 * common implementation utilities and interfaces
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

    @brief Prototypes for utility functions used by PortAudio implementations.

    Some functions declared here are defined in pa_front.c while others
    are implemented separately for each platform.
*/


// (amalg) #include "portaudio.h"

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


struct PaUtilHostApiRepresentation;


/** Retrieve a specific host API representation. This function can be used
 by implementations to retrieve a pointer to their representation in
 host api specific extension functions which aren't passed a rep pointer
 by pa_front.c.

 @param hostApi A pointer to a host API represenation pointer. Apon success
 this will receive the requested representation pointer.

 @param type A valid host API type identifier.

 @returns An error code. If the result is PaNoError then a pointer to the
 requested host API representation will be stored in *hostApi. If the host API
 specified by type is not found, this function returns paHostApiNotFound.
*/
PaError PaUtil_GetHostApiRepresentation( struct PaUtilHostApiRepresentation **hostApi,
        PaHostApiTypeId type );


/** Convert a PortAudio device index into a host API specific device index.
 @param hostApiDevice Pointer to a device index, on success this will recieve the
 converted device index value.
 @param device The PortAudio device index to convert.
 @param hostApi The host api which the index should be converted for.

 @returns On success returns PaNoError and places the converted index in the
 hostApiDevice parameter.
*/
PaError PaUtil_DeviceIndexToHostApiDeviceIndex(
        PaDeviceIndex *hostApiDevice, PaDeviceIndex device,
        struct PaUtilHostApiRepresentation *hostApi );


/** Set the host error information returned by Pa_GetLastHostErrorInfo. This
 function and the paUnanticipatedHostError error code should be used as a
 last resort.  Implementors should use existing PA error codes where possible,
 or nominate new ones. Note that at it is always better to use
 PaUtil_SetLastHostErrorInfo() and paUnanticipatedHostError than to return an
 ambiguous or inaccurate PaError code.

 @param hostApiType  The host API which encountered the error (ie of the caller)

 @param errorCode The error code returned by the native API function.

 @param errorText A string describing the error. PaUtil_SetLastHostErrorInfo
 makes a copy of the string, so it is not necessary for the pointer to remain
 valid after the call to PaUtil_SetLastHostErrorInfo() returns.

*/
void PaUtil_SetLastHostErrorInfo( PaHostApiTypeId hostApiType, long errorCode,
        const char *errorText );


        
/* the following functions are implemented in a platform platform specific
 .c file
*/

/** Allocate size bytes, guaranteed to be aligned to a FIXME byte boundary */
void *PaUtil_AllocateMemory( long size );


/** Realease block if non-NULL. block may be NULL */
void PaUtil_FreeMemory( void *block );


/** Return the number of currently allocated blocks. This function can be
 used for detecting memory leaks.

 @note Allocations will only be tracked if PA_TRACK_MEMORY is #defined. If
 it isn't, this function will always return 0.
*/
int PaUtil_CountCurrentlyAllocatedBlocks( void );


/** Initialize the clock used by PaUtil_GetTime(). Call this before calling
 PaUtil_GetTime.

 @see PaUtil_GetTime
*/
void PaUtil_InitializeClock( void );


/** Return the system time in seconds. Used to implement CPU load functions

 @see PaUtil_InitializeClock
*/
double PaUtil_GetTime( void );


/* void Pa_Sleep( long msec );  must also be implemented in per-platform .c file */



#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_UTIL_H */

/*
 * $Id$
 * Portable Audio I/O Library allocation group implementation
 * memory allocation group for tracking allocation groups
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Allocation Group implementation.
*/


// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_util.h"


/*
    Maintain 3 singly linked lists...
    linkBlocks: the buffers used to allocate the links
    spareLinks: links available for use in the allocations list
    allocations: the buffers currently allocated using PaUtil_ContextAllocateMemory()

    Link block size is doubled every time new links are allocated.
*/


#define PA_INITIAL_LINK_COUNT_    16

struct PaUtilAllocationGroupLink
{
    struct PaUtilAllocationGroupLink *next;
    void *buffer;
};

/*
    Allocate a block of links. The first link will have it's buffer member
    pointing to the block, and it's next member set to <nextBlock>. The remaining
    links will have NULL buffer members, and each link will point to
    the next link except the last, which will point to <nextSpare>
*/
static struct PaUtilAllocationGroupLink *AllocateLinks( long count,
        struct PaUtilAllocationGroupLink *nextBlock,
        struct PaUtilAllocationGroupLink *nextSpare )
{
    struct PaUtilAllocationGroupLink *result;
    int i;
    
    result = (struct PaUtilAllocationGroupLink *)PaUtil_AllocateMemory(
            sizeof(struct PaUtilAllocationGroupLink) * count );
    if( result )
    {
        /* the block link */
        result[0].buffer = result;
        result[0].next = nextBlock;

        /* the spare links */
        for( i=1; i<count; ++i )
        {
            result[i].buffer = 0;
            result[i].next = &result[i+1];
        }
        result[count-1].next = nextSpare;
    }
    
    return result;
}


PaUtilAllocationGroup* PaUtil_CreateAllocationGroup( void )
{
    PaUtilAllocationGroup* result = 0;
    struct PaUtilAllocationGroupLink *links;


    links = AllocateLinks( PA_INITIAL_LINK_COUNT_, 0, 0 );
    if( links != 0 )
    {
        result = (PaUtilAllocationGroup*)PaUtil_AllocateMemory( sizeof(PaUtilAllocationGroup) );
        if( result )
        {
            result->linkCount = PA_INITIAL_LINK_COUNT_;
            result->linkBlocks = &links[0];
            result->spareLinks = &links[1];
            result->allocations = 0;
        }
        else
        {
            PaUtil_FreeMemory( links );
        }
    }

    return result;
}


void PaUtil_DestroyAllocationGroup( PaUtilAllocationGroup* group )
{
    struct PaUtilAllocationGroupLink *current = group->linkBlocks;
    struct PaUtilAllocationGroupLink *next;

    while( current )
    {
        next = current->next;
        PaUtil_FreeMemory( current->buffer );
        current = next;
    }

    PaUtil_FreeMemory( group );
}


void* PaUtil_GroupAllocateMemory( PaUtilAllocationGroup* group, long size )
{
    struct PaUtilAllocationGroupLink *links, *link;
    void *result = 0;
    
    /* allocate more links if necessary */
    if( !group->spareLinks )
    {
        /* double the link count on each block allocation */
        links = AllocateLinks( group->linkCount, group->linkBlocks, group->spareLinks );
        if( links )
        {
            group->linkCount += group->linkCount;
            group->linkBlocks = &links[0];
            group->spareLinks = &links[1];
        }
    }

    if( group->spareLinks )
    {
        result = PaUtil_AllocateMemory( size );
        if( result )
        {
            link = group->spareLinks;
            group->spareLinks = link->next;

            link->buffer = result;
            link->next = group->allocations;

            group->allocations = link;
        }
    }

    return result;    
}


void PaUtil_GroupFreeMemory( PaUtilAllocationGroup* group, void *buffer )
{
    struct PaUtilAllocationGroupLink *current = group->allocations;
    struct PaUtilAllocationGroupLink *previous = 0;

    if( buffer == 0 )
        return;

    /* find the right link and remove it */
    while( current )
    {
        if( current->buffer == buffer )
        {
            if( previous )
            {
                previous->next = current->next;
            }
            else
            {
                group->allocations = current->next;
            }

            current->buffer = 0;
            current->next = group->spareLinks;
            group->spareLinks = current;

            break;
        }
        
        previous = current;
        current = current->next;
    }

    PaUtil_FreeMemory( buffer ); /* free the memory whether we found it in the list or not */
}


void PaUtil_FreeAllAllocations( PaUtilAllocationGroup* group )
{
    struct PaUtilAllocationGroupLink *current = group->allocations;
    struct PaUtilAllocationGroupLink *previous = 0;

    /* free all buffers in the allocations list */
    while( current )
    {
        PaUtil_FreeMemory( current->buffer );
        current->buffer = 0;

        previous = current;
        current = current->next;
    }

    /* link the former allocations list onto the front of the spareLinks list */
    if( previous )
    {
        previous->next = group->spareLinks;
        group->spareLinks = group->allocations;
        group->allocations = 0;
    }
}

/*
 * $Id$
 * Portable Audio I/O Library sample conversion mechanism
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Conversion function implementations.
 
 If the C9x function lrintf() is available, define PA_USE_C99_LRINTF to use it

 @todo Consider whether functions which dither but don't clip should exist,
 V18 automatically enabled clipping whenever dithering was selected. Perhaps
 we should do the same. 
    see: "require clipping for dithering sample conversion functions?"
    http://www.portaudio.com/trac/ticket/112

 @todo implement the converters marked IMPLEMENT ME: Int32_To_Int24_Dither,
 Int32_To_UInt8_Dither, Int24_To_Int16_Dither, Int24_To_Int8_Dither, 
 Int24_To_UInt8_Dither, Int16_To_Int8_Dither, Int16_To_UInt8_Dither
    see: "some conversion functions are not implemented in pa_converters.c"
    http://www.portaudio.com/trac/ticket/35

 @todo review the converters marked REVIEW: Float32_To_Int32,
 Float32_To_Int32_Dither, Float32_To_Int32_Clip, Float32_To_Int32_DitherClip,
 Int32_To_Int16_Dither, Int32_To_Int8_Dither, Int16_To_Int32
*/


// (amalg) #include "pa_converters.h"
// (amalg) #include "pa_dither.h"
// (amalg) #include "pa_endianness.h"
// (amalg) #include "pa_types.h"


PaSampleFormat PaUtil_SelectClosestAvailableFormat(
        PaSampleFormat availableFormats, PaSampleFormat format )
{
    PaSampleFormat result;

    format &= ~paNonInterleaved;
    availableFormats &= ~paNonInterleaved;
    
    if( (format & availableFormats) == 0 )
    {
        /* NOTE: this code depends on the sample format constants being in
            descending order of quality - ie best quality is 0
            FIXME: should write an assert which checks that all of the
            known constants conform to that requirement.
        */

        if( format != 0x01 )
        {
            /* scan for better formats */
            result = format;
            do
            {
                result >>= 1;
            }
            while( (result & availableFormats) == 0 && result != 0 );
        }
        else
        {
            result = 0;
        }
        
        if( result == 0 ){
            /* scan for worse formats */
            result = format;
            do
            {
                result <<= 1;
            }
            while( (result & availableFormats) == 0 && result != paCustomFormat );

            if( (result & availableFormats) == 0 )
                result = paSampleFormatNotSupported;
        }
        
    }else{
        result = format;
    }

    return result;
}

/* -------------------------------------------------------------------------- */

#define PA_SELECT_FORMAT_( format, float32, int32, int24, int16, int8, uint8 ) \
    switch( format & ~paNonInterleaved ){                                      \
    case paFloat32:                                                            \
        float32                                                                \
    case paInt32:                                                              \
        int32                                                                  \
    case paInt24:                                                              \
        int24                                                                  \
    case paInt16:                                                              \
        int16                                                                  \
    case paInt8:                                                               \
        int8                                                                   \
    case paUInt8:                                                              \
        uint8                                                                  \
    default: return 0;                                                         \
    }

/* -------------------------------------------------------------------------- */

#define PA_SELECT_CONVERTER_DITHER_CLIP_( flags, source, destination )         \
    if( flags & paClipOff ){ /* no clip */                                     \
        if( flags & paDitherOff ){ /* no dither */                             \
            return paConverters. source ## _To_ ## destination;                \
        }else{ /* dither */                                                    \
            return paConverters. source ## _To_ ## destination ## _Dither;     \
        }                                                                      \
    }else{ /* clip */                                                          \
        if( flags & paDitherOff ){ /* no dither */                             \
            return paConverters. source ## _To_ ## destination ## _Clip;       \
        }else{ /* dither */                                                    \
            return paConverters. source ## _To_ ## destination ## _DitherClip; \
        }                                                                      \
    }

/* -------------------------------------------------------------------------- */

#define PA_SELECT_CONVERTER_DITHER_( flags, source, destination )              \
    if( flags & paDitherOff ){ /* no dither */                                 \
        return paConverters. source ## _To_ ## destination;                    \
    }else{ /* dither */                                                        \
        return paConverters. source ## _To_ ## destination ## _Dither;         \
    }

/* -------------------------------------------------------------------------- */

#define PA_USE_CONVERTER_( source, destination )\
    return paConverters. source ## _To_ ## destination;

/* -------------------------------------------------------------------------- */

#define PA_UNITY_CONVERSION_( wordlength )\
    return paConverters. Copy_ ## wordlength ## _To_ ## wordlength;

/* -------------------------------------------------------------------------- */

PaUtilConverter* PaUtil_SelectConverter( PaSampleFormat sourceFormat,
        PaSampleFormat destinationFormat, PaStreamFlags flags )
{
    PA_SELECT_FORMAT_( sourceFormat,
                       /* paFloat32: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_UNITY_CONVERSION_( 32 ),
                                          /* paInt32: */          PA_SELECT_CONVERTER_DITHER_CLIP_( flags, Float32, Int32 ),
                                          /* paInt24: */          PA_SELECT_CONVERTER_DITHER_CLIP_( flags, Float32, Int24 ),
                                          /* paInt16: */          PA_SELECT_CONVERTER_DITHER_CLIP_( flags, Float32, Int16 ),
                                          /* paInt8: */           PA_SELECT_CONVERTER_DITHER_CLIP_( flags, Float32, Int8 ),
                                          /* paUInt8: */          PA_SELECT_CONVERTER_DITHER_CLIP_( flags, Float32, UInt8 )
                                        ),
                       /* paInt32: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_USE_CONVERTER_( Int32, Float32 ),
                                          /* paInt32: */          PA_UNITY_CONVERSION_( 32 ),
                                          /* paInt24: */          PA_SELECT_CONVERTER_DITHER_( flags, Int32, Int24 ),
                                          /* paInt16: */          PA_SELECT_CONVERTER_DITHER_( flags, Int32, Int16 ),
                                          /* paInt8: */           PA_SELECT_CONVERTER_DITHER_( flags, Int32, Int8 ),
                                          /* paUInt8: */          PA_SELECT_CONVERTER_DITHER_( flags, Int32, UInt8 )
                                        ),
                       /* paInt24: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_USE_CONVERTER_( Int24, Float32 ),
                                          /* paInt32: */          PA_USE_CONVERTER_( Int24, Int32 ),
                                          /* paInt24: */          PA_UNITY_CONVERSION_( 24 ),
                                          /* paInt16: */          PA_SELECT_CONVERTER_DITHER_( flags, Int24, Int16 ),
                                          /* paInt8: */           PA_SELECT_CONVERTER_DITHER_( flags, Int24, Int8 ),
                                          /* paUInt8: */          PA_SELECT_CONVERTER_DITHER_( flags, Int24, UInt8 )
                                        ),
                       /* paInt16: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_USE_CONVERTER_( Int16, Float32 ),
                                          /* paInt32: */          PA_USE_CONVERTER_( Int16, Int32 ),
                                          /* paInt24: */          PA_USE_CONVERTER_( Int16, Int24 ),
                                          /* paInt16: */          PA_UNITY_CONVERSION_( 16 ),
                                          /* paInt8: */           PA_SELECT_CONVERTER_DITHER_( flags, Int16, Int8 ),
                                          /* paUInt8: */          PA_SELECT_CONVERTER_DITHER_( flags, Int16, UInt8 )
                                        ),
                       /* paInt8: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_USE_CONVERTER_( Int8, Float32 ),
                                          /* paInt32: */          PA_USE_CONVERTER_( Int8, Int32 ),
                                          /* paInt24: */          PA_USE_CONVERTER_( Int8, Int24 ),
                                          /* paInt16: */          PA_USE_CONVERTER_( Int8, Int16 ),
                                          /* paInt8: */           PA_UNITY_CONVERSION_( 8 ),
                                          /* paUInt8: */          PA_USE_CONVERTER_( Int8, UInt8 )
                                        ),
                       /* paUInt8: */
                       PA_SELECT_FORMAT_( destinationFormat,
                                          /* paFloat32: */        PA_USE_CONVERTER_( UInt8, Float32 ),
                                          /* paInt32: */          PA_USE_CONVERTER_( UInt8, Int32 ),
                                          /* paInt24: */          PA_USE_CONVERTER_( UInt8, Int24 ),
                                          /* paInt16: */          PA_USE_CONVERTER_( UInt8, Int16 ),
                                          /* paInt8: */           PA_USE_CONVERTER_( UInt8, Int8 ),
                                          /* paUInt8: */          PA_UNITY_CONVERSION_( 8 )
                                        )
                     )
}

/* -------------------------------------------------------------------------- */

#ifdef PA_NO_STANDARD_CONVERTERS

/* -------------------------------------------------------------------------- */

PaUtilConverterTable paConverters = {
    0, /* PaUtilConverter *Float32_To_Int32; */
    0, /* PaUtilConverter *Float32_To_Int32_Dither; */
    0, /* PaUtilConverter *Float32_To_Int32_Clip; */
    0, /* PaUtilConverter *Float32_To_Int32_DitherClip; */

    0, /* PaUtilConverter *Float32_To_Int24; */
    0, /* PaUtilConverter *Float32_To_Int24_Dither; */
    0, /* PaUtilConverter *Float32_To_Int24_Clip; */
    0, /* PaUtilConverter *Float32_To_Int24_DitherClip; */

    0, /* PaUtilConverter *Float32_To_Int16; */
    0, /* PaUtilConverter *Float32_To_Int16_Dither; */
    0, /* PaUtilConverter *Float32_To_Int16_Clip; */
    0, /* PaUtilConverter *Float32_To_Int16_DitherClip; */

    0, /* PaUtilConverter *Float32_To_Int8; */
    0, /* PaUtilConverter *Float32_To_Int8_Dither; */
    0, /* PaUtilConverter *Float32_To_Int8_Clip; */
    0, /* PaUtilConverter *Float32_To_Int8_DitherClip; */

    0, /* PaUtilConverter *Float32_To_UInt8; */
    0, /* PaUtilConverter *Float32_To_UInt8_Dither; */
    0, /* PaUtilConverter *Float32_To_UInt8_Clip; */
    0, /* PaUtilConverter *Float32_To_UInt8_DitherClip; */

    0, /* PaUtilConverter *Int32_To_Float32; */
    0, /* PaUtilConverter *Int32_To_Int24; */
    0, /* PaUtilConverter *Int32_To_Int24_Dither; */
    0, /* PaUtilConverter *Int32_To_Int16; */
    0, /* PaUtilConverter *Int32_To_Int16_Dither; */
    0, /* PaUtilConverter *Int32_To_Int8; */
    0, /* PaUtilConverter *Int32_To_Int8_Dither; */
    0, /* PaUtilConverter *Int32_To_UInt8; */
    0, /* PaUtilConverter *Int32_To_UInt8_Dither; */

    0, /* PaUtilConverter *Int24_To_Float32; */
    0, /* PaUtilConverter *Int24_To_Int32; */
    0, /* PaUtilConverter *Int24_To_Int16; */
    0, /* PaUtilConverter *Int24_To_Int16_Dither; */
    0, /* PaUtilConverter *Int24_To_Int8; */
    0, /* PaUtilConverter *Int24_To_Int8_Dither; */
    0, /* PaUtilConverter *Int24_To_UInt8; */
    0, /* PaUtilConverter *Int24_To_UInt8_Dither; */
    
    0, /* PaUtilConverter *Int16_To_Float32; */
    0, /* PaUtilConverter *Int16_To_Int32; */
    0, /* PaUtilConverter *Int16_To_Int24; */
    0, /* PaUtilConverter *Int16_To_Int8; */
    0, /* PaUtilConverter *Int16_To_Int8_Dither; */
    0, /* PaUtilConverter *Int16_To_UInt8; */
    0, /* PaUtilConverter *Int16_To_UInt8_Dither; */

    0, /* PaUtilConverter *Int8_To_Float32; */
    0, /* PaUtilConverter *Int8_To_Int32; */
    0, /* PaUtilConverter *Int8_To_Int24 */
    0, /* PaUtilConverter *Int8_To_Int16; */
    0, /* PaUtilConverter *Int8_To_UInt8; */

    0, /* PaUtilConverter *UInt8_To_Float32; */
    0, /* PaUtilConverter *UInt8_To_Int32; */
    0, /* PaUtilConverter *UInt8_To_Int24; */
    0, /* PaUtilConverter *UInt8_To_Int16; */
    0, /* PaUtilConverter *UInt8_To_Int8; */

    0, /* PaUtilConverter *Copy_8_To_8; */
    0, /* PaUtilConverter *Copy_16_To_16; */
    0, /* PaUtilConverter *Copy_24_To_24; */
    0  /* PaUtilConverter *Copy_32_To_32; */
};

/* -------------------------------------------------------------------------- */

#else /* PA_NO_STANDARD_CONVERTERS is not defined */

/* -------------------------------------------------------------------------- */

#define PA_CLIP_( val, min, max )\
    { val = ((val) < (min)) ? (min) : (((val) > (max)) ? (max) : (val)); }


static const float const_1_div_128_ = 1.0f / 128.0f;  /* 8 bit multiplier */

static const float const_1_div_32768_ = 1.0f / 32768.f; /* 16 bit multiplier */

static const double const_1_div_2147483648_ = 1.0 / 2147483648.0; /* 32 bit multiplier */

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        /* REVIEW */
#ifdef PA_USE_C99_LRINTF
        float scaled = *src * 0x7FFFFFFF;
        *dest = lrintf(scaled-0.5f);
#else
        double scaled = *src * 0x7FFFFFFF;
        *dest = (PaInt32) scaled;        
#endif
        
        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;

    while( count-- )
    {
        /* REVIEW */
#ifdef PA_USE_C99_LRINTF
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = ((float)*src * (2147483646.0f)) + dither;
        *dest = lrintf(dithered - 0.5f);
#else
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        double dithered = ((double)*src * (2147483646.0)) + dither;
        *dest = (PaInt32) dithered;
#endif
        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;
    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        /* REVIEW */
#ifdef PA_USE_C99_LRINTF
        float scaled = *src * 0x7FFFFFFF;
        PA_CLIP_( scaled, -2147483648.f, 2147483647.f  );
        *dest = lrintf(scaled-0.5f);
#else
        double scaled = *src * 0x7FFFFFFF;
        PA_CLIP_( scaled, -2147483648., 2147483647.  );
        *dest = (PaInt32) scaled;
#endif

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;

    while( count-- )
    {
        /* REVIEW */
#ifdef PA_USE_C99_LRINTF
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = ((float)*src * (2147483646.0f)) + dither;
        PA_CLIP_( dithered, -2147483648.f, 2147483647.f  );
        *dest = lrintf(dithered-0.5f);
#else
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        double dithered = ((double)*src * (2147483646.0)) + dither;
        PA_CLIP_( dithered, -2147483648., 2147483647.  );
        *dest = (PaInt32) dithered;
#endif

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        /* convert to 32 bit and drop the low 8 bits */
        double scaled = (double)(*src) * 2147483647.0;
        temp = (PaInt32) scaled;
        
#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;

    while( count-- )
    {
        /* convert to 32 bit and drop the low 8 bits */

        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        double dithered = ((double)*src * (2147483646.0)) + dither;
        
        temp = (PaInt32) dithered;

#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        /* convert to 32 bit and drop the low 8 bits */
        double scaled = *src * 0x7FFFFFFF;
        PA_CLIP_( scaled, -2147483648., 2147483647.  );
        temp = (PaInt32) scaled;

#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;
    
    while( count-- )
    {
        /* convert to 32 bit and drop the low 8 bits */
        
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        double dithered = ((double)*src * (2147483646.0)) + dither;
        PA_CLIP_( dithered, -2147483648., 2147483647.  );
        
        temp = (PaInt32) dithered;

#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
#ifdef PA_USE_C99_LRINTF
        float tempf = (*src * (32767.0f)) ;
        *dest = lrintf(tempf-0.5f);
#else
        short samp = (short) (*src * (32767.0f));
        *dest = samp;
#endif

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt16 *dest = (PaInt16*)destinationBuffer;

    while( count-- )
    {

        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (32766.0f)) + dither;

#ifdef PA_USE_C99_LRINTF
        *dest = lrintf(dithered-0.5f);
#else
        *dest = (PaInt16) dithered;
#endif

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
#ifdef PA_USE_C99_LRINTF
        long samp = lrintf((*src * (32767.0f)) -0.5f);
#else
        long samp = (PaInt32) (*src * (32767.0f));
#endif
        PA_CLIP_( samp, -0x8000, 0x7FFF );
        *dest = (PaInt16) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {

        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (32766.0f)) + dither;
        PaInt32 samp = (PaInt32) dithered;
        PA_CLIP_( samp, -0x8000, 0x7FFF );
#ifdef PA_USE_C99_LRINTF
        *dest = lrintf(samp-0.5f);
#else
        *dest = (PaInt16) samp;
#endif

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        signed char samp = (signed char) (*src * (127.0f));
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    
    while( count-- )
    {
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (126.0f)) + dither;
        PaInt32 samp = (PaInt32) dithered;
        *dest = (signed char) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int8_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        PaInt32 samp = (PaInt32)(*src * (127.0f));
        PA_CLIP_( samp, -0x80, 0x7F );
        *dest = (signed char) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int8_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (126.0f)) + dither;
        PaInt32 samp = (PaInt32) dithered;
        PA_CLIP_( samp, -0x80, 0x7F );
        *dest = (signed char) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_UInt8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        unsigned char samp = (unsigned char)(128 + ((unsigned char) (*src * (127.0f))));
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_UInt8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    
    while( count-- )
    {
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (126.0f)) + dither;
        PaInt32 samp = (PaInt32) dithered;
        *dest = (unsigned char) (128 + samp);
        
        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_UInt8_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        PaInt32 samp = 128 + (PaInt32)(*src * (127.0f));
        PA_CLIP_( samp, 0x0000, 0x00FF );
        *dest = (unsigned char) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_UInt8_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        /* use smaller scaler to prevent overflow when we add the dither */
        float dithered = (*src * (126.0f)) + dither;
        PaInt32 samp = 128 + (PaInt32) dithered;
        PA_CLIP_( samp, 0x0000, 0x00FF );
        *dest = (unsigned char) samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Float32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    float *dest =  (float*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        *dest = (float) ((double)*src * const_1_div_2147483648_);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src    = (PaInt32*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    (void) ditherGenerator; /* unused parameter */
    
	while( count-- )
    {
		/* REVIEW */
#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(*src >> 8);
        dest[1] = (unsigned char)(*src >> 16);
        dest[2] = (unsigned char)(*src >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(*src >> 24);
        dest[1] = (unsigned char)(*src >> 16);
        dest[2] = (unsigned char)(*src >> 8);
#endif
        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int24_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    (void) destinationBuffer; /* unused parameters */
    (void) destinationStride; /* unused parameters */
    (void) sourceBuffer; /* unused parameters */
    (void) sourceStride; /* unused parameters */
    (void) count; /* unused parameters */
    (void) ditherGenerator; /* unused parameters */
    /* IMPLEMENT ME */
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        *dest = (PaInt16) ((*src) >> 16);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int16_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    PaInt32 dither;

    while( count-- )
    {
        /* REVIEW */
        dither = PaUtil_Generate16BitTriangularDither( ditherGenerator );
        *dest = (PaInt16) ((((*src)>>1) + dither) >> 15);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        *dest = (signed char) ((*src) >> 24);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_Int8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    PaInt32 dither;

    while( count-- )
    {
        /* REVIEW */
        dither = PaUtil_Generate16BitTriangularDither( ditherGenerator );
        *dest = (signed char) ((((*src)>>1) + dither) >> 23);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_UInt8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
		(*dest) = (unsigned char)(((*src) >> 24) + 128); 

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int32_To_UInt8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt32 *src = (PaInt32*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        /* IMPLEMENT ME */

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Float32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    float *dest = (float*)destinationBuffer;
    PaInt32 temp;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        temp = (((PaInt32)src[0]) << 8);  
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 24);
#elif defined(PA_BIG_ENDIAN)
        temp = (((PaInt32)src[0]) << 24);
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 8);
#endif

        *dest = (float) ((double)temp * const_1_div_2147483648_);

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src  = (unsigned char*)sourceBuffer;
    PaInt32 *dest = (PaInt32*)  destinationBuffer;
    PaInt32 temp;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        temp = (((PaInt32)src[0]) << 8);  
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 24);
#elif defined(PA_BIG_ENDIAN)
        temp = (((PaInt32)src[0]) << 24);
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 8);
#endif

        *dest = temp;

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    PaInt16 *dest = (PaInt16*)destinationBuffer;
    
    PaInt16 temp;

    (void) ditherGenerator; /* unused parameter */
        
    while( count-- )
    {
		
#if defined(PA_LITTLE_ENDIAN)
		/* src[0] is discarded */
        temp = (((PaInt16)src[1]));
        temp = temp | (PaInt16)(((PaInt16)src[2]) << 8);
#elif defined(PA_BIG_ENDIAN)
		/* src[2] is discarded */
        temp = (PaInt16)(((PaInt16)src[0]) << 8);
        temp = temp | (((PaInt16)src[1]));
#endif

        *dest = temp;

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Int16_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    PaInt16 *dest = (PaInt16*)destinationBuffer;

    PaInt32 temp, dither;

    while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        temp = (((PaInt32)src[0]) << 8);  
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 24);
#elif defined(PA_BIG_ENDIAN)
        temp = (((PaInt32)src[0]) << 24);
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 8);
#endif

        /* REVIEW */
        dither = PaUtil_Generate16BitTriangularDither( ditherGenerator );
        *dest = (PaInt16) (((temp >> 1) + dither) >> 15);

        src  += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Int8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    signed char  *dest = (signed char*)destinationBuffer;
    
    (void) ditherGenerator; /* unused parameter */
        
    while( count-- )
    {	
	
#if defined(PA_LITTLE_ENDIAN)
		/* src[0] is discarded */
		/* src[1] is discarded */
        *dest = src[2];
#elif defined(PA_BIG_ENDIAN)
		/* src[2] is discarded */
		/* src[1] is discarded */
		*dest = src[0];
#endif

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_Int8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    signed char  *dest = (signed char*)destinationBuffer;
    
    PaInt32 temp, dither;

    while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        temp = (((PaInt32)src[0]) << 8);  
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 24);
#elif defined(PA_BIG_ENDIAN)
        temp = (((PaInt32)src[0]) << 24);
        temp = temp | (((PaInt32)src[1]) << 16);
        temp = temp | (((PaInt32)src[2]) << 8);
#endif

        /* REVIEW */
        dither = PaUtil_Generate16BitTriangularDither( ditherGenerator );
        *dest = (signed char) (((temp >> 1) + dither) >> 23);

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_UInt8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    
    (void) ditherGenerator; /* unused parameter */
        
    while( count-- )
    {
		
#if defined(PA_LITTLE_ENDIAN)
		/* src[0] is discarded */
		/* src[1] is discarded */
        *dest = (unsigned char)(src[2] + 128);
#elif defined(PA_BIG_ENDIAN)
        *dest = (unsigned char)(src[0] + 128);
		/* src[1] is discarded */
		/* src[2] is discarded */		
#endif

        src += sourceStride * 3;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int24_To_UInt8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    (void) destinationBuffer; /* unused parameters */
    (void) destinationStride; /* unused parameters */
    (void) sourceBuffer; /* unused parameters */
    (void) sourceStride; /* unused parameters */
    (void) count; /* unused parameters */
    (void) ditherGenerator; /* unused parameters */
    /* IMPLEMENT ME */
}

/* -------------------------------------------------------------------------- */

static void Int16_To_Float32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    float *dest =  (float*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        float samp = *src * const_1_div_32768_; /* FIXME: i'm concerned about this being asymetrical with float->int16 -rb */
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        /* REVIEW: we should consider something like
            (*src << 16) | (*src & 0xFFFF)
        */
        
        *dest = *src << 16;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src   = (PaInt16*) sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt16 temp;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        temp = *src;
        
#if defined(PA_LITTLE_ENDIAN)
        dest[0] = 0;
        dest[1] = (unsigned char)(temp);
        dest[2] = (unsigned char)(temp >> 8);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp);
        dest[2] = 0;
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_Int8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        (*dest) = (signed char)((*src) >> 8);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_Int8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    signed char *dest =  (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        /* IMPLEMENT ME */

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_UInt8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
		(*dest) = (unsigned char)(((*src) >> 8) + 128); 

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int16_To_UInt8_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaInt16 *src = (PaInt16*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        /* IMPLEMENT ME */

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int8_To_Float32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    signed char *src = (signed char*)sourceBuffer;
    float *dest =  (float*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        float samp = *src * const_1_div_128_;
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int8_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    signed char *src = (signed char*)sourceBuffer;
    PaInt32 *dest =  (PaInt32*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
		(*dest) = (*src) << 24;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int8_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    signed char *src = (signed char*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = (*src);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (*src);
        dest[1] = 0;
        dest[2] = 0;
#endif

        src += sourceStride;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Int8_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    signed char *src = (signed char*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        (*dest) = (PaInt16)((*src) << 8);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Int8_To_UInt8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    signed char *src = (signed char*)sourceBuffer;
    unsigned char *dest =  (unsigned char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        (*dest) = (unsigned char)(*src + 128);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void UInt8_To_Float32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    float *dest =  (float*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        float samp = (*src - 128) * const_1_div_128_;
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void UInt8_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    PaInt32 *dest = (PaInt32*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
		(*dest) = (*src - 128) << 24;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void UInt8_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
	unsigned char *src  = (unsigned char*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    (void) ditherGenerator; /* unused parameters */
    
	while( count-- )
    {

#if defined(PA_LITTLE_ENDIAN)
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = (unsigned char)(*src - 128);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(*src - 128);
        dest[1] = 0;
        dest[2] = 0;
#endif
		
        src += sourceStride;
        dest += destinationStride * 3;    
	}
}

/* -------------------------------------------------------------------------- */

static void UInt8_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    PaInt16 *dest =  (PaInt16*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        (*dest) = (PaInt16)((*src - 128) << 8);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void UInt8_To_Int8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    signed char  *dest = (signed char*)destinationBuffer;
    (void)ditherGenerator; /* unused parameter */

    while( count-- )
    {
        (*dest) = (signed char)(*src - 128);

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Copy_8_To_8(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
                                                      
    (void) ditherGenerator; /* unused parameter */

    while( count-- )
    {
        *dest = *src;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Copy_16_To_16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaUint16 *src = (PaUint16 *)sourceBuffer;
    PaUint16 *dest = (PaUint16 *)destinationBuffer;
                                                        
    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        *dest = *src;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Copy_24_To_24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        dest[0] = src[0];
        dest[1] = src[1];
        dest[2] = src[2];

        src += sourceStride * 3;
        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Copy_32_To_32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    PaUint32 *dest = (PaUint32 *)destinationBuffer;
    PaUint32 *src = (PaUint32 *)sourceBuffer;

    (void) ditherGenerator; /* unused parameter */
    
    while( count-- )
    {
        *dest = *src;

        src += sourceStride;
        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

PaUtilConverterTable paConverters = {
    Float32_To_Int32,              /* PaUtilConverter *Float32_To_Int32; */
    Float32_To_Int32_Dither,       /* PaUtilConverter *Float32_To_Int32_Dither; */
    Float32_To_Int32_Clip,         /* PaUtilConverter *Float32_To_Int32_Clip; */
    Float32_To_Int32_DitherClip,   /* PaUtilConverter *Float32_To_Int32_DitherClip; */

    Float32_To_Int24,              /* PaUtilConverter *Float32_To_Int24; */
    Float32_To_Int24_Dither,       /* PaUtilConverter *Float32_To_Int24_Dither; */
    Float32_To_Int24_Clip,         /* PaUtilConverter *Float32_To_Int24_Clip; */
    Float32_To_Int24_DitherClip,   /* PaUtilConverter *Float32_To_Int24_DitherClip; */
    
    Float32_To_Int16,              /* PaUtilConverter *Float32_To_Int16; */
    Float32_To_Int16_Dither,       /* PaUtilConverter *Float32_To_Int16_Dither; */
    Float32_To_Int16_Clip,         /* PaUtilConverter *Float32_To_Int16_Clip; */
    Float32_To_Int16_DitherClip,   /* PaUtilConverter *Float32_To_Int16_DitherClip; */

    Float32_To_Int8,               /* PaUtilConverter *Float32_To_Int8; */
    Float32_To_Int8_Dither,        /* PaUtilConverter *Float32_To_Int8_Dither; */
    Float32_To_Int8_Clip,          /* PaUtilConverter *Float32_To_Int8_Clip; */
    Float32_To_Int8_DitherClip,    /* PaUtilConverter *Float32_To_Int8_DitherClip; */

    Float32_To_UInt8,              /* PaUtilConverter *Float32_To_UInt8; */
    Float32_To_UInt8_Dither,       /* PaUtilConverter *Float32_To_UInt8_Dither; */
    Float32_To_UInt8_Clip,         /* PaUtilConverter *Float32_To_UInt8_Clip; */
    Float32_To_UInt8_DitherClip,   /* PaUtilConverter *Float32_To_UInt8_DitherClip; */

    Int32_To_Float32,              /* PaUtilConverter *Int32_To_Float32; */
    Int32_To_Int24,                /* PaUtilConverter *Int32_To_Int24; */
    Int32_To_Int24_Dither,         /* PaUtilConverter *Int32_To_Int24_Dither; */
    Int32_To_Int16,                /* PaUtilConverter *Int32_To_Int16; */
    Int32_To_Int16_Dither,         /* PaUtilConverter *Int32_To_Int16_Dither; */
    Int32_To_Int8,                 /* PaUtilConverter *Int32_To_Int8; */
    Int32_To_Int8_Dither,          /* PaUtilConverter *Int32_To_Int8_Dither; */
    Int32_To_UInt8,                /* PaUtilConverter *Int32_To_UInt8; */
    Int32_To_UInt8_Dither,         /* PaUtilConverter *Int32_To_UInt8_Dither; */

    Int24_To_Float32,              /* PaUtilConverter *Int24_To_Float32; */
    Int24_To_Int32,                /* PaUtilConverter *Int24_To_Int32; */
    Int24_To_Int16,                /* PaUtilConverter *Int24_To_Int16; */
    Int24_To_Int16_Dither,         /* PaUtilConverter *Int24_To_Int16_Dither; */
    Int24_To_Int8,                 /* PaUtilConverter *Int24_To_Int8; */
    Int24_To_Int8_Dither,          /* PaUtilConverter *Int24_To_Int8_Dither; */
    Int24_To_UInt8,                /* PaUtilConverter *Int24_To_UInt8; */
    Int24_To_UInt8_Dither,         /* PaUtilConverter *Int24_To_UInt8_Dither; */

    Int16_To_Float32,              /* PaUtilConverter *Int16_To_Float32; */
    Int16_To_Int32,                /* PaUtilConverter *Int16_To_Int32; */
    Int16_To_Int24,                /* PaUtilConverter *Int16_To_Int24; */
    Int16_To_Int8,                 /* PaUtilConverter *Int16_To_Int8; */
    Int16_To_Int8_Dither,          /* PaUtilConverter *Int16_To_Int8_Dither; */
    Int16_To_UInt8,                /* PaUtilConverter *Int16_To_UInt8; */
    Int16_To_UInt8_Dither,         /* PaUtilConverter *Int16_To_UInt8_Dither; */

    Int8_To_Float32,               /* PaUtilConverter *Int8_To_Float32; */
    Int8_To_Int32,                 /* PaUtilConverter *Int8_To_Int32; */
    Int8_To_Int24,                 /* PaUtilConverter *Int8_To_Int24 */
    Int8_To_Int16,                 /* PaUtilConverter *Int8_To_Int16; */
    Int8_To_UInt8,                 /* PaUtilConverter *Int8_To_UInt8; */

    UInt8_To_Float32,              /* PaUtilConverter *UInt8_To_Float32; */
    UInt8_To_Int32,                /* PaUtilConverter *UInt8_To_Int32; */
    UInt8_To_Int24,                /* PaUtilConverter *UInt8_To_Int24; */
    UInt8_To_Int16,                /* PaUtilConverter *UInt8_To_Int16; */
    UInt8_To_Int8,                 /* PaUtilConverter *UInt8_To_Int8; */

    Copy_8_To_8,                   /* PaUtilConverter *Copy_8_To_8; */
    Copy_16_To_16,                 /* PaUtilConverter *Copy_16_To_16; */
    Copy_24_To_24,                 /* PaUtilConverter *Copy_24_To_24; */
    Copy_32_To_32                  /* PaUtilConverter *Copy_32_To_32; */
};

/* -------------------------------------------------------------------------- */

#endif /* PA_NO_STANDARD_CONVERTERS */

/* -------------------------------------------------------------------------- */

PaUtilZeroer* PaUtil_SelectZeroer( PaSampleFormat destinationFormat )
{
    switch( destinationFormat & ~paNonInterleaved ){
    case paFloat32:
        return paZeroers.Zero32;
    case paInt32:
        return paZeroers.Zero32;
    case paInt24:
        return paZeroers.Zero24;
    case paInt16:
        return paZeroers.Zero16;
    case paInt8:
        return paZeroers.Zero8;
    case paUInt8:
        return paZeroers.ZeroU8;
    default: return 0;
    }
}

/* -------------------------------------------------------------------------- */

#ifdef PA_NO_STANDARD_ZEROERS

/* -------------------------------------------------------------------------- */

PaUtilZeroerTable paZeroers = {
    0,  /* PaUtilZeroer *ZeroU8; */
    0,  /* PaUtilZeroer *Zero8; */
    0,  /* PaUtilZeroer *Zero16; */
    0,  /* PaUtilZeroer *Zero24; */
    0,  /* PaUtilZeroer *Zero32; */
};

/* -------------------------------------------------------------------------- */

#else /* PA_NO_STANDARD_ZEROERS is not defined */

/* -------------------------------------------------------------------------- */

static void ZeroU8( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    unsigned char *dest = (unsigned char*)destinationBuffer;

    while( count-- )
    {
        *dest = 128;

        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Zero8( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    unsigned char *dest = (unsigned char*)destinationBuffer;

    while( count-- )
    {
        *dest = 0;

        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Zero16( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    PaUint16 *dest = (PaUint16 *)destinationBuffer;

    while( count-- )
    {
        *dest = 0;

        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

static void Zero24( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    unsigned char *dest = (unsigned char*)destinationBuffer;

    while( count-- )
    {
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;

        dest += destinationStride * 3;
    }
}

/* -------------------------------------------------------------------------- */

static void Zero32( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    PaUint32 *dest = (PaUint32 *)destinationBuffer;

    while( count-- )
    {
        *dest = 0;

        dest += destinationStride;
    }
}

/* -------------------------------------------------------------------------- */

PaUtilZeroerTable paZeroers = {
    ZeroU8,  /* PaUtilZeroer *ZeroU8; */
    Zero8,  /* PaUtilZeroer *Zero8; */
    Zero16,  /* PaUtilZeroer *Zero16; */
    Zero24,  /* PaUtilZeroer *Zero24; */
    Zero32,  /* PaUtilZeroer *Zero32; */
};

/* -------------------------------------------------------------------------- */

#endif /* PA_NO_STANDARD_ZEROERS */
/*
 * $Id$
 * Portable Audio I/O Library CPU Load measurement functions
 * Portable CPU load measurement facility.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 2002 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Functions to assist in measuring the CPU utilization of a callback
 stream. Used to implement the Pa_GetStreamCpuLoad() function.

 @todo Dynamically calculate the coefficients used to smooth the CPU Load
 Measurements over time to provide a uniform characterisation of CPU Load
 independent of rate at which PaUtil_BeginCpuLoadMeasurement /
 PaUtil_EndCpuLoadMeasurement are called. see http://www.portaudio.com/trac/ticket/113
*/


// (amalg) #include "pa_cpuload.h"

#include <assert.h>

// (amalg) #include "pa_util.h"   /* for PaUtil_GetTime() */


void PaUtil_InitializeCpuLoadMeasurer( PaUtilCpuLoadMeasurer* measurer, double sampleRate )
{
    assert( sampleRate > 0 );

    measurer->samplingPeriod = 1. / sampleRate;
    measurer->averageLoad = 0.;
}

void PaUtil_ResetCpuLoadMeasurer( PaUtilCpuLoadMeasurer* measurer )
{
    measurer->averageLoad = 0.;
}

void PaUtil_BeginCpuLoadMeasurement( PaUtilCpuLoadMeasurer* measurer )
{
    measurer->measurementStartTime = PaUtil_GetTime();
}


void PaUtil_EndCpuLoadMeasurement( PaUtilCpuLoadMeasurer* measurer, unsigned long framesProcessed )
{
    double measurementEndTime, secondsFor100Percent, measuredLoad;

    if( framesProcessed > 0 ){
        measurementEndTime = PaUtil_GetTime();

        assert( framesProcessed > 0 );
        secondsFor100Percent = framesProcessed * measurer->samplingPeriod;

        measuredLoad = (measurementEndTime - measurer->measurementStartTime) / secondsFor100Percent;

        /* Low pass filter the calculated CPU load to reduce jitter using a simple IIR low pass filter. */
        /** FIXME @todo these coefficients shouldn't be hardwired see: http://www.portaudio.com/trac/ticket/113 */
#define LOWPASS_COEFFICIENT_0   (0.9)
#define LOWPASS_COEFFICIENT_1   (0.99999 - LOWPASS_COEFFICIENT_0)

        measurer->averageLoad = (LOWPASS_COEFFICIENT_0 * measurer->averageLoad) +
                               (LOWPASS_COEFFICIENT_1 * measuredLoad);
    }
}


double PaUtil_GetCpuLoad( PaUtilCpuLoadMeasurer* measurer )
{
    return measurer->averageLoad;
}
/*
 * $Id: pa_log.c $
 * Portable Audio I/O Library Multi-Host API front end
 * Validate function parameters and manage multiple host APIs.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2006 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Implements log function.

    PaUtil_SetLogPrintFunction can be user called to replace the provided
	DefaultLogPrint function, which writes to stderr.
	One can NOT pass var_args across compiler/dll boundaries as it is not
	"byte code/abi portable". So the technique used here is to allocate a local
	a static array, write in it, then callback the user with a pointer to its
	start.
*/

#include <stdio.h>
#include <stdarg.h>

// (amalg) #include "pa_debugprint.h"

// for OutputDebugStringA
#if defined(_MSC_VER) && defined(PA_ENABLE_MSVC_DEBUG_OUTPUT)
	#define WIN32_LEAN_AND_MEAN // exclude rare headers
	// (amalg) #include "windows.h"
#endif

// User callback
static PaUtilLogCallback userCB = NULL;

// Sets user callback
void PaUtil_SetDebugPrintFunction(PaUtilLogCallback cb)
{
    userCB = cb;
}

/*
 If your platform doesnt have vsnprintf, you are stuck with a
 VERY dangerous alternative, vsprintf (with no n)
*/
#if _MSC_VER
	/* Some Windows Mobile SDKs don't define vsnprintf but all define _vsnprintf (hopefully).
	   According to MSDN "vsnprintf is identical to _vsnprintf". So we use _vsnprintf with MSC.
	*/
	#define VSNPRINTF  _vsnprintf 
#else
	#define VSNPRINTF  vsnprintf
#endif

#define PA_LOG_BUF_SIZE 2048

void PaUtil_DebugPrint( const char *format, ... )
{
	// Optional logging into Output console of Visual Studio
#if defined(_MSC_VER) && defined(PA_ENABLE_MSVC_DEBUG_OUTPUT)
	{
		char buf[PA_LOG_BUF_SIZE];
		va_list ap;
		va_start(ap, format);
		VSNPRINTF(buf, sizeof(buf), format, ap);
		buf[sizeof(buf)-1] = 0;
		OutputDebugStringA(buf);
		va_end(ap);
	}
#endif

	// Output to User-Callback
    if (userCB != NULL)
    {
        char strdump[PA_LOG_BUF_SIZE];
        va_list ap;
        va_start(ap, format);
        VSNPRINTF(strdump, sizeof(strdump), format, ap);
        strdump[sizeof(strdump)-1] = 0;
        userCB(strdump);
        va_end(ap);
    }
    else
	// Standard output to stderr
    {
        va_list ap;
        va_start(ap, format);
        vfprintf(stderr, format, ap);
        va_end(ap);
        fflush(stderr);
    }
}
/*
 * $Id$
 * Portable Audio I/O Library triangular dither generator
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Phil Burk, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Functions for generating dither noise
*/

// (amalg) #include "pa_types.h"
// (amalg) #include "pa_dither.h"


/* Note that the linear congruential algorithm requires 32 bit integers
 * because it uses arithmetic overflow. So use PaUint32 instead of
 * unsigned long so it will work on 64 bit systems.
 */

#define PA_DITHER_BITS_   (15)


void PaUtil_InitializeTriangularDitherState( PaUtilTriangularDitherGenerator *state )
{
    state->previous = 0;
    state->randSeed1 = 22222;
    state->randSeed2 = 5555555;
}


PaInt32 PaUtil_Generate16BitTriangularDither( PaUtilTriangularDitherGenerator *state )
{
    PaInt32 current, highPass;

    /* Generate two random numbers. */
    state->randSeed1 = (state->randSeed1 * 196314165) + 907633515;
    state->randSeed2 = (state->randSeed2 * 196314165) + 907633515;

    /* Generate triangular distribution about 0.
     * Shift before adding to prevent overflow which would skew the distribution.
     * Also shift an extra bit for the high pass filter. 
     */
#define DITHER_SHIFT_  ((sizeof(PaInt32)*8 - PA_DITHER_BITS_) + 1)
	
    current = (((PaInt32)state->randSeed1)>>DITHER_SHIFT_) +
              (((PaInt32)state->randSeed2)>>DITHER_SHIFT_);

    /* High pass filter to reduce audibility. */
    highPass = current - state->previous;
    state->previous = current;
    return highPass;
}


/* Multiply by PA_FLOAT_DITHER_SCALE_ to get a float between -2.0 and +1.99999 */
#define PA_FLOAT_DITHER_SCALE_  (1.0f / ((1<<PA_DITHER_BITS_)-1))
static const float const_float_dither_scale_ = PA_FLOAT_DITHER_SCALE_;

float PaUtil_GenerateFloatTriangularDither( PaUtilTriangularDitherGenerator *state )
{
    PaInt32 current, highPass;

    /* Generate two random numbers. */
    state->randSeed1 = (state->randSeed1 * 196314165) + 907633515;
    state->randSeed2 = (state->randSeed2 * 196314165) + 907633515;

    /* Generate triangular distribution about 0.
     * Shift before adding to prevent overflow which would skew the distribution.
     * Also shift an extra bit for the high pass filter. 
     */
    current = (((PaInt32)state->randSeed1)>>DITHER_SHIFT_) +
              (((PaInt32)state->randSeed2)>>DITHER_SHIFT_);

    /* High pass filter to reduce audibility. */
    highPass = current - state->previous;
    state->previous = current;
    return ((float)highPass) * const_float_dither_scale_;
}


/*
The following alternate dither algorithms (from musicdsp.org) could be
considered
*/

/*Noise shaped dither  (March 2000)
-------------------

This is a simple implementation of highpass triangular-PDF dither with
2nd-order noise shaping, for use when truncating floating point audio
data to fixed point.

The noise shaping lowers the noise floor by 11dB below 5kHz (@ 44100Hz
sample rate) compared to triangular-PDF dither. The code below assumes
input data is in the range +1 to -1 and doesn't check for overloads!

To save time when generating dither for multiple channels you can do
things like this:  r3=(r1 & 0x7F)<<8; instead of calling rand() again.



  int   r1, r2;                //rectangular-PDF random numbers
  float s1, s2;                //error feedback buffers
  float s = 0.5f;              //set to 0.0f for no noise shaping
  float w = pow(2.0,bits-1);   //word length (usually bits=16)
  float wi= 1.0f/w;            
  float d = wi / RAND_MAX;     //dither amplitude (2 lsb)
  float o = wi * 0.5f;         //remove dc offset
  float in, tmp;
  int   out;


//for each sample...

  r2=r1;                               //can make HP-TRI dither by
  r1=rand();                           //subtracting previous rand()
    
  in += s * (s1 + s1 - s2);            //error feedback
  tmp = in + o + d * (float)(r1 - r2); //dc offset and dither 
  
  out = (int)(w * tmp);                //truncate downwards
  if(tmp<0.0f) out--;                  //this is faster than floor()

  s2 = s1;                            
  s1 = in - wi * (float)out;           //error



-- 
paul.kellett@maxim.abel.co.uk
http://www.maxim.abel.co.uk
*/


/*
16-to-8-bit first-order dither

Type : First order error feedforward dithering code
References : Posted by Jon Watte

Notes : 
This is about as simple a dithering algorithm as you can implement, but it's
likely to sound better than just truncating to N bits.

Note that you might not want to carry forward the full difference for infinity.
It's probably likely that the worst performance hit comes from the saturation
conditionals, which can be avoided with appropriate instructions on many DSPs
and integer SIMD type instructions, or CMOV.

Last, if sound quality is paramount (such as when going from > 16 bits to 16
bits) you probably want to use a higher-order dither function found elsewhere
on this site. 


Code : 
// This code will down-convert and dither a 16-bit signed short 
// mono signal into an 8-bit unsigned char signal, using a first 
// order forward-feeding error term dither. 

#define uchar unsigned char 

void dither_one_channel_16_to_8( short * input, uchar * output, int count, int * memory ) 
{ 
  int m = *memory; 
  while( count-- > 0 ) { 
    int i = *input++; 
    i += m; 
    int j = i + 32768 - 128; 
    uchar o; 
    if( j < 0 ) { 
      o = 0; 
    } 
    else if( j > 65535 ) { 
      o = 255; 
    } 
    else { 
      o = (uchar)((j>>8)&0xff); 
    } 
    m = ((j-32768+128)-i); 
    *output++ = o; 
  } 
  *memory = m; 
} 
*/
/*
 * $Id$
 * Portable Audio I/O Library Multi-Host API front end
 * Validate function parameters and manage multiple host APIs.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Implements PortAudio API functions defined in portaudio.h, checks
 some errors, delegates platform-specific behavior to host API implementations.

 Implements the functions defined in the PortAudio API (portaudio.h),
 validates some parameters and checks for state inconsistencies before
 forwarding API requests to specific Host API implementations (via the
 interface declared in pa_hostapi.h), and Streams (via the interface
 declared in pa_stream.h).

 This file manages initialization and termination of Host API
 implementations via initializer functions stored in the paHostApiInitializers
 global array (usually defined in an os-specific pa_[os]_hostapis.c file).

 This file maintains a list of all open streams and closes them at Pa_Terminate().

 Some utility functions declared in pa_util.h are implemented in this file.

 All PortAudio API functions can be conditionally compiled with logging code.
 To compile with logging, define the PA_LOG_API_CALLS precompiler symbol.
*/


#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h> /* needed for strtol() */
#include <assert.h> /* needed by PA_VALIDATE_ENDIANNESS */

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_endianness.h"
// (amalg) #include "pa_types.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_trace.h" /* still usefull?*/
// (amalg) #include "pa_debugprint.h"

#ifndef PA_GIT_REVISION
// (amalg) #include "pa_gitrevision.h"
#endif

/**
 * This is incremented if we make incompatible API changes.
 * This version scheme is based loosely on http://semver.org/
 */
#define paVersionMajor     19

/**
 * This is incremented when we add functionality in a backwards-compatible manner.
 * Or it is set to zero when paVersionMajor is incremented.
 */
#define paVersionMinor      6

/**
 * This is incremented when we make backwards-compatible bug fixes.
 * Or it is set to zero when paVersionMinor changes.
 */
#define paVersionSubMinor   0

/**
 * This is a combination of paVersionMajor, paVersionMinor and paVersionSubMinor.
 * It will always increase so that version numbers can be compared as integers to
 * see which is later.
 */
#define paVersion  paMakeVersionNumber(paVersionMajor, paVersionMinor, paVersionSubMinor)

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

#define PA_VERSION_STRING_ TOSTRING(paVersionMajor) "." TOSTRING(paVersionMinor) "." TOSTRING(paVersionSubMinor)
#define PA_VERSION_TEXT_   "PortAudio V" PA_VERSION_STRING_ "-devel, revision " TOSTRING(PA_GIT_REVISION)

int Pa_GetVersion( void )
{
    return paVersion;
}

const char* Pa_GetVersionText( void )
{
    return PA_VERSION_TEXT_;
}

static PaVersionInfo versionInfo_ = {
    /*.versionMajor =*/ paVersionMajor,
    /*.versionMinor =*/ paVersionMinor,
    /*.versionSubMinor =*/ paVersionSubMinor,
    /*.versionControlRevision =*/ TOSTRING(PA_GIT_REVISION),
    /*.versionText =*/ PA_VERSION_TEXT_
};

const PaVersionInfo* Pa_GetVersionInfo()
{
    return &versionInfo_;
}

#define PA_LAST_HOST_ERROR_TEXT_LENGTH_  1024

static char lastHostErrorText_[ PA_LAST_HOST_ERROR_TEXT_LENGTH_ + 1 ] = {0};

static PaHostErrorInfo lastHostErrorInfo_ = { (PaHostApiTypeId)-1, 0, lastHostErrorText_ };


void PaUtil_SetLastHostErrorInfo( PaHostApiTypeId hostApiType, long errorCode,
        const char *errorText )
{
    lastHostErrorInfo_.hostApiType = hostApiType;
    lastHostErrorInfo_.errorCode = errorCode;

    strncpy( lastHostErrorText_, errorText, PA_LAST_HOST_ERROR_TEXT_LENGTH_ );
}



static PaUtilHostApiRepresentation **hostApis_ = 0;
static int hostApisCount_ = 0;
static int defaultHostApiIndex_ = 0;
static int initializationCount_ = 0;
static int deviceCount_ = 0;

PaUtilStreamRepresentation *firstOpenStream_ = NULL;


#define PA_IS_INITIALISED_ (initializationCount_ != 0)


static int CountHostApiInitializers( void )
{
    int result = 0;

    while( paHostApiInitializers[ result ] != 0 )
        ++result;
    return result;
}


static void TerminateHostApis( void )
{
    /* terminate in reverse order from initialization */
    PA_DEBUG(("TerminateHostApis in \n"));

    while( hostApisCount_ > 0 )
    {
        --hostApisCount_;
        hostApis_[hostApisCount_]->Terminate( hostApis_[hostApisCount_] );
    }
    hostApisCount_ = 0;
    defaultHostApiIndex_ = 0;
    deviceCount_ = 0;

    if( hostApis_ != 0 )
        PaUtil_FreeMemory( hostApis_ );
    hostApis_ = 0;

    PA_DEBUG(("TerminateHostApis out\n"));
}


static PaError InitializeHostApis( void )
{
    PaError result = paNoError;
    int i, initializerCount, baseDeviceIndex;

    initializerCount = CountHostApiInitializers();

    hostApis_ = (PaUtilHostApiRepresentation**)PaUtil_AllocateMemory(
            sizeof(PaUtilHostApiRepresentation*) * initializerCount );
    if( !hostApis_ )
    {
        result = paInsufficientMemory;
        goto error;
    }

    hostApisCount_ = 0;
    defaultHostApiIndex_ = -1; /* indicates that we haven't determined the default host API yet */
    deviceCount_ = 0;
    baseDeviceIndex = 0;

    for( i=0; i< initializerCount; ++i )
    {
        hostApis_[hostApisCount_] = NULL;

        PA_DEBUG(( "before paHostApiInitializers[%d].\n",i));

        result = paHostApiInitializers[i]( &hostApis_[hostApisCount_], hostApisCount_ );
        if( result != paNoError )
            goto error;

        PA_DEBUG(( "after paHostApiInitializers[%d].\n",i));

        if( hostApis_[hostApisCount_] )
        {
            PaUtilHostApiRepresentation* hostApi = hostApis_[hostApisCount_];
            assert( hostApi->info.defaultInputDevice < hostApi->info.deviceCount );
            assert( hostApi->info.defaultOutputDevice < hostApi->info.deviceCount );

            /* the first successfully initialized host API with a default input *or*
               output device is used as the default host API.
            */
            if( (defaultHostApiIndex_ == -1) &&
                    ( hostApi->info.defaultInputDevice != paNoDevice
                        || hostApi->info.defaultOutputDevice != paNoDevice ) )
            {
                defaultHostApiIndex_ = hostApisCount_;
            }

            hostApi->privatePaFrontInfo.baseDeviceIndex = baseDeviceIndex;

            if( hostApi->info.defaultInputDevice != paNoDevice )
                hostApi->info.defaultInputDevice += baseDeviceIndex;

            if( hostApi->info.defaultOutputDevice != paNoDevice )
                hostApi->info.defaultOutputDevice += baseDeviceIndex;

            baseDeviceIndex += hostApi->info.deviceCount;
            deviceCount_ += hostApi->info.deviceCount;

            ++hostApisCount_;
        }
    }

    /* if no host APIs have devices, the default host API is the first initialized host API */
    if( defaultHostApiIndex_ == -1 )
        defaultHostApiIndex_ = 0;

    return result;

error:
    TerminateHostApis();
    return result;
}


/*
    FindHostApi() finds the index of the host api to which
    <device> belongs and returns it. if <hostSpecificDeviceIndex> is
    non-null, the host specific device index is returned in it.
    returns -1 if <device> is out of range.

*/
static int FindHostApi( PaDeviceIndex device, int *hostSpecificDeviceIndex )
{
    int i=0;

    if( !PA_IS_INITIALISED_ )
        return -1;

    if( device < 0 )
        return -1;

    while( i < hostApisCount_
            && device >= hostApis_[i]->info.deviceCount )
    {

        device -= hostApis_[i]->info.deviceCount;
        ++i;
    }

    if( i >= hostApisCount_ )
        return -1;

    if( hostSpecificDeviceIndex )
        *hostSpecificDeviceIndex = device;

    return i;
}


static void AddOpenStream( PaStream* stream )
{
    ((PaUtilStreamRepresentation*)stream)->nextOpenStream = firstOpenStream_;
    firstOpenStream_ = (PaUtilStreamRepresentation*)stream;
}


static void RemoveOpenStream( PaStream* stream )
{
    PaUtilStreamRepresentation *previous = NULL;
    PaUtilStreamRepresentation *current = firstOpenStream_;

    while( current != NULL )
    {
        if( ((PaStream*)current) == stream )
        {
            if( previous == NULL )
            {
                firstOpenStream_ = current->nextOpenStream;
            }
            else
            {
                previous->nextOpenStream = current->nextOpenStream;
            }
            return;
        }
        else
        {
            previous = current;
            current = current->nextOpenStream;
        }
    }
}


static void CloseOpenStreams( void )
{
    /* we call Pa_CloseStream() here to ensure that the same destruction
        logic is used for automatically closed streams */

    while( firstOpenStream_ != NULL )
        Pa_CloseStream( firstOpenStream_ );
}


PaError Pa_Initialize( void )
{
    PaError result;

    PA_LOGAPI_ENTER( "Pa_Initialize" );

    if( PA_IS_INITIALISED_ )
    {
        ++initializationCount_;
        result = paNoError;
    }
    else
    {
        PA_VALIDATE_TYPE_SIZES;
        PA_VALIDATE_ENDIANNESS;

        PaUtil_InitializeClock();
        PaUtil_ResetTraceMessages();

        result = InitializeHostApis();
        if( result == paNoError )
            ++initializationCount_;
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_Initialize", result );

    return result;
}


PaError Pa_Terminate( void )
{
    PaError result;

    PA_LOGAPI_ENTER( "Pa_Terminate" );

    if( PA_IS_INITIALISED_ )
    {
        // leave initializationCount_>0 so that Pa_CloseStream() can execute
        if( initializationCount_ == 1 )
        {
            CloseOpenStreams();

            TerminateHostApis();

            PaUtil_DumpTraceMessages();
        }
        --initializationCount_;
        result = paNoError;
    }
    else
    {
        result=  paNotInitialized;
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_Terminate", result );

    return result;
}


const PaHostErrorInfo* Pa_GetLastHostErrorInfo( void )
{
    return &lastHostErrorInfo_;
}


const char *Pa_GetErrorText( PaError errorCode )
{
    const char *result;

    switch( errorCode )
    {
    case paNoError:                  result = "Success"; break;
    case paNotInitialized:           result = "PortAudio not initialized"; break;
    /** @todo could catenate the last host error text to result in the case of paUnanticipatedHostError. see: http://www.portaudio.com/trac/ticket/114 */
    case paUnanticipatedHostError:   result = "Unanticipated host error"; break;
    case paInvalidChannelCount:      result = "Invalid number of channels"; break;
    case paInvalidSampleRate:        result = "Invalid sample rate"; break;
    case paInvalidDevice:            result = "Invalid device"; break;
    case paInvalidFlag:              result = "Invalid flag"; break;
    case paSampleFormatNotSupported: result = "Sample format not supported"; break;
    case paBadIODeviceCombination:   result = "Illegal combination of I/O devices"; break;
    case paInsufficientMemory:       result = "Insufficient memory"; break;
    case paBufferTooBig:             result = "Buffer too big"; break;
    case paBufferTooSmall:           result = "Buffer too small"; break;
    case paNullCallback:             result = "No callback routine specified"; break;
    case paBadStreamPtr:             result = "Invalid stream pointer"; break;
    case paTimedOut:                 result = "Wait timed out"; break;
    case paInternalError:            result = "Internal PortAudio error"; break;
    case paDeviceUnavailable:        result = "Device unavailable"; break;
    case paIncompatibleHostApiSpecificStreamInfo:   result = "Incompatible host API specific stream info"; break;
    case paStreamIsStopped:          result = "Stream is stopped"; break;
    case paStreamIsNotStopped:       result = "Stream is not stopped"; break;
    case paInputOverflowed:          result = "Input overflowed"; break;
    case paOutputUnderflowed:        result = "Output underflowed"; break;
    case paHostApiNotFound:          result = "Host API not found"; break;
    case paInvalidHostApi:           result = "Invalid host API"; break;
    case paCanNotReadFromACallbackStream:       result = "Can't read from a callback stream"; break;
    case paCanNotWriteToACallbackStream:        result = "Can't write to a callback stream"; break;
    case paCanNotReadFromAnOutputOnlyStream:    result = "Can't read from an output only stream"; break;
    case paCanNotWriteToAnInputOnlyStream:      result = "Can't write to an input only stream"; break;
    case paIncompatibleStreamHostApi: result = "Incompatible stream host API"; break;
    case paBadBufferPtr:             result = "Bad buffer pointer"; break;
    default:
		if( errorCode > 0 )
			result = "Invalid error code (value greater than zero)";
        else
			result = "Invalid error code";
        break;
    }
    return result;
}


PaHostApiIndex Pa_HostApiTypeIdToHostApiIndex( PaHostApiTypeId type )
{
    PaHostApiIndex result;
    int i;

    PA_LOGAPI_ENTER_PARAMS( "Pa_HostApiTypeIdToHostApiIndex" );
    PA_LOGAPI(("\tPaHostApiTypeId type: %d\n", type ));

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        result = paHostApiNotFound;

        for( i=0; i < hostApisCount_; ++i )
        {
            if( hostApis_[i]->info.type == type )
            {
                result = i;
                break;
            }
        }
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_HostApiTypeIdToHostApiIndex", "PaHostApiIndex: %d", result );

    return result;
}


PaError PaUtil_GetHostApiRepresentation( struct PaUtilHostApiRepresentation **hostApi,
        PaHostApiTypeId type )
{
    PaError result;
    int i;

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        result = paHostApiNotFound;

        for( i=0; i < hostApisCount_; ++i )
        {
            if( hostApis_[i]->info.type == type )
            {
                *hostApi = hostApis_[i];
                result = paNoError;
                break;
            }
        }
    }

    return result;
}


PaError PaUtil_DeviceIndexToHostApiDeviceIndex(
        PaDeviceIndex *hostApiDevice, PaDeviceIndex device, struct PaUtilHostApiRepresentation *hostApi )
{
    PaError result;
    PaDeviceIndex x;

    x = device - hostApi->privatePaFrontInfo.baseDeviceIndex;

    if( x < 0 || x >= hostApi->info.deviceCount )
    {
        result = paInvalidDevice;
    }
    else
    {
        *hostApiDevice = x;
        result = paNoError;
    }

    return result;
}


PaHostApiIndex Pa_GetHostApiCount( void )
{
    int result;

    PA_LOGAPI_ENTER( "Pa_GetHostApiCount" );

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        result = hostApisCount_;
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_GetHostApiCount", "PaHostApiIndex: %d", result );

    return result;
}


PaHostApiIndex Pa_GetDefaultHostApi( void )
{
    int result;

    PA_LOGAPI_ENTER( "Pa_GetDefaultHostApi" );

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        result = defaultHostApiIndex_;

        /* internal consistency check: make sure that the default host api
         index is within range */

        if( result < 0 || result >= hostApisCount_ )
        {
            result = paInternalError;
        }
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_GetDefaultHostApi", "PaHostApiIndex: %d", result );

    return result;
}


const PaHostApiInfo* Pa_GetHostApiInfo( PaHostApiIndex hostApi )
{
    PaHostApiInfo *info;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetHostApiInfo" );
    PA_LOGAPI(("\tPaHostApiIndex hostApi: %d\n", hostApi ));

    if( !PA_IS_INITIALISED_ )
    {
        info = NULL;

        PA_LOGAPI(("Pa_GetHostApiInfo returned:\n" ));
        PA_LOGAPI(("\tPaHostApiInfo*: NULL [ PortAudio not initialized ]\n" ));

    }
    else if( hostApi < 0 || hostApi >= hostApisCount_ )
    {
        info = NULL;

        PA_LOGAPI(("Pa_GetHostApiInfo returned:\n" ));
        PA_LOGAPI(("\tPaHostApiInfo*: NULL [ hostApi out of range ]\n" ));

    }
    else
    {
        info = &hostApis_[hostApi]->info;

        PA_LOGAPI(("Pa_GetHostApiInfo returned:\n" ));
        PA_LOGAPI(("\tPaHostApiInfo*: 0x%p\n", info ));
        PA_LOGAPI(("\t{\n" ));
        PA_LOGAPI(("\t\tint structVersion: %d\n", info->structVersion ));
        PA_LOGAPI(("\t\tPaHostApiTypeId type: %d\n", info->type ));
        PA_LOGAPI(("\t\tconst char *name: %s\n", info->name ));
        PA_LOGAPI(("\t}\n" ));

    }

     return info;
}


PaDeviceIndex Pa_HostApiDeviceIndexToDeviceIndex( PaHostApiIndex hostApi, int hostApiDeviceIndex )
{
    PaDeviceIndex result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_HostApiDeviceIndexToPaDeviceIndex" );
    PA_LOGAPI(("\tPaHostApiIndex hostApi: %d\n", hostApi ));
    PA_LOGAPI(("\tint hostApiDeviceIndex: %d\n", hostApiDeviceIndex ));

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        if( hostApi < 0 || hostApi >= hostApisCount_ )
        {
            result = paInvalidHostApi;
        }
        else
        {
            if( hostApiDeviceIndex < 0 ||
                    hostApiDeviceIndex >= hostApis_[hostApi]->info.deviceCount )
            {
                result = paInvalidDevice;
            }
            else
            {
                result = hostApis_[hostApi]->privatePaFrontInfo.baseDeviceIndex + hostApiDeviceIndex;
            }
        }
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_HostApiDeviceIndexToPaDeviceIndex", "PaDeviceIndex: %d", result );

    return result;
}


PaDeviceIndex Pa_GetDeviceCount( void )
{
    PaDeviceIndex result;

    PA_LOGAPI_ENTER( "Pa_GetDeviceCount" );

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;
    }
    else
    {
        result = deviceCount_;
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_GetDeviceCount", "PaDeviceIndex: %d", result );

    return result;
}


PaDeviceIndex Pa_GetDefaultInputDevice( void )
{
    PaHostApiIndex hostApi;
    PaDeviceIndex result;

    PA_LOGAPI_ENTER( "Pa_GetDefaultInputDevice" );

    hostApi = Pa_GetDefaultHostApi();
    if( hostApi < 0 )
    {
        result = paNoDevice;
    }
    else
    {
        result = hostApis_[hostApi]->info.defaultInputDevice;
    }

    PA_LOGAPI_EXIT_T( "Pa_GetDefaultInputDevice", "PaDeviceIndex: %d", result );

    return result;
}


PaDeviceIndex Pa_GetDefaultOutputDevice( void )
{
    PaHostApiIndex hostApi;
    PaDeviceIndex result;

    PA_LOGAPI_ENTER( "Pa_GetDefaultOutputDevice" );

    hostApi = Pa_GetDefaultHostApi();
    if( hostApi < 0 )
    {
        result = paNoDevice;
    }
    else
    {
        result = hostApis_[hostApi]->info.defaultOutputDevice;
    }

    PA_LOGAPI_EXIT_T( "Pa_GetDefaultOutputDevice", "PaDeviceIndex: %d", result );

    return result;
}


const PaDeviceInfo* Pa_GetDeviceInfo( PaDeviceIndex device )
{
    int hostSpecificDeviceIndex;
    int hostApiIndex = FindHostApi( device, &hostSpecificDeviceIndex );
    PaDeviceInfo *result;


    PA_LOGAPI_ENTER_PARAMS( "Pa_GetDeviceInfo" );
    PA_LOGAPI(("\tPaDeviceIndex device: %d\n", device ));

    if( hostApiIndex < 0 )
    {
        result = NULL;

        PA_LOGAPI(("Pa_GetDeviceInfo returned:\n" ));
        PA_LOGAPI(("\tPaDeviceInfo* NULL [ invalid device index ]\n" ));

    }
    else
    {
        result = hostApis_[hostApiIndex]->deviceInfos[ hostSpecificDeviceIndex ];

        PA_LOGAPI(("Pa_GetDeviceInfo returned:\n" ));
        PA_LOGAPI(("\tPaDeviceInfo*: 0x%p:\n", result ));
        PA_LOGAPI(("\t{\n" ));

        PA_LOGAPI(("\t\tint structVersion: %d\n", result->structVersion ));
        PA_LOGAPI(("\t\tconst char *name: %s\n", result->name ));
        PA_LOGAPI(("\t\tPaHostApiIndex hostApi: %d\n", result->hostApi ));
        PA_LOGAPI(("\t\tint maxInputChannels: %d\n", result->maxInputChannels ));
        PA_LOGAPI(("\t\tint maxOutputChannels: %d\n", result->maxOutputChannels ));
        PA_LOGAPI(("\t}\n" ));

    }

    return result;
}


/*
    SampleFormatIsValid() returns 1 if sampleFormat is a sample format
    defined in portaudio.h, or 0 otherwise.
*/
static int SampleFormatIsValid( PaSampleFormat format )
{
    switch( format & ~paNonInterleaved )
    {
    case paFloat32: return 1;
    case paInt16: return 1;
    case paInt32: return 1;
    case paInt24: return 1;
    case paInt8: return 1;
    case paUInt8: return 1;
    case paCustomFormat: return 1;
    default: return 0;
    }
}

/*
    NOTE: make sure this validation list is kept syncronised with the one in
            pa_hostapi.h

    ValidateOpenStreamParameters() checks that parameters to Pa_OpenStream()
    conform to the expected values as described below. This function is
    also designed to be used with the proposed Pa_IsFormatSupported() function.

    There are basically two types of validation that could be performed:
    Generic conformance validation, and device capability mismatch
    validation. This function performs only generic conformance validation.
    Validation that would require knowledge of device capabilities is
    not performed because of potentially complex relationships between
    combinations of parameters - for example, even if the sampleRate
    seems ok, it might not be for a duplex stream - we have no way of
    checking this in an API-neutral way, so we don't try.

    On success the function returns PaNoError and fills in hostApi,
    hostApiInputDeviceID, and hostApiOutputDeviceID fields. On failure
    the function returns an error code indicating the first encountered
    parameter error.


    If ValidateOpenStreamParameters() returns paNoError, the following
    assertions are guaranteed to be true.

    - at least one of inputParameters & outputParmeters is valid (not NULL)

    - if inputParameters & outputParameters are both valid, that
        inputParameters->device & outputParameters->device  both use the same host api

    PaDeviceIndex inputParameters->device
        - is within range (0 to Pa_GetDeviceCount-1) Or:
        - is paUseHostApiSpecificDeviceSpecification and
            inputParameters->hostApiSpecificStreamInfo is non-NULL and refers
            to a valid host api

    int inputParameters->channelCount
        - if inputParameters->device is not paUseHostApiSpecificDeviceSpecification, channelCount is > 0
        - upper bound is NOT validated against device capabilities

    PaSampleFormat inputParameters->sampleFormat
        - is one of the sample formats defined in portaudio.h

    void *inputParameters->hostApiSpecificStreamInfo
        - if supplied its hostApi field matches the input device's host Api

    PaDeviceIndex outputParmeters->device
        - is within range (0 to Pa_GetDeviceCount-1)

    int outputParmeters->channelCount
        - if inputDevice is valid, channelCount is > 0
        - upper bound is NOT validated against device capabilities

    PaSampleFormat outputParmeters->sampleFormat
        - is one of the sample formats defined in portaudio.h

    void *outputParmeters->hostApiSpecificStreamInfo
        - if supplied its hostApi field matches the output device's host Api

    double sampleRate
        - is not an 'absurd' rate (less than 1000. or greater than 384000.)
        - sampleRate is NOT validated against device capabilities

    PaStreamFlags streamFlags
        - unused platform neutral flags are zero
        - paNeverDropInput is only used for full-duplex callback streams with
            variable buffer size (paFramesPerBufferUnspecified)
*/
static PaError ValidateOpenStreamParameters(
    const PaStreamParameters *inputParameters,
    const PaStreamParameters *outputParameters,
    double sampleRate,
    unsigned long framesPerBuffer,
    PaStreamFlags streamFlags,
    PaStreamCallback *streamCallback,
    PaUtilHostApiRepresentation **hostApi,
    PaDeviceIndex *hostApiInputDevice,
    PaDeviceIndex *hostApiOutputDevice )
{
    int inputHostApiIndex  = -1, /* Surpress uninitialised var warnings: compiler does */
        outputHostApiIndex = -1; /* not see that if inputParameters and outputParame-  */
                                 /* ters are both nonzero, these indices are set.      */

    if( (inputParameters == NULL) && (outputParameters == NULL) )
    {
        return paInvalidDevice; /** @todo should be a new error code "invalid device parameters" or something */
    }
    else
    {
        if( inputParameters == NULL )
        {
            *hostApiInputDevice = paNoDevice;
        }
        else if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
        {
            if( inputParameters->hostApiSpecificStreamInfo )
            {
                inputHostApiIndex = Pa_HostApiTypeIdToHostApiIndex(
                        ((PaUtilHostApiSpecificStreamInfoHeader*)inputParameters->hostApiSpecificStreamInfo)->hostApiType );

                if( inputHostApiIndex != -1 )
                {
                    *hostApiInputDevice = paUseHostApiSpecificDeviceSpecification;
                    *hostApi = hostApis_[inputHostApiIndex];
                }
                else
                {
                    return paInvalidDevice;
                }
            }
            else
            {
                return paInvalidDevice;
            }
        }
        else
        {
            if( inputParameters->device < 0 || inputParameters->device >= deviceCount_ )
                return paInvalidDevice;

            inputHostApiIndex = FindHostApi( inputParameters->device, hostApiInputDevice );
            if( inputHostApiIndex < 0 )
                return paInternalError;

            *hostApi = hostApis_[inputHostApiIndex];

            if( inputParameters->channelCount <= 0 )
                return paInvalidChannelCount;

            if( !SampleFormatIsValid( inputParameters->sampleFormat ) )
                return paSampleFormatNotSupported;

            if( inputParameters->hostApiSpecificStreamInfo != NULL )
            {
                if( ((PaUtilHostApiSpecificStreamInfoHeader*)inputParameters->hostApiSpecificStreamInfo)->hostApiType
                        != (*hostApi)->info.type )
                    return paIncompatibleHostApiSpecificStreamInfo;
            }
        }

        if( outputParameters == NULL )
        {
            *hostApiOutputDevice = paNoDevice;
        }
        else if( outputParameters->device == paUseHostApiSpecificDeviceSpecification  )
        {
            if( outputParameters->hostApiSpecificStreamInfo )
            {
                outputHostApiIndex = Pa_HostApiTypeIdToHostApiIndex(
                        ((PaUtilHostApiSpecificStreamInfoHeader*)outputParameters->hostApiSpecificStreamInfo)->hostApiType );

                if( outputHostApiIndex != -1 )
                {
                    *hostApiOutputDevice = paUseHostApiSpecificDeviceSpecification;
                    *hostApi = hostApis_[outputHostApiIndex];
                }
                else
                {
                    return paInvalidDevice;
                }
            }
            else
            {
                return paInvalidDevice;
            }
        }
        else
        {
            if( outputParameters->device < 0 || outputParameters->device >= deviceCount_ )
                return paInvalidDevice;

            outputHostApiIndex = FindHostApi( outputParameters->device, hostApiOutputDevice );
            if( outputHostApiIndex < 0 )
                return paInternalError;

            *hostApi = hostApis_[outputHostApiIndex];

            if( outputParameters->channelCount <= 0 )
                return paInvalidChannelCount;

            if( !SampleFormatIsValid( outputParameters->sampleFormat ) )
                return paSampleFormatNotSupported;

            if( outputParameters->hostApiSpecificStreamInfo != NULL )
            {
                if( ((PaUtilHostApiSpecificStreamInfoHeader*)outputParameters->hostApiSpecificStreamInfo)->hostApiType
                        != (*hostApi)->info.type )
                    return paIncompatibleHostApiSpecificStreamInfo;
            }
        }

        if( (inputParameters != NULL) && (outputParameters != NULL) )
        {
            /* ensure that both devices use the same API */
            if( inputHostApiIndex != outputHostApiIndex )
                return paBadIODeviceCombination;
        }
    }


    /* Check for absurd sample rates. */
    if( (sampleRate < 1000.0) || (sampleRate > 384000.0) )
        return paInvalidSampleRate;

    if( ((streamFlags & ~paPlatformSpecificFlags) & ~(paClipOff | paDitherOff | paNeverDropInput | paPrimeOutputBuffersUsingStreamCallback ) ) != 0 )
        return paInvalidFlag;

    if( streamFlags & paNeverDropInput )
    {
        /* must be a callback stream */
        if( !streamCallback )
             return paInvalidFlag;

        /* must be a full duplex stream */
        if( (inputParameters == NULL) || (outputParameters == NULL) )
            return paInvalidFlag;

        /* must use paFramesPerBufferUnspecified */
        if( framesPerBuffer != paFramesPerBufferUnspecified )
            return paInvalidFlag;
    }

    return paNoError;
}


PaError Pa_IsFormatSupported( const PaStreamParameters *inputParameters,
                              const PaStreamParameters *outputParameters,
                              double sampleRate )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi = 0;
    PaDeviceIndex hostApiInputDevice = paNoDevice, hostApiOutputDevice = paNoDevice;
    PaStreamParameters hostApiInputParameters, hostApiOutputParameters;
    PaStreamParameters *hostApiInputParametersPtr, *hostApiOutputParametersPtr;


#ifdef PA_LOG_API_CALLS
    PA_LOGAPI_ENTER_PARAMS( "Pa_IsFormatSupported" );

    if( inputParameters == NULL ){
        PA_LOGAPI(("\tPaStreamParameters *inputParameters: NULL\n" ));
    }else{
        PA_LOGAPI(("\tPaStreamParameters *inputParameters: 0x%p\n", inputParameters ));
        PA_LOGAPI(("\tPaDeviceIndex inputParameters->device: %d\n", inputParameters->device ));
        PA_LOGAPI(("\tint inputParameters->channelCount: %d\n", inputParameters->channelCount ));
        PA_LOGAPI(("\tPaSampleFormat inputParameters->sampleFormat: %d\n", inputParameters->sampleFormat ));
        PA_LOGAPI(("\tPaTime inputParameters->suggestedLatency: %f\n", inputParameters->suggestedLatency ));
        PA_LOGAPI(("\tvoid *inputParameters->hostApiSpecificStreamInfo: 0x%p\n", inputParameters->hostApiSpecificStreamInfo ));
    }

    if( outputParameters == NULL ){
        PA_LOGAPI(("\tPaStreamParameters *outputParameters: NULL\n" ));
    }else{
        PA_LOGAPI(("\tPaStreamParameters *outputParameters: 0x%p\n", outputParameters ));
        PA_LOGAPI(("\tPaDeviceIndex outputParameters->device: %d\n", outputParameters->device ));
        PA_LOGAPI(("\tint outputParameters->channelCount: %d\n", outputParameters->channelCount ));
        PA_LOGAPI(("\tPaSampleFormat outputParameters->sampleFormat: %d\n", outputParameters->sampleFormat ));
        PA_LOGAPI(("\tPaTime outputParameters->suggestedLatency: %f\n", outputParameters->suggestedLatency ));
        PA_LOGAPI(("\tvoid *outputParameters->hostApiSpecificStreamInfo: 0x%p\n", outputParameters->hostApiSpecificStreamInfo ));
    }

    PA_LOGAPI(("\tdouble sampleRate: %g\n", sampleRate ));
#endif

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;

        PA_LOGAPI_EXIT_PAERROR( "Pa_IsFormatSupported", result );
        return result;
    }

    result = ValidateOpenStreamParameters( inputParameters,
                                           outputParameters,
                                           sampleRate, 0, paNoFlag, 0,
                                           &hostApi,
                                           &hostApiInputDevice,
                                           &hostApiOutputDevice );
    if( result != paNoError )
    {
        PA_LOGAPI_EXIT_PAERROR( "Pa_IsFormatSupported", result );
        return result;
    }


    if( inputParameters )
    {
        hostApiInputParameters.device = hostApiInputDevice;
        hostApiInputParameters.channelCount = inputParameters->channelCount;
        hostApiInputParameters.sampleFormat = inputParameters->sampleFormat;
        hostApiInputParameters.suggestedLatency = inputParameters->suggestedLatency;
        hostApiInputParameters.hostApiSpecificStreamInfo = inputParameters->hostApiSpecificStreamInfo;
        hostApiInputParametersPtr = &hostApiInputParameters;
    }
    else
    {
        hostApiInputParametersPtr = NULL;
    }

    if( outputParameters )
    {
        hostApiOutputParameters.device = hostApiOutputDevice;
        hostApiOutputParameters.channelCount = outputParameters->channelCount;
        hostApiOutputParameters.sampleFormat = outputParameters->sampleFormat;
        hostApiOutputParameters.suggestedLatency = outputParameters->suggestedLatency;
        hostApiOutputParameters.hostApiSpecificStreamInfo = outputParameters->hostApiSpecificStreamInfo;
        hostApiOutputParametersPtr = &hostApiOutputParameters;
    }
    else
    {
        hostApiOutputParametersPtr = NULL;
    }

    result = hostApi->IsFormatSupported( hostApi,
                                  hostApiInputParametersPtr, hostApiOutputParametersPtr,
                                  sampleRate );

#ifdef PA_LOG_API_CALLS
    PA_LOGAPI(("Pa_OpenStream returned:\n" ));
    if( result == paFormatIsSupported )
        PA_LOGAPI(("\tPaError: 0 [ paFormatIsSupported ]\n" ));
    else
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));
#endif

    return result;
}


PaError Pa_OpenStream( PaStream** stream,
                       const PaStreamParameters *inputParameters,
                       const PaStreamParameters *outputParameters,
                       double sampleRate,
                       unsigned long framesPerBuffer,
                       PaStreamFlags streamFlags,
                       PaStreamCallback *streamCallback,
                       void *userData )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi = 0;
    PaDeviceIndex hostApiInputDevice = paNoDevice, hostApiOutputDevice = paNoDevice;
    PaStreamParameters hostApiInputParameters, hostApiOutputParameters;
    PaStreamParameters *hostApiInputParametersPtr, *hostApiOutputParametersPtr;


#ifdef PA_LOG_API_CALLS
    PA_LOGAPI_ENTER_PARAMS( "Pa_OpenStream" );
    PA_LOGAPI(("\tPaStream** stream: 0x%p\n", stream ));

    if( inputParameters == NULL ){
        PA_LOGAPI(("\tPaStreamParameters *inputParameters: NULL\n" ));
    }else{
        PA_LOGAPI(("\tPaStreamParameters *inputParameters: 0x%p\n", inputParameters ));
        PA_LOGAPI(("\tPaDeviceIndex inputParameters->device: %d\n", inputParameters->device ));
        PA_LOGAPI(("\tint inputParameters->channelCount: %d\n", inputParameters->channelCount ));
        PA_LOGAPI(("\tPaSampleFormat inputParameters->sampleFormat: %d\n", inputParameters->sampleFormat ));
        PA_LOGAPI(("\tPaTime inputParameters->suggestedLatency: %f\n", inputParameters->suggestedLatency ));
        PA_LOGAPI(("\tvoid *inputParameters->hostApiSpecificStreamInfo: 0x%p\n", inputParameters->hostApiSpecificStreamInfo ));
    }

    if( outputParameters == NULL ){
        PA_LOGAPI(("\tPaStreamParameters *outputParameters: NULL\n" ));
    }else{
        PA_LOGAPI(("\tPaStreamParameters *outputParameters: 0x%p\n", outputParameters ));
        PA_LOGAPI(("\tPaDeviceIndex outputParameters->device: %d\n", outputParameters->device ));
        PA_LOGAPI(("\tint outputParameters->channelCount: %d\n", outputParameters->channelCount ));
        PA_LOGAPI(("\tPaSampleFormat outputParameters->sampleFormat: %d\n", outputParameters->sampleFormat ));
        PA_LOGAPI(("\tPaTime outputParameters->suggestedLatency: %f\n", outputParameters->suggestedLatency ));
        PA_LOGAPI(("\tvoid *outputParameters->hostApiSpecificStreamInfo: 0x%p\n", outputParameters->hostApiSpecificStreamInfo ));
    }

    PA_LOGAPI(("\tdouble sampleRate: %g\n", sampleRate ));
    PA_LOGAPI(("\tunsigned long framesPerBuffer: %d\n", framesPerBuffer ));
    PA_LOGAPI(("\tPaStreamFlags streamFlags: 0x%x\n", streamFlags ));
    PA_LOGAPI(("\tPaStreamCallback *streamCallback: 0x%p\n", streamCallback ));
    PA_LOGAPI(("\tvoid *userData: 0x%p\n", userData ));
#endif

    if( !PA_IS_INITIALISED_ )
    {
        result = paNotInitialized;

        PA_LOGAPI(("Pa_OpenStream returned:\n" ));
        PA_LOGAPI(("\t*(PaStream** stream): undefined\n" ));
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));
        return result;
    }

    /* Check for parameter errors.
        NOTE: make sure this validation list is kept syncronised with the one
        in pa_hostapi.h
    */

    if( stream == NULL )
    {
        result = paBadStreamPtr;

        PA_LOGAPI(("Pa_OpenStream returned:\n" ));
        PA_LOGAPI(("\t*(PaStream** stream): undefined\n" ));
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));
        return result;
    }

    result = ValidateOpenStreamParameters( inputParameters,
                                           outputParameters,
                                           sampleRate, framesPerBuffer,
                                           streamFlags, streamCallback,
                                           &hostApi,
                                           &hostApiInputDevice,
                                           &hostApiOutputDevice );
    if( result != paNoError )
    {
        PA_LOGAPI(("Pa_OpenStream returned:\n" ));
        PA_LOGAPI(("\t*(PaStream** stream): undefined\n" ));
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));
        return result;
    }


    if( inputParameters )
    {
        hostApiInputParameters.device = hostApiInputDevice;
        hostApiInputParameters.channelCount = inputParameters->channelCount;
        hostApiInputParameters.sampleFormat = inputParameters->sampleFormat;
        hostApiInputParameters.suggestedLatency = inputParameters->suggestedLatency;
        hostApiInputParameters.hostApiSpecificStreamInfo = inputParameters->hostApiSpecificStreamInfo;
        hostApiInputParametersPtr = &hostApiInputParameters;
    }
    else
    {
        hostApiInputParametersPtr = NULL;
    }

    if( outputParameters )
    {
        hostApiOutputParameters.device = hostApiOutputDevice;
        hostApiOutputParameters.channelCount = outputParameters->channelCount;
        hostApiOutputParameters.sampleFormat = outputParameters->sampleFormat;
        hostApiOutputParameters.suggestedLatency = outputParameters->suggestedLatency;
        hostApiOutputParameters.hostApiSpecificStreamInfo = outputParameters->hostApiSpecificStreamInfo;
        hostApiOutputParametersPtr = &hostApiOutputParameters;
    }
    else
    {
        hostApiOutputParametersPtr = NULL;
    }

    result = hostApi->OpenStream( hostApi, stream,
                                  hostApiInputParametersPtr, hostApiOutputParametersPtr,
                                  sampleRate, framesPerBuffer, streamFlags, streamCallback, userData );

    if( result == paNoError )
        AddOpenStream( *stream );


    PA_LOGAPI(("Pa_OpenStream returned:\n" ));
    PA_LOGAPI(("\t*(PaStream** stream): 0x%p\n", *stream ));
    PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));

    return result;
}


PaError Pa_OpenDefaultStream( PaStream** stream,
                              int inputChannelCount,
                              int outputChannelCount,
                              PaSampleFormat sampleFormat,
                              double sampleRate,
                              unsigned long framesPerBuffer,
                              PaStreamCallback *streamCallback,
                              void *userData )
{
    PaError result;
    PaStreamParameters hostApiInputParameters, hostApiOutputParameters;
    PaStreamParameters *hostApiInputParametersPtr, *hostApiOutputParametersPtr;

    PA_LOGAPI_ENTER_PARAMS( "Pa_OpenDefaultStream" );
    PA_LOGAPI(("\tPaStream** stream: 0x%p\n", stream ));
    PA_LOGAPI(("\tint inputChannelCount: %d\n", inputChannelCount ));
    PA_LOGAPI(("\tint outputChannelCount: %d\n", outputChannelCount ));
    PA_LOGAPI(("\tPaSampleFormat sampleFormat: %d\n", sampleFormat ));
    PA_LOGAPI(("\tdouble sampleRate: %g\n", sampleRate ));
    PA_LOGAPI(("\tunsigned long framesPerBuffer: %d\n", framesPerBuffer ));
    PA_LOGAPI(("\tPaStreamCallback *streamCallback: 0x%p\n", streamCallback ));
    PA_LOGAPI(("\tvoid *userData: 0x%p\n", userData ));


    if( inputChannelCount > 0 )
    {
        hostApiInputParameters.device = Pa_GetDefaultInputDevice();
		if( hostApiInputParameters.device == paNoDevice )
			return paDeviceUnavailable;

        hostApiInputParameters.channelCount = inputChannelCount;
        hostApiInputParameters.sampleFormat = sampleFormat;
        /* defaultHighInputLatency is used below instead of
           defaultLowInputLatency because it is more important for the default
           stream to work reliably than it is for it to work with the lowest
           latency.
         */
        hostApiInputParameters.suggestedLatency =
             Pa_GetDeviceInfo( hostApiInputParameters.device )->defaultHighInputLatency;
        hostApiInputParameters.hostApiSpecificStreamInfo = NULL;
        hostApiInputParametersPtr = &hostApiInputParameters;
    }
    else
    {
        hostApiInputParametersPtr = NULL;
    }

    if( outputChannelCount > 0 )
    {
        hostApiOutputParameters.device = Pa_GetDefaultOutputDevice();
		if( hostApiOutputParameters.device == paNoDevice )
			return paDeviceUnavailable;

        hostApiOutputParameters.channelCount = outputChannelCount;
        hostApiOutputParameters.sampleFormat = sampleFormat;
        /* defaultHighOutputLatency is used below instead of
           defaultLowOutputLatency because it is more important for the default
           stream to work reliably than it is for it to work with the lowest
           latency.
         */
        hostApiOutputParameters.suggestedLatency =
             Pa_GetDeviceInfo( hostApiOutputParameters.device )->defaultHighOutputLatency;
        hostApiOutputParameters.hostApiSpecificStreamInfo = NULL;
        hostApiOutputParametersPtr = &hostApiOutputParameters;
    }
    else
    {
        hostApiOutputParametersPtr = NULL;
    }


    result = Pa_OpenStream(
                 stream, hostApiInputParametersPtr, hostApiOutputParametersPtr,
                 sampleRate, framesPerBuffer, paNoFlag, streamCallback, userData );

    PA_LOGAPI(("Pa_OpenDefaultStream returned:\n" ));
    PA_LOGAPI(("\t*(PaStream** stream): 0x%p", *stream ));
    PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));

    return result;
}


PaError PaUtil_ValidateStreamPointer( PaStream* stream )
{
    if( !PA_IS_INITIALISED_ ) return paNotInitialized;

    if( stream == NULL ) return paBadStreamPtr;

    if( ((PaUtilStreamRepresentation*)stream)->magic != PA_STREAM_MAGIC )
        return paBadStreamPtr;

    return paNoError;
}


PaError Pa_CloseStream( PaStream* stream )
{
    PaUtilStreamInterface *interface;
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_CloseStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    /* always remove the open stream from our list, even if this function
        eventually returns an error. Otherwise CloseOpenStreams() will
        get stuck in an infinite loop */
    RemoveOpenStream( stream ); /* be sure to call this _before_ closing the stream */

    if( result == paNoError )
    {
        interface = PA_STREAM_INTERFACE(stream);

        /* abort the stream if it isn't stopped */
        result = interface->IsStopped( stream );
        if( result == 1 )
            result = paNoError;
        else if( result == 0 )
            result = interface->Abort( stream );

        if( result == paNoError )                 /** @todo REVIEW: shouldn't we close anyway? see: http://www.portaudio.com/trac/ticket/115 */
            result = interface->Close( stream );
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_CloseStream", result );

    return result;
}


PaError Pa_SetStreamFinishedCallback( PaStream *stream, PaStreamFinishedCallback* streamFinishedCallback )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_SetStreamFinishedCallback" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));
    PA_LOGAPI(("\tPaStreamFinishedCallback* streamFinishedCallback: 0x%p\n", streamFinishedCallback ));

    if( result == paNoError )
    {
        result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
        if( result == 0 )
        {
            result = paStreamIsNotStopped ;
        }
        if( result == 1 )
        {
            PA_STREAM_REP( stream )->streamFinishedCallback = streamFinishedCallback;
            result = paNoError;
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_SetStreamFinishedCallback", result );

    return result;

}


PaError Pa_StartStream( PaStream *stream )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_StartStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
    {
        result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
        if( result == 0 )
        {
            result = paStreamIsNotStopped ;
        }
        else if( result == 1 )
        {
            result = PA_STREAM_INTERFACE(stream)->Start( stream );
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_StartStream", result );

    return result;
}


PaError Pa_StopStream( PaStream *stream )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_StopStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
    {
        result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
        if( result == 0 )
        {
            result = PA_STREAM_INTERFACE(stream)->Stop( stream );
        }
        else if( result == 1 )
        {
            result = paStreamIsStopped;
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_StopStream", result );

    return result;
}


PaError Pa_AbortStream( PaStream *stream )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_AbortStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
    {
        result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
        if( result == 0 )
        {
            result = PA_STREAM_INTERFACE(stream)->Abort( stream );
        }
        else if( result == 1 )
        {
            result = paStreamIsStopped;
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_AbortStream", result );

    return result;
}


PaError Pa_IsStreamStopped( PaStream *stream )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_IsStreamStopped" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
        result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );

    PA_LOGAPI_EXIT_PAERROR( "Pa_IsStreamStopped", result );

    return result;
}


PaError Pa_IsStreamActive( PaStream *stream )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_IsStreamActive" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
        result = PA_STREAM_INTERFACE(stream)->IsActive( stream );


    PA_LOGAPI_EXIT_PAERROR( "Pa_IsStreamActive", result );

    return result;
}


const PaStreamInfo* Pa_GetStreamInfo( PaStream *stream )
{
    PaError error = PaUtil_ValidateStreamPointer( stream );
    const PaStreamInfo *result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetStreamInfo" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( error != paNoError )
    {
        result = 0;

        PA_LOGAPI(("Pa_GetStreamInfo returned:\n" ));
        PA_LOGAPI(("\tconst PaStreamInfo*: 0 [PaError error:%d ( %s )]\n", error, Pa_GetErrorText( error ) ));

    }
    else
    {
        result = &PA_STREAM_REP( stream )->streamInfo;

        PA_LOGAPI(("Pa_GetStreamInfo returned:\n" ));
        PA_LOGAPI(("\tconst PaStreamInfo*: 0x%p:\n", result ));
        PA_LOGAPI(("\t{" ));

        PA_LOGAPI(("\t\tint structVersion: %d\n", result->structVersion ));
        PA_LOGAPI(("\t\tPaTime inputLatency: %f\n", result->inputLatency ));
        PA_LOGAPI(("\t\tPaTime outputLatency: %f\n", result->outputLatency ));
        PA_LOGAPI(("\t\tdouble sampleRate: %f\n", result->sampleRate ));
        PA_LOGAPI(("\t}\n" ));

    }

    return result;
}


PaTime Pa_GetStreamTime( PaStream *stream )
{
    PaError error = PaUtil_ValidateStreamPointer( stream );
    PaTime result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetStreamTime" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( error != paNoError )
    {
        result = 0;

        PA_LOGAPI(("Pa_GetStreamTime returned:\n" ));
        PA_LOGAPI(("\tPaTime: 0 [PaError error:%d ( %s )]\n", result, error, Pa_GetErrorText( error ) ));

    }
    else
    {
        result = PA_STREAM_INTERFACE(stream)->GetTime( stream );

        PA_LOGAPI(("Pa_GetStreamTime returned:\n" ));
        PA_LOGAPI(("\tPaTime: %g\n", result ));

    }

    return result;
}


double Pa_GetStreamCpuLoad( PaStream* stream )
{
    PaError error = PaUtil_ValidateStreamPointer( stream );
    double result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetStreamCpuLoad" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( error != paNoError )
    {

        result = 0.0;

        PA_LOGAPI(("Pa_GetStreamCpuLoad returned:\n" ));
        PA_LOGAPI(("\tdouble: 0.0 [PaError error: %d ( %s )]\n", error, Pa_GetErrorText( error ) ));

    }
    else
    {
        result = PA_STREAM_INTERFACE(stream)->GetCpuLoad( stream );

        PA_LOGAPI(("Pa_GetStreamCpuLoad returned:\n" ));
        PA_LOGAPI(("\tdouble: %g\n", result ));

    }

    return result;
}


PaError Pa_ReadStream( PaStream* stream,
                       void *buffer,
                       unsigned long frames )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_ReadStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
    {
        if( frames == 0 )
        {
            /* @todo Should we not allow the implementation to signal any overflow condition? see: http://www.portaudio.com/trac/ticket/116*/
            result = paNoError;
        }
        else if( buffer == 0 )
        {
            result = paBadBufferPtr;
        }
        else
        {
            result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
            if( result == 0 )
            {
                result = PA_STREAM_INTERFACE(stream)->Read( stream, buffer, frames );
            }
            else if( result == 1 )
            {
                result = paStreamIsStopped;
            }
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_ReadStream", result );

    return result;
}


PaError Pa_WriteStream( PaStream* stream,
                        const void *buffer,
                        unsigned long frames )
{
    PaError result = PaUtil_ValidateStreamPointer( stream );

    PA_LOGAPI_ENTER_PARAMS( "Pa_WriteStream" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( result == paNoError )
    {
        if( frames == 0 )
        {
            /* @todo Should we not allow the implementation to signal any underflow condition? see: http://www.portaudio.com/trac/ticket/116*/
            result = paNoError;
        }
        else if( buffer == 0 )
        {
            result = paBadBufferPtr;
        }
        else
        {
            result = PA_STREAM_INTERFACE(stream)->IsStopped( stream );
            if( result == 0 )
            {
                result = PA_STREAM_INTERFACE(stream)->Write( stream, buffer, frames );
            }
            else if( result == 1 )
            {
                result = paStreamIsStopped;
            }
        }
    }

    PA_LOGAPI_EXIT_PAERROR( "Pa_WriteStream", result );

    return result;
}

signed long Pa_GetStreamReadAvailable( PaStream* stream )
{
    PaError error = PaUtil_ValidateStreamPointer( stream );
    signed long result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetStreamReadAvailable" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( error != paNoError )
    {
        result = 0;

        PA_LOGAPI(("Pa_GetStreamReadAvailable returned:\n" ));
        PA_LOGAPI(("\tunsigned long: 0 [ PaError error: %d ( %s ) ]\n", error, Pa_GetErrorText( error ) ));

    }
    else
    {
        result = PA_STREAM_INTERFACE(stream)->GetReadAvailable( stream );

        PA_LOGAPI(("Pa_GetStreamReadAvailable returned:\n" ));
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));

    }

    return result;
}


signed long Pa_GetStreamWriteAvailable( PaStream* stream )
{
    PaError error = PaUtil_ValidateStreamPointer( stream );
    signed long result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetStreamWriteAvailable" );
    PA_LOGAPI(("\tPaStream* stream: 0x%p\n", stream ));

    if( error != paNoError )
    {
        result = 0;

        PA_LOGAPI(("Pa_GetStreamWriteAvailable returned:\n" ));
        PA_LOGAPI(("\tunsigned long: 0 [ PaError error: %d ( %s ) ]\n", error, Pa_GetErrorText( error ) ));

    }
    else
    {
        result = PA_STREAM_INTERFACE(stream)->GetWriteAvailable( stream );

        PA_LOGAPI(("Pa_GetStreamWriteAvailable returned:\n" ));
        PA_LOGAPI(("\tPaError: %d ( %s )\n", result, Pa_GetErrorText( result ) ));

    }

    return result;
}


PaError Pa_GetSampleSize( PaSampleFormat format )
{
    int result;

    PA_LOGAPI_ENTER_PARAMS( "Pa_GetSampleSize" );
    PA_LOGAPI(("\tPaSampleFormat format: %d\n", format ));

    switch( format & ~paNonInterleaved )
    {

    case paUInt8:
    case paInt8:
        result = 1;
        break;

    case paInt16:
        result = 2;
        break;

    case paInt24:
        result = 3;
        break;

    case paFloat32:
    case paInt32:
        result = 4;
        break;

    default:
        result = paSampleFormatNotSupported;
        break;
    }

    PA_LOGAPI_EXIT_PAERROR_OR_T_RESULT( "Pa_GetSampleSize", "int: %d", result );

    return (PaError) result;
}

/*
 * $Id$
 * Portable Audio I/O Library
 * streamCallback <-> host buffer processing adapter
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Buffer Processor implementation.
*/


#include <assert.h>
#include <string.h> /* memset() */

// (amalg) #include "pa_process.h"
// (amalg) #include "pa_util.h"


#define PA_FRAMES_PER_TEMP_BUFFER_WHEN_HOST_BUFFER_SIZE_IS_UNKNOWN_    1024

#define PA_MIN_( a, b ) ( ((a)<(b)) ? (a) : (b) )


/* greatest common divisor - PGCD in French */
static unsigned long GCD( unsigned long a, unsigned long b )
{
    return (b==0) ? a : GCD( b, a%b);
}

/* least common multiple - PPCM in French */
static unsigned long LCM( unsigned long a, unsigned long b )
{
    return (a*b) / GCD(a,b);
}

#define PA_MAX_( a, b ) (((a) > (b)) ? (a) : (b))

static unsigned long CalculateFrameShift( unsigned long M, unsigned long N )
{
    unsigned long result = 0;
    unsigned long i;
    unsigned long lcm;

    assert( M > 0 );
    assert( N > 0 );

    lcm = LCM( M, N );
    for( i = M; i < lcm; i += M )
        result = PA_MAX_( result, i % N );

    return result;
}


PaError PaUtil_InitializeBufferProcessor( PaUtilBufferProcessor* bp,
        int inputChannelCount, PaSampleFormat userInputSampleFormat,
        PaSampleFormat hostInputSampleFormat,
        int outputChannelCount, PaSampleFormat userOutputSampleFormat,
        PaSampleFormat hostOutputSampleFormat,
        double sampleRate,
        PaStreamFlags streamFlags,
        unsigned long framesPerUserBuffer,
        unsigned long framesPerHostBuffer,
        PaUtilHostBufferSizeMode hostBufferSizeMode,
        PaStreamCallback *streamCallback, void *userData )
{
    PaError result = paNoError;
    PaError bytesPerSample;
    unsigned long tempInputBufferSize, tempOutputBufferSize;
    PaStreamFlags tempInputStreamFlags;

    if( streamFlags & paNeverDropInput )
    {
        /* paNeverDropInput is only valid for full-duplex callback streams, with an unspecified number of frames per buffer. */
        if( !streamCallback || !(inputChannelCount > 0 && outputChannelCount > 0) ||
                framesPerUserBuffer != paFramesPerBufferUnspecified )
            return paInvalidFlag;
    }

    /* initialize buffer ptrs to zero so they can be freed if necessary in error */
    bp->tempInputBuffer = 0;
    bp->tempInputBufferPtrs = 0;
    bp->tempOutputBuffer = 0;
    bp->tempOutputBufferPtrs = 0;

    bp->framesPerUserBuffer = framesPerUserBuffer;
    bp->framesPerHostBuffer = framesPerHostBuffer;

    bp->inputChannelCount = inputChannelCount;
    bp->outputChannelCount = outputChannelCount;

    bp->hostBufferSizeMode = hostBufferSizeMode;

    bp->hostInputChannels[0] = bp->hostInputChannels[1] = 0;
    bp->hostOutputChannels[0] = bp->hostOutputChannels[1] = 0;

    if( framesPerUserBuffer == 0 ) /* streamCallback will accept any buffer size */
    {
        bp->useNonAdaptingProcess = 1;
        bp->initialFramesInTempInputBuffer = 0;
        bp->initialFramesInTempOutputBuffer = 0;

        if( hostBufferSizeMode == paUtilFixedHostBufferSize
                || hostBufferSizeMode == paUtilBoundedHostBufferSize )
        {
            bp->framesPerTempBuffer = framesPerHostBuffer;
        }
        else /* unknown host buffer size */
        {
             bp->framesPerTempBuffer = PA_FRAMES_PER_TEMP_BUFFER_WHEN_HOST_BUFFER_SIZE_IS_UNKNOWN_;
        }
    }
    else
    {
        bp->framesPerTempBuffer = framesPerUserBuffer;

        if( hostBufferSizeMode == paUtilFixedHostBufferSize
                && framesPerHostBuffer % framesPerUserBuffer == 0 )
        {
            bp->useNonAdaptingProcess = 1;
            bp->initialFramesInTempInputBuffer = 0;
            bp->initialFramesInTempOutputBuffer = 0;
        }
        else
        {
            bp->useNonAdaptingProcess = 0;

            if( inputChannelCount > 0 && outputChannelCount > 0 )
            {
                /* full duplex */
                if( hostBufferSizeMode == paUtilFixedHostBufferSize )
                {
                    unsigned long frameShift =
                        CalculateFrameShift( framesPerHostBuffer, framesPerUserBuffer );

                    if( framesPerUserBuffer > framesPerHostBuffer )
                    {
                        bp->initialFramesInTempInputBuffer = frameShift;
                        bp->initialFramesInTempOutputBuffer = 0;
                    }
                    else
                    {
                        bp->initialFramesInTempInputBuffer = 0;
                        bp->initialFramesInTempOutputBuffer = frameShift;
                    }
                }
                else /* variable host buffer size, add framesPerUserBuffer latency */
                {
                    bp->initialFramesInTempInputBuffer = 0;
                    bp->initialFramesInTempOutputBuffer = framesPerUserBuffer;
                }
            }
            else
            {
                /* half duplex */
                bp->initialFramesInTempInputBuffer = 0;
                bp->initialFramesInTempOutputBuffer = 0;
            }
        }
    }


    bp->framesInTempInputBuffer = bp->initialFramesInTempInputBuffer;
    bp->framesInTempOutputBuffer = bp->initialFramesInTempOutputBuffer;

    
    if( inputChannelCount > 0 )
    {
        bytesPerSample = Pa_GetSampleSize( hostInputSampleFormat );
        if( bytesPerSample > 0 )
        {
            bp->bytesPerHostInputSample = bytesPerSample;
        }
        else
        {
            result = bytesPerSample;
            goto error;
        }

        bytesPerSample = Pa_GetSampleSize( userInputSampleFormat );
        if( bytesPerSample > 0 )
        {
            bp->bytesPerUserInputSample = bytesPerSample;
        }
        else
        {
            result = bytesPerSample;
            goto error;
        }

        /* Under the assumption that no ADC in existence delivers better than 24bits resolution,
            we disable dithering when host input format is paInt32 and user format is paInt24, 
            since the host samples will just be padded with zeros anyway. */

        tempInputStreamFlags = streamFlags;
        if( !(tempInputStreamFlags & paDitherOff) /* dither is on */
                && (hostInputSampleFormat & paInt32) /* host input format is int32 */
                && (userInputSampleFormat & paInt24) /* user requested format is int24 */ ){

            tempInputStreamFlags = tempInputStreamFlags | paDitherOff;
        }

        bp->inputConverter =
            PaUtil_SelectConverter( hostInputSampleFormat, userInputSampleFormat, tempInputStreamFlags );

        bp->inputZeroer = PaUtil_SelectZeroer( userInputSampleFormat );
            
        bp->userInputIsInterleaved = (userInputSampleFormat & paNonInterleaved)?0:1;
		
        bp->hostInputIsInterleaved = (hostInputSampleFormat & paNonInterleaved)?0:1;

        bp->userInputSampleFormatIsEqualToHost = ((userInputSampleFormat & ~paNonInterleaved) == (hostInputSampleFormat & ~paNonInterleaved));

        tempInputBufferSize =
            bp->framesPerTempBuffer * bp->bytesPerUserInputSample * inputChannelCount;
         
        bp->tempInputBuffer = PaUtil_AllocateMemory( tempInputBufferSize );
        if( bp->tempInputBuffer == 0 )
        {
            result = paInsufficientMemory;
            goto error;
        }
        
        if( bp->framesInTempInputBuffer > 0 )
            memset( bp->tempInputBuffer, 0, tempInputBufferSize );

        if( userInputSampleFormat & paNonInterleaved )
        {
            bp->tempInputBufferPtrs =
                (void **)PaUtil_AllocateMemory( sizeof(void*)*inputChannelCount );
            if( bp->tempInputBufferPtrs == 0 )
            {
                result = paInsufficientMemory;
                goto error;
            }
        }

        bp->hostInputChannels[0] = (PaUtilChannelDescriptor*)
                PaUtil_AllocateMemory( sizeof(PaUtilChannelDescriptor) * inputChannelCount * 2);
        if( bp->hostInputChannels[0] == 0 )
        {
            result = paInsufficientMemory;
            goto error;
        }

        bp->hostInputChannels[1] = &bp->hostInputChannels[0][inputChannelCount];
    }

    if( outputChannelCount > 0 )
    {
        bytesPerSample = Pa_GetSampleSize( hostOutputSampleFormat );
        if( bytesPerSample > 0 )
        {
            bp->bytesPerHostOutputSample = bytesPerSample;
        }
        else
        {
            result = bytesPerSample;
            goto error;
        }

        bytesPerSample = Pa_GetSampleSize( userOutputSampleFormat );
        if( bytesPerSample > 0 )
        {
            bp->bytesPerUserOutputSample = bytesPerSample;
        }
        else
        {
            result = bytesPerSample;
            goto error;
        }

        bp->outputConverter =
            PaUtil_SelectConverter( userOutputSampleFormat, hostOutputSampleFormat, streamFlags );

        bp->outputZeroer = PaUtil_SelectZeroer( hostOutputSampleFormat );

        bp->userOutputIsInterleaved = (userOutputSampleFormat & paNonInterleaved)?0:1;

        bp->hostOutputIsInterleaved = (hostOutputSampleFormat & paNonInterleaved)?0:1;

        bp->userOutputSampleFormatIsEqualToHost = ((userOutputSampleFormat & ~paNonInterleaved) == (hostOutputSampleFormat & ~paNonInterleaved));

        tempOutputBufferSize =
                bp->framesPerTempBuffer * bp->bytesPerUserOutputSample * outputChannelCount;

        bp->tempOutputBuffer = PaUtil_AllocateMemory( tempOutputBufferSize );
        if( bp->tempOutputBuffer == 0 )
        {
            result = paInsufficientMemory;
            goto error;
        }

        if( bp->framesInTempOutputBuffer > 0 )
            memset( bp->tempOutputBuffer, 0, tempOutputBufferSize );
        
        if( userOutputSampleFormat & paNonInterleaved )
        {
            bp->tempOutputBufferPtrs =
                (void **)PaUtil_AllocateMemory( sizeof(void*)*outputChannelCount );
            if( bp->tempOutputBufferPtrs == 0 )
            {
                result = paInsufficientMemory;
                goto error;
            }
        }

        bp->hostOutputChannels[0] = (PaUtilChannelDescriptor*)
                PaUtil_AllocateMemory( sizeof(PaUtilChannelDescriptor)*outputChannelCount * 2 );
        if( bp->hostOutputChannels[0] == 0 )
        {                                                                     
            result = paInsufficientMemory;
            goto error;
        }

        bp->hostOutputChannels[1] = &bp->hostOutputChannels[0][outputChannelCount];
    }

    PaUtil_InitializeTriangularDitherState( &bp->ditherGenerator );

    bp->samplePeriod = 1. / sampleRate;

    bp->streamCallback = streamCallback;
    bp->userData = userData;

    return result;

error:
    if( bp->tempInputBuffer )
        PaUtil_FreeMemory( bp->tempInputBuffer );

    if( bp->tempInputBufferPtrs )
        PaUtil_FreeMemory( bp->tempInputBufferPtrs );

    if( bp->hostInputChannels[0] )
        PaUtil_FreeMemory( bp->hostInputChannels[0] );

    if( bp->tempOutputBuffer )
        PaUtil_FreeMemory( bp->tempOutputBuffer );

    if( bp->tempOutputBufferPtrs )
        PaUtil_FreeMemory( bp->tempOutputBufferPtrs );

    if( bp->hostOutputChannels[0] )
        PaUtil_FreeMemory( bp->hostOutputChannels[0] );

    return result;
}


void PaUtil_TerminateBufferProcessor( PaUtilBufferProcessor* bp )
{
    if( bp->tempInputBuffer )
        PaUtil_FreeMemory( bp->tempInputBuffer );

    if( bp->tempInputBufferPtrs )
        PaUtil_FreeMemory( bp->tempInputBufferPtrs );

    if( bp->hostInputChannels[0] )
        PaUtil_FreeMemory( bp->hostInputChannels[0] );
        
    if( bp->tempOutputBuffer )
        PaUtil_FreeMemory( bp->tempOutputBuffer );

    if( bp->tempOutputBufferPtrs )
        PaUtil_FreeMemory( bp->tempOutputBufferPtrs );

    if( bp->hostOutputChannels[0] )
        PaUtil_FreeMemory( bp->hostOutputChannels[0] );
}


void PaUtil_ResetBufferProcessor( PaUtilBufferProcessor* bp )
{
    unsigned long tempInputBufferSize, tempOutputBufferSize;

    bp->framesInTempInputBuffer = bp->initialFramesInTempInputBuffer;
    bp->framesInTempOutputBuffer = bp->initialFramesInTempOutputBuffer;

    if( bp->framesInTempInputBuffer > 0 )
    {
        tempInputBufferSize =
            bp->framesPerTempBuffer * bp->bytesPerUserInputSample * bp->inputChannelCount;
        memset( bp->tempInputBuffer, 0, tempInputBufferSize );
    }

    if( bp->framesInTempOutputBuffer > 0 )
    {      
        tempOutputBufferSize =
            bp->framesPerTempBuffer * bp->bytesPerUserOutputSample * bp->outputChannelCount;
        memset( bp->tempOutputBuffer, 0, tempOutputBufferSize );
    }
}


unsigned long PaUtil_GetBufferProcessorInputLatencyFrames( PaUtilBufferProcessor* bp )
{
    return bp->initialFramesInTempInputBuffer;
}


unsigned long PaUtil_GetBufferProcessorOutputLatencyFrames( PaUtilBufferProcessor* bp )
{
    return bp->initialFramesInTempOutputBuffer;
}


void PaUtil_SetInputFrameCount( PaUtilBufferProcessor* bp,
        unsigned long frameCount )
{
    if( frameCount == 0 )
        bp->hostInputFrameCount[0] = bp->framesPerHostBuffer;
    else
        bp->hostInputFrameCount[0] = frameCount;
}
        

void PaUtil_SetNoInput( PaUtilBufferProcessor* bp )
{
    assert( bp->inputChannelCount > 0 );

    bp->hostInputChannels[0][0].data = 0;
}


void PaUtil_SetInputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data, unsigned int stride )
{
    assert( channel < bp->inputChannelCount );
    
    bp->hostInputChannels[0][channel].data = data;
    bp->hostInputChannels[0][channel].stride = stride;
}


void PaUtil_SetInterleavedInputChannels( PaUtilBufferProcessor* bp,
        unsigned int firstChannel, void *data, unsigned int channelCount )
{
    unsigned int i;
    unsigned int channel = firstChannel;
    unsigned char *p = (unsigned char*)data;

    if( channelCount == 0 )
        channelCount = bp->inputChannelCount;

    assert( firstChannel < bp->inputChannelCount );
    assert( firstChannel + channelCount <= bp->inputChannelCount );
    assert( bp->hostInputIsInterleaved );

    for( i=0; i< channelCount; ++i )
    {
        bp->hostInputChannels[0][channel+i].data = p;
        p += bp->bytesPerHostInputSample;
        bp->hostInputChannels[0][channel+i].stride = channelCount;
    }
}


void PaUtil_SetNonInterleavedInputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data )
{
    assert( channel < bp->inputChannelCount );
    assert( !bp->hostInputIsInterleaved );
    
    bp->hostInputChannels[0][channel].data = data;
    bp->hostInputChannels[0][channel].stride = 1;
}


void PaUtil_Set2ndInputFrameCount( PaUtilBufferProcessor* bp,
        unsigned long frameCount )
{
    bp->hostInputFrameCount[1] = frameCount;
}


void PaUtil_Set2ndInputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data, unsigned int stride )
{
    assert( channel < bp->inputChannelCount );

    bp->hostInputChannels[1][channel].data = data;
    bp->hostInputChannels[1][channel].stride = stride;
}


void PaUtil_Set2ndInterleavedInputChannels( PaUtilBufferProcessor* bp,
        unsigned int firstChannel, void *data, unsigned int channelCount )
{
    unsigned int i;
    unsigned int channel = firstChannel;
    unsigned char *p = (unsigned char*)data;

    if( channelCount == 0 )
        channelCount = bp->inputChannelCount;

    assert( firstChannel < bp->inputChannelCount );
    assert( firstChannel + channelCount <= bp->inputChannelCount );
    assert( bp->hostInputIsInterleaved );
    
    for( i=0; i< channelCount; ++i )
    {
        bp->hostInputChannels[1][channel+i].data = p;
        p += bp->bytesPerHostInputSample;
        bp->hostInputChannels[1][channel+i].stride = channelCount;
    }
}

        
void PaUtil_Set2ndNonInterleavedInputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data )
{
    assert( channel < bp->inputChannelCount );
    assert( !bp->hostInputIsInterleaved );
    
    bp->hostInputChannels[1][channel].data = data;
    bp->hostInputChannels[1][channel].stride = 1;
}


void PaUtil_SetOutputFrameCount( PaUtilBufferProcessor* bp,
        unsigned long frameCount )
{
    if( frameCount == 0 )
        bp->hostOutputFrameCount[0] = bp->framesPerHostBuffer;
    else
        bp->hostOutputFrameCount[0] = frameCount;
}


void PaUtil_SetNoOutput( PaUtilBufferProcessor* bp )
{
    assert( bp->outputChannelCount > 0 );

    bp->hostOutputChannels[0][0].data = 0;

    /* note that only NonAdaptingProcess is able to deal with no output at this stage. not implemented for AdaptingProcess */
}


void PaUtil_SetOutputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data, unsigned int stride )
{
    assert( channel < bp->outputChannelCount );
    assert( data != NULL );

    bp->hostOutputChannels[0][channel].data = data;
    bp->hostOutputChannels[0][channel].stride = stride;
}


void PaUtil_SetInterleavedOutputChannels( PaUtilBufferProcessor* bp,
        unsigned int firstChannel, void *data, unsigned int channelCount )
{
    unsigned int i;
    unsigned int channel = firstChannel;
    unsigned char *p = (unsigned char*)data;

    if( channelCount == 0 )
        channelCount = bp->outputChannelCount;

    assert( firstChannel < bp->outputChannelCount );
    assert( firstChannel + channelCount <= bp->outputChannelCount );
    assert( bp->hostOutputIsInterleaved );
    
    for( i=0; i< channelCount; ++i )
    {
        PaUtil_SetOutputChannel( bp, channel + i, p, channelCount );
        p += bp->bytesPerHostOutputSample;
    }
}


void PaUtil_SetNonInterleavedOutputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data )
{
    assert( channel < bp->outputChannelCount );
    assert( !bp->hostOutputIsInterleaved );

    PaUtil_SetOutputChannel( bp, channel, data, 1 );
}


void PaUtil_Set2ndOutputFrameCount( PaUtilBufferProcessor* bp,
        unsigned long frameCount )
{
    bp->hostOutputFrameCount[1] = frameCount;
}


void PaUtil_Set2ndOutputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data, unsigned int stride )
{
    assert( channel < bp->outputChannelCount );
    assert( data != NULL );

    bp->hostOutputChannels[1][channel].data = data;
    bp->hostOutputChannels[1][channel].stride = stride;
}


void PaUtil_Set2ndInterleavedOutputChannels( PaUtilBufferProcessor* bp,
        unsigned int firstChannel, void *data, unsigned int channelCount )
{
    unsigned int i;
    unsigned int channel = firstChannel;
    unsigned char *p = (unsigned char*)data;

    if( channelCount == 0 )
        channelCount = bp->outputChannelCount;

    assert( firstChannel < bp->outputChannelCount );
    assert( firstChannel + channelCount <= bp->outputChannelCount );
    assert( bp->hostOutputIsInterleaved );
    
    for( i=0; i< channelCount; ++i )
    {
        PaUtil_Set2ndOutputChannel( bp, channel + i, p, channelCount );
        p += bp->bytesPerHostOutputSample;
    }
}

        
void PaUtil_Set2ndNonInterleavedOutputChannel( PaUtilBufferProcessor* bp,
        unsigned int channel, void *data )
{
    assert( channel < bp->outputChannelCount );
    assert( !bp->hostOutputIsInterleaved );
    
    PaUtil_Set2ndOutputChannel( bp, channel, data, 1 );
}


void PaUtil_BeginBufferProcessing( PaUtilBufferProcessor* bp,
        PaStreamCallbackTimeInfo* timeInfo, PaStreamCallbackFlags callbackStatusFlags )
{
    bp->timeInfo = timeInfo;

    /* the first streamCallback will be called to process samples which are
        currently in the input buffer before the ones starting at the timeInfo time */
        
    bp->timeInfo->inputBufferAdcTime -= bp->framesInTempInputBuffer * bp->samplePeriod;
    
    /* We just pass through timeInfo->currentTime provided by the caller. This is
        not strictly conformant to the word of the spec, since the buffer processor 
        might call the callback multiple times, and we never refresh currentTime. */

    /* the first streamCallback will be called to generate samples which will be
        outputted after the frames currently in the output buffer have been
        outputted. */
    bp->timeInfo->outputBufferDacTime += bp->framesInTempOutputBuffer * bp->samplePeriod;

    bp->callbackStatusFlags = callbackStatusFlags;

    bp->hostInputFrameCount[1] = 0;
    bp->hostOutputFrameCount[1] = 0;
}


/*
    NonAdaptingProcess() is a simple buffer copying adaptor that can handle
    both full and half duplex copies. It processes framesToProcess frames,
    broken into blocks bp->framesPerTempBuffer long.
    This routine can be used when the streamCallback doesn't care what length
    the buffers are, or when framesToProcess is an integer multiple of
    bp->framesPerTempBuffer, in which case streamCallback will always be called
    with bp->framesPerTempBuffer samples.
*/
static unsigned long NonAdaptingProcess( PaUtilBufferProcessor *bp,
        int *streamCallbackResult,
        PaUtilChannelDescriptor *hostInputChannels,
        PaUtilChannelDescriptor *hostOutputChannels,
        unsigned long framesToProcess )
{
    void *userInput, *userOutput;
    unsigned char *srcBytePtr, *destBytePtr;
    unsigned int srcSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int srcChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int destSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int destChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i;
    unsigned long frameCount;
    unsigned long framesToGo = framesToProcess;
    unsigned long framesProcessed = 0;
    int skipOutputConvert = 0;
    int skipInputConvert = 0;


    if( *streamCallbackResult == paContinue )
    {
        do
        {
            frameCount = PA_MIN_( bp->framesPerTempBuffer, framesToGo );

            /* configure user input buffer and convert input data (host -> user) */
            if( bp->inputChannelCount == 0 )
            {
                /* no input */
                userInput = 0;
            }
            else /* there are input channels */
            {
                
                destBytePtr = (unsigned char *)bp->tempInputBuffer;

                if( bp->userInputIsInterleaved )
                {
                    destSampleStrideSamples = bp->inputChannelCount;
                    destChannelStrideBytes = bp->bytesPerUserInputSample;

                    /* process host buffer directly, or use temp buffer if formats differ or host buffer non-interleaved,
                     * or if num channels differs between the host (set in stride) and the user (eg with some Alsa hw:) */
                    if( bp->userInputSampleFormatIsEqualToHost && bp->hostInputIsInterleaved
                        && bp->hostInputChannels[0][0].data && bp->inputChannelCount == hostInputChannels[0].stride )
                    {
                        userInput = hostInputChannels[0].data;
                        destBytePtr = (unsigned char *)hostInputChannels[0].data;
                        skipInputConvert = 1;
                    }
                    else
                    {
                        userInput = bp->tempInputBuffer;
                    }
                }
                else /* user input is not interleaved */
                {
                    destSampleStrideSamples = 1;
                    destChannelStrideBytes = frameCount * bp->bytesPerUserInputSample;

                    /* setup non-interleaved ptrs */
                    if( bp->userInputSampleFormatIsEqualToHost && !bp->hostInputIsInterleaved && bp->hostInputChannels[0][0].data )
                    {
                        for( i=0; i<bp->inputChannelCount; ++i )
                        {
                            bp->tempInputBufferPtrs[i] = hostInputChannels[i].data;
                        }
                        skipInputConvert = 1;
                    }
                    else
                    {
                        for( i=0; i<bp->inputChannelCount; ++i )
                        {
                            bp->tempInputBufferPtrs[i] = ((unsigned char*)bp->tempInputBuffer) +
                                i * bp->bytesPerUserInputSample * frameCount;
                        }
                    }
                
                    userInput = bp->tempInputBufferPtrs;
                }

                if( !bp->hostInputChannels[0][0].data )
                {
                    /* no input was supplied (see PaUtil_SetNoInput), so
                        zero the input buffer */

                    for( i=0; i<bp->inputChannelCount; ++i )
                    {
                        bp->inputZeroer( destBytePtr, destSampleStrideSamples, frameCount );
                        destBytePtr += destChannelStrideBytes;  /* skip to next destination channel */
                    }
                }
                else
	            {
                    if( skipInputConvert )
                    {
                        for( i=0; i<bp->inputChannelCount; ++i )
                        {
                            /* advance src ptr for next iteration */
                            hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                                    frameCount * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
                        }
                    }
                    else
                    {
                        for( i=0; i<bp->inputChannelCount; ++i )
                        {
                            bp->inputConverter( destBytePtr, destSampleStrideSamples,
                                                    hostInputChannels[i].data,
                                                    hostInputChannels[i].stride,
                                                    frameCount, &bp->ditherGenerator );

                            destBytePtr += destChannelStrideBytes;  /* skip to next destination channel */

                            /* advance src ptr for next iteration */
                            hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                                    frameCount * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
                        }
                    }
                }
            }

            /* configure user output buffer */
            if( bp->outputChannelCount == 0 )
            {
                /* no output */
                userOutput = 0;
            }
            else /* there are output channels */
            {
                if( bp->userOutputIsInterleaved )
                {
                    /* process host buffer directly, or use temp buffer if formats differ or host buffer non-interleaved,
                     * or if num channels differs between the host (set in stride) and the user (eg with some Alsa hw:) */
                    if( bp->userOutputSampleFormatIsEqualToHost && bp->hostOutputIsInterleaved
                          && bp->outputChannelCount == hostOutputChannels[0].stride )
                    {
                        userOutput = hostOutputChannels[0].data;
                        skipOutputConvert = 1;
                    }
                    else
                    {
                        userOutput = bp->tempOutputBuffer;
                    }
                }
                else /* user output is not interleaved */
                {
                    if( bp->userOutputSampleFormatIsEqualToHost && !bp->hostOutputIsInterleaved )
                    {
                        for( i=0; i<bp->outputChannelCount; ++i )
                        {
                            bp->tempOutputBufferPtrs[i] = hostOutputChannels[i].data;
                        }
                        skipOutputConvert = 1;
                    }
                    else
                    {
                        for( i=0; i<bp->outputChannelCount; ++i )
                        {
                            bp->tempOutputBufferPtrs[i] = ((unsigned char*)bp->tempOutputBuffer) +
                                i * bp->bytesPerUserOutputSample * frameCount;
                        }
                    }

                    userOutput = bp->tempOutputBufferPtrs;
                }
            }
        
            *streamCallbackResult = bp->streamCallback( userInput, userOutput,
                    frameCount, bp->timeInfo, bp->callbackStatusFlags, bp->userData );

            if( *streamCallbackResult == paAbort )
            {
                /* callback returned paAbort, don't advance framesProcessed
                        and framesToGo, they will be handled below */
            }
            else
            {
                bp->timeInfo->inputBufferAdcTime += frameCount * bp->samplePeriod;
                bp->timeInfo->outputBufferDacTime += frameCount * bp->samplePeriod;

                /* convert output data (user -> host) */
                
                if( bp->outputChannelCount != 0 && bp->hostOutputChannels[0][0].data )
                {
                    if( skipOutputConvert )
					{
						for( i=0; i<bp->outputChannelCount; ++i )
                    	{
                        	/* advance dest ptr for next iteration */
                        	hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                            	    frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
                    	}
					}
					else
					{

                    	srcBytePtr = (unsigned char *)bp->tempOutputBuffer;

                    	if( bp->userOutputIsInterleaved )
                    	{
                        	srcSampleStrideSamples = bp->outputChannelCount;
                        	srcChannelStrideBytes = bp->bytesPerUserOutputSample;
                    	}
                    	else /* user output is not interleaved */
                    	{
                        	srcSampleStrideSamples = 1;
                        	srcChannelStrideBytes = frameCount * bp->bytesPerUserOutputSample;
                    	}

                    	for( i=0; i<bp->outputChannelCount; ++i )
                    	{
                        	bp->outputConverter(    hostOutputChannels[i].data,
                                                	hostOutputChannels[i].stride,
                                                	srcBytePtr, srcSampleStrideSamples,
                                                	frameCount, &bp->ditherGenerator );

                        	srcBytePtr += srcChannelStrideBytes;  /* skip to next source channel */

                        	/* advance dest ptr for next iteration */
                        	hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                                		frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
                    	}
					}
                }
             
                framesProcessed += frameCount;

                framesToGo -= frameCount;
            }
        }
        while( framesToGo > 0  && *streamCallbackResult == paContinue );
    }

    if( framesToGo > 0 )
    {
        /* zero any remaining frames output. There will only be remaining frames
            if the callback has returned paComplete or paAbort */

        frameCount = framesToGo;

        if( bp->outputChannelCount != 0 && bp->hostOutputChannels[0][0].data )
        {
            for( i=0; i<bp->outputChannelCount; ++i )
            {
                bp->outputZeroer(   hostOutputChannels[i].data,
                                    hostOutputChannels[i].stride,
                                    frameCount );

                /* advance dest ptr for next iteration */
                hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                        frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
            }
        }

        framesProcessed += frameCount;
    }

    return framesProcessed;
}


/*
    AdaptingInputOnlyProcess() is a half duplex input buffer processor. It
    converts data from the input buffers into the temporary input buffer,
    when the temporary input buffer is full, it calls the streamCallback.
*/
static unsigned long AdaptingInputOnlyProcess( PaUtilBufferProcessor *bp,
        int *streamCallbackResult,
        PaUtilChannelDescriptor *hostInputChannels,
        unsigned long framesToProcess )
{
    void *userInput, *userOutput;
    unsigned char *destBytePtr;
    unsigned int destSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int destChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i;
    unsigned long frameCount;
    unsigned long framesToGo = framesToProcess;
    unsigned long framesProcessed = 0;
    
    userOutput = 0;

    do
    {
        frameCount = ( bp->framesInTempInputBuffer + framesToGo > bp->framesPerUserBuffer )
                ? ( bp->framesPerUserBuffer - bp->framesInTempInputBuffer )
                : framesToGo;

        /* convert frameCount samples into temp buffer */

        if( bp->userInputIsInterleaved )
        {
            destBytePtr = ((unsigned char*)bp->tempInputBuffer) +
                    bp->bytesPerUserInputSample * bp->inputChannelCount *
                    bp->framesInTempInputBuffer;
                      
            destSampleStrideSamples = bp->inputChannelCount;
            destChannelStrideBytes = bp->bytesPerUserInputSample;

            userInput = bp->tempInputBuffer;
        }
        else /* user input is not interleaved */
        {
            destBytePtr = ((unsigned char*)bp->tempInputBuffer) +
                    bp->bytesPerUserInputSample * bp->framesInTempInputBuffer;

            destSampleStrideSamples = 1;
            destChannelStrideBytes = bp->framesPerUserBuffer * bp->bytesPerUserInputSample;

            /* setup non-interleaved ptrs */
            for( i=0; i<bp->inputChannelCount; ++i )
            {
                bp->tempInputBufferPtrs[i] = ((unsigned char*)bp->tempInputBuffer) +
                    i * bp->bytesPerUserInputSample * bp->framesPerUserBuffer;
            }
                    
            userInput = bp->tempInputBufferPtrs;
        }

        for( i=0; i<bp->inputChannelCount; ++i )
        {
            bp->inputConverter( destBytePtr, destSampleStrideSamples,
                                    hostInputChannels[i].data,
                                    hostInputChannels[i].stride,
                                    frameCount, &bp->ditherGenerator );

            destBytePtr += destChannelStrideBytes;  /* skip to next destination channel */

            /* advance src ptr for next iteration */
            hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                    frameCount * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
        }

        bp->framesInTempInputBuffer += frameCount;

        if( bp->framesInTempInputBuffer == bp->framesPerUserBuffer )
        {
            /**
            @todo (non-critical optimisation)
            The conditional below implements the continue/complete/abort mechanism
            simply by continuing on iterating through the input buffer, but not
            passing the data to the callback. With care, the outer loop could be
            terminated earlier, thus some unneeded conversion cycles would be
            saved.
            */
            if( *streamCallbackResult == paContinue )
            {
                bp->timeInfo->outputBufferDacTime = 0;

                *streamCallbackResult = bp->streamCallback( userInput, userOutput,
                        bp->framesPerUserBuffer, bp->timeInfo,
                        bp->callbackStatusFlags, bp->userData );

                bp->timeInfo->inputBufferAdcTime += bp->framesPerUserBuffer * bp->samplePeriod;
            }
            
            bp->framesInTempInputBuffer = 0;
        }

        framesProcessed += frameCount;

        framesToGo -= frameCount;
    }while( framesToGo > 0 );

    return framesProcessed;
}


/*
    AdaptingOutputOnlyProcess() is a half duplex output buffer processor.
    It converts data from the temporary output buffer, to the output buffers,
    when the temporary output buffer is empty, it calls the streamCallback.
*/
static unsigned long AdaptingOutputOnlyProcess( PaUtilBufferProcessor *bp,
        int *streamCallbackResult,
        PaUtilChannelDescriptor *hostOutputChannels,
        unsigned long framesToProcess )
{
    void *userInput, *userOutput;
    unsigned char *srcBytePtr;
    unsigned int srcSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int srcChannelStrideBytes;  /* stride from one channel to the next, in bytes */
    unsigned int i;
    unsigned long frameCount;
    unsigned long framesToGo = framesToProcess;
    unsigned long framesProcessed = 0;

    do
    {
        if( bp->framesInTempOutputBuffer == 0 && *streamCallbackResult == paContinue )
        {
            userInput = 0;

            /* setup userOutput */
            if( bp->userOutputIsInterleaved )
            {
                userOutput = bp->tempOutputBuffer;
            }
            else /* user output is not interleaved */
            {
                for( i = 0; i < bp->outputChannelCount; ++i )
                {
                    bp->tempOutputBufferPtrs[i] = ((unsigned char*)bp->tempOutputBuffer) +
                            i * bp->framesPerUserBuffer * bp->bytesPerUserOutputSample;
                }

                userOutput = bp->tempOutputBufferPtrs;
            }

            bp->timeInfo->inputBufferAdcTime = 0;
            
            *streamCallbackResult = bp->streamCallback( userInput, userOutput,
                    bp->framesPerUserBuffer, bp->timeInfo,
                    bp->callbackStatusFlags, bp->userData );

            if( *streamCallbackResult == paAbort )
            {
                /* if the callback returned paAbort, we disregard its output */
            }
            else
            {
                bp->timeInfo->outputBufferDacTime += bp->framesPerUserBuffer * bp->samplePeriod;

                bp->framesInTempOutputBuffer = bp->framesPerUserBuffer;
            }
        }

        if( bp->framesInTempOutputBuffer > 0 )
        {
            /* convert frameCount frames from user buffer to host buffer */

            frameCount = PA_MIN_( bp->framesInTempOutputBuffer, framesToGo );

            if( bp->userOutputIsInterleaved )
            {
                srcBytePtr = ((unsigned char*)bp->tempOutputBuffer) +
                        bp->bytesPerUserOutputSample * bp->outputChannelCount *
                        (bp->framesPerUserBuffer - bp->framesInTempOutputBuffer);

                srcSampleStrideSamples = bp->outputChannelCount;
                srcChannelStrideBytes = bp->bytesPerUserOutputSample;
            }
            else /* user output is not interleaved */
            {
                srcBytePtr = ((unsigned char*)bp->tempOutputBuffer) +
                        bp->bytesPerUserOutputSample *
                        (bp->framesPerUserBuffer - bp->framesInTempOutputBuffer);
                            
                srcSampleStrideSamples = 1;
                srcChannelStrideBytes = bp->framesPerUserBuffer * bp->bytesPerUserOutputSample;
            }

            for( i=0; i<bp->outputChannelCount; ++i )
            {
                bp->outputConverter(    hostOutputChannels[i].data,
                                        hostOutputChannels[i].stride,
                                        srcBytePtr, srcSampleStrideSamples,
                                        frameCount, &bp->ditherGenerator );

                srcBytePtr += srcChannelStrideBytes;  /* skip to next source channel */

                /* advance dest ptr for next iteration */
                hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                        frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
            }

            bp->framesInTempOutputBuffer -= frameCount;
        }
        else
        {
            /* no more user data is available because the callback has returned
                paComplete or paAbort. Fill the remainder of the host buffer
                with zeros.
            */

            frameCount = framesToGo;

            for( i=0; i<bp->outputChannelCount; ++i )
            {
                bp->outputZeroer(   hostOutputChannels[i].data,
                                    hostOutputChannels[i].stride,
                                    frameCount );

                /* advance dest ptr for next iteration */
                hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                        frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
            }
        }
        
        framesProcessed += frameCount;
        
        framesToGo -= frameCount;

    }while( framesToGo > 0 );

    return framesProcessed;
}

/* CopyTempOutputBuffersToHostOutputBuffers is called from AdaptingProcess to copy frames from
	tempOutputBuffer to hostOutputChannels. This includes data conversion
	and interleaving. 
*/
static void CopyTempOutputBuffersToHostOutputBuffers( PaUtilBufferProcessor *bp)
{
    unsigned long maxFramesToCopy;
    PaUtilChannelDescriptor *hostOutputChannels;
    unsigned int frameCount;
    unsigned char *srcBytePtr;
    unsigned int srcSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int srcChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i;

     /* copy frames from user to host output buffers */
     while( bp->framesInTempOutputBuffer > 0 &&
             ((bp->hostOutputFrameCount[0] + bp->hostOutputFrameCount[1]) > 0) )
     {
         maxFramesToCopy = bp->framesInTempOutputBuffer;

         /* select the output buffer set (1st or 2nd) */
         if( bp->hostOutputFrameCount[0] > 0 )
         {
             hostOutputChannels = bp->hostOutputChannels[0];
             frameCount = PA_MIN_( bp->hostOutputFrameCount[0], maxFramesToCopy );
         }
         else
         {
             hostOutputChannels = bp->hostOutputChannels[1];
             frameCount = PA_MIN_( bp->hostOutputFrameCount[1], maxFramesToCopy );
         }

         if( bp->userOutputIsInterleaved )
         {
             srcBytePtr = ((unsigned char*)bp->tempOutputBuffer) +
                     bp->bytesPerUserOutputSample * bp->outputChannelCount *
                     (bp->framesPerUserBuffer - bp->framesInTempOutputBuffer);
                         
             srcSampleStrideSamples = bp->outputChannelCount;
             srcChannelStrideBytes = bp->bytesPerUserOutputSample;
         }
         else /* user output is not interleaved */
         {
             srcBytePtr = ((unsigned char*)bp->tempOutputBuffer) +
                     bp->bytesPerUserOutputSample *
                     (bp->framesPerUserBuffer - bp->framesInTempOutputBuffer);

             srcSampleStrideSamples = 1;
             srcChannelStrideBytes = bp->framesPerUserBuffer * bp->bytesPerUserOutputSample;
         }

         for( i=0; i<bp->outputChannelCount; ++i )
         {
             assert( hostOutputChannels[i].data != NULL );
             bp->outputConverter(    hostOutputChannels[i].data,
                                     hostOutputChannels[i].stride,
                                     srcBytePtr, srcSampleStrideSamples,
                                     frameCount, &bp->ditherGenerator );

             srcBytePtr += srcChannelStrideBytes;  /* skip to next source channel */

             /* advance dest ptr for next iteration */
             hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                     frameCount * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
         }

         if( bp->hostOutputFrameCount[0] > 0 )
             bp->hostOutputFrameCount[0] -= frameCount;
         else
             bp->hostOutputFrameCount[1] -= frameCount;

         bp->framesInTempOutputBuffer -= frameCount;
     }
}

/*
    AdaptingProcess is a full duplex adapting buffer processor. It converts
    data from the temporary output buffer into the host output buffers, then
    from the host input buffers into the temporary input buffers. Calling the
    streamCallback when necessary.
    When processPartialUserBuffers is 0, all available input data will be
    consumed and all available output space will be filled. When
    processPartialUserBuffers is non-zero, as many full user buffers
    as possible will be processed, but partial buffers will not be consumed.
*/
static unsigned long AdaptingProcess( PaUtilBufferProcessor *bp,
        int *streamCallbackResult, int processPartialUserBuffers )
{
    void *userInput, *userOutput;
    unsigned long framesProcessed = 0;
    unsigned long framesAvailable;
    unsigned long endProcessingMinFrameCount;
    unsigned long maxFramesToCopy;
    PaUtilChannelDescriptor *hostInputChannels, *hostOutputChannels;
    unsigned int frameCount;
    unsigned char *destBytePtr;
    unsigned int destSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int destChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i, j;
 

    framesAvailable = bp->hostInputFrameCount[0] + bp->hostInputFrameCount[1];/* this is assumed to be the same as the output buffer's frame count */

    if( processPartialUserBuffers )
        endProcessingMinFrameCount = 0;
    else
        endProcessingMinFrameCount = (bp->framesPerUserBuffer - 1);

    /* Fill host output with remaining frames in user output (tempOutputBuffer) */
    CopyTempOutputBuffersToHostOutputBuffers( bp );		  	

    while( framesAvailable > endProcessingMinFrameCount ) 
    {

        if( bp->framesInTempOutputBuffer == 0 && *streamCallbackResult != paContinue )
        {
            /* the callback will not be called any more, so zero what remains
                of the host output buffers */

            for( i=0; i<2; ++i )
            {
                frameCount = bp->hostOutputFrameCount[i];
                if( frameCount > 0 )
                {
                    hostOutputChannels = bp->hostOutputChannels[i];
                    
                    for( j=0; j<bp->outputChannelCount; ++j )
                    {
                        bp->outputZeroer(   hostOutputChannels[j].data,
                                            hostOutputChannels[j].stride,
                                            frameCount );

                        /* advance dest ptr for next iteration  */
                        hostOutputChannels[j].data = ((unsigned char*)hostOutputChannels[j].data) +
                                frameCount * hostOutputChannels[j].stride * bp->bytesPerHostOutputSample;
                    }
                    bp->hostOutputFrameCount[i] = 0;
                }
            }
        }          


        /* copy frames from host to user input buffers */
        while( bp->framesInTempInputBuffer < bp->framesPerUserBuffer &&
                ((bp->hostInputFrameCount[0] + bp->hostInputFrameCount[1]) > 0) )
        {
            maxFramesToCopy = bp->framesPerUserBuffer - bp->framesInTempInputBuffer;

            /* select the input buffer set (1st or 2nd) */
            if( bp->hostInputFrameCount[0] > 0 )
            {
                hostInputChannels = bp->hostInputChannels[0];
                frameCount = PA_MIN_( bp->hostInputFrameCount[0], maxFramesToCopy );
            }
            else
            {
                hostInputChannels = bp->hostInputChannels[1];
                frameCount = PA_MIN_( bp->hostInputFrameCount[1], maxFramesToCopy );
            }

            /* configure conversion destination pointers */
            if( bp->userInputIsInterleaved )
            {
                destBytePtr = ((unsigned char*)bp->tempInputBuffer) +
                        bp->bytesPerUserInputSample * bp->inputChannelCount *
                        bp->framesInTempInputBuffer;

                destSampleStrideSamples = bp->inputChannelCount;
                destChannelStrideBytes = bp->bytesPerUserInputSample;
            }
            else /* user input is not interleaved */
            {
                destBytePtr = ((unsigned char*)bp->tempInputBuffer) +
                        bp->bytesPerUserInputSample * bp->framesInTempInputBuffer;

                destSampleStrideSamples = 1;
                destChannelStrideBytes = bp->framesPerUserBuffer * bp->bytesPerUserInputSample;
            }

            for( i=0; i<bp->inputChannelCount; ++i )
            {
                bp->inputConverter( destBytePtr, destSampleStrideSamples,
                                        hostInputChannels[i].data,
                                        hostInputChannels[i].stride,
                                        frameCount, &bp->ditherGenerator );

                destBytePtr += destChannelStrideBytes;  /* skip to next destination channel */

                /* advance src ptr for next iteration */
                hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                        frameCount * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
            }

            if( bp->hostInputFrameCount[0] > 0 )
                bp->hostInputFrameCount[0] -= frameCount;
            else
                bp->hostInputFrameCount[1] -= frameCount;
                
            bp->framesInTempInputBuffer += frameCount;

            /* update framesAvailable and framesProcessed based on input consumed
                unless something is very wrong this will also correspond to the
                amount of output generated */
            framesAvailable -= frameCount;
            framesProcessed += frameCount;
        }

        /* call streamCallback */
        if( bp->framesInTempInputBuffer == bp->framesPerUserBuffer &&
            bp->framesInTempOutputBuffer == 0 )
        {
            if( *streamCallbackResult == paContinue )
            {
                /* setup userInput */
                if( bp->userInputIsInterleaved )
                {
                    userInput = bp->tempInputBuffer;
                }
                else /* user input is not interleaved */
                {
                    for( i = 0; i < bp->inputChannelCount; ++i )
                    {
                        bp->tempInputBufferPtrs[i] = ((unsigned char*)bp->tempInputBuffer) +
                                i * bp->framesPerUserBuffer * bp->bytesPerUserInputSample;
                    }

                    userInput = bp->tempInputBufferPtrs;
                }

                /* setup userOutput */
                if( bp->userOutputIsInterleaved )
                {
                    userOutput = bp->tempOutputBuffer;
                }
                else /* user output is not interleaved */
                {
                    for( i = 0; i < bp->outputChannelCount; ++i )
                    {
                        bp->tempOutputBufferPtrs[i] = ((unsigned char*)bp->tempOutputBuffer) +
                                i * bp->framesPerUserBuffer * bp->bytesPerUserOutputSample;
                    }

                    userOutput = bp->tempOutputBufferPtrs;
                }

                /* call streamCallback */

                *streamCallbackResult = bp->streamCallback( userInput, userOutput,
                        bp->framesPerUserBuffer, bp->timeInfo,
                        bp->callbackStatusFlags, bp->userData );

                bp->timeInfo->inputBufferAdcTime += bp->framesPerUserBuffer * bp->samplePeriod;
                bp->timeInfo->outputBufferDacTime += bp->framesPerUserBuffer * bp->samplePeriod;

                bp->framesInTempInputBuffer = 0;

                if( *streamCallbackResult == paAbort )
                    bp->framesInTempOutputBuffer = 0;
                else
                    bp->framesInTempOutputBuffer = bp->framesPerUserBuffer;
            }
            else
            {
                /* paComplete or paAbort has already been called. */

                bp->framesInTempInputBuffer = 0;
            }
        }

        /* copy frames from user (tempOutputBuffer) to host output buffers (hostOutputChannels) 
           Means to process the user output provided by the callback. Has to be called after
            each callback. */
        CopyTempOutputBuffersToHostOutputBuffers( bp );		  	

    }
    
    return framesProcessed;
}


unsigned long PaUtil_EndBufferProcessing( PaUtilBufferProcessor* bp, int *streamCallbackResult )
{
    unsigned long framesToProcess, framesToGo;
    unsigned long framesProcessed = 0;
    
    if( bp->inputChannelCount != 0 && bp->outputChannelCount != 0
            && bp->hostInputChannels[0][0].data /* input was supplied (see PaUtil_SetNoInput) */
            && bp->hostOutputChannels[0][0].data /* output was supplied (see PaUtil_SetNoOutput) */ )
    {
        assert( (bp->hostInputFrameCount[0] + bp->hostInputFrameCount[1]) ==
                (bp->hostOutputFrameCount[0] + bp->hostOutputFrameCount[1]) );
    }

    assert( *streamCallbackResult == paContinue
            || *streamCallbackResult == paComplete
            || *streamCallbackResult == paAbort ); /* don't forget to pass in a valid callback result value */

    if( bp->useNonAdaptingProcess )
    {
        if( bp->inputChannelCount != 0 && bp->outputChannelCount != 0 )
        {
            /* full duplex non-adapting process, splice buffers if they are
                different lengths */

            framesToGo = bp->hostOutputFrameCount[0] + bp->hostOutputFrameCount[1]; /* relies on assert above for input/output equivalence */

            do{
                unsigned long noInputInputFrameCount;
                unsigned long *hostInputFrameCount;
                PaUtilChannelDescriptor *hostInputChannels;
                unsigned long noOutputOutputFrameCount;
                unsigned long *hostOutputFrameCount;
                PaUtilChannelDescriptor *hostOutputChannels;
                unsigned long framesProcessedThisIteration;

                if( !bp->hostInputChannels[0][0].data )
                {
                    /* no input was supplied (see PaUtil_SetNoInput)
                        NonAdaptingProcess knows how to deal with this
                    */
                    noInputInputFrameCount = framesToGo;
                    hostInputFrameCount = &noInputInputFrameCount;
                    hostInputChannels = 0;
                }
                else if( bp->hostInputFrameCount[0] != 0 )
                {
                    hostInputFrameCount = &bp->hostInputFrameCount[0];
                    hostInputChannels = bp->hostInputChannels[0];
                }
                else
                {
                    hostInputFrameCount = &bp->hostInputFrameCount[1];
                    hostInputChannels = bp->hostInputChannels[1];
                }

                if( !bp->hostOutputChannels[0][0].data )
                {
                    /* no output was supplied (see PaUtil_SetNoOutput)
                        NonAdaptingProcess knows how to deal with this
                    */
                    noOutputOutputFrameCount = framesToGo;
                    hostOutputFrameCount = &noOutputOutputFrameCount;
                    hostOutputChannels = 0;
                }
                if( bp->hostOutputFrameCount[0] != 0 )
                {
                    hostOutputFrameCount = &bp->hostOutputFrameCount[0];
                    hostOutputChannels = bp->hostOutputChannels[0];
                }
                else
                {
                    hostOutputFrameCount = &bp->hostOutputFrameCount[1];
                    hostOutputChannels = bp->hostOutputChannels[1];
                }

                framesToProcess = PA_MIN_( *hostInputFrameCount,
                                       *hostOutputFrameCount );

                assert( framesToProcess != 0 );
                
                framesProcessedThisIteration = NonAdaptingProcess( bp, streamCallbackResult,
                        hostInputChannels, hostOutputChannels,
                        framesToProcess );                                       

                *hostInputFrameCount -= framesProcessedThisIteration;
                *hostOutputFrameCount -= framesProcessedThisIteration;

                framesProcessed += framesProcessedThisIteration;
                framesToGo -= framesProcessedThisIteration;
                
            }while( framesToGo > 0 );
        }
        else
        {
            /* half duplex non-adapting process, just process 1st and 2nd buffer */
            /* process first buffer */

            framesToProcess = (bp->inputChannelCount != 0)
                            ? bp->hostInputFrameCount[0]
                            : bp->hostOutputFrameCount[0];

            framesProcessed = NonAdaptingProcess( bp, streamCallbackResult,
                        bp->hostInputChannels[0], bp->hostOutputChannels[0],
                        framesToProcess );

            /* process second buffer if provided */
    
            framesToProcess = (bp->inputChannelCount != 0)
                            ? bp->hostInputFrameCount[1]
                            : bp->hostOutputFrameCount[1];
            if( framesToProcess > 0 )
            {
                framesProcessed += NonAdaptingProcess( bp, streamCallbackResult,
                    bp->hostInputChannels[1], bp->hostOutputChannels[1],
                    framesToProcess );
            }
        }
    }
    else /* block adaption necessary*/
    {

        if( bp->inputChannelCount != 0 && bp->outputChannelCount != 0 )
        {
            /* full duplex */
            
            if( bp->hostBufferSizeMode == paUtilVariableHostBufferSizePartialUsageAllowed  )
            {
                framesProcessed = AdaptingProcess( bp, streamCallbackResult,
                        0 /* dont process partial user buffers */ );
            }
            else
            {
                framesProcessed = AdaptingProcess( bp, streamCallbackResult,
                        1 /* process partial user buffers */ );
            }
        }
        else if( bp->inputChannelCount != 0 )
        {
            /* input only */
            framesToProcess = bp->hostInputFrameCount[0];

            framesProcessed = AdaptingInputOnlyProcess( bp, streamCallbackResult,
                        bp->hostInputChannels[0], framesToProcess );

            framesToProcess = bp->hostInputFrameCount[1];
            if( framesToProcess > 0 )
            {
                framesProcessed += AdaptingInputOnlyProcess( bp, streamCallbackResult,
                        bp->hostInputChannels[1], framesToProcess );
            }
        }
        else
        {
            /* output only */
            framesToProcess = bp->hostOutputFrameCount[0];

            framesProcessed = AdaptingOutputOnlyProcess( bp, streamCallbackResult,
                        bp->hostOutputChannels[0], framesToProcess );

            framesToProcess = bp->hostOutputFrameCount[1];
            if( framesToProcess > 0 )
            {
                framesProcessed += AdaptingOutputOnlyProcess( bp, streamCallbackResult,
                        bp->hostOutputChannels[1], framesToProcess );
            }
        }
    }

    return framesProcessed;
}


int PaUtil_IsBufferProcessorOutputEmpty( PaUtilBufferProcessor* bp )
{
    return (bp->framesInTempOutputBuffer) ? 0 : 1;
} 


unsigned long PaUtil_CopyInput( PaUtilBufferProcessor* bp,
        void **buffer, unsigned long frameCount )
{
    PaUtilChannelDescriptor *hostInputChannels;
    unsigned int framesToCopy;
    unsigned char *destBytePtr;
    void **nonInterleavedDestPtrs;
    unsigned int destSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int destChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i;

    hostInputChannels = bp->hostInputChannels[0];
    framesToCopy = PA_MIN_( bp->hostInputFrameCount[0], frameCount );

    if( bp->userInputIsInterleaved )
    {
        destBytePtr = (unsigned char*)*buffer;
        
        destSampleStrideSamples = bp->inputChannelCount;
        destChannelStrideBytes = bp->bytesPerUserInputSample;

        for( i=0; i<bp->inputChannelCount; ++i )
        {
            bp->inputConverter( destBytePtr, destSampleStrideSamples,
                                hostInputChannels[i].data,
                                hostInputChannels[i].stride,
                                framesToCopy, &bp->ditherGenerator );

            destBytePtr += destChannelStrideBytes;  /* skip to next dest channel */

            /* advance source ptr for next iteration */
            hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                    framesToCopy * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
        }

        /* advance callers dest pointer (buffer) */
        *buffer = ((unsigned char *)*buffer) +
                framesToCopy * bp->inputChannelCount * bp->bytesPerUserInputSample;
    }
    else
    {
        /* user input is not interleaved */
        
        nonInterleavedDestPtrs = (void**)*buffer;

        destSampleStrideSamples = 1;
        
        for( i=0; i<bp->inputChannelCount; ++i )
        {
            destBytePtr = (unsigned char*)nonInterleavedDestPtrs[i];

            bp->inputConverter( destBytePtr, destSampleStrideSamples,
                                hostInputChannels[i].data,
                                hostInputChannels[i].stride,
                                framesToCopy, &bp->ditherGenerator );

            /* advance callers dest pointer (nonInterleavedDestPtrs[i]) */
            destBytePtr += bp->bytesPerUserInputSample * framesToCopy;
            nonInterleavedDestPtrs[i] = destBytePtr;
            
            /* advance source ptr for next iteration */
            hostInputChannels[i].data = ((unsigned char*)hostInputChannels[i].data) +
                    framesToCopy * hostInputChannels[i].stride * bp->bytesPerHostInputSample;
        }
    }

    bp->hostInputFrameCount[0] -= framesToCopy;
    
    return framesToCopy;
}

unsigned long PaUtil_CopyOutput( PaUtilBufferProcessor* bp,
        const void ** buffer, unsigned long frameCount )
{
    PaUtilChannelDescriptor *hostOutputChannels;
    unsigned int framesToCopy;
    unsigned char *srcBytePtr;
    void **nonInterleavedSrcPtrs;
    unsigned int srcSampleStrideSamples; /* stride from one sample to the next within a channel, in samples */
    unsigned int srcChannelStrideBytes; /* stride from one channel to the next, in bytes */
    unsigned int i;

    hostOutputChannels = bp->hostOutputChannels[0];
    framesToCopy = PA_MIN_( bp->hostOutputFrameCount[0], frameCount );

    if( bp->userOutputIsInterleaved )
    {
        srcBytePtr = (unsigned char*)*buffer;
        
        srcSampleStrideSamples = bp->outputChannelCount;
        srcChannelStrideBytes = bp->bytesPerUserOutputSample;

        for( i=0; i<bp->outputChannelCount; ++i )
        {
            bp->outputConverter(    hostOutputChannels[i].data,
                                    hostOutputChannels[i].stride,
                                    srcBytePtr, srcSampleStrideSamples,
                                    framesToCopy, &bp->ditherGenerator );

            srcBytePtr += srcChannelStrideBytes;  /* skip to next source channel */

            /* advance dest ptr for next iteration */
            hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                    framesToCopy * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
        }

        /* advance callers source pointer (buffer) */
        *buffer = ((unsigned char *)*buffer) +
                framesToCopy * bp->outputChannelCount * bp->bytesPerUserOutputSample;

    }
    else
    {
        /* user output is not interleaved */
        
        nonInterleavedSrcPtrs = (void**)*buffer;

        srcSampleStrideSamples = 1;
        
        for( i=0; i<bp->outputChannelCount; ++i )
        {
            srcBytePtr = (unsigned char*)nonInterleavedSrcPtrs[i];
            
            bp->outputConverter(    hostOutputChannels[i].data,
                                    hostOutputChannels[i].stride,
                                    srcBytePtr, srcSampleStrideSamples,
                                    framesToCopy, &bp->ditherGenerator );


            /* advance callers source pointer (nonInterleavedSrcPtrs[i]) */
            srcBytePtr += bp->bytesPerUserOutputSample * framesToCopy;
            nonInterleavedSrcPtrs[i] = srcBytePtr;
            
            /* advance dest ptr for next iteration */
            hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                    framesToCopy * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
        }
    }

    bp->hostOutputFrameCount[0] += framesToCopy;
    
    return framesToCopy;
}


unsigned long PaUtil_ZeroOutput( PaUtilBufferProcessor* bp, unsigned long frameCount )
{
    PaUtilChannelDescriptor *hostOutputChannels;
    unsigned int framesToZero;
    unsigned int i;

    hostOutputChannels = bp->hostOutputChannels[0];
    framesToZero = PA_MIN_( bp->hostOutputFrameCount[0], frameCount );

    for( i=0; i<bp->outputChannelCount; ++i )
    {
        bp->outputZeroer(   hostOutputChannels[i].data,
                            hostOutputChannels[i].stride,
                            framesToZero );


        /* advance dest ptr for next iteration */
        hostOutputChannels[i].data = ((unsigned char*)hostOutputChannels[i].data) +
                framesToZero * hostOutputChannels[i].stride * bp->bytesPerHostOutputSample;
    }

    bp->hostOutputFrameCount[0] += framesToZero;
    
    return framesToZero;
}
/*
 * $Id$
 * Portable Audio I/O Library
 * Ring Buffer utility.
 *
 * Author: Phil Burk, http://www.softsynth.com
 * modified for SMP safety on Mac OS X by Bjorn Roche
 * modified for SMP safety on Linux by Leland Lucius
 * also, allowed for const where possible
 * modified for multiple-byte-sized data elements by Sven Fischer 
 *
 * Note that this is safe only for a single-thread reader and a
 * single-thread writer.
 *
 * This program uses the PortAudio Portable Audio Library.
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup common_src
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
// (amalg) #include "pa_ringbuffer.h"
#include <string.h>
// (amalg) #include "pa_memorybarrier.h"

/***************************************************************************
 * Initialize FIFO.
 * elementCount must be power of 2, returns -1 if not.
 */
ring_buffer_size_t PaUtil_InitializeRingBuffer( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementSizeBytes, ring_buffer_size_t elementCount, void *dataPtr )
{
    if( ((elementCount-1) & elementCount) != 0) return -1; /* Not Power of two. */
    rbuf->bufferSize = elementCount;
    rbuf->buffer = (char *)dataPtr;
    PaUtil_FlushRingBuffer( rbuf );
    rbuf->bigMask = (elementCount*2)-1;
    rbuf->smallMask = (elementCount)-1;
    rbuf->elementSizeBytes = elementSizeBytes;
    return 0;
}

/***************************************************************************
** Return number of elements available for reading. */
ring_buffer_size_t PaUtil_GetRingBufferReadAvailable( const PaUtilRingBuffer *rbuf )
{
    return ( (rbuf->writeIndex - rbuf->readIndex) & rbuf->bigMask );
}
/***************************************************************************
** Return number of elements available for writing. */
ring_buffer_size_t PaUtil_GetRingBufferWriteAvailable( const PaUtilRingBuffer *rbuf )
{
    return ( rbuf->bufferSize - PaUtil_GetRingBufferReadAvailable(rbuf));
}

/***************************************************************************
** Clear buffer. Should only be called when buffer is NOT being read or written. */
void PaUtil_FlushRingBuffer( PaUtilRingBuffer *rbuf )
{
    rbuf->writeIndex = rbuf->readIndex = 0;
}

/***************************************************************************
** Get address of region(s) to which we can write data.
** If the region is contiguous, size2 will be zero.
** If non-contiguous, size2 will be the size of second region.
** Returns room available to be written or elementCount, whichever is smaller.
*/
ring_buffer_size_t PaUtil_GetRingBufferWriteRegions( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount,
                                       void **dataPtr1, ring_buffer_size_t *sizePtr1,
                                       void **dataPtr2, ring_buffer_size_t *sizePtr2 )
{
    ring_buffer_size_t   index;
    ring_buffer_size_t   available = PaUtil_GetRingBufferWriteAvailable( rbuf );
    if( elementCount > available ) elementCount = available;
    /* Check to see if write is not contiguous. */
    index = rbuf->writeIndex & rbuf->smallMask;
    if( (index + elementCount) > rbuf->bufferSize )
    {
        /* Write data in two blocks that wrap the buffer. */
        ring_buffer_size_t   firstHalf = rbuf->bufferSize - index;
        *dataPtr1 = &rbuf->buffer[index*rbuf->elementSizeBytes];
        *sizePtr1 = firstHalf;
        *dataPtr2 = &rbuf->buffer[0];
        *sizePtr2 = elementCount - firstHalf;
    }
    else
    {
        *dataPtr1 = &rbuf->buffer[index*rbuf->elementSizeBytes];
        *sizePtr1 = elementCount;
        *dataPtr2 = NULL;
        *sizePtr2 = 0;
    }

    if( available )
        PaUtil_FullMemoryBarrier(); /* (write-after-read) => full barrier */

    return elementCount;
}


/***************************************************************************
*/
ring_buffer_size_t PaUtil_AdvanceRingBufferWriteIndex( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount )
{
    /* ensure that previous writes are seen before we update the write index 
       (write after write)
    */
    PaUtil_WriteMemoryBarrier();
    return rbuf->writeIndex = (rbuf->writeIndex + elementCount) & rbuf->bigMask;
}

/***************************************************************************
** Get address of region(s) from which we can read data.
** If the region is contiguous, size2 will be zero.
** If non-contiguous, size2 will be the size of second region.
** Returns room available to be read or elementCount, whichever is smaller.
*/
ring_buffer_size_t PaUtil_GetRingBufferReadRegions( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount,
                                void **dataPtr1, ring_buffer_size_t *sizePtr1,
                                void **dataPtr2, ring_buffer_size_t *sizePtr2 )
{
    ring_buffer_size_t   index;
    ring_buffer_size_t   available = PaUtil_GetRingBufferReadAvailable( rbuf ); /* doesn't use memory barrier */
    if( elementCount > available ) elementCount = available;
    /* Check to see if read is not contiguous. */
    index = rbuf->readIndex & rbuf->smallMask;
    if( (index + elementCount) > rbuf->bufferSize )
    {
        /* Write data in two blocks that wrap the buffer. */
        ring_buffer_size_t firstHalf = rbuf->bufferSize - index;
        *dataPtr1 = &rbuf->buffer[index*rbuf->elementSizeBytes];
        *sizePtr1 = firstHalf;
        *dataPtr2 = &rbuf->buffer[0];
        *sizePtr2 = elementCount - firstHalf;
    }
    else
    {
        *dataPtr1 = &rbuf->buffer[index*rbuf->elementSizeBytes];
        *sizePtr1 = elementCount;
        *dataPtr2 = NULL;
        *sizePtr2 = 0;
    }
    
    if( available )
        PaUtil_ReadMemoryBarrier(); /* (read-after-read) => read barrier */

    return elementCount;
}
/***************************************************************************
*/
ring_buffer_size_t PaUtil_AdvanceRingBufferReadIndex( PaUtilRingBuffer *rbuf, ring_buffer_size_t elementCount )
{
    /* ensure that previous reads (copies out of the ring buffer) are always completed before updating (writing) the read index. 
       (write-after-read) => full barrier
    */
    PaUtil_FullMemoryBarrier();
    return rbuf->readIndex = (rbuf->readIndex + elementCount) & rbuf->bigMask;
}

/***************************************************************************
** Return elements written. */
ring_buffer_size_t PaUtil_WriteRingBuffer( PaUtilRingBuffer *rbuf, const void *data, ring_buffer_size_t elementCount )
{
    ring_buffer_size_t size1, size2, numWritten;
    void *data1, *data2;
    numWritten = PaUtil_GetRingBufferWriteRegions( rbuf, elementCount, &data1, &size1, &data2, &size2 );
    if( size2 > 0 )
    {

        memcpy( data1, data, size1*rbuf->elementSizeBytes );
        data = ((char *)data) + size1*rbuf->elementSizeBytes;
        memcpy( data2, data, size2*rbuf->elementSizeBytes );
    }
    else
    {
        memcpy( data1, data, size1*rbuf->elementSizeBytes );
    }
    PaUtil_AdvanceRingBufferWriteIndex( rbuf, numWritten );
    return numWritten;
}

/***************************************************************************
** Return elements read. */
ring_buffer_size_t PaUtil_ReadRingBuffer( PaUtilRingBuffer *rbuf, void *data, ring_buffer_size_t elementCount )
{
    ring_buffer_size_t size1, size2, numRead;
    void *data1, *data2;
    numRead = PaUtil_GetRingBufferReadRegions( rbuf, elementCount, &data1, &size1, &data2, &size2 );
    if( size2 > 0 )
    {
        memcpy( data, data1, size1*rbuf->elementSizeBytes );
        data = ((char *)data) + size1*rbuf->elementSizeBytes;
        memcpy( data, data2, size2*rbuf->elementSizeBytes );
    }
    else
    {
        memcpy( data, data1, size1*rbuf->elementSizeBytes );
    }
    PaUtil_AdvanceRingBufferReadIndex( rbuf, numRead );
    return numRead;
}
/*
 * $Id$
 * Portable Audio I/O Library
 * stream interface
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 2008 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Stream interfaces, representation structures and helper functions
 used to interface between pa_front.c host API implementations.
*/


// (amalg) #include "pa_stream.h"


void PaUtil_InitializeStreamInterface( PaUtilStreamInterface *streamInterface,
                                       PaError (*Close)( PaStream* ),
                                       PaError (*Start)( PaStream* ),
                                       PaError (*Stop)( PaStream* ),
                                       PaError (*Abort)( PaStream* ),
                                       PaError (*IsStopped)( PaStream* ),
                                       PaError (*IsActive)( PaStream* ),
                                       PaTime (*GetTime)( PaStream* ),
                                       double (*GetCpuLoad)( PaStream* ),
                                       PaError (*Read)( PaStream*, void *, unsigned long ),
                                       PaError (*Write)( PaStream*, const void *, unsigned long ),
                                       signed long (*GetReadAvailable)( PaStream* ),
                                       signed long (*GetWriteAvailable)( PaStream* )  )
{
    streamInterface->Close = Close;
    streamInterface->Start = Start;
    streamInterface->Stop = Stop;
    streamInterface->Abort = Abort;
    streamInterface->IsStopped = IsStopped;
    streamInterface->IsActive = IsActive;
    streamInterface->GetTime = GetTime;
    streamInterface->GetCpuLoad = GetCpuLoad;
    streamInterface->Read = Read;
    streamInterface->Write = Write;
    streamInterface->GetReadAvailable = GetReadAvailable;
    streamInterface->GetWriteAvailable = GetWriteAvailable;
}


void PaUtil_InitializeStreamRepresentation( PaUtilStreamRepresentation *streamRepresentation,
        PaUtilStreamInterface *streamInterface,
        PaStreamCallback *streamCallback,
        void *userData )
{
    streamRepresentation->magic = PA_STREAM_MAGIC;
    streamRepresentation->nextOpenStream = 0;
    streamRepresentation->streamInterface = streamInterface;
    streamRepresentation->streamCallback = streamCallback;
    streamRepresentation->streamFinishedCallback = 0;

    streamRepresentation->userData = userData;

    streamRepresentation->streamInfo.inputLatency = 0.;
    streamRepresentation->streamInfo.outputLatency = 0.;
    streamRepresentation->streamInfo.sampleRate = 0.;
}


void PaUtil_TerminateStreamRepresentation( PaUtilStreamRepresentation *streamRepresentation )
{
    streamRepresentation->magic = 0;
}


PaError PaUtil_DummyRead( PaStream* stream,
                               void *buffer,
                               unsigned long frames )
{
    (void)stream; /* unused parameter */
    (void)buffer; /* unused parameter */
    (void)frames; /* unused parameter */

    return paCanNotReadFromACallbackStream;
}


PaError PaUtil_DummyWrite( PaStream* stream,
                               const void *buffer,
                               unsigned long frames )
{
    (void)stream; /* unused parameter */
    (void)buffer; /* unused parameter */
    (void)frames; /* unused parameter */

    return paCanNotWriteToACallbackStream;
}


signed long PaUtil_DummyGetReadAvailable( PaStream* stream )
{
    (void)stream; /* unused parameter */

    return paCanNotReadFromACallbackStream;
}


signed long PaUtil_DummyGetWriteAvailable( PaStream* stream )
{
    (void)stream; /* unused parameter */

    return paCanNotWriteToACallbackStream;
}


double PaUtil_DummyGetCpuLoad( PaStream* stream )
{
    (void)stream; /* unused parameter */

    return 0.0;
}
/*
 * $Id$
 * Portable Audio I/O Library Trace Facility
 * Store trace information in real-time for later printing.
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2000 Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup common_src

 @brief Real-time safe event trace logging facility for debugging.
*/


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>
// (amalg) #include "pa_trace.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_debugprint.h"

#if PA_TRACE_REALTIME_EVENTS

static char const *traceTextArray[PA_MAX_TRACE_RECORDS];
static int traceIntArray[PA_MAX_TRACE_RECORDS];
static int traceIndex = 0;
static int traceBlock = 0;

/*********************************************************************/
void PaUtil_ResetTraceMessages()
{
    traceIndex = 0;
}

/*********************************************************************/
void PaUtil_DumpTraceMessages()
{
    int i;
    int messageCount = (traceIndex < PA_MAX_TRACE_RECORDS) ? traceIndex : PA_MAX_TRACE_RECORDS;

    printf("DumpTraceMessages: traceIndex = %d\n", traceIndex );
    for( i=0; i<messageCount; i++ )
    {
        printf("%3d: %s = 0x%08X\n",
               i, traceTextArray[i], traceIntArray[i] );
    }
    PaUtil_ResetTraceMessages();
    fflush(stdout);
}

/*********************************************************************/
void PaUtil_AddTraceMessage( const char *msg, int data )
{
    if( (traceIndex == PA_MAX_TRACE_RECORDS) && (traceBlock == 0) )
    {
        traceBlock = 1;
        /*  PaUtil_DumpTraceMessages(); */
    }
    else if( traceIndex < PA_MAX_TRACE_RECORDS )
    {
        traceTextArray[traceIndex] = msg;
        traceIntArray[traceIndex] = data;
        traceIndex++;
    }
}

/************************************************************************/
/* High performance log alternative                                     */
/************************************************************************/

typedef unsigned long long  PaUint64;

typedef struct __PaHighPerformanceLog
{
    unsigned    magik;
    int         writePtr;
    int         readPtr;
    int         size;
    double      refTime;
    char*       data;
} PaHighPerformanceLog;

static const unsigned kMagik = 0xcafebabe;

#define USEC_PER_SEC    (1000000ULL)

int PaUtil_InitializeHighSpeedLog( LogHandle* phLog, unsigned maxSizeInBytes )
{
    PaHighPerformanceLog* pLog = (PaHighPerformanceLog*)PaUtil_AllocateMemory(sizeof(PaHighPerformanceLog));
    if (pLog == 0)
    {
        return paInsufficientMemory;
    }
    assert(phLog != 0);
    *phLog = pLog;

    pLog->data = (char*)PaUtil_AllocateMemory(maxSizeInBytes);
    if (pLog->data == 0)
    {
        PaUtil_FreeMemory(pLog);
        return paInsufficientMemory;
    }
    pLog->magik = kMagik;
    pLog->size = maxSizeInBytes;
    pLog->refTime = PaUtil_GetTime();
    return paNoError;
}

void PaUtil_ResetHighSpeedLogTimeRef( LogHandle hLog )
{
    PaHighPerformanceLog* pLog = (PaHighPerformanceLog*)hLog;
    assert(pLog->magik == kMagik);
    pLog->refTime = PaUtil_GetTime();
}

typedef struct __PaLogEntryHeader
{
    int    size;
    double timeStamp;
} PaLogEntryHeader;

#ifdef __APPLE__
#define _vsnprintf vsnprintf
#define min(a,b) ((a)<(b)?(a):(b))
#endif


int PaUtil_AddHighSpeedLogMessage( LogHandle hLog, const char* fmt, ... )
{
    va_list l;
    int n = 0;
    PaHighPerformanceLog* pLog = (PaHighPerformanceLog*)hLog;
    if (pLog != 0)
    {
        PaLogEntryHeader* pHeader;
        char* p;
        int maxN;
        assert(pLog->magik == kMagik);
        pHeader = (PaLogEntryHeader*)( pLog->data + pLog->writePtr );
        p = (char*)( pHeader + 1 );
        maxN = pLog->size - pLog->writePtr - 2 * sizeof(PaLogEntryHeader);

        pHeader->timeStamp = PaUtil_GetTime() - pLog->refTime;
        if (maxN > 0)
        {
            if (maxN > 32)
            {
                va_start(l, fmt);
                n = _vsnprintf(p, min(1024, maxN), fmt, l);
                va_end(l);
            }
            else {
                n = sprintf(p, "End of log...");
            }
            n = ((n + sizeof(unsigned)) & ~(sizeof(unsigned)-1)) + sizeof(PaLogEntryHeader);
            pHeader->size = n;
#if 0
            PaUtil_DebugPrint("%05u.%03u: %s\n", pHeader->timeStamp/1000, pHeader->timeStamp%1000, p);
#endif
            pLog->writePtr += n;
        }
    }
    return n;
}

void PaUtil_DumpHighSpeedLog( LogHandle hLog, const char* fileName )
{
    FILE* f = (fileName != NULL) ? fopen(fileName, "w") : stdout;
    unsigned localWritePtr;
    PaHighPerformanceLog* pLog = (PaHighPerformanceLog*)hLog;
    assert(pLog->magik == kMagik);
    localWritePtr = pLog->writePtr;
    while (pLog->readPtr != localWritePtr)
    {
        const PaLogEntryHeader* pHeader = (const PaLogEntryHeader*)( pLog->data + pLog->readPtr );
        const char* p = (const char*)( pHeader + 1 );
        const PaUint64 ts = (const PaUint64)( pHeader->timeStamp * USEC_PER_SEC );
        assert(pHeader->size < (1024+sizeof(unsigned)+sizeof(PaLogEntryHeader)));
        fprintf(f, "%05u.%03u: %s\n", (unsigned)(ts/1000), (unsigned)(ts%1000), p);
        pLog->readPtr += pHeader->size;
    }
    if (f != stdout)
    {
        fclose(f);
    }
}

void PaUtil_DiscardHighSpeedLog( LogHandle hLog )
{
    PaHighPerformanceLog* pLog = (PaHighPerformanceLog*)hLog;
    assert(pLog->magik == kMagik);
    PaUtil_FreeMemory(pLog->data);
    PaUtil_FreeMemory(pLog);
}

#else
/* This stub was added so that this file will generate a symbol.
 * Otherwise linker/archiver programs will complain.
 */
int PaUtil_TraceStubToSatisfyLinker(void)
{
	return 0;
}
#endif /* TRACE_REALTIME_EVENTS */

#ifdef WIN32
/*
 * Microsoft COM initialization routines
 * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup win_src

 @brief Microsoft COM initialization routines.
*/

#ifndef PA_WIN_COINITIALIZE_H
#define PA_WIN_COINITIALIZE_H

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/**
 @brief Data type used to hold the result of an attempt to initialize COM
    using PaWinUtil_CoInitialize. Must be retained between a call to 
    PaWinUtil_CoInitialize and a matching call to PaWinUtil_CoUninitialize.
*/
typedef struct PaWinUtilComInitializationResult{
    int state;
    int initializingThreadId;
} PaWinUtilComInitializationResult;


/**
 @brief Initialize Microsoft COM subsystem on the current thread.

 @param hostApiType the host API type id of the caller. Used for error reporting.

 @param comInitializationResult An output parameter. The value pointed to by 
        this parameter stores information required by PaWinUtil_CoUninitialize 
        to correctly uninitialize COM. The value should be retained and later 
        passed to PaWinUtil_CoUninitialize.

 If PaWinUtil_CoInitialize returns paNoError, the caller must later call
 PaWinUtil_CoUninitialize once.
*/
PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );


/**
 @brief Uninitialize the Microsoft COM subsystem on the current thread using 
 the result of a previous call to PaWinUtil_CoInitialize. Must be called on the same
 thread as PaWinUtil_CoInitialize.

 @param hostApiType the host API type id of the caller. Used for error reporting.

 @param comInitializationResult An input parameter. A pointer to a value previously
 initialized by a call to PaWinUtil_CoInitialize.
*/
void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_WIN_COINITIALIZE_H */
#ifndef PA_WIN_WDMKS_UTILS_H
#define PA_WIN_WDMKS_UTILS_H

/*
 * PortAudio Portable Real-Time Audio Library
 * Windows WDM KS utilities
 *
 * Copyright (c) 1999 - 2007 Ross Bencina, Andrew Baldwin
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @brief Utilities for working with the Windows WDM KS API
*/

#ifdef __cplusplus
extern "C" {
#endif

/**
    Query for the maximum number of channels supported by any pin of the
    specified device. Returns 0 if the query fails for any reason.

    @param wcharDevicePath A system level PnP interface path, supplied as a WCHAR unicode string.
    Declard as void* to avoid introducing a dependency on wchar_t here.

    @param isInput A flag specifying whether to query for input (non-zero) or output (zero) channels.
*/
int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput );


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* PA_WIN_WDMKS_UTILS_H *//*
 * Plain Intel IA32 assembly implementations of PortAudio sample converter functions.
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup win_src
*/

#ifndef PA_X86_PLAIN_CONVERTERS_H
#define PA_X86_PLAIN_CONVERTERS_H

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/**
 @brief Install optimized converter functions suitable for all IA32 processors

 It is recommended to call PaUtil_InitializeX86PlainConverters prior to calling Pa_Initialize
*/
void PaUtil_InitializeX86PlainConverters( void );


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* PA_X86_PLAIN_CONVERTERS_H */
/*
 * Microsoft COM initialization routines
 * Copyright (c) 1999-2011 Ross Bencina, Dmitry Kostjuchenko
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/** @file
 @ingroup win_src

 @brief Microsoft COM initialization routines.
*/

#include <windows.h>
#include <objbase.h>

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_debugprint.h"

// (amalg) #include "pa_win_coinitialize.h"


#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) && !(defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)) /* MSC version 6 and above */
#pragma comment( lib, "ole32.lib" )
#endif


/* use some special bit patterns here to try to guard against uninitialized memory errors */
#define PAWINUTIL_COM_INITIALIZED       (0xb38f)
#define PAWINUTIL_COM_NOT_INITIALIZED   (0xf1cd)


PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
{
    HRESULT hr;

    comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;

    /*
        If COM is already initialized CoInitialize will either return
        FALSE, or RPC_E_CHANGED_MODE if it was initialised in a different
        threading mode. In either case we shouldn't consider it an error
        but we need to be careful to not call CoUninitialize() if 
        RPC_E_CHANGED_MODE was returned.
    */

#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY != WINAPI_FAMILY_APP)
    hr = CoInitialize(0); /* use legacy-safe equivalent to CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) */
#else
	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif
    if( FAILED(hr) && hr != RPC_E_CHANGED_MODE )
    {
        PA_DEBUG(("CoInitialize(0) failed. hr=%d\n", hr));

        if( hr == E_OUTOFMEMORY )
            return paInsufficientMemory;

        {
            char *lpMsgBuf;
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &lpMsgBuf,
                0,
                NULL
            );
            PaUtil_SetLastHostErrorInfo( hostApiType, hr, lpMsgBuf );
            LocalFree( lpMsgBuf );
        }

        return paUnanticipatedHostError;
    }

    if( hr != RPC_E_CHANGED_MODE )
    {
        comInitializationResult->state = PAWINUTIL_COM_INITIALIZED;

        /*
            Memorize calling thread id and report warning on Uninitialize if 
            calling thread is different as CoInitialize must match CoUninitialize 
            in the same thread.
        */
        comInitializationResult->initializingThreadId = GetCurrentThreadId();
    }

    return paNoError;
}


void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
{
    if( comInitializationResult->state != PAWINUTIL_COM_NOT_INITIALIZED
            && comInitializationResult->state != PAWINUTIL_COM_INITIALIZED ){
    
        PA_DEBUG(("ERROR: PaWinUtil_CoUninitialize called without calling PaWinUtil_CoInitialize\n"));
    }

    if( comInitializationResult->state == PAWINUTIL_COM_INITIALIZED )
    {
        DWORD currentThreadId = GetCurrentThreadId();
		if( comInitializationResult->initializingThreadId != currentThreadId )
		{
			PA_DEBUG(("ERROR: failed PaWinUtil_CoUninitialize calling thread[%d] does not match initializing thread[%d]\n",
				currentThreadId, comInitializationResult->initializingThreadId));
		}
		else
		{
			CoUninitialize();

            comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;
		}
    }
}/*
 * $Id$
 * Portable Audio I/O Library Windows initialization table
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup win_src

    @brief Win32 host API initialization function table.
*/

/* This is needed to make this source file depend on CMake option changes
   and at the same time make it transparent for clients not using CMake.
*/
#ifdef PORTAUDIO_CMAKE_GENERATED
// (amalg) #include "options_cmake.h"
#endif

// (amalg) #include "pa_hostapi.h"


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

PaError PaSkeleton_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaWinMme_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaWinDs_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaAsio_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaWinWdm_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */


PaUtilHostApiInitializer *paHostApiInitializers[] =
    {

#if PA_USE_WMME
        PaWinMme_Initialize,
#endif

#if PA_USE_DS
        PaWinDs_Initialize,
#endif

#if PA_USE_ASIO
        PaAsio_Initialize,
#endif

#if PA_USE_WASAPI
		PaWasapi_Initialize,
#endif

#if PA_USE_WDMKS
        PaWinWdm_Initialize,
#endif

#if PA_USE_SKELETON
        PaSkeleton_Initialize, /* just for testing. last in list so it isn't marked as default. */
#endif

        0   /* NULL terminated array */
    };


/*
 * $Id$
 * Portable Audio I/O Library
 * Win32 platform-specific support functions
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup win_src

 @brief Win32 implementation of platform-specific PaUtil support functions.
*/
 
#include <windows.h>

#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
	#include <sys/timeb.h> /* for _ftime_s() */
#else
	#include <mmsystem.h> /* for timeGetTime() */
	#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) /* MSC version 6 and above */
	#pragma comment( lib, "winmm.lib" )
	#endif
#endif

// (amalg) #include "pa_util.h"

/*
   Track memory allocations to avoid leaks.
 */

#if PA_TRACK_MEMORY
static int numAllocations_ = 0;
#endif


void *PaUtil_AllocateMemory( long size )
{
    void *result = GlobalAlloc( GPTR, size );

#if PA_TRACK_MEMORY
    if( result != NULL ) numAllocations_ += 1;
#endif
    return result;
}


void PaUtil_FreeMemory( void *block )
{
    if( block != NULL )
    {
        GlobalFree( block );
#if PA_TRACK_MEMORY
        numAllocations_ -= 1;
#endif

    }
}


int PaUtil_CountCurrentlyAllocatedBlocks( void )
{
#if PA_TRACK_MEMORY
    return numAllocations_;
#else
    return 0;
#endif
}


void Pa_Sleep( long msec )
{
    Sleep( msec );
}

static int usePerformanceCounter_;
static double secondsPerTick_;

void PaUtil_InitializeClock( void )
{
    LARGE_INTEGER ticksPerSecond;

    if( QueryPerformanceFrequency( &ticksPerSecond ) != 0 )
    {
        usePerformanceCounter_ = 1;
        secondsPerTick_ = 1.0 / (double)ticksPerSecond.QuadPart;
    }
    else
    {
        usePerformanceCounter_ = 0;
    }
}


double PaUtil_GetTime( void )
{
    LARGE_INTEGER time;

    if( usePerformanceCounter_ )
    {
        /*
            Note: QueryPerformanceCounter has a known issue where it can skip forward
            by a few seconds (!) due to a hardware bug on some PCI-ISA bridge hardware.
            This is documented here:
            http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323&

            The work-arounds are not very paletable and involve querying GetTickCount 
            at every time step.

            Using rdtsc is not a good option on multi-core systems.

            For now we just use QueryPerformanceCounter(). It's good, most of the time.
        */
        QueryPerformanceCounter( &time );
        return time.QuadPart * secondsPerTick_;
    }
    else
    {
#ifndef UNDER_CE
	#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
        return GetTickCount64() * .001;
	#else
        return timeGetTime() * .001;
	#endif
#else
        return GetTickCount() * .001;
#endif                
    }
}
/*
 * PortAudio Portable Real-Time Audio Library
 * Windows WAVEFORMAT* data structure utilities
 * portaudio.h should be included before this file.
 *
 * Copyright (c) 2007 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

#include <windows.h>
#include <mmsystem.h>
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
    #include <mmreg.h> /* for WAVEFORMATEX */
#endif

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_win_waveformat.h"


#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE         0xFFFE
#endif


static GUID pawin_ksDataFormatSubtypeGuidBase = 
	{ (USHORT)(WAVE_FORMAT_PCM), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 };


int PaWin_SampleFormatToLinearWaveFormatTag( PaSampleFormat sampleFormat )
{
    if( sampleFormat == paFloat32 )
        return PAWIN_WAVE_FORMAT_IEEE_FLOAT;
    
    return PAWIN_WAVE_FORMAT_PCM;
}


void PaWin_InitializeWaveFormatEx( PaWinWaveFormat *waveFormat, 
		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate )
{
	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
	unsigned long bytesPerFrame = numChannels * bytesPerSample;
	
    waveFormatEx->wFormatTag = waveFormatTag;
	waveFormatEx->nChannels = (WORD)numChannels;
	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
	waveFormatEx->cbSize = 0;
}


void PaWin_InitializeWaveFormatExtensible( PaWinWaveFormat *waveFormat, 
		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate,
		PaWinWaveFormatChannelMask channelMask )
{
	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
	unsigned long bytesPerFrame = numChannels * bytesPerSample;
    GUID guid;

	waveFormatEx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
	waveFormatEx->nChannels = (WORD)numChannels;
	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
	waveFormatEx->cbSize = 22;

	*((WORD*)&waveFormat->fields[PAWIN_INDEXOF_WVALIDBITSPERSAMPLE]) =
			waveFormatEx->wBitsPerSample;

	*((DWORD*)&waveFormat->fields[PAWIN_INDEXOF_DWCHANNELMASK]) = channelMask;
		
    guid = pawin_ksDataFormatSubtypeGuidBase;
    guid.Data1 = (USHORT)waveFormatTag;
    *((GUID*)&waveFormat->fields[PAWIN_INDEXOF_SUBFORMAT]) = guid;
}

PaWinWaveFormatChannelMask PaWin_DefaultChannelMask( int numChannels )
{
	switch( numChannels ){
		case 1:
			return PAWIN_SPEAKER_MONO;
		case 2:
			return PAWIN_SPEAKER_STEREO; 
		case 3:
            return PAWIN_SPEAKER_FRONT_LEFT | PAWIN_SPEAKER_FRONT_CENTER | PAWIN_SPEAKER_FRONT_RIGHT;
		case 4:
			return PAWIN_SPEAKER_QUAD;
		case 5:
            return PAWIN_SPEAKER_QUAD | PAWIN_SPEAKER_FRONT_CENTER;
		case 6:
            /* The meaning of the PAWIN_SPEAKER_5POINT1 flag has changed over time:
                http://msdn2.microsoft.com/en-us/library/aa474707.aspx
               We use PAWIN_SPEAKER_5POINT1 (not PAWIN_SPEAKER_5POINT1_SURROUND)
               because on some cards (eg Audigy) PAWIN_SPEAKER_5POINT1_SURROUND 
               results in a virtual mixdown placing the rear output in the 
               front _and_ rear speakers.
            */
			return PAWIN_SPEAKER_5POINT1; 
        /* case 7: */
		case 8:
            /* RoBi: PAWIN_SPEAKER_7POINT1_SURROUND fits normal surround sound setups better than PAWIN_SPEAKER_7POINT1, f.i. NVidia HDMI Audio
               output is silent on channels 5&6 with NVidia drivers, and channel 7&8 with Micrsoft HD Audio driver using PAWIN_SPEAKER_7POINT1. 
               With PAWIN_SPEAKER_7POINT1_SURROUND both setups work OK. */
			return PAWIN_SPEAKER_7POINT1_SURROUND;
	}

    /* Apparently some Audigy drivers will output silence 
       if the direct-out constant (0) is used. So this is not ideal.    

       RoBi 2012-12-19: Also, NVidia driver seem to output garbage instead. Again not very ideal.
    */
	return  PAWIN_SPEAKER_DIRECTOUT;

    /* Note that Alec Rogers proposed the following as an alternate method to 
        generate the default channel mask, however it doesn't seem to be an improvement
        over the above, since some drivers will matrix outputs mapping to non-present
        speakers accross multiple physical speakers.

        if(nChannels==1) {
            pwfFormat->dwChannelMask = SPEAKER_FRONT_CENTER;
        }
        else {
            pwfFormat->dwChannelMask = 0;
            for(i=0; i<nChannels; i++)
                pwfFormat->dwChannelMask = (pwfFormat->dwChannelMask << 1) | 0x1;
        }
    */
}
/*
 * PortAudio Portable Real-Time Audio Library
 * Windows WDM KS utilities
 *
 * Copyright (c) 1999 - 2007 Andrew Baldwin, Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

#include <windows.h>
#include <mmreg.h>
#ifndef WAVE_FORMAT_IEEE_FLOAT
    #define WAVE_FORMAT_IEEE_FLOAT 0x0003   // MinGW32 does not define this
#endif    
#ifndef _WAVEFORMATEXTENSIBLE_
    #define _WAVEFORMATEXTENSIBLE_          // MinGW32 does not define this
#endif
#ifndef _INC_MMREG
    #define _INC_MMREG                      // for STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
#endif
#include <winioctl.h>						// MinGW32 does not define this automatically

#if defined(__GNUC__)

// (amalg) #include "../../hostapi/wasapi/mingw-include/ks.h"
// (amalg) #include "../../hostapi/wasapi/mingw-include/ksmedia.h"

#else

#include <ks.h>
#include <ksmedia.h>

#endif

#include <stdio.h>                          // just for some development printfs

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_win_wdmks_utils.h"


/* PortAudio-local instances of GUIDs previously sourced from ksguid.lib */

/* GUID KSDATAFORMAT_TYPE_AUDIO */
static const GUID pa_KSDATAFORMAT_TYPE_AUDIO = { STATIC_KSDATAFORMAT_TYPE_AUDIO };

/* GUID KSDATAFORMAT_SUBTYPE_IEEE_FLOAT */
static const GUID pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = { STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT };

/* GUID KSDATAFORMAT_SUBTYPE_PCM */
static const GUID pa_KSDATAFORMAT_SUBTYPE_PCM = { STATIC_KSDATAFORMAT_SUBTYPE_PCM };

/* GUID KSDATAFORMAT_SUBTYPE_WAVEFORMATEX */
static const GUID pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX = { STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX };

/* GUID KSMEDIUMSETID_Standard */
static const GUID pa_KSMEDIUMSETID_Standard = { STATIC_KSMEDIUMSETID_Standard };

/* GUID KSINTERFACESETID_Standard */
static const GUID pa_KSINTERFACESETID_Standard = { STATIC_KSINTERFACESETID_Standard };

/* GUID KSPROPSETID_Pin */
static const GUID pa_KSPROPSETID_Pin = { STATIC_KSPROPSETID_Pin };

#define pa_IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))


static PaError WdmGetPinPropertySimple(
    HANDLE  handle,
    unsigned long pinId,
    unsigned long property,
    void* value,
    unsigned long valueSize )
{
    DWORD bytesReturned;
    KSP_PIN ksPProp;
    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
    ksPProp.Property.Id = property;
    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksPProp.PinId = pinId;
    ksPProp.Reserved = 0;

    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
            value, valueSize, &bytesReturned, NULL ) == 0 || bytesReturned != valueSize )
    {
        return paUnanticipatedHostError;
    }
    else
    {
        return paNoError;
    }
}


static PaError WdmGetPinPropertyMulti(
    HANDLE handle,
    unsigned long pinId,
    unsigned long property,
    KSMULTIPLE_ITEM** ksMultipleItem)
{
    unsigned long multipleItemSize = 0;
    KSP_PIN ksPProp;
    DWORD bytesReturned;

    *ksMultipleItem = 0;

    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
    ksPProp.Property.Id = property;
    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksPProp.PinId = pinId;
    ksPProp.Reserved = 0;

    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp.Property,
            sizeof(KSP_PIN), NULL, 0, &multipleItemSize, NULL ) == 0 && GetLastError() != ERROR_MORE_DATA )
    {
        return paUnanticipatedHostError;
    }

    *ksMultipleItem = (KSMULTIPLE_ITEM*)PaUtil_AllocateMemory( multipleItemSize );
    if( !*ksMultipleItem )
    {
        return paInsufficientMemory;
    }

    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
            (void*)*ksMultipleItem,  multipleItemSize, &bytesReturned, NULL ) == 0 || bytesReturned != multipleItemSize )
    {
        PaUtil_FreeMemory( ksMultipleItem );
        return paUnanticipatedHostError;
    }

    return paNoError;
}


static int GetKSFilterPinCount( HANDLE deviceHandle )
{
    DWORD result;

    if( WdmGetPinPropertySimple( deviceHandle, 0, KSPROPERTY_PIN_CTYPES, &result, sizeof(result) ) == paNoError ){
        return result;
    }else{
        return 0;
    }
}


static KSPIN_COMMUNICATION GetKSFilterPinPropertyCommunication( HANDLE deviceHandle, int pinId )
{
    KSPIN_COMMUNICATION result;

    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_COMMUNICATION, &result, sizeof(result) ) == paNoError ){
        return result;
    }else{
        return KSPIN_COMMUNICATION_NONE;
    }
}


static KSPIN_DATAFLOW GetKSFilterPinPropertyDataflow( HANDLE deviceHandle, int pinId )
{
    KSPIN_DATAFLOW result;

    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_DATAFLOW, &result, sizeof(result) ) == paNoError ){
        return result;
    }else{
        return (KSPIN_DATAFLOW)0;
    }
}


static int KSFilterPinPropertyIdentifiersInclude( 
        HANDLE deviceHandle, int pinId, unsigned long property, const GUID *identifierSet, unsigned long identifierId  )
{
    KSMULTIPLE_ITEM* item = NULL;
    KSIDENTIFIER* identifier;
    int i;
    int result = 0;

    if( WdmGetPinPropertyMulti( deviceHandle, pinId, property, &item) != paNoError )
        return 0;
    
    identifier = (KSIDENTIFIER*)(item+1);

    for( i = 0; i < (int)item->Count; i++ )
    {
        if( !memcmp( (void*)&identifier[i].Set, (void*)identifierSet, sizeof( GUID ) ) &&
           ( identifier[i].Id == identifierId ) )
        {
            result = 1;
            break;
        }
    }

    PaUtil_FreeMemory( item );

    return result;
}


/* return the maximum channel count supported by any pin on the device. 
   if isInput is non-zero we query input pins, otherwise output pins.
*/
int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput )
{
    HANDLE deviceHandle;
	ULONG i;
    int pinCount, pinId;
    int result = 0;
    KSPIN_DATAFLOW requiredDataflowDirection = (isInput ? KSPIN_DATAFLOW_OUT : KSPIN_DATAFLOW_IN );
    
    if( !wcharDevicePath )
        return 0;

    deviceHandle = CreateFileW( (LPCWSTR)wcharDevicePath, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL );
    if( deviceHandle == INVALID_HANDLE_VALUE )
        return 0;

    pinCount = GetKSFilterPinCount( deviceHandle );
    for( pinId = 0; pinId < pinCount; ++pinId )
    {
        KSPIN_COMMUNICATION communication = GetKSFilterPinPropertyCommunication( deviceHandle, pinId );
        KSPIN_DATAFLOW dataflow = GetKSFilterPinPropertyDataflow( deviceHandle, pinId );
        if( ( dataflow == requiredDataflowDirection ) &&
                (( communication == KSPIN_COMMUNICATION_SINK) ||
                 ( communication == KSPIN_COMMUNICATION_BOTH)) 
             && ( KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING )
                || KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_LOOPED_STREAMING ) )
             && KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
                    KSPROPERTY_PIN_MEDIUMS, &pa_KSMEDIUMSETID_Standard, KSMEDIUM_STANDARD_DEVIO ) )
         {
            KSMULTIPLE_ITEM* item = NULL;
            if( WdmGetPinPropertyMulti( deviceHandle, pinId, KSPROPERTY_PIN_DATARANGES, &item ) == paNoError )
            {
                KSDATARANGE *dataRange = (KSDATARANGE*)(item+1);

                for( i=0; i < item->Count; ++i ){

                    if( pa_IS_VALID_WAVEFORMATEX_GUID(&dataRange->SubFormat)
                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_PCM, sizeof(GUID) ) == 0
                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, sizeof(GUID) ) == 0
                            || ( ( memcmp( (void*)&dataRange->MajorFormat, (void*)&pa_KSDATAFORMAT_TYPE_AUDIO, sizeof(GUID) ) == 0 )
                                && ( memcmp( (void*)&dataRange->SubFormat, (void*)&KSDATAFORMAT_SUBTYPE_WILDCARD, sizeof(GUID) ) == 0 ) ) )
                    {
                        KSDATARANGE_AUDIO *dataRangeAudio = (KSDATARANGE_AUDIO*)dataRange;
                        
                        /*
                        printf( ">>> %d %d %d %d %S\n", isInput, dataflow, communication, dataRangeAudio->MaximumChannels, devicePath );
                       
                        if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WAVEFORMATEX, sizeof(GUID) ) == 0 )
                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\n" );
                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_DSOUND, sizeof(GUID) ) == 0 )
                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_DSOUND\n" );
                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WILDCARD, sizeof(GUID) ) == 0 )
                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WILDCARD\n" );
                        else
                            printf( "\tspecifier: ?\n" );
                        */

                        /*
                            We assume that very high values for MaximumChannels are not useful and indicate
                            that the driver isn't prepared to tell us the real number of channels which it supports.
                        */
                        if( dataRangeAudio->MaximumChannels  < 0xFFFFUL && (int)dataRangeAudio->MaximumChannels > result )
                            result = (int)dataRangeAudio->MaximumChannels;
                    }
                    
                    dataRange = (KSDATARANGE*)( ((char*)dataRange) + dataRange->FormatSize);
                }

                PaUtil_FreeMemory( item );
            }
        }
    }
    
    CloseHandle( deviceHandle );
    return result;
}
/*
 * Plain Intel IA32 assembly implementations of PortAudio sample converter functions.
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup win_src
*/

// (amalg) #include "pa_x86_plain_converters.h"

// (amalg) #include "pa_converters.h"
// (amalg) #include "pa_dither.h"

/*
    the main reason these versions are faster than the equivalent C versions
    is that float -> int casting is expensive in C on x86 because the rounding
    mode needs to be changed for every cast. these versions only set
    the rounding mode once outside the loop.

    small additional speed gains are made by the way that clamping is
    implemented.

TODO:
    o- inline dither code
    o- implement Dither only (no-clip) versions
    o- implement int8 and uint8 versions
    o- test thouroughly

    o- the packed 24 bit functions could benefit from unrolling and avoiding
        byte and word sized register access.
*/

/* -------------------------------------------------------------------------- */

/*
#define PA_CLIP_( val, min, max )\
    { val = ((val) < (min)) ? (min) : (((val) > (max)) ? (max) : (val)); }
*/

/*
    the following notes were used to determine whether a floating point
    value should be saturated (ie >1 or <-1) by loading it into an integer
    register. these should be rewritten so that they make sense.

    an ieee floating point value

    1.xxxxxxxxxxxxxxxxxxxx?


    is less than  or equal to 1 and greater than or equal to -1 either:

        if the mantissa is 0 and the unbiased exponent is 0

        OR

        if the unbiased exponent < 0

    this translates to:

        if the mantissa is 0 and the biased exponent is 7F

        or

        if the biased exponent is less than 7F


    therefore the value is greater than 1 or less than -1 if

        the mantissa is not 0 and the biased exponent is 7F

        or

        if the biased exponent is greater than 7F


    in other words, if we mask out the sign bit, the value is
    greater than 1 or less than -1 if its integer representation is greater than:

    0 01111111 0000 0000 0000 0000 0000 000

    0011 1111 1000 0000 0000 0000 0000 0000 => 0x3F800000
*/

#if defined(_WIN64) || defined(_WIN32_WCE)

/*
	-EMT64/AMD64 uses different asm
	-VC2005 doesnt allow _WIN64 with inline assembly either!
 */
void PaUtil_InitializeX86PlainConverters( void )
{
}

#else

/* -------------------------------------------------------------------------- */

static const short fpuControlWord_ = 0x033F; /*round to nearest, 64 bit precision, all exceptions masked*/
static const double int32Scaler_ = 0x7FFFFFFF;
static const double ditheredInt32Scaler_ = 0x7FFFFFFE;
static const double int24Scaler_ = 0x7FFFFF;
static const double ditheredInt24Scaler_ = 0x7FFFFE;
static const double int16Scaler_ = 0x7FFF;
static const double ditheredInt16Scaler_ = 0x7FFE;

#define PA_DITHER_BITS_   (15)
/* Multiply by PA_FLOAT_DITHER_SCALE_ to get a float between -2.0 and +1.99999 */
#define PA_FLOAT_DITHER_SCALE_  (1.0F / ((1<<PA_DITHER_BITS_)-1))
static const float const_float_dither_scale_ = PA_FLOAT_DITHER_SCALE_;
#define PA_DITHER_SHIFT_  ((32 - PA_DITHER_BITS_) + 1)

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    signed long *dest =  (signed long*)destinationBuffer;
    (void)ditherGenerator; // unused parameter

    while( count-- )
    {
        // REVIEW
        double scaled = *src * 0x7FFFFFFF;
        *dest = (signed long) scaled;

        src += sourceStride;
        dest += destinationStride;
    }
*/

    short savedFpuControlWord;

    (void) ditherGenerator; /* unused parameter */


    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32 and int32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi
    
        mov     edi, destinationBuffer
        
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int32Scaler_             // stack:  (int)0x7FFFFFFF

    Float32_To_Int32_loop:

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFFFFFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFFFFFF, (int)0x7FFFFFFF
        /*
            note: we could store to a temporary qword here which would cause
            wraparound distortion instead of int indefinite 0x10. that would
            be more work, and given that not enabling clipping is only advisable
            when you know that your signal isn't going to clip it isn't worth it.
        */
        fistp   dword ptr [edi]         // pop st(0) into dest, stack:  (int)0x7FFFFFFF

        add     edi, ebx                // increment destination ptr
        //lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int32_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    signed long *dest =  (signed long*)destinationBuffer;
    (void) ditherGenerator; // unused parameter

    while( count-- )
    {
        // REVIEW
        double scaled = *src * 0x7FFFFFFF;
        PA_CLIP_( scaled, -2147483648., 2147483647.  );
        *dest = (signed long) scaled;

        src += sourceStride;
        dest += destinationStride;
    }
*/

    short savedFpuControlWord;

    (void) ditherGenerator; /* unused parameter */

    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32 and int32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi
    
        mov     edi, destinationBuffer
        
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int32Scaler_             // stack:  (int)0x7FFFFFFF

    Float32_To_Int32_Clip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int32_Clip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFFFFFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFFFFFF, (int)0x7FFFFFFF
        fistp   dword ptr [edi]         // pop st(0) into dest, stack:  (int)0x7FFFFFFF
        jmp     Float32_To_Int32_Clip_stored
    
    Float32_To_Int32_Clip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     edx, 0x7FFFFFFF         // convert to maximum range integers
        mov     dword ptr [edi], edx

    Float32_To_Int32_Clip_stored:

        //add     edi, ebx                // increment destination ptr
        lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int32_Clip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int32_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
    /*
    float *src = (float*)sourceBuffer;
    signed long *dest =  (signed long*)destinationBuffer;

    while( count-- )
    {
        // REVIEW
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        // use smaller scaler to prevent overflow when we add the dither
        double dithered = ((double)*src * (2147483646.0)) + dither;
        PA_CLIP_( dithered, -2147483648., 2147483647.  );
        *dest = (signed long) dithered;


        src += sourceStride;
        dest += destinationStride;
    }
    */

    short savedFpuControlWord;

    // spill storage:
    signed long sourceByteStride;
    signed long highpassedDither;

    // dither state:
    unsigned long ditherPrevious = ditherGenerator->previous;
    unsigned long ditherRandSeed1 = ditherGenerator->randSeed1;
    unsigned long ditherRandSeed2 = ditherGenerator->randSeed2;
                    
    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32 and int32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi
    
        mov     edi, destinationBuffer
        
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     ditheredInt32Scaler_    // stack:  int scaler

    Float32_To_Int32_DitherClip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int32_DitherClip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, int scaler
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*(int scaler), int scaler

        /*
        // call PaUtil_GenerateFloatTriangularDither with C calling convention
        mov     sourceByteStride, eax   // save eax
        mov     sourceEnd, ecx          // save ecx
        push    ditherGenerator         // pass ditherGenerator parameter on stack
	    call    PaUtil_GenerateFloatTriangularDither  // stack:  dither, value*(int scaler), int scaler
	    pop     edx                     // clear parameter off stack
        mov     ecx, sourceEnd          // restore ecx
        mov     eax, sourceByteStride   // restore eax
        */

    // generate dither
        mov     sourceByteStride, eax   // save eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed1
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     ditherRandSeed1, eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed2
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     edx, ditherRandSeed1
        shr     edx, PA_DITHER_SHIFT_
        mov     ditherRandSeed2, eax
        shr     eax, PA_DITHER_SHIFT_
        //add     eax, edx                // eax -> current
        lea     eax, [eax+edx]
        mov     edx, ditherPrevious
        neg     edx
        lea     edx, [eax+edx]          // highpass = current - previous
        mov     highpassedDither, edx
        mov     ditherPrevious, eax     // previous = current
        mov     eax, sourceByteStride   // restore eax
        fild    highpassedDither
        fmul    const_float_dither_scale_
    // end generate dither, dither signal in st(0)
    
        faddp   st(1), st(0)            // stack: dither + value*(int scaler), int scaler
        fistp   dword ptr [edi]         // pop st(0) into dest, stack:  int scaler
        jmp     Float32_To_Int32_DitherClip_stored
    
    Float32_To_Int32_DitherClip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     edx, 0x7FFFFFFF         // convert to maximum range integers
        mov     dword ptr [edi], edx

    Float32_To_Int32_DitherClip_stored:

        //add     edi, ebx              // increment destination ptr
        lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int32_DitherClip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }

    ditherGenerator->previous = ditherPrevious;
    ditherGenerator->randSeed1 = ditherRandSeed1;
    ditherGenerator->randSeed2 = ditherRandSeed2;
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    signed long temp;

    (void) ditherGenerator; // unused parameter
    
    while( count-- )
    {
        // convert to 32 bit and drop the low 8 bits
        double scaled = *src * 0x7FFFFFFF;
        temp = (signed long) scaled;

        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);

        src += sourceStride;
        dest += destinationStride * 3;
    }
*/

    short savedFpuControlWord;
    
    signed long tempInt32;

    (void) ditherGenerator; /* unused parameter */
                 
    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi

        mov     edi, destinationBuffer

        mov     edx, 3                  // sizeof int24
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int24Scaler_             // stack:  (int)0x7FFFFF

    Float32_To_Int24_loop:

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFFFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFFFF, (int)0x7FFFFF
        fistp   tempInt32               // pop st(0) into tempInt32, stack:  (int)0x7FFFFF
        mov     edx, tempInt32

        mov     byte ptr [edi], DL
        shr     edx, 8
        //mov     byte ptr [edi+1], DL
        //mov     byte ptr [edi+2], DH
        mov     word ptr [edi+1], DX

        //add     edi, ebx                // increment destination ptr
        lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int24_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    signed long temp;

    (void) ditherGenerator; // unused parameter
    
    while( count-- )
    {
        // convert to 32 bit and drop the low 8 bits
        double scaled = *src * 0x7FFFFFFF;
        PA_CLIP_( scaled, -2147483648., 2147483647.  );
        temp = (signed long) scaled;

        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);

        src += sourceStride;
        dest += destinationStride * 3;
    }
*/

    short savedFpuControlWord;
    
    signed long tempInt32;

    (void) ditherGenerator; /* unused parameter */
                 
    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi

        mov     edi, destinationBuffer

        mov     edx, 3                  // sizeof int24
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int24Scaler_             // stack:  (int)0x7FFFFF

    Float32_To_Int24_Clip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int24_Clip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFFFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFFFF, (int)0x7FFFFF
        fistp   tempInt32               // pop st(0) into tempInt32, stack:  (int)0x7FFFFF
        mov     edx, tempInt32
        jmp     Float32_To_Int24_Clip_store
    
    Float32_To_Int24_Clip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     edx, 0x7FFFFF           // convert to maximum range integers

    Float32_To_Int24_Clip_store:

        mov     byte ptr [edi], DL
        shr     edx, 8
        //mov     byte ptr [edi+1], DL
        //mov     byte ptr [edi+2], DH
        mov     word ptr [edi+1], DX

        //add     edi, ebx                // increment destination ptr
        lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int24_Clip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int24_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    signed long temp;
    
    while( count-- )
    {
        // convert to 32 bit and drop the low 8 bits

        // FIXME: the dither amplitude here appears to be too small by 8 bits
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        // use smaller scaler to prevent overflow when we add the dither
        double dithered = ((double)*src * (2147483646.0)) + dither;
        PA_CLIP_( dithered, -2147483648., 2147483647.  );
        
        temp = (signed long) dithered;

        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);

        src += sourceStride;
        dest += destinationStride * 3;
    }
*/

    short savedFpuControlWord;

    // spill storage:
    signed long sourceByteStride;
    signed long highpassedDither;

    // dither state:
    unsigned long ditherPrevious = ditherGenerator->previous;
    unsigned long ditherRandSeed1 = ditherGenerator->randSeed1;
    unsigned long ditherRandSeed2 = ditherGenerator->randSeed2;
    
    signed long tempInt32;
                 
    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi

        mov     edi, destinationBuffer

        mov     edx, 3                  // sizeof int24
        mov     ebx, destinationStride
        imul    ebx, edx

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     ditheredInt24Scaler_    // stack:  int scaler

    Float32_To_Int24_DitherClip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int24_DitherClip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, int scaler
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*(int scaler), int scaler

    /*
        // call PaUtil_GenerateFloatTriangularDither with C calling convention
        mov     sourceByteStride, eax   // save eax
        mov     sourceEnd, ecx          // save ecx
        push    ditherGenerator         // pass ditherGenerator parameter on stack
	    call    PaUtil_GenerateFloatTriangularDither  // stack:  dither, value*(int scaler), int scaler
	    pop     edx                     // clear parameter off stack
        mov     ecx, sourceEnd          // restore ecx
        mov     eax, sourceByteStride   // restore eax
    */
    
    // generate dither
        mov     sourceByteStride, eax   // save eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed1
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     ditherRandSeed1, eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed2
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     edx, ditherRandSeed1
        shr     edx, PA_DITHER_SHIFT_
        mov     ditherRandSeed2, eax
        shr     eax, PA_DITHER_SHIFT_
        //add     eax, edx                // eax -> current
        lea     eax, [eax+edx]
        mov     edx, ditherPrevious
        neg     edx
        lea     edx, [eax+edx]          // highpass = current - previous
        mov     highpassedDither, edx
        mov     ditherPrevious, eax     // previous = current
        mov     eax, sourceByteStride   // restore eax
        fild    highpassedDither
        fmul    const_float_dither_scale_
    // end generate dither, dither signal in st(0)

        faddp   st(1), st(0)            // stack: dither * value*(int scaler), int scaler
        fistp   tempInt32               // pop st(0) into tempInt32, stack:  int scaler
        mov     edx, tempInt32
        jmp     Float32_To_Int24_DitherClip_store
    
    Float32_To_Int24_DitherClip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     edx, 0x7FFFFF           // convert to maximum range integers

    Float32_To_Int24_DitherClip_store:

        mov     byte ptr [edi], DL
        shr     edx, 8
        //mov     byte ptr [edi+1], DL
        //mov     byte ptr [edi+2], DH
        mov     word ptr [edi+1], DX

        //add     edi, ebx                // increment destination ptr
        lea     edi, [edi+ebx]

        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int24_DitherClip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }

    ditherGenerator->previous = ditherPrevious;
    ditherGenerator->randSeed1 = ditherRandSeed1;
    ditherGenerator->randSeed2 = ditherRandSeed2;
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    signed short *dest =  (signed short*)destinationBuffer;
    (void)ditherGenerator; // unused parameter

    while( count-- )
    {

        short samp = (short) (*src * (32767.0f));
        *dest = samp;

        src += sourceStride;
        dest += destinationStride;
    }
*/

    short savedFpuControlWord;
   
    (void) ditherGenerator; /* unused parameter */

    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx                // source byte stride

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi                // source end ptr = count * source byte stride + source ptr

        mov     edi, destinationBuffer

        mov     edx, 2                  // sizeof int16
        mov     ebx, destinationStride
        imul    ebx, edx                // destination byte stride

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int16Scaler_            // stack:  (int)0x7FFF

    Float32_To_Int16_loop:

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFF, (int)0x7FFF
        fistp   word ptr [edi]          // store scaled int into dest, stack:  (int)0x7FFF

        add     edi, ebx                // increment destination ptr
        //lea     edi, [edi+ebx]
        
        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int16_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16_Clip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    signed short *dest =  (signed short*)destinationBuffer;
    (void)ditherGenerator; // unused parameter

    while( count-- )
    {
        long samp = (signed long) (*src * (32767.0f));
        PA_CLIP_( samp, -0x8000, 0x7FFF );
        *dest = (signed short) samp;

        src += sourceStride;
        dest += destinationStride;
    }
*/

    short savedFpuControlWord;
   
    (void) ditherGenerator; /* unused parameter */

    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx                // source byte stride

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi                // source end ptr = count * source byte stride + source ptr

        mov     edi, destinationBuffer

        mov     edx, 2                  // sizeof int16
        mov     ebx, destinationStride
        imul    ebx, edx                // destination byte stride

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     int16Scaler_            // stack:  (int)0x7FFF

    Float32_To_Int16_Clip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int16_Clip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, (int)0x7FFF
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*0x7FFF, (int)0x7FFF
        fistp   word ptr [edi]          // store scaled int into dest, stack:  (int)0x7FFF
        jmp     Float32_To_Int16_Clip_stored
    
    Float32_To_Int16_Clip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     dx, 0x7FFF              // convert to maximum range integers
        mov     word ptr [edi], dx      // store clamped into into dest

    Float32_To_Int16_Clip_stored:

        add     edi, ebx                // increment destination ptr
        //lea     edi, [edi+ebx]
        
        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int16_Clip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }
}

/* -------------------------------------------------------------------------- */

static void Float32_To_Int16_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, PaUtilTriangularDitherGenerator *ditherGenerator )
{
/*
    float *src = (float*)sourceBuffer;
    signed short *dest =  (signed short*)destinationBuffer;
    (void)ditherGenerator; // unused parameter

    while( count-- )
    {

        float dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        // use smaller scaler to prevent overflow when we add the dither 
        float dithered = (*src * (32766.0f)) + dither;
        signed long samp = (signed long) dithered;
        PA_CLIP_( samp, -0x8000, 0x7FFF );
        *dest = (signed short) samp;

        src += sourceStride;
        dest += destinationStride;
    }
*/

    short savedFpuControlWord;

    // spill storage:
    signed long sourceByteStride;
    signed long highpassedDither;

    // dither state:
    unsigned long ditherPrevious = ditherGenerator->previous;
    unsigned long ditherRandSeed1 = ditherGenerator->randSeed1;
    unsigned long ditherRandSeed2 = ditherGenerator->randSeed2;

    __asm{
        // esi -> source ptr
        // eax -> source byte stride
        // edi -> destination ptr
        // ebx -> destination byte stride
        // ecx -> source end ptr
        // edx -> temp

        mov     esi, sourceBuffer

        mov     edx, 4                  // sizeof float32
        mov     eax, sourceStride
        imul    eax, edx                // source byte stride

        mov     ecx, count
        imul    ecx, eax
        add     ecx, esi                // source end ptr = count * source byte stride + source ptr

        mov     edi, destinationBuffer

        mov     edx, 2                  // sizeof int16
        mov     ebx, destinationStride
        imul    ebx, edx                // destination byte stride

        fwait
        fstcw   savedFpuControlWord
        fldcw   fpuControlWord_

        fld     ditheredInt16Scaler_    // stack:  int scaler

    Float32_To_Int16_DitherClip_loop:

        mov     edx, dword ptr [esi]    // load floating point value into integer register

        and     edx, 0x7FFFFFFF         // mask off sign
        cmp     edx, 0x3F800000         // greater than 1.0 or less than -1.0

        jg      Float32_To_Int16_DitherClip_clamp

        // load unscaled value into st(0)
        fld     dword ptr [esi]         // stack:  value, int scaler
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        fmul    st(0), st(1)            // st(0) *= st(1), stack:  value*(int scaler), int scaler

        /*
        // call PaUtil_GenerateFloatTriangularDither with C calling convention
        mov     sourceByteStride, eax   // save eax
        mov     sourceEnd, ecx          // save ecx
        push    ditherGenerator         // pass ditherGenerator parameter on stack
	    call    PaUtil_GenerateFloatTriangularDither  // stack:  dither, value*(int scaler), int scaler
	    pop     edx                     // clear parameter off stack
        mov     ecx, sourceEnd          // restore ecx
        mov     eax, sourceByteStride   // restore eax
        */

    // generate dither
        mov     sourceByteStride, eax   // save eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed1
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     ditherRandSeed1, eax
        mov     edx, 196314165
        mov     eax, ditherRandSeed2
        mul     edx                     // eax:edx = eax * 196314165
        //add     eax, 907633515
        lea     eax, [eax+907633515]
        mov     edx, ditherRandSeed1
        shr     edx, PA_DITHER_SHIFT_
        mov     ditherRandSeed2, eax
        shr     eax, PA_DITHER_SHIFT_
        //add     eax, edx                // eax -> current
        lea     eax, [eax+edx]            // current = randSeed1>>x + randSeed2>>x
        mov     edx, ditherPrevious
        neg     edx
        lea     edx, [eax+edx]          // highpass = current - previous
        mov     highpassedDither, edx
        mov     ditherPrevious, eax     // previous = current
        mov     eax, sourceByteStride   // restore eax
        fild    highpassedDither
        fmul    const_float_dither_scale_
    // end generate dither, dither signal in st(0)
        
        faddp   st(1), st(0)            // stack: dither * value*(int scaler), int scaler
        fistp   word ptr [edi]          // store scaled int into dest, stack:  int scaler
        jmp     Float32_To_Int16_DitherClip_stored
    
    Float32_To_Int16_DitherClip_clamp:
        mov     edx, dword ptr [esi]    // load floating point value into integer register
        shr     edx, 31                 // move sign bit into bit 0
        add     esi, eax                // increment source ptr
        //lea     esi, [esi+eax]
        add     dx, 0x7FFF              // convert to maximum range integers
        mov     word ptr [edi], dx      // store clamped into into dest

    Float32_To_Int16_DitherClip_stored:

        add     edi, ebx                // increment destination ptr
        //lea     edi, [edi+ebx]
        
        cmp     esi, ecx                // has src ptr reached end?
        jne     Float32_To_Int16_DitherClip_loop

        ffree   st(0)
        fincstp

        fwait
        fnclex
        fldcw   savedFpuControlWord
    }

    ditherGenerator->previous = ditherPrevious;
    ditherGenerator->randSeed1 = ditherRandSeed1;
    ditherGenerator->randSeed2 = ditherRandSeed2;
}

/* -------------------------------------------------------------------------- */

void PaUtil_InitializeX86PlainConverters( void )
{
    paConverters.Float32_To_Int32 = Float32_To_Int32;
    paConverters.Float32_To_Int32_Clip = Float32_To_Int32_Clip;
    paConverters.Float32_To_Int32_DitherClip = Float32_To_Int32_DitherClip;

    paConverters.Float32_To_Int24 = Float32_To_Int24;
    paConverters.Float32_To_Int24_Clip = Float32_To_Int24_Clip;
    paConverters.Float32_To_Int24_DitherClip = Float32_To_Int24_DitherClip;
    
    paConverters.Float32_To_Int16 = Float32_To_Int16;
    paConverters.Float32_To_Int16_Clip = Float32_To_Int16_Clip;
    paConverters.Float32_To_Int16_DitherClip = Float32_To_Int16_DitherClip;
}

#endif

/* -------------------------------------------------------------------------- */
#else
/*
 * $Id$
 * Portable Audio I/O Library
 * UNIX platform-specific support functions
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2000 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup unix_src
*/

#ifndef PA_UNIX_UTIL_H
#define PA_UNIX_UTIL_H

// (amalg) #include "pa_cpuload.h"
#include <assert.h>
#include <pthread.h>
#include <signal.h>

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

#define PA_MIN(x,y) ( (x) < (y) ? (x) : (y) )
#define PA_MAX(x,y) ( (x) > (y) ? (x) : (y) )

/* Utilize GCC branch prediction for error tests */
#if defined __GNUC__ && __GNUC__ >= 3
#define UNLIKELY(expr) __builtin_expect( (expr), 0 )
#else
#define UNLIKELY(expr) (expr)
#endif

#define STRINGIZE_HELPER(expr) #expr
#define STRINGIZE(expr) STRINGIZE_HELPER(expr)

#define PA_UNLESS(expr, code) \
    do { \
        if( UNLIKELY( (expr) == 0 ) ) \
        { \
            PaUtil_DebugPrint(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = (code); \
            goto error; \
        } \
    } while (0);

static PaError paUtilErr_;          /* Used with PA_ENSURE */

/* Check PaError */
#define PA_ENSURE(expr) \
    do { \
        if( UNLIKELY( (paUtilErr_ = (expr)) < paNoError ) ) \
        { \
            PaUtil_DebugPrint(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = paUtilErr_; \
            goto error; \
        } \
    } while (0);

#define PA_ASSERT_CALL(expr, success) \
    paUtilErr_ = (expr); \
    assert( success == paUtilErr_ );

#define PA_ENSURE_SYSTEM(expr, success) \
    do { \
        if( UNLIKELY( (paUtilErr_ = (expr)) != success ) ) \
        { \
            /* PaUtil_SetLastHostErrorInfo should only be used in the main thread */ \
            if( pthread_equal(pthread_self(), paUnixMainThread) ) \
            { \
                PaUtil_SetLastHostErrorInfo( paALSA, paUtilErr_, strerror( paUtilErr_ ) ); \
            } \
            PaUtil_DebugPrint( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" ); \
            result = paUnanticipatedHostError; \
            goto error; \
        } \
    } while( 0 );

typedef struct {
    pthread_t callbackThread;
} PaUtilThreading;

PaError PaUtil_InitializeThreading( PaUtilThreading *threading );
void PaUtil_TerminateThreading( PaUtilThreading *threading );
PaError PaUtil_StartThreading( PaUtilThreading *threading, void *(*threadRoutine)(void *), void *data );
PaError PaUtil_CancelThreading( PaUtilThreading *threading, int wait, PaError *exitResult );

/* State accessed by utility functions */

/*
void PaUnix_SetRealtimeScheduling( int rt );

void PaUtil_InitializeThreading( PaUtilThreading *th, PaUtilCpuLoadMeasurer *clm );

PaError PaUtil_CreateCallbackThread( PaUtilThreading *th, void *(*CallbackThreadFunc)( void * ), PaStream *s );

PaError PaUtil_KillCallbackThread( PaUtilThreading *th, PaError *exitResult );

void PaUtil_CallbackUpdate( PaUtilThreading *th );
*/

extern pthread_t paUnixMainThread;

typedef struct
{
    pthread_mutex_t mtx;
} PaUnixMutex;

PaError PaUnixMutex_Initialize( PaUnixMutex* self );
PaError PaUnixMutex_Terminate( PaUnixMutex* self );
PaError PaUnixMutex_Lock( PaUnixMutex* self );
PaError PaUnixMutex_Unlock( PaUnixMutex* self );

typedef struct
{
    pthread_t thread;
    int parentWaiting;
    int stopRequested;
    int locked;
    PaUnixMutex mtx;
    pthread_cond_t cond;
    volatile sig_atomic_t stopRequest;
} PaUnixThread;

/** Initialize global threading state.
 */
PaError PaUnixThreading_Initialize();

/** Perish, passing on eventual error code.
 *
 * A thin wrapper around pthread_exit, will automatically pass on any error code to the joining thread.
 * If the result indicates an error, i.e. it is not equal to paNoError, this function will automatically
 * allocate a pointer so the error is passed on with pthread_exit. If the result indicates that all is
 * well however, only a NULL pointer will be handed to pthread_exit. Thus, the joining thread should
 * check whether a non-NULL result pointer is obtained from pthread_join and make sure to free it.
 * @param result: The error code to pass on to the joining thread.
 */
#define PaUnixThreading_EXIT(result) \
    do { \
        PaError* pres = NULL; \
        if( paNoError != (result) ) \
        { \
            pres = malloc( sizeof (PaError) ); \
            *pres = (result); \
        } \
        pthread_exit( pres ); \
    } while (0);

/** Spawn a thread.
 *
 * Intended for spawning the callback thread from the main thread. This function can even block (for a certain
 * time or indefinitely) untill notified by the callback thread (using PaUnixThread_NotifyParent), which can be
 * useful in order to make sure that callback has commenced before returning from Pa_StartStream.
 * @param threadFunc: The function to be executed in the child thread.
 * @param waitForChild: If not 0, wait for child thread to call PaUnixThread_NotifyParent. Less than 0 means
 * wait for ever, greater than 0 wait for the specified time.
 * @param rtSched: Enable realtime scheduling?
 * @return: If timed out waiting on child, paTimedOut.
 */
PaError PaUnixThread_New( PaUnixThread* self, void* (*threadFunc)( void* ), void* threadArg, PaTime waitForChild,
        int rtSched );

/** Terminate thread.
 *
 * @param wait: If true, request that background thread stop and wait untill it does, else cancel it.
 * @param exitResult: If non-null this will upon return contain the exit status of the thread.
 */
PaError PaUnixThread_Terminate( PaUnixThread* self, int wait, PaError* exitResult );

/** Prepare to notify waiting parent thread.
 *
 * An internal lock must be held before the parent is notified in PaUnixThread_NotifyParent, call this to
 * acquire it beforehand.
 * @return: If parent is not waiting, paInternalError.
 */
PaError PaUnixThread_PrepareNotify( PaUnixThread* self );

/** Notify waiting parent thread.
 *
 * @return: If parent timed out waiting, paTimedOut. If parent was never waiting, paInternalError.
 */
PaError PaUnixThread_NotifyParent( PaUnixThread* self );

/** Has the parent thread requested this thread to stop?
 */
int PaUnixThread_StopRequested( PaUnixThread* self );

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif
/*
 * $Id$
 * Portable Audio I/O Library UNIX initialization table
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup unix_src
*/

// (amalg) #include "pa_hostapi.h"

PaError PaJack_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaAlsa_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaOSS_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
/* Added for IRIX, Pieter, oct 2, 2003: */
PaError PaSGI_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
/* Linux AudioScience HPI */
PaError PaAsiHpi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
PaError PaSkeleton_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

/** Note that on Linux, ALSA is placed before OSS so that the former is preferred over the latter.
 */

PaUtilHostApiInitializer *paHostApiInitializers[] =
    {
#ifdef __linux__

#if PA_USE_ALSA
        PaAlsa_Initialize,
#endif

#if PA_USE_OSS
        PaOSS_Initialize,
#endif

#else   /* __linux__ */

#if PA_USE_OSS
        PaOSS_Initialize,
#endif

#if PA_USE_ALSA
        PaAlsa_Initialize,
#endif

#endif  /* __linux__ */

#if PA_USE_JACK
        PaJack_Initialize,
#endif
                    /* Added for IRIX, Pieter, oct 2, 2003: */
#if PA_USE_SGI 
        PaSGI_Initialize,
#endif

#if PA_USE_ASIHPI
        PaAsiHpi_Initialize,
#endif

#if PA_USE_COREAUDIO
        PaMacCore_Initialize,
#endif

#if PA_USE_SKELETON
        PaSkeleton_Initialize,
#endif

        0   /* NULL terminated array */
    };
/*
 * $Id$
 * Portable Audio I/O Library
 * UNIX platform-specific support functions
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2000 Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup unix_src
*/
 
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <assert.h>
#include <string.h> /* For memset */
#include <math.h>
#include <errno.h>

#if defined(__APPLE__) && !defined(HAVE_MACH_ABSOLUTE_TIME)
#define HAVE_MACH_ABSOLUTE_TIME
#endif
#ifdef HAVE_MACH_ABSOLUTE_TIME
#include <mach/mach_time.h>
#endif

// (amalg) #include "pa_util.h"
// (amalg) #include "pa_unix_util.h"
// (amalg) #include "pa_debugprint.h"

/*
   Track memory allocations to avoid leaks.
 */

#if PA_TRACK_MEMORY
static int numAllocations_ = 0;
#endif


void *PaUtil_AllocateMemory( long size )
{
    void *result = malloc( size );

#if PA_TRACK_MEMORY
    if( result != NULL ) numAllocations_ += 1;
#endif
    return result;
}


void PaUtil_FreeMemory( void *block )
{
    if( block != NULL )
    {
        free( block );
#if PA_TRACK_MEMORY
        numAllocations_ -= 1;
#endif

    }
}


int PaUtil_CountCurrentlyAllocatedBlocks( void )
{
#if PA_TRACK_MEMORY
    return numAllocations_;
#else
    return 0;
#endif
}


void Pa_Sleep( long msec )
{
#ifdef HAVE_NANOSLEEP
    struct timespec req = {0}, rem = {0};
    PaTime time = msec / 1.e3;
    req.tv_sec = (time_t)time;
    assert(time - req.tv_sec < 1.0);
    req.tv_nsec = (long)((time - req.tv_sec) * 1.e9);
    nanosleep(&req, &rem);
    /* XXX: Try sleeping the remaining time (contained in rem) if interrupted by a signal? */
#else
    while( msec > 999 )     /* For OpenBSD and IRIX, argument */
        {                   /* to usleep must be < 1000000.   */
        usleep( 999000 );
        msec -= 999;
        }
    usleep( msec * 1000 );
#endif
}

#ifdef HAVE_MACH_ABSOLUTE_TIME
/*
    Discussion on the CoreAudio mailing list suggests that calling
    gettimeofday (or anything else in the BSD layer) is not real-time
    safe, so we use mach_absolute_time on OSX. This implementation is 
    based on these two links:

    Technical Q&A QA1398 - Mach Absolute Time Units
    http://developer.apple.com/mac/library/qa/qa2004/qa1398.html

    Tutorial: Performance and Time.
    http://www.macresearch.org/tutorial_performance_and_time
*/

/* Scaler to convert the result of mach_absolute_time to seconds */
static double machSecondsConversionScaler_ = 0.0; 
#endif

void PaUtil_InitializeClock( void )
{
#ifdef HAVE_MACH_ABSOLUTE_TIME
    mach_timebase_info_data_t info;
    kern_return_t err = mach_timebase_info( &info );
    if( err == 0  )
        machSecondsConversionScaler_ = 1e-9 * (double) info.numer / (double) info.denom;
#endif
}


PaTime PaUtil_GetTime( void )
{
#ifdef HAVE_MACH_ABSOLUTE_TIME
    return mach_absolute_time() * machSecondsConversionScaler_;
#elif defined(HAVE_CLOCK_GETTIME)
    struct timespec tp;
    clock_gettime(CLOCK_REALTIME, &tp);
    return (PaTime)(tp.tv_sec + tp.tv_nsec * 1e-9);
#else
    struct timeval tv;
    gettimeofday( &tv, NULL );
    return (PaTime) tv.tv_usec * 1e-6 + tv.tv_sec;
#endif
}

PaError PaUtil_InitializeThreading( PaUtilThreading *threading )
{
    (void) paUtilErr_;
    return paNoError;
}

void PaUtil_TerminateThreading( PaUtilThreading *threading )
{
}

PaError PaUtil_StartThreading( PaUtilThreading *threading, void *(*threadRoutine)(void *), void *data )
{
    pthread_create( &threading->callbackThread, NULL, threadRoutine, data );
    return paNoError;
}

PaError PaUtil_CancelThreading( PaUtilThreading *threading, int wait, PaError *exitResult )
{
    PaError result = paNoError;
    void *pret;

    if( exitResult )
        *exitResult = paNoError;

    /* If pthread_cancel is not supported (Android platform) whole this function can lead to indefinite waiting if 
       working thread (callbackThread) has'n received any stop signals from outside, please keep 
       this in mind when considering using PaUtil_CancelThreading
    */
#ifdef PTHREAD_CANCELED
    /* Only kill the thread if it isn't in the process of stopping (flushing adaptation buffers) */
    if( !wait )
        pthread_cancel( threading->callbackThread );   /* XXX: Safe to call this if the thread has exited on its own? */
#endif
    pthread_join( threading->callbackThread, &pret );

#ifdef PTHREAD_CANCELED
    if( pret && PTHREAD_CANCELED != pret )
#else
    /* !wait means the thread may have been canceled */
    if( pret && wait )
#endif
    {
        if( exitResult )
            *exitResult = *(PaError *) pret;
        free( pret );
    }

    return result;
}

/* Threading */
/* paUnixMainThread 
 * We have to be a bit careful with defining this global variable,
 * as explained below. */
#ifdef __APPLE__
/* apple/gcc has a "problem" with global vars and dynamic libs.
   Initializing it seems to fix the problem.
   Described a bit in this thread:
   http://gcc.gnu.org/ml/gcc/2005-06/msg00179.html
*/
pthread_t paUnixMainThread = 0;
#else
/*pthreads are opaque. We don't know that asigning it an int value
  always makes sense, so we don't initialize it unless we have to.*/
pthread_t paUnixMainThread = 0;
#endif

PaError PaUnixThreading_Initialize()
{
    paUnixMainThread = pthread_self();
    return paNoError;
}

static PaError BoostPriority( PaUnixThread* self )
{
    PaError result = paNoError;
    struct sched_param spm = { 0 };
    /* Priority should only matter between contending FIFO threads? */
    spm.sched_priority = 1;

    assert( self );

    if( pthread_setschedparam( self->thread, SCHED_FIFO, &spm ) != 0 )
    {
        PA_UNLESS( errno == EPERM, paInternalError );  /* Lack permission to raise priority */
        PA_DEBUG(( "Failed bumping priority\n" ));
        result = 0;
    }
    else
    {
        result = 1; /* Success */
    }
error:
    return result;
}

PaError PaUnixThread_New( PaUnixThread* self, void* (*threadFunc)( void* ), void* threadArg, PaTime waitForChild,
        int rtSched )
{
    PaError result = paNoError;
    pthread_attr_t attr;
    int started = 0;

    memset( self, 0, sizeof (PaUnixThread) );
    PaUnixMutex_Initialize( &self->mtx );
    PA_ASSERT_CALL( pthread_cond_init( &self->cond, NULL ), 0 );

    self->parentWaiting = 0 != waitForChild;

    /* Spawn thread */

/* Temporarily disabled since we should test during configuration for presence of required mman.h header */
#if 0
#if defined _POSIX_MEMLOCK && (_POSIX_MEMLOCK != -1)
    if( rtSched )
    {
        if( mlockall( MCL_CURRENT | MCL_FUTURE ) < 0 )
        {
            int savedErrno = errno;             /* In case errno gets overwritten */
            assert( savedErrno != EINVAL );     /* Most likely a programmer error */
            PA_UNLESS( (savedErrno == EPERM), paInternalError );
            PA_DEBUG(( "%s: Failed locking memory\n", __FUNCTION__ ));
        }
        else
            PA_DEBUG(( "%s: Successfully locked memory\n", __FUNCTION__ ));
    }
#endif
#endif

    PA_UNLESS( !pthread_attr_init( &attr ), paInternalError );
    /* Priority relative to other processes */
    PA_UNLESS( !pthread_attr_setscope( &attr, PTHREAD_SCOPE_SYSTEM ), paInternalError );   

    PA_UNLESS( !pthread_create( &self->thread, &attr, threadFunc, threadArg ), paInternalError );
    started = 1;

    if( rtSched )
    {
#if 0
        if( self->useWatchdog )
        {
            int err;
            struct sched_param wdSpm = { 0 };
            /* Launch watchdog, watchdog sets callback thread priority */
            int prio = PA_MIN( self->rtPrio + 4, sched_get_priority_max( SCHED_FIFO ) );
            wdSpm.sched_priority = prio;

            PA_UNLESS( !pthread_attr_init( &attr ), paInternalError );
            PA_UNLESS( !pthread_attr_setinheritsched( &attr, PTHREAD_EXPLICIT_SCHED ), paInternalError );
            PA_UNLESS( !pthread_attr_setscope( &attr, PTHREAD_SCOPE_SYSTEM ), paInternalError );
            PA_UNLESS( !pthread_attr_setschedpolicy( &attr, SCHED_FIFO ), paInternalError );
            PA_UNLESS( !pthread_attr_setschedparam( &attr, &wdSpm ), paInternalError );
            if( (err = pthread_create( &self->watchdogThread, &attr, &WatchdogFunc, self )) )
            {
                PA_UNLESS( err == EPERM, paInternalError );
                /* Permission error, go on without realtime privileges */
                PA_DEBUG(( "Failed bumping priority\n" ));
            }
            else
            {
                int policy;
                self->watchdogRunning = 1;
                PA_ENSURE_SYSTEM( pthread_getschedparam( self->watchdogThread, &policy, &wdSpm ), 0 );
                /* Check if priority is right, policy could potentially differ from SCHED_FIFO (but that's alright) */
                if( wdSpm.sched_priority != prio )
                {
                    PA_DEBUG(( "Watchdog priority not set correctly (%d)\n", wdSpm.sched_priority ));
                    PA_ENSURE( paInternalError );
                }
            }
        }
        else
#endif
            PA_ENSURE( BoostPriority( self ) );

        {
            int policy;
            struct sched_param spm;
            pthread_getschedparam(self->thread, &policy, &spm);
        }
    }
    
    if( self->parentWaiting )
    {
        PaTime till;
        struct timespec ts;
        int res = 0;
        PaTime now;

        PA_ENSURE( PaUnixMutex_Lock( &self->mtx ) );

        /* Wait for stream to be started */
        now = PaUtil_GetTime();
        till = now + waitForChild;

        while( self->parentWaiting && !res )
        {
            if( waitForChild > 0 )
            {
                ts.tv_sec = (time_t) floor( till );
                ts.tv_nsec = (long) ((till - floor( till )) * 1e9);
                res = pthread_cond_timedwait( &self->cond, &self->mtx.mtx, &ts );
            }
            else
            {
                res = pthread_cond_wait( &self->cond, &self->mtx.mtx );
            }
        }

        PA_ENSURE( PaUnixMutex_Unlock( &self->mtx ) );

        PA_UNLESS( !res || ETIMEDOUT == res, paInternalError );
        PA_DEBUG(( "%s: Waited for %g seconds for stream to start\n", __FUNCTION__, PaUtil_GetTime() - now ));
        if( ETIMEDOUT == res )
        {
            PA_ENSURE( paTimedOut );
        }
    }

end:
    return result;
error:
    if( started )
    {
        PaUnixThread_Terminate( self, 0, NULL );
    }

    goto end;
}

PaError PaUnixThread_Terminate( PaUnixThread* self, int wait, PaError* exitResult )
{
    PaError result = paNoError;
    void* pret;

    if( exitResult )
    {
        *exitResult = paNoError;
    }
#if 0
    if( watchdogExitResult )
        *watchdogExitResult = paNoError;

    if( th->watchdogRunning )
    {
        pthread_cancel( th->watchdogThread );
        PA_ENSURE_SYSTEM( pthread_join( th->watchdogThread, &pret ), 0 );

        if( pret && pret != PTHREAD_CANCELED )
        {
            if( watchdogExitResult )
                *watchdogExitResult = *(PaError *) pret;
            free( pret );
        }
    }
#endif

    /* Only kill the thread if it isn't in the process of stopping (flushing adaptation buffers) */
    /* TODO: Make join time out */
    self->stopRequested = wait;
    if( !wait )
    {
        PA_DEBUG(( "%s: Canceling thread %d\n", __FUNCTION__, self->thread ));
        /* XXX: Safe to call this if the thread has exited on its own? */
#ifdef PTHREAD_CANCELED
        pthread_cancel( self->thread );
#endif
    }
    PA_DEBUG(( "%s: Joining thread %d\n", __FUNCTION__, self->thread ));
    PA_ENSURE_SYSTEM( pthread_join( self->thread, &pret ), 0 );

#ifdef PTHREAD_CANCELED
    if( pret && PTHREAD_CANCELED != pret )
#else
    /* !wait means the thread may have been canceled */
    if( pret && wait )
#endif
    {
        if( exitResult )
        {
            *exitResult = *(PaError*)pret;
        }
        free( pret );
    }

error:
    PA_ASSERT_CALL( PaUnixMutex_Terminate( &self->mtx ), paNoError );
    PA_ASSERT_CALL( pthread_cond_destroy( &self->cond ), 0 );

    return result;
}

PaError PaUnixThread_PrepareNotify( PaUnixThread* self )
{
    PaError result = paNoError;
    PA_UNLESS( self->parentWaiting, paInternalError );

    PA_ENSURE( PaUnixMutex_Lock( &self->mtx ) );
    self->locked = 1;

error:
    return result;
}

PaError PaUnixThread_NotifyParent( PaUnixThread* self )
{
    PaError result = paNoError;
    PA_UNLESS( self->parentWaiting, paInternalError );

    if( !self->locked )
    {
        PA_ENSURE( PaUnixMutex_Lock( &self->mtx ) );
        self->locked = 1;
    }
    self->parentWaiting = 0;
    pthread_cond_signal( &self->cond );
    PA_ENSURE( PaUnixMutex_Unlock( &self->mtx ) );
    self->locked = 0;

error:
    return result;
}

int PaUnixThread_StopRequested( PaUnixThread* self )
{
    return self->stopRequested;
}

PaError PaUnixMutex_Initialize( PaUnixMutex* self )
{
    PaError result = paNoError;
    PA_ASSERT_CALL( pthread_mutex_init( &self->mtx, NULL ), 0 );
    return result;
}

PaError PaUnixMutex_Terminate( PaUnixMutex* self )
{
    PaError result = paNoError;
    PA_ASSERT_CALL( pthread_mutex_destroy( &self->mtx ), 0 );
    return result;
}

/** Lock mutex.
 *
 * We're disabling thread cancellation while the thread is holding a lock, so mutexes are 
 * properly unlocked at termination time.
 */
PaError PaUnixMutex_Lock( PaUnixMutex* self )
{
    PaError result = paNoError;
    
#ifdef PTHREAD_CANCEL
	int oldState;
    PA_ENSURE_SYSTEM( pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, &oldState ), 0 );
#endif
    PA_ENSURE_SYSTEM( pthread_mutex_lock( &self->mtx ), 0 );

error:
    return result;
}

/** Unlock mutex.
 *
 * Thread cancellation is enabled again after the mutex is properly unlocked.
 */
PaError PaUnixMutex_Unlock( PaUnixMutex* self )
{
    PaError result = paNoError;

    PA_ENSURE_SYSTEM( pthread_mutex_unlock( &self->mtx ), 0 );
#ifdef PTHREAD_CANCEL
	int oldState;
    PA_ENSURE_SYSTEM( pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, &oldState ), 0 );
#endif

error:
    return result;
}


#if 0
static void OnWatchdogExit( void *userData )
{
    PaAlsaThreading *th = (PaAlsaThreading *) userData;
    struct sched_param spm = { 0 };
    assert( th );

    PA_ASSERT_CALL( pthread_setschedparam( th->callbackThread, SCHED_OTHER, &spm ), 0 );    /* Lower before exiting */
    PA_DEBUG(( "Watchdog exiting\n" ));
}

static void *WatchdogFunc( void *userData )
{
    PaError result = paNoError, *pres = NULL;
    int err;
    PaAlsaThreading *th = (PaAlsaThreading *) userData;
    unsigned intervalMsec = 500;
    const PaTime maxSeconds = 3.;   /* Max seconds between callbacks */
    PaTime timeThen = PaUtil_GetTime(), timeNow, timeElapsed, cpuTimeThen, cpuTimeNow, cpuTimeElapsed;
    double cpuLoad, avgCpuLoad = 0.;
    int throttled = 0;

    assert( th );

    /* Execute OnWatchdogExit when exiting */
    pthread_cleanup_push( &OnWatchdogExit, th );

    /* Boost priority of callback thread */
    PA_ENSURE( result = BoostPriority( th ) );
    if( !result )
    {
        /* Boost failed, might as well exit */
        pthread_exit( NULL );
    }

    cpuTimeThen = th->callbackCpuTime;
    {
        int policy;
        struct sched_param spm = { 0 };
        pthread_getschedparam( pthread_self(), &policy, &spm );
        PA_DEBUG(( "%s: Watchdog priority is %d\n", __FUNCTION__, spm.sched_priority ));
    }

    while( 1 )
    {
        double lowpassCoeff = 0.9, lowpassCoeff1 = 0.99999 - lowpassCoeff;
        
        /* Test before and after in case whatever underlying sleep call isn't interrupted by pthread_cancel */
        pthread_testcancel();
        Pa_Sleep( intervalMsec );
        pthread_testcancel();

        if( PaUtil_GetTime() - th->callbackTime > maxSeconds )
        {
            PA_DEBUG(( "Watchdog: Terminating callback thread\n" ));
            /* Tell thread to terminate */
            err = pthread_kill( th->callbackThread, SIGKILL );
            pthread_exit( NULL );
        }

        PA_DEBUG(( "%s: PortAudio reports CPU load: %g\n", __FUNCTION__, PaUtil_GetCpuLoad( th->cpuLoadMeasurer ) ));

        /* Check if we should throttle, or unthrottle :P */
        cpuTimeNow = th->callbackCpuTime;
        cpuTimeElapsed = cpuTimeNow - cpuTimeThen;
        cpuTimeThen = cpuTimeNow;

        timeNow = PaUtil_GetTime();
        timeElapsed = timeNow - timeThen;
        timeThen = timeNow;
        cpuLoad = cpuTimeElapsed / timeElapsed;
        avgCpuLoad = avgCpuLoad * lowpassCoeff + cpuLoad * lowpassCoeff1;
        /*
        if( throttled )
            PA_DEBUG(( "Watchdog: CPU load: %g, %g\n", avgCpuLoad, cpuTimeElapsed ));
            */
        if( PaUtil_GetCpuLoad( th->cpuLoadMeasurer ) > .925 )
        {
            static int policy;
            static struct sched_param spm = { 0 };
            static const struct sched_param defaultSpm = { 0 };
            PA_DEBUG(( "%s: Throttling audio thread, priority %d\n", __FUNCTION__, spm.sched_priority ));

            pthread_getschedparam( th->callbackThread, &policy, &spm );
            if( !pthread_setschedparam( th->callbackThread, SCHED_OTHER, &defaultSpm ) )
            {
                throttled = 1;
            }
            else
                PA_DEBUG(( "Watchdog: Couldn't lower priority of audio thread: %s\n", strerror( errno ) ));

            /* Give other processes a go, before raising priority again */
            PA_DEBUG(( "%s: Watchdog sleeping for %lu msecs before unthrottling\n", __FUNCTION__, th->throttledSleepTime ));
            Pa_Sleep( th->throttledSleepTime );

            /* Reset callback priority */
            if( pthread_setschedparam( th->callbackThread, SCHED_FIFO, &spm ) != 0 )
            {
                PA_DEBUG(( "%s: Couldn't raise priority of audio thread: %s\n", __FUNCTION__, strerror( errno ) ));
            }

            if( PaUtil_GetCpuLoad( th->cpuLoadMeasurer ) >= .99 )
                intervalMsec = 50;
            else
                intervalMsec = 100;

            /*
            lowpassCoeff = .97;
            lowpassCoeff1 = .99999 - lowpassCoeff;
            */
        }
        else if( throttled && avgCpuLoad < .8 )
        {
            intervalMsec = 500;
            throttled = 0;

            /*
            lowpassCoeff = .9;
            lowpassCoeff1 = .99999 - lowpassCoeff;
            */
        }
    }

    pthread_cleanup_pop( 1 );   /* Execute cleanup on exit */

error:
    /* Shouldn't get here in the normal case */

    /* Pass on error code */
    pres = malloc( sizeof (PaError) );
    *pres = result;
    
    pthread_exit( pres );
}

static void CallbackUpdate( PaAlsaThreading *th )
{
    th->callbackTime = PaUtil_GetTime();
    th->callbackCpuTime = PaUtil_GetCpuLoad( th->cpuLoadMeasurer );
}

/*
static void *CanaryFunc( void *userData )
{
    const unsigned intervalMsec = 1000;
    PaUtilThreading *th = (PaUtilThreading *) userData;

    while( 1 )
    {
        th->canaryTime = PaUtil_GetTime();

        pthread_testcancel();
        Pa_Sleep( intervalMsec );
    }

    pthread_exit( NULL );
}
*/
#endif
#endif

#if PA_USE_ALSA
/*
 * $Id$
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 * ALSA implementation by Joshua Haberman and Arve Knudsen
 *
 * Copyright (c) 2002 Joshua Haberman <joshua@haberman.com>
 * Copyright (c) 2005-2009 Arve Knudsen <arve.knudsen@gmail.com>
 * Copyright (c) 2008 Kevin Kofler <kevin.kofler@chello.at>
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#define ALSA_PCM_NEW_HW_PARAMS_API
#define ALSA_PCM_NEW_SW_PARAMS_API
#include <alsa/asoundlib.h>
#undef ALSA_PCM_NEW_HW_PARAMS_API
#undef ALSA_PCM_NEW_SW_PARAMS_API

#include <sys/poll.h>
#include <string.h> /* strlen() */
#include <limits.h>
#include <math.h>
#include <pthread.h>
#include <signal.h>
#include <time.h>
#include <sys/mman.h>
#include <signal.h> /* For sig_atomic_t */
#ifdef PA_ALSA_DYNAMIC
    #include <dlfcn.h> /* For dlXXX functions */
#endif

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_unix_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_endianness.h"
// (amalg) #include "pa_debugprint.h"

// (amalg) #include "pa_linux_alsa.h"

/* Add missing define (for compatibility with older ALSA versions) */
#ifndef SND_PCM_TSTAMP_ENABLE
    #define SND_PCM_TSTAMP_ENABLE SND_PCM_TSTAMP_MMAP
#endif

/* Combine version elements into a single (unsigned) integer */
#define ALSA_VERSION_INT(major, minor, subminor)  ((major << 16) | (minor << 8) | subminor)

/* The acceptable tolerance of sample rate set, to that requested (as a ratio, eg 50 is 2%, 100 is 1%) */
#define RATE_MAX_DEVIATE_RATIO 100

/* Defines Alsa function types and pointers to these functions. */
#define _PA_DEFINE_FUNC(x)  typedef typeof(x) x##_ft; static x##_ft *alsa_##x = 0

/* Alloca helper. */
#define __alsa_snd_alloca(ptr,type) do { size_t __alsa_alloca_size = alsa_##type##_sizeof(); (*ptr) = (type##_t *) alloca(__alsa_alloca_size); memset(*ptr, 0, __alsa_alloca_size); } while (0)

_PA_DEFINE_FUNC(snd_pcm_open);
_PA_DEFINE_FUNC(snd_pcm_close);
_PA_DEFINE_FUNC(snd_pcm_nonblock);
_PA_DEFINE_FUNC(snd_pcm_frames_to_bytes);
_PA_DEFINE_FUNC(snd_pcm_prepare);
_PA_DEFINE_FUNC(snd_pcm_start);
_PA_DEFINE_FUNC(snd_pcm_resume);
_PA_DEFINE_FUNC(snd_pcm_wait);
_PA_DEFINE_FUNC(snd_pcm_state);
_PA_DEFINE_FUNC(snd_pcm_avail_update);
_PA_DEFINE_FUNC(snd_pcm_areas_silence);
_PA_DEFINE_FUNC(snd_pcm_mmap_begin);
_PA_DEFINE_FUNC(snd_pcm_mmap_commit);
_PA_DEFINE_FUNC(snd_pcm_readi);
_PA_DEFINE_FUNC(snd_pcm_readn);
_PA_DEFINE_FUNC(snd_pcm_writei);
_PA_DEFINE_FUNC(snd_pcm_writen);
_PA_DEFINE_FUNC(snd_pcm_drain);
_PA_DEFINE_FUNC(snd_pcm_recover);
_PA_DEFINE_FUNC(snd_pcm_drop);
_PA_DEFINE_FUNC(snd_pcm_area_copy);
_PA_DEFINE_FUNC(snd_pcm_poll_descriptors);
_PA_DEFINE_FUNC(snd_pcm_poll_descriptors_count);
_PA_DEFINE_FUNC(snd_pcm_poll_descriptors_revents);
_PA_DEFINE_FUNC(snd_pcm_format_size);
_PA_DEFINE_FUNC(snd_pcm_link);
_PA_DEFINE_FUNC(snd_pcm_delay);

_PA_DEFINE_FUNC(snd_pcm_hw_params_sizeof);
_PA_DEFINE_FUNC(snd_pcm_hw_params_malloc);
_PA_DEFINE_FUNC(snd_pcm_hw_params_free);
_PA_DEFINE_FUNC(snd_pcm_hw_params_any);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_access);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_format);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_channels);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_set_periods_near);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_rate_near); //!!!
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_rate);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_rate_resample);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_set_buffer_time_near);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_buffer_size);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_buffer_size_near); //!!!
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_buffer_size_min);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_set_period_time_near);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_period_size_near);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_periods_integer);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_periods_min);

_PA_DEFINE_FUNC(snd_pcm_hw_params_get_buffer_size);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_get_period_size);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_get_access);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_get_periods);
//_PA_DEFINE_FUNC(snd_pcm_hw_params_get_rate);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_channels_min);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_channels_max);

_PA_DEFINE_FUNC(snd_pcm_hw_params_test_period_size);
_PA_DEFINE_FUNC(snd_pcm_hw_params_test_format);
_PA_DEFINE_FUNC(snd_pcm_hw_params_test_access);
_PA_DEFINE_FUNC(snd_pcm_hw_params_dump);
_PA_DEFINE_FUNC(snd_pcm_hw_params);

_PA_DEFINE_FUNC(snd_pcm_hw_params_get_periods_min);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_periods_max);
_PA_DEFINE_FUNC(snd_pcm_hw_params_set_period_size);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_period_size_min);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_period_size_max);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_buffer_size_max);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_rate_min);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_rate_max);
_PA_DEFINE_FUNC(snd_pcm_hw_params_get_rate_numden);
#define alsa_snd_pcm_hw_params_alloca(ptr) __alsa_snd_alloca(ptr, snd_pcm_hw_params)

_PA_DEFINE_FUNC(snd_pcm_sw_params_sizeof);
_PA_DEFINE_FUNC(snd_pcm_sw_params_malloc);
_PA_DEFINE_FUNC(snd_pcm_sw_params_current);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_avail_min);
_PA_DEFINE_FUNC(snd_pcm_sw_params);
_PA_DEFINE_FUNC(snd_pcm_sw_params_free);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_start_threshold);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_stop_threshold);
_PA_DEFINE_FUNC(snd_pcm_sw_params_get_boundary);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_silence_threshold);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_silence_size);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_xfer_align);
_PA_DEFINE_FUNC(snd_pcm_sw_params_set_tstamp_mode);
#define alsa_snd_pcm_sw_params_alloca(ptr) __alsa_snd_alloca(ptr, snd_pcm_sw_params)

_PA_DEFINE_FUNC(snd_pcm_info);
_PA_DEFINE_FUNC(snd_pcm_info_sizeof);
_PA_DEFINE_FUNC(snd_pcm_info_malloc);
_PA_DEFINE_FUNC(snd_pcm_info_free);
_PA_DEFINE_FUNC(snd_pcm_info_set_device);
_PA_DEFINE_FUNC(snd_pcm_info_set_subdevice);
_PA_DEFINE_FUNC(snd_pcm_info_set_stream);
_PA_DEFINE_FUNC(snd_pcm_info_get_name);
_PA_DEFINE_FUNC(snd_pcm_info_get_card);
#define alsa_snd_pcm_info_alloca(ptr) __alsa_snd_alloca(ptr, snd_pcm_info)

_PA_DEFINE_FUNC(snd_ctl_pcm_next_device);
_PA_DEFINE_FUNC(snd_ctl_pcm_info);
_PA_DEFINE_FUNC(snd_ctl_open);
_PA_DEFINE_FUNC(snd_ctl_close);
_PA_DEFINE_FUNC(snd_ctl_card_info_malloc);
_PA_DEFINE_FUNC(snd_ctl_card_info_free);
_PA_DEFINE_FUNC(snd_ctl_card_info);
_PA_DEFINE_FUNC(snd_ctl_card_info_sizeof);
_PA_DEFINE_FUNC(snd_ctl_card_info_get_name);
#define alsa_snd_ctl_card_info_alloca(ptr) __alsa_snd_alloca(ptr, snd_ctl_card_info)

_PA_DEFINE_FUNC(snd_config);
_PA_DEFINE_FUNC(snd_config_update);
_PA_DEFINE_FUNC(snd_config_search);
_PA_DEFINE_FUNC(snd_config_iterator_entry);
_PA_DEFINE_FUNC(snd_config_iterator_first);
_PA_DEFINE_FUNC(snd_config_iterator_end);
_PA_DEFINE_FUNC(snd_config_iterator_next);
_PA_DEFINE_FUNC(snd_config_get_string);
_PA_DEFINE_FUNC(snd_config_get_id);
_PA_DEFINE_FUNC(snd_config_update_free_global);

_PA_DEFINE_FUNC(snd_pcm_status);
_PA_DEFINE_FUNC(snd_pcm_status_sizeof);
_PA_DEFINE_FUNC(snd_pcm_status_get_tstamp);
_PA_DEFINE_FUNC(snd_pcm_status_get_state);
_PA_DEFINE_FUNC(snd_pcm_status_get_trigger_tstamp);
_PA_DEFINE_FUNC(snd_pcm_status_get_delay);
#define alsa_snd_pcm_status_alloca(ptr) __alsa_snd_alloca(ptr, snd_pcm_status)

_PA_DEFINE_FUNC(snd_card_next);
_PA_DEFINE_FUNC(snd_asoundlib_version);
_PA_DEFINE_FUNC(snd_strerror);
_PA_DEFINE_FUNC(snd_output_stdio_attach);

#define alsa_snd_config_for_each(pos, next, node)\
    for (pos = alsa_snd_config_iterator_first(node),\
         next = alsa_snd_config_iterator_next(pos);\
         pos != alsa_snd_config_iterator_end(node); pos = next, next = alsa_snd_config_iterator_next(pos))

#undef _PA_DEFINE_FUNC

/* Redefine 'PA_ALSA_PATHNAME' to a different Alsa library name if desired. */
#ifndef PA_ALSA_PATHNAME
    #define PA_ALSA_PATHNAME "libasound.so"
#endif
static const char *g_AlsaLibName = PA_ALSA_PATHNAME;

/* Handle to dynamically loaded library. */
static void *g_AlsaLib = NULL;

#ifdef PA_ALSA_DYNAMIC

#define _PA_LOCAL_IMPL(x) __pa_local_##x

int _PA_LOCAL_IMPL(snd_pcm_hw_params_set_rate_near) (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int *val, int *dir)
{
    int ret;

    if(( ret = alsa_snd_pcm_hw_params_set_rate(pcm, params, (*val), (*dir)) ) < 0 )
        return ret;

    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_set_buffer_size_near) (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_uframes_t *val)
{
    int ret;

    if(( ret = alsa_snd_pcm_hw_params_set_buffer_size(pcm, params, (*val)) ) < 0 )
        return ret;

    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_set_period_size_near) (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_uframes_t *val, int *dir)
{
    int ret;

    if(( ret = alsa_snd_pcm_hw_params_set_period_size(pcm, params, (*val), (*dir)) ) < 0 )
        return ret;

    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_channels_min) (const snd_pcm_hw_params_t *params, unsigned int *val)
{
    (*val) = 1;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_channels_max) (const snd_pcm_hw_params_t *params, unsigned int *val)
{
    (*val) = 2;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_periods_min) (const snd_pcm_hw_params_t *params, unsigned int *val, int *dir)
{
    (*val) = 2;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_periods_max) (const snd_pcm_hw_params_t *params, unsigned int *val, int *dir)
{
    (*val) = 8;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_period_size_min) (const snd_pcm_hw_params_t *params, snd_pcm_uframes_t *frames, int *dir)
{
    (*frames) = 64;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_period_size_max) (const snd_pcm_hw_params_t *params, snd_pcm_uframes_t *frames, int *dir)
{
    (*frames) = 512;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_buffer_size_max) (const snd_pcm_hw_params_t *params, snd_pcm_uframes_t *val)
{
    int ret;
    int dir                = 0;
    snd_pcm_uframes_t pmax = 0;
    unsigned int      pcnt = 0;

    if(( ret = _PA_LOCAL_IMPL(snd_pcm_hw_params_get_period_size_max)(params, &pmax, &dir) ) < 0 )
        return ret;
    if(( ret = _PA_LOCAL_IMPL(snd_pcm_hw_params_get_periods_max)(params, &pcnt, &dir) ) < 0 )
        return ret;

    (*val) = pmax * pcnt;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_rate_min) (const snd_pcm_hw_params_t *params, unsigned int *val, int *dir)
{
    (*val) = 44100;
    return 0;
}

int _PA_LOCAL_IMPL(snd_pcm_hw_params_get_rate_max) (const snd_pcm_hw_params_t *params, unsigned int *val, int *dir)
{
    (*val) = 44100;
    return 0;
}

#endif // PA_ALSA_DYNAMIC

/* Trying to load Alsa library dynamically if 'PA_ALSA_DYNAMIC' is defined, othervise
   will link during compilation.
*/
static int PaAlsa_LoadLibrary()
{
#ifdef PA_ALSA_DYNAMIC

    PA_DEBUG(( "%s: loading ALSA library file - %s\n", __FUNCTION__, g_AlsaLibName ));

    dlerror();
    g_AlsaLib = dlopen(g_AlsaLibName, (RTLD_NOW|RTLD_GLOBAL) );
    if (g_AlsaLib == NULL)
    {
        PA_DEBUG(( "%s: failed dlopen() ALSA library file - %s, error: %s\n", __FUNCTION__, g_AlsaLibName, dlerror() ));
        return 0;
    }

    PA_DEBUG(( "%s: loading ALSA API\n", __FUNCTION__ ));

    #define _PA_LOAD_FUNC(x) do {             \
        alsa_##x = dlsym( g_AlsaLib, #x );      \
        if( alsa_##x == NULL ) {               \
            PA_DEBUG(( "%s: symbol [%s] not found in - %s, error: %s\n", __FUNCTION__, #x, g_AlsaLibName, dlerror() )); }\
        } while(0)

#else

    #define _PA_LOAD_FUNC(x) alsa_##x = &x

#endif

    _PA_LOAD_FUNC(snd_pcm_open);
    _PA_LOAD_FUNC(snd_pcm_close);
    _PA_LOAD_FUNC(snd_pcm_nonblock);
    _PA_LOAD_FUNC(snd_pcm_frames_to_bytes);
    _PA_LOAD_FUNC(snd_pcm_prepare);
    _PA_LOAD_FUNC(snd_pcm_start);
    _PA_LOAD_FUNC(snd_pcm_resume);
    _PA_LOAD_FUNC(snd_pcm_wait);
    _PA_LOAD_FUNC(snd_pcm_state);
    _PA_LOAD_FUNC(snd_pcm_avail_update);
    _PA_LOAD_FUNC(snd_pcm_areas_silence);
    _PA_LOAD_FUNC(snd_pcm_mmap_begin);
    _PA_LOAD_FUNC(snd_pcm_mmap_commit);
    _PA_LOAD_FUNC(snd_pcm_readi);
    _PA_LOAD_FUNC(snd_pcm_readn);
    _PA_LOAD_FUNC(snd_pcm_writei);
    _PA_LOAD_FUNC(snd_pcm_writen);
    _PA_LOAD_FUNC(snd_pcm_drain);
    _PA_LOAD_FUNC(snd_pcm_recover);
    _PA_LOAD_FUNC(snd_pcm_drop);
    _PA_LOAD_FUNC(snd_pcm_area_copy);
    _PA_LOAD_FUNC(snd_pcm_poll_descriptors);
    _PA_LOAD_FUNC(snd_pcm_poll_descriptors_count);
    _PA_LOAD_FUNC(snd_pcm_poll_descriptors_revents);
    _PA_LOAD_FUNC(snd_pcm_format_size);
    _PA_LOAD_FUNC(snd_pcm_link);
    _PA_LOAD_FUNC(snd_pcm_delay);

    _PA_LOAD_FUNC(snd_pcm_hw_params_sizeof);
    _PA_LOAD_FUNC(snd_pcm_hw_params_malloc);
    _PA_LOAD_FUNC(snd_pcm_hw_params_free);
    _PA_LOAD_FUNC(snd_pcm_hw_params_any);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_access);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_format);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_channels);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_set_periods_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_rate_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_rate);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_rate_resample);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_set_buffer_time_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_buffer_size);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_buffer_size_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_buffer_size_min);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_set_period_time_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_period_size_near);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_periods_integer);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_periods_min);

    _PA_LOAD_FUNC(snd_pcm_hw_params_get_buffer_size);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_get_period_size);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_get_access);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_get_periods);
//    _PA_LOAD_FUNC(snd_pcm_hw_params_get_rate);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_channels_min);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_channels_max);

    _PA_LOAD_FUNC(snd_pcm_hw_params_test_period_size);
    _PA_LOAD_FUNC(snd_pcm_hw_params_test_format);
    _PA_LOAD_FUNC(snd_pcm_hw_params_test_access);
    _PA_LOAD_FUNC(snd_pcm_hw_params_dump);
    _PA_LOAD_FUNC(snd_pcm_hw_params);

    _PA_LOAD_FUNC(snd_pcm_hw_params_get_periods_min);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_periods_max);
    _PA_LOAD_FUNC(snd_pcm_hw_params_set_period_size);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_period_size_min);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_period_size_max);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_buffer_size_max);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_rate_min);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_rate_max);
    _PA_LOAD_FUNC(snd_pcm_hw_params_get_rate_numden);

    _PA_LOAD_FUNC(snd_pcm_sw_params_sizeof);
    _PA_LOAD_FUNC(snd_pcm_sw_params_malloc);
    _PA_LOAD_FUNC(snd_pcm_sw_params_current);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_avail_min);
    _PA_LOAD_FUNC(snd_pcm_sw_params);
    _PA_LOAD_FUNC(snd_pcm_sw_params_free);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_start_threshold);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_stop_threshold);
    _PA_LOAD_FUNC(snd_pcm_sw_params_get_boundary);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_silence_threshold);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_silence_size);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_xfer_align);
    _PA_LOAD_FUNC(snd_pcm_sw_params_set_tstamp_mode);

    _PA_LOAD_FUNC(snd_pcm_info);
    _PA_LOAD_FUNC(snd_pcm_info_sizeof);
    _PA_LOAD_FUNC(snd_pcm_info_malloc);
    _PA_LOAD_FUNC(snd_pcm_info_free);
    _PA_LOAD_FUNC(snd_pcm_info_set_device);
    _PA_LOAD_FUNC(snd_pcm_info_set_subdevice);
    _PA_LOAD_FUNC(snd_pcm_info_set_stream);
    _PA_LOAD_FUNC(snd_pcm_info_get_name);
    _PA_LOAD_FUNC(snd_pcm_info_get_card);

    _PA_LOAD_FUNC(snd_ctl_pcm_next_device);
    _PA_LOAD_FUNC(snd_ctl_pcm_info);
    _PA_LOAD_FUNC(snd_ctl_open);
    _PA_LOAD_FUNC(snd_ctl_close);
    _PA_LOAD_FUNC(snd_ctl_card_info_malloc);
    _PA_LOAD_FUNC(snd_ctl_card_info_free);
    _PA_LOAD_FUNC(snd_ctl_card_info);
    _PA_LOAD_FUNC(snd_ctl_card_info_sizeof);
    _PA_LOAD_FUNC(snd_ctl_card_info_get_name);

    _PA_LOAD_FUNC(snd_config);
    _PA_LOAD_FUNC(snd_config_update);
    _PA_LOAD_FUNC(snd_config_search);
    _PA_LOAD_FUNC(snd_config_iterator_entry);
    _PA_LOAD_FUNC(snd_config_iterator_first);
    _PA_LOAD_FUNC(snd_config_iterator_end);
    _PA_LOAD_FUNC(snd_config_iterator_next);
    _PA_LOAD_FUNC(snd_config_get_string);
    _PA_LOAD_FUNC(snd_config_get_id);
    _PA_LOAD_FUNC(snd_config_update_free_global);

    _PA_LOAD_FUNC(snd_pcm_status);
    _PA_LOAD_FUNC(snd_pcm_status_sizeof);
    _PA_LOAD_FUNC(snd_pcm_status_get_tstamp);
    _PA_LOAD_FUNC(snd_pcm_status_get_state);
    _PA_LOAD_FUNC(snd_pcm_status_get_trigger_tstamp);
    _PA_LOAD_FUNC(snd_pcm_status_get_delay);

    _PA_LOAD_FUNC(snd_card_next);
    _PA_LOAD_FUNC(snd_asoundlib_version);
    _PA_LOAD_FUNC(snd_strerror);
    _PA_LOAD_FUNC(snd_output_stdio_attach);
#undef _PA_LOAD_FUNC

#ifdef PA_ALSA_DYNAMIC
    PA_DEBUG(( "%s: loaded ALSA API - ok\n", __FUNCTION__ ));

#define _PA_VALIDATE_LOAD_REPLACEMENT(x)\
    do {\
        if( alsa_##x == NULL )\
        {\
            alsa_##x = &_PA_LOCAL_IMPL(x);\
            PA_DEBUG(( "%s: replacing [%s] with local implementation\n", __FUNCTION__, #x ));\
        }\
    } while (0)

    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_set_rate_near);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_set_buffer_size_near);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_set_period_size_near);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_channels_min);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_channels_max);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_periods_min);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_periods_max);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_period_size_min);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_period_size_max);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_buffer_size_max);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_rate_min);
    _PA_VALIDATE_LOAD_REPLACEMENT(snd_pcm_hw_params_get_rate_max);

#undef _PA_LOCAL_IMPL
#undef _PA_VALIDATE_LOAD_REPLACEMENT

#endif // PA_ALSA_DYNAMIC

    return 1;
}

void PaAlsa_SetLibraryPathName( const char *pathName )
{
#ifdef PA_ALSA_DYNAMIC
    g_AlsaLibName = pathName;
#else
    (void)pathName;
#endif
}

/* Close handle to Alsa library. */
static void PaAlsa_CloseLibrary()
{
#ifdef PA_ALSA_DYNAMIC
    dlclose(g_AlsaLib);
    g_AlsaLib = NULL;
#endif
}

/* Check return value of ALSA function, and map it to PaError */
#define ENSURE_(expr, code) \
    do { \
        int __pa_unsure_error_id;\
        if( UNLIKELY( (__pa_unsure_error_id = (expr)) < 0 ) ) \
        { \
            /* PaUtil_SetLastHostErrorInfo should only be used in the main thread */ \
            if( (code) == paUnanticipatedHostError && pthread_equal( pthread_self(), paUnixMainThread) ) \
            { \
                PaUtil_SetLastHostErrorInfo( paALSA, __pa_unsure_error_id, alsa_snd_strerror( __pa_unsure_error_id ) ); \
            } \
            PaUtil_DebugPrint( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" ); \
            if( (code) == paUnanticipatedHostError ) \
                PA_DEBUG(( "Host error description: %s\n", alsa_snd_strerror( __pa_unsure_error_id ) )); \
            result = (code); \
            goto error; \
        } \
    } while (0)

#define ASSERT_CALL_(expr, success) \
    do {\
        int __pa_assert_error_id;\
        __pa_assert_error_id = (expr);\
        assert( success == __pa_assert_error_id );\
    } while (0)

static int numPeriods_ = 4;
static int busyRetries_ = 100;

int PaAlsa_SetNumPeriods( int numPeriods )
{
    numPeriods_ = numPeriods;
    return paNoError;
}

typedef enum
{
    StreamDirection_In,
    StreamDirection_Out
} StreamDirection;

typedef struct
{
    PaSampleFormat hostSampleFormat;
    int numUserChannels, numHostChannels;
    int userInterleaved, hostInterleaved;
    int canMmap;
    void *nonMmapBuffer;
    unsigned int nonMmapBufferSize;
    PaDeviceIndex device;     /* Keep the device index */
    int deviceIsPlug; /* Distinguish plug types from direct 'hw:' devices */
    int useReventFix; /* Alsa older than 1.0.16, plug devices need a fix */

    snd_pcm_t *pcm;
    snd_pcm_uframes_t framesPerPeriod, alsaBufferSize;
    snd_pcm_format_t nativeFormat;
    unsigned int nfds;
    int ready;  /* Marked ready from poll */
    void **userBuffers;
    snd_pcm_uframes_t offset;
    StreamDirection streamDir;

    snd_pcm_channel_area_t *channelAreas;  /* Needed for channel adaption */
} PaAlsaStreamComponent;

/* Implementation specific stream structure */
typedef struct PaAlsaStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;
    PaUnixThread thread;

    unsigned long framesPerUserBuffer, maxFramesPerHostBuffer;

    int primeBuffers;
    int callbackMode;              /* bool: are we running in callback mode? */
    int pcmsSynced;                /* Have we successfully synced pcms */
    int rtSched;

    /* the callback thread uses these to poll the sound device(s), waiting
     * for data to be ready/available */
    struct pollfd* pfds;
    int pollTimeout;

    /* Used in communication between threads */
    volatile sig_atomic_t callback_finished; /* bool: are we in the "callback finished" state? */
    volatile sig_atomic_t callbackAbort;    /* Drop frames? */
    volatile sig_atomic_t isActive;         /* Is stream in active state? (Between StartStream and StopStream || !paContinue) */
    PaUnixMutex stateMtx;                   /* Used to synchronize access to stream state */

    int neverDropInput;

    PaTime underrun;
    PaTime overrun;

    PaAlsaStreamComponent capture, playback;
}
PaAlsaStream;

/* PaAlsaHostApiRepresentation - host api datastructure specific to this implementation */

typedef struct PaAlsaHostApiRepresentation
{
    PaUtilHostApiRepresentation baseHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;

    PaHostApiIndex hostApiIndex;
    PaUint32 alsaLibVersion; /* Retrieved from the library at run-time */
}
PaAlsaHostApiRepresentation;

typedef struct PaAlsaDeviceInfo
{
    PaDeviceInfo baseDeviceInfo;
    char *alsaName;
    int isPlug;
    int minInputChannels;
    int minOutputChannels;
}
PaAlsaDeviceInfo;

/* prototypes for functions declared in this file */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *callback,
                           void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError BuildDeviceList( PaAlsaHostApiRepresentation *hostApi );
static int SetApproximateSampleRate( snd_pcm_t *pcm, snd_pcm_hw_params_t *hwParams, double sampleRate );
static int GetExactSampleRate( snd_pcm_hw_params_t *hwParams, double *sampleRate );
static PaUint32 PaAlsaVersionNum(void);

/* Callback prototypes */
static void *CallbackThreadFunc( void *userData );

/* Blocking prototypes */
static signed long GetStreamReadAvailable( PaStream* s );
static signed long GetStreamWriteAvailable( PaStream* s );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );


static const PaAlsaDeviceInfo *GetDeviceInfo( const PaUtilHostApiRepresentation *hostApi, int device )
{
    return (const PaAlsaDeviceInfo *)hostApi->deviceInfos[device];
}

/** Uncommented because AlsaErrorHandler is unused for anything good yet. If AlsaErrorHandler is
    to be used, do not forget to register this callback in PaAlsa_Initialize, and unregister in Terminate.
*/
/*static void AlsaErrorHandler(const char *file, int line, const char *function, int err, const char *fmt, ...)
{
}*/

PaError PaAlsa_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaAlsaHostApiRepresentation *alsaHostApi = NULL;

    /* Try loading Alsa library. */
    if (!PaAlsa_LoadLibrary())
        return paHostApiNotFound;

    PA_UNLESS( alsaHostApi = (PaAlsaHostApiRepresentation*) PaUtil_AllocateMemory(
                sizeof(PaAlsaHostApiRepresentation) ), paInsufficientMemory );
    PA_UNLESS( alsaHostApi->allocations = PaUtil_CreateAllocationGroup(), paInsufficientMemory );
    alsaHostApi->hostApiIndex = hostApiIndex;
    alsaHostApi->alsaLibVersion = PaAlsaVersionNum();

    *hostApi = (PaUtilHostApiRepresentation*)alsaHostApi;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paALSA;
    (*hostApi)->info.name = "ALSA";

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    /** If AlsaErrorHandler is to be used, do not forget to unregister callback pointer in
        Terminate function.
    */
    /*ENSURE_( snd_lib_error_set_handler(AlsaErrorHandler), paUnanticipatedHostError );*/

    PA_ENSURE( BuildDeviceList( alsaHostApi ) );

    PaUtil_InitializeStreamInterface( &alsaHostApi->callbackStreamInterface,
                                      CloseStream, StartStream,
                                      StopStream, AbortStream,
                                      IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable,
                                      PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &alsaHostApi->blockingStreamInterface,
                                      CloseStream, StartStream,
                                      StopStream, AbortStream,
                                      IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream,
                                      GetStreamReadAvailable,
                                      GetStreamWriteAvailable );

    PA_ENSURE( PaUnixThreading_Initialize() );

    return result;

error:
    if( alsaHostApi )
    {
        if( alsaHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( alsaHostApi->allocations );
            PaUtil_DestroyAllocationGroup( alsaHostApi->allocations );
        }

        PaUtil_FreeMemory( alsaHostApi );
    }

    return result;
}

static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaAlsaHostApiRepresentation *alsaHostApi = (PaAlsaHostApiRepresentation*)hostApi;

    assert( hostApi );

    /** See AlsaErrorHandler and PaAlsa_Initialize for details.
    */
    /*snd_lib_error_set_handler(NULL);*/

    if( alsaHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( alsaHostApi->allocations );
        PaUtil_DestroyAllocationGroup( alsaHostApi->allocations );
    }

    PaUtil_FreeMemory( alsaHostApi );
    alsa_snd_config_update_free_global();

    /* Close Alsa library. */
    PaAlsa_CloseLibrary();
}

/** Determine max channels and default latencies.
 *
 * This function provides functionality to grope an opened (might be opened for capture or playback) pcm device for
 * traits like max channels, suitable default latencies and default sample rate. Upon error, max channels is set to zero,
 * and a suitable result returned. The device is closed before returning.
 */
static PaError GropeDevice( snd_pcm_t* pcm, int isPlug, StreamDirection mode, int openBlocking,
        PaAlsaDeviceInfo* devInfo )
{
    PaError result = paNoError;
    snd_pcm_hw_params_t *hwParams;
    snd_pcm_uframes_t alsaBufferFrames, alsaPeriodFrames;
    unsigned int minChans, maxChans;
    int* minChannels, * maxChannels;
    double * defaultLowLatency, * defaultHighLatency, * defaultSampleRate =
        &devInfo->baseDeviceInfo.defaultSampleRate;
    double defaultSr = *defaultSampleRate;
    int dir;

    assert( pcm );

    PA_DEBUG(( "%s: collecting info ..\n", __FUNCTION__ ));

    if( StreamDirection_In == mode )
    {
        minChannels = &devInfo->minInputChannels;
        maxChannels = &devInfo->baseDeviceInfo.maxInputChannels;
        defaultLowLatency = &devInfo->baseDeviceInfo.defaultLowInputLatency;
        defaultHighLatency = &devInfo->baseDeviceInfo.defaultHighInputLatency;
    }
    else
    {
        minChannels = &devInfo->minOutputChannels;
        maxChannels = &devInfo->baseDeviceInfo.maxOutputChannels;
        defaultLowLatency = &devInfo->baseDeviceInfo.defaultLowOutputLatency;
        defaultHighLatency = &devInfo->baseDeviceInfo.defaultHighOutputLatency;
    }

    ENSURE_( alsa_snd_pcm_nonblock( pcm, 0 ), paUnanticipatedHostError );

    alsa_snd_pcm_hw_params_alloca( &hwParams );
    alsa_snd_pcm_hw_params_any( pcm, hwParams );

    if( defaultSr >= 0 )
    {
        /* Could be that the device opened in one mode supports samplerates that the other mode wont have,
         * so try again .. */
        if( SetApproximateSampleRate( pcm, hwParams, defaultSr ) < 0 )
        {
            defaultSr = -1.;
            alsa_snd_pcm_hw_params_any( pcm, hwParams ); /* Clear any params (rate) that might have been set */
            PA_DEBUG(( "%s: Original default samplerate failed, trying again ..\n", __FUNCTION__ ));
        }
    }

    if( defaultSr < 0. )           /* Default sample rate not set */
    {
        unsigned int sampleRate = 44100;        /* Will contain approximate rate returned by alsa-lib */

        /* Don't allow rate resampling when probing for the default rate (but ignore if this call fails) */
        alsa_snd_pcm_hw_params_set_rate_resample( pcm, hwParams, 0 );
        if( alsa_snd_pcm_hw_params_set_rate_near( pcm, hwParams, &sampleRate, NULL ) < 0 )
        {
            result = paUnanticipatedHostError;
            goto error;
        }
        ENSURE_( GetExactSampleRate( hwParams, &defaultSr ), paUnanticipatedHostError );
    }

    ENSURE_( alsa_snd_pcm_hw_params_get_channels_min( hwParams, &minChans ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_hw_params_get_channels_max( hwParams, &maxChans ), paUnanticipatedHostError );
    assert( maxChans <= INT_MAX );
    assert( maxChans > 0 );    /* Weird linking issue could cause wrong version of ALSA symbols to be called,
                                   resulting in zeroed values */

    /* XXX: Limit to sensible number (ALSA plugins accept a crazy amount of channels)? */
    if( isPlug && maxChans > 128 )
    {
        maxChans = 128;
        PA_DEBUG(( "%s: Limiting number of plugin channels to %u\n", __FUNCTION__, maxChans ));
    }

    /* TWEAKME:
     * Giving values for default min and max latency is not straightforward.
     *  * for low latency, we want to give the lowest value that will work reliably.
     *      This varies based on the sound card, kernel, CPU, etc.  Better to give
     *      sub-optimal latency than to give a number too low and cause dropouts.
     *  * for high latency we want to give a large enough value that dropouts are basically impossible.
     *      This doesn't really require as much tweaking, since providing too large a number will
     *      just cause us to select the nearest setting that will work at stream config time.
     */
    /* Try low latency values, (sometimes the buffer & period that result are larger) */
    alsaBufferFrames = 512;
    alsaPeriodFrames = 128;
    ENSURE_( alsa_snd_pcm_hw_params_set_buffer_size_near( pcm, hwParams, &alsaBufferFrames ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( pcm, hwParams, &alsaPeriodFrames, &dir ), paUnanticipatedHostError );
    *defaultLowLatency = (double) (alsaBufferFrames - alsaPeriodFrames) / defaultSr;

    /* Base the high latency case on values four times larger */
    alsaBufferFrames = 2048;
    alsaPeriodFrames = 512;
    /* Have to reset hwParams, to set new buffer size; need to also set sample rate again */
    ENSURE_( alsa_snd_pcm_hw_params_any( pcm, hwParams ), paUnanticipatedHostError );
    ENSURE_( SetApproximateSampleRate( pcm, hwParams, defaultSr ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_hw_params_set_buffer_size_near( pcm, hwParams, &alsaBufferFrames ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( pcm, hwParams, &alsaPeriodFrames, &dir ), paUnanticipatedHostError );
    *defaultHighLatency = (double) (alsaBufferFrames - alsaPeriodFrames) / defaultSr;

    *minChannels = (int)minChans;
    *maxChannels = (int)maxChans;
    *defaultSampleRate = defaultSr;

end:
    alsa_snd_pcm_close( pcm );
    return result;

error:
    goto end;
}

/* Initialize device info with invalid values (maxInputChannels and maxOutputChannels are set to zero since these indicate
 * whether input/output is available) */
static void InitializeDeviceInfo( PaDeviceInfo *deviceInfo )
{
    deviceInfo->structVersion = -1;
    deviceInfo->name = NULL;
    deviceInfo->hostApi = -1;
    deviceInfo->maxInputChannels = 0;
    deviceInfo->maxOutputChannels = 0;
    deviceInfo->defaultLowInputLatency = -1.;
    deviceInfo->defaultLowOutputLatency = -1.;
    deviceInfo->defaultHighInputLatency = -1.;
    deviceInfo->defaultHighOutputLatency = -1.;
    deviceInfo->defaultSampleRate = -1.;
}


/* Retrieve the version of the runtime Alsa-lib, as a single number equivalent to
 * SND_LIB_VERSION.  Only a version string is available ("a.b.c") so this has to be converted.
 * Assume 'a' and 'b' are single digits only.
 */
static PaUint32 PaAlsaVersionNum(void)
{
    char* verStr;
    PaUint32 verNum;

    verStr = (char*) alsa_snd_asoundlib_version();
    verNum = ALSA_VERSION_INT( atoi(verStr), atoi(verStr + 2), atoi(verStr + 4) );
    PA_DEBUG(( "ALSA version (build): " SND_LIB_VERSION_STR "\nALSA version (runtime): %s\n", verStr ));

    return verNum;
}


/* Helper struct */
typedef struct
{
    char *alsaName;
    char *name;
    int isPlug;
    int hasPlayback;
    int hasCapture;
} HwDevInfo;


HwDevInfo predefinedNames[] = {
    { "center_lfe", NULL, 0, 1, 0 },
/* { "default", NULL, 0, 1, 1 }, */
    { "dmix", NULL, 0, 1, 0 },
/* { "dpl", NULL, 0, 1, 0 }, */
/* { "dsnoop", NULL, 0, 0, 1 }, */
    { "front", NULL, 0, 1, 0 },
    { "iec958", NULL, 0, 1, 0 },
/* { "modem", NULL, 0, 1, 0 }, */
    { "rear", NULL, 0, 1, 0 },
    { "side", NULL, 0, 1, 0 },
/*     { "spdif", NULL, 0, 0, 0 }, */
    { "surround40", NULL, 0, 1, 0 },
    { "surround41", NULL, 0, 1, 0 },
    { "surround50", NULL, 0, 1, 0 },
    { "surround51", NULL, 0, 1, 0 },
    { "surround71", NULL, 0, 1, 0 },

    { "AndroidPlayback_Earpiece_normal",         NULL, 0, 1, 0 },
    { "AndroidPlayback_Speaker_normal",          NULL, 0, 1, 0 },
    { "AndroidPlayback_Bluetooth_normal",        NULL, 0, 1, 0 },
    { "AndroidPlayback_Headset_normal",          NULL, 0, 1, 0 },
    { "AndroidPlayback_Speaker_Headset_normal",  NULL, 0, 1, 0 },
    { "AndroidPlayback_Bluetooth-A2DP_normal",   NULL, 0, 1, 0 },
    { "AndroidPlayback_ExtraDockSpeaker_normal", NULL, 0, 1, 0 },
    { "AndroidPlayback_TvOut_normal",            NULL, 0, 1, 0 },

    { "AndroidRecord_Microphone",                NULL, 0, 0, 1 },
    { "AndroidRecord_Earpiece_normal",           NULL, 0, 0, 1 },
    { "AndroidRecord_Speaker_normal",            NULL, 0, 0, 1 },
    { "AndroidRecord_Headset_normal",            NULL, 0, 0, 1 },
    { "AndroidRecord_Bluetooth_normal",          NULL, 0, 0, 1 },
    { "AndroidRecord_Speaker_Headset_normal",    NULL, 0, 0, 1 },

    { NULL, NULL, 0, 1, 0 }
};

static const HwDevInfo *FindDeviceName( const char *name )
{
    int i;

    for( i = 0; predefinedNames[i].alsaName; i++ )
    {
        if( strcmp( name, predefinedNames[i].alsaName ) == 0 )
        {
            return &predefinedNames[i];
        }
    }

    return NULL;
}

static PaError PaAlsa_StrDup( PaAlsaHostApiRepresentation *alsaApi,
        char **dst,
        const char *src)
{
    PaError result = paNoError;
    int len = strlen( src ) + 1;

    /* PA_DEBUG(("PaStrDup %s %d\n", src, len)); */

    PA_UNLESS( *dst = (char *)PaUtil_GroupAllocateMemory( alsaApi->allocations, len ),
            paInsufficientMemory );
    strncpy( *dst, src, len );

error:
    return result;
}

/* Disregard some standard plugins
 */
static int IgnorePlugin( const char *pluginId )
{
    static const char *ignoredPlugins[] = {"hw", "plughw", "plug", "dsnoop", "tee",
        "file", "null", "shm", "cards", "rate_convert", NULL};
    int i = 0;
    while( ignoredPlugins[i] )
    {
        if( !strcmp( pluginId, ignoredPlugins[i] ) )
        {
            return 1;
        }
        ++i;
    }

    return 0;
}

/* Skip past parts at the beginning of a (pcm) info name that are already in the card name, to avoid duplication */
static char *SkipCardDetailsInName( char *infoSkipName, char *cardRefName )
{
    char *lastSpacePosn = infoSkipName;

    /* Skip matching chars; but only in chunks separated by ' ' (not part words etc), so track lastSpacePosn */
    while( *cardRefName )
    {
        while( *infoSkipName && *cardRefName && *infoSkipName == *cardRefName)
        {
            infoSkipName++;
            cardRefName++;
            if( *infoSkipName == ' ' || *infoSkipName == '\0' )
                lastSpacePosn = infoSkipName;
        }
        infoSkipName = lastSpacePosn;
        /* Look for another chunk; post-increment means ends pointing to next char */
        while( *cardRefName && ( *cardRefName++ != ' ' ));
    }
    if( *infoSkipName == '\0' )
        return "-"; /* The 2 names were identical; instead of a nul-string, return a marker string */

    /* Now want to move to the first char after any spaces */
    while( *lastSpacePosn && *lastSpacePosn == ' ' )
        lastSpacePosn++;
    /* Skip a single separator char if present in the remaining pcm name; (pa will add its own) */
    if(( *lastSpacePosn == '-' || *lastSpacePosn == ':' ) && *(lastSpacePosn + 1) == ' ' )
        lastSpacePosn += 2;

    return lastSpacePosn;
}

/** Open PCM device.
 *
 * Wrapper around alsa_snd_pcm_open which may repeatedly retry opening a device if it is busy, for
 * a certain time. This is because dmix may temporarily hold on to a device after it (dmix)
 * has been opened and closed.
 * @param mode: Open mode (e.g., SND_PCM_BLOCKING).
 * @param waitOnBusy: Retry opening busy device for up to one second?
 **/
static int OpenPcm( snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode, int waitOnBusy )
{
    int ret, tries = 0, maxTries = waitOnBusy ? busyRetries_ : 0;

    ret = alsa_snd_pcm_open( pcmp, name, stream, mode );

    for( tries = 0; tries < maxTries && -EBUSY == ret; ++tries )
    {
        Pa_Sleep( 10 );
        ret = alsa_snd_pcm_open( pcmp, name, stream, mode );
        if( -EBUSY != ret )
        {
            PA_DEBUG(( "%s: Successfully opened initially busy device after %d tries\n", __FUNCTION__, tries ));
        }
    }
    if( -EBUSY == ret )
    {
        PA_DEBUG(( "%s: Failed to open busy device '%s'\n", __FUNCTION__, name ));
    }
    else
    {
        if( ret < 0 )
            PA_DEBUG(( "%s: Opened device '%s' ptr[%p] - result: [%d:%s]\n", __FUNCTION__, name, *pcmp, ret, alsa_snd_strerror(ret) ));
    }

    return ret;
}

static PaError FillInDevInfo( PaAlsaHostApiRepresentation *alsaApi, HwDevInfo* deviceHwInfo, int blocking,
        PaAlsaDeviceInfo* devInfo, int* devIdx )
{
    PaError result = 0;
    PaDeviceInfo *baseDeviceInfo = &devInfo->baseDeviceInfo;
    snd_pcm_t *pcm = NULL;
    PaUtilHostApiRepresentation *baseApi = &alsaApi->baseHostApiRep;

    PA_DEBUG(( "%s: Filling device info for: %s\n", __FUNCTION__, deviceHwInfo->name ));

    /* Zero fields */
    InitializeDeviceInfo( baseDeviceInfo );

    /* To determine device capabilities, we must open the device and query the
     * hardware parameter configuration space */

    /* Query capture */
    if( deviceHwInfo->hasCapture &&
        OpenPcm( &pcm, deviceHwInfo->alsaName, SND_PCM_STREAM_CAPTURE, blocking, 0 ) >= 0 )
    {
        if( GropeDevice( pcm, deviceHwInfo->isPlug, StreamDirection_In, blocking, devInfo ) != paNoError )
        {
            /* Error */
            PA_DEBUG(( "%s: Failed groping %s for capture\n", __FUNCTION__, deviceHwInfo->alsaName ));
            goto end;
        }
    }

    /* Query playback */
    if( deviceHwInfo->hasPlayback &&
        OpenPcm( &pcm, deviceHwInfo->alsaName, SND_PCM_STREAM_PLAYBACK, blocking, 0 ) >= 0 )
    {
        if( GropeDevice( pcm, deviceHwInfo->isPlug, StreamDirection_Out, blocking, devInfo ) != paNoError )
        {
            /* Error */
            PA_DEBUG(( "%s: Failed groping %s for playback\n", __FUNCTION__, deviceHwInfo->alsaName ));
            goto end;
        }
    }

    baseDeviceInfo->structVersion = 2;
    baseDeviceInfo->hostApi = alsaApi->hostApiIndex;
    baseDeviceInfo->name = deviceHwInfo->name;
    devInfo->alsaName = deviceHwInfo->alsaName;
    devInfo->isPlug = deviceHwInfo->isPlug;

    /* A: Storing pointer to PaAlsaDeviceInfo object as pointer to PaDeviceInfo object.
     * Should now be safe to add device info, unless the device supports neither capture nor playback
     */
    if( baseDeviceInfo->maxInputChannels > 0 || baseDeviceInfo->maxOutputChannels > 0 )
    {
        /* Make device default if there isn't already one or it is the ALSA "default" device */
        if( ( baseApi->info.defaultInputDevice == paNoDevice ||
            !strcmp( deviceHwInfo->alsaName, "default" ) ) && baseDeviceInfo->maxInputChannels > 0 )
        {
            baseApi->info.defaultInputDevice = *devIdx;
            PA_DEBUG(( "Default input device: %s\n", deviceHwInfo->name ));
        }
        if( ( baseApi->info.defaultOutputDevice == paNoDevice ||
            !strcmp( deviceHwInfo->alsaName, "default" ) ) && baseDeviceInfo->maxOutputChannels > 0 )
        {
            baseApi->info.defaultOutputDevice = *devIdx;
            PA_DEBUG(( "Default output device: %s\n", deviceHwInfo->name ));
        }
        PA_DEBUG(( "%s: Adding device %s: %d\n", __FUNCTION__, deviceHwInfo->name, *devIdx ));
        baseApi->deviceInfos[*devIdx] = (PaDeviceInfo *) devInfo;
        (*devIdx) += 1;
    }
    else
    {
        PA_DEBUG(( "%s: Skipped device: %s, all channels == 0\n", __FUNCTION__, deviceHwInfo->name ));
    }

end:
    return result;
}

/* Build PaDeviceInfo list, ignore devices for which we cannot determine capabilities (possibly busy, sigh) */
static PaError BuildDeviceList( PaAlsaHostApiRepresentation *alsaApi )
{
    PaUtilHostApiRepresentation *baseApi = &alsaApi->baseHostApiRep;
    PaAlsaDeviceInfo *deviceInfoArray;
    int cardIdx = -1, devIdx = 0;
    snd_ctl_card_info_t *cardInfo;
    PaError result = paNoError;
    size_t numDeviceNames = 0, maxDeviceNames = 1, i;
    HwDevInfo *hwDevInfos = NULL;
    snd_config_t *topNode = NULL;
    snd_pcm_info_t *pcmInfo;
    int res;
    int blocking = SND_PCM_NONBLOCK;
    int usePlughw = 0;
    char *hwPrefix = "";
    char alsaCardName[50];
#ifdef PA_ENABLE_DEBUG_OUTPUT
    PaTime startTime = PaUtil_GetTime();
#endif

    if( getenv( "PA_ALSA_INITIALIZE_BLOCK" ) && atoi( getenv( "PA_ALSA_INITIALIZE_BLOCK" ) ) )
        blocking = 0;

    /* If PA_ALSA_PLUGHW is 1 (non-zero), use the plughw: pcm throughout instead of hw: */
    if( getenv( "PA_ALSA_PLUGHW" ) && atoi( getenv( "PA_ALSA_PLUGHW" ) ) )
    {
        usePlughw = 1;
        hwPrefix = "plug";
        PA_DEBUG(( "%s: Using Plughw\n", __FUNCTION__ ));
    }

    /* These two will be set to the first working input and output device, respectively */
    baseApi->info.defaultInputDevice = paNoDevice;
    baseApi->info.defaultOutputDevice = paNoDevice;

    /* Gather info about hw devices

     * alsa_snd_card_next() modifies the integer passed to it to be:
     *      the index of the first card if the parameter is -1
     *      the index of the next card if the parameter is the index of a card
     *      -1 if there are no more cards
     *
     * The function itself returns 0 if it succeeded. */
    cardIdx = -1;
    alsa_snd_ctl_card_info_alloca( &cardInfo );
    alsa_snd_pcm_info_alloca( &pcmInfo );
    while( alsa_snd_card_next( &cardIdx ) == 0 && cardIdx >= 0 )
    {
        char *cardName;
        int devIdx = -1;
        snd_ctl_t *ctl;
        char buf[50];

        snprintf( alsaCardName, sizeof (alsaCardName), "hw:%d", cardIdx );

        /* Acquire name of card */
        if( alsa_snd_ctl_open( &ctl, alsaCardName, 0 ) < 0 )
        {
            /* Unable to open card :( */
            PA_DEBUG(( "%s: Unable to open device %s\n", __FUNCTION__, alsaCardName ));
            continue;
        }
        alsa_snd_ctl_card_info( ctl, cardInfo );

        PA_ENSURE( PaAlsa_StrDup( alsaApi, &cardName, alsa_snd_ctl_card_info_get_name( cardInfo )) );

        while( alsa_snd_ctl_pcm_next_device( ctl, &devIdx ) == 0 && devIdx >= 0 )
        {
            char *alsaDeviceName, *deviceName, *infoName;
            size_t len;
            int hasPlayback = 0, hasCapture = 0;

            snprintf( buf, sizeof (buf), "%s%s,%d", hwPrefix, alsaCardName, devIdx );

            /* Obtain info about this particular device */
            alsa_snd_pcm_info_set_device( pcmInfo, devIdx );
            alsa_snd_pcm_info_set_subdevice( pcmInfo, 0 );
            alsa_snd_pcm_info_set_stream( pcmInfo, SND_PCM_STREAM_CAPTURE );
            if( alsa_snd_ctl_pcm_info( ctl, pcmInfo ) >= 0 )
            {
                hasCapture = 1;
            }

            alsa_snd_pcm_info_set_stream( pcmInfo, SND_PCM_STREAM_PLAYBACK );
            if( alsa_snd_ctl_pcm_info( ctl, pcmInfo ) >= 0 )
            {
                hasPlayback = 1;
            }

            if( !hasPlayback && !hasCapture )
            {
                /* Error */
                continue;
            }

            infoName = SkipCardDetailsInName( (char *)alsa_snd_pcm_info_get_name( pcmInfo ), cardName );

            /* The length of the string written by snprintf plus terminating 0 */
            len = snprintf( NULL, 0, "%s: %s (%s)", cardName, infoName, buf ) + 1;
            PA_UNLESS( deviceName = (char *)PaUtil_GroupAllocateMemory( alsaApi->allocations, len ),
                    paInsufficientMemory );
            snprintf( deviceName, len, "%s: %s (%s)", cardName, infoName, buf );

            ++numDeviceNames;
            if( !hwDevInfos || numDeviceNames > maxDeviceNames )
            {
                maxDeviceNames *= 2;
                PA_UNLESS( hwDevInfos = (HwDevInfo *) realloc( hwDevInfos, maxDeviceNames * sizeof (HwDevInfo) ),
                        paInsufficientMemory );
            }

            PA_ENSURE( PaAlsa_StrDup( alsaApi, &alsaDeviceName, buf ) );

            hwDevInfos[ numDeviceNames - 1 ].alsaName = alsaDeviceName;
            hwDevInfos[ numDeviceNames - 1 ].name = deviceName;
            hwDevInfos[ numDeviceNames - 1 ].isPlug = usePlughw;
            hwDevInfos[ numDeviceNames - 1 ].hasPlayback = hasPlayback;
            hwDevInfos[ numDeviceNames - 1 ].hasCapture = hasCapture;
        }
        alsa_snd_ctl_close( ctl );
    }

    /* Iterate over plugin devices */
    if( NULL == (*alsa_snd_config) )
    {
        /* alsa_snd_config_update is called implicitly by some functions, if this hasn't happened snd_config will be NULL (bleh) */
        ENSURE_( alsa_snd_config_update(), paUnanticipatedHostError );
        PA_DEBUG(( "Updating snd_config\n" ));
    }
    assert( *alsa_snd_config );
    if( ( res = alsa_snd_config_search( *alsa_snd_config, "pcm", &topNode ) ) >= 0 )
    {
        snd_config_iterator_t i, next;

        alsa_snd_config_for_each( i, next, topNode )
        {
            const char *tpStr = "unknown", *idStr = NULL;
            int err = 0;

            char *alsaDeviceName, *deviceName;
            const HwDevInfo *predefined = NULL;
            snd_config_t *n = alsa_snd_config_iterator_entry( i ), * tp = NULL;;

            if( (err = alsa_snd_config_search( n, "type", &tp )) < 0 )
            {
                if( -ENOENT != err )
                {
                    ENSURE_(err, paUnanticipatedHostError);
                }
            }
            else
            {
                ENSURE_( alsa_snd_config_get_string( tp, &tpStr ), paUnanticipatedHostError );
            }
            ENSURE_( alsa_snd_config_get_id( n, &idStr ), paUnanticipatedHostError );
            if( IgnorePlugin( idStr ) )
            {
                PA_DEBUG(( "%s: Ignoring ALSA plugin device [%s] of type [%s]\n", __FUNCTION__, idStr, tpStr ));
                continue;
            }
            PA_DEBUG(( "%s: Found plugin [%s] of type [%s]\n", __FUNCTION__, idStr, tpStr ));

            PA_UNLESS( alsaDeviceName = (char*)PaUtil_GroupAllocateMemory( alsaApi->allocations,
                                                            strlen(idStr) + 6 ), paInsufficientMemory );
            strcpy( alsaDeviceName, idStr );
            PA_UNLESS( deviceName = (char*)PaUtil_GroupAllocateMemory( alsaApi->allocations,
                                                            strlen(idStr) + 1 ), paInsufficientMemory );
            strcpy( deviceName, idStr );

            ++numDeviceNames;
            if( !hwDevInfos || numDeviceNames > maxDeviceNames )
            {
                maxDeviceNames *= 2;
                PA_UNLESS( hwDevInfos = (HwDevInfo *) realloc( hwDevInfos, maxDeviceNames * sizeof (HwDevInfo) ),
                        paInsufficientMemory );
            }

            predefined = FindDeviceName( alsaDeviceName );

            hwDevInfos[numDeviceNames - 1].alsaName = alsaDeviceName;
            hwDevInfos[numDeviceNames - 1].name     = deviceName;
            hwDevInfos[numDeviceNames - 1].isPlug   = 1;

            if( predefined )
            {
                hwDevInfos[numDeviceNames - 1].hasPlayback = predefined->hasPlayback;
                hwDevInfos[numDeviceNames - 1].hasCapture  = predefined->hasCapture;
            }
            else
            {
                hwDevInfos[numDeviceNames - 1].hasPlayback = 1;
                hwDevInfos[numDeviceNames - 1].hasCapture  = 1;
            }
        }
    }
    else
        PA_DEBUG(( "%s: Iterating over ALSA plugins failed: %s\n", __FUNCTION__, alsa_snd_strerror( res ) ));

    /* allocate deviceInfo memory based on the number of devices */
    PA_UNLESS( baseApi->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
            alsaApi->allocations, sizeof(PaDeviceInfo*) * (numDeviceNames) ), paInsufficientMemory );

    /* allocate all device info structs in a contiguous block */
    PA_UNLESS( deviceInfoArray = (PaAlsaDeviceInfo*)PaUtil_GroupAllocateMemory(
            alsaApi->allocations, sizeof(PaAlsaDeviceInfo) * numDeviceNames ), paInsufficientMemory );

    /* Loop over list of cards, filling in info. If a device is deemed unavailable (can't get name),
     * it's ignored.
     *
     * Note that we do this in two stages. This is a workaround owing to the fact that the 'dmix'
     * plugin may cause the underlying hardware device to be busy for a short while even after it
     * (dmix) is closed. The 'default' plugin may also point to the dmix plugin, so the same goes
     * for this.
     */
    PA_DEBUG(( "%s: Filling device info for %d devices\n", __FUNCTION__, numDeviceNames ));
    for( i = 0, devIdx = 0; i < numDeviceNames; ++i )
    {
        PaAlsaDeviceInfo* devInfo = &deviceInfoArray[i];
        HwDevInfo* hwInfo = &hwDevInfos[i];
        if( !strcmp( hwInfo->name, "dmix" ) || !strcmp( hwInfo->name, "default" ) )
        {
            continue;
        }

        PA_ENSURE( FillInDevInfo( alsaApi, hwInfo, blocking, devInfo, &devIdx ) );
    }
    assert( devIdx < numDeviceNames );
    /* Now inspect 'dmix' and 'default' plugins */
    for( i = 0; i < numDeviceNames; ++i )
    {
        PaAlsaDeviceInfo* devInfo = &deviceInfoArray[i];
        HwDevInfo* hwInfo = &hwDevInfos[i];
        if( strcmp( hwInfo->name, "dmix" ) && strcmp( hwInfo->name, "default" ) )
        {
            continue;
        }

        PA_ENSURE( FillInDevInfo( alsaApi, hwInfo, blocking, devInfo, &devIdx ) );
    }
    free( hwDevInfos );

    baseApi->info.deviceCount = devIdx;   /* Number of successfully queried devices */

#ifdef PA_ENABLE_DEBUG_OUTPUT
    PA_DEBUG(( "%s: Building device list took %f seconds\n", __FUNCTION__, PaUtil_GetTime() - startTime ));
#endif

end:
    return result;

error:
    /* No particular action */
    goto end;
}

/* Check against known device capabilities */
static PaError ValidateParameters( const PaStreamParameters *parameters, PaUtilHostApiRepresentation *hostApi, StreamDirection mode )
{
    PaError result = paNoError;
    int maxChans;
    const PaAlsaDeviceInfo *deviceInfo = NULL;
    assert( parameters );

    if( parameters->device != paUseHostApiSpecificDeviceSpecification )
    {
        assert( parameters->device < hostApi->info.deviceCount );
        PA_UNLESS( parameters->hostApiSpecificStreamInfo == NULL, paBadIODeviceCombination );
        deviceInfo = GetDeviceInfo( hostApi, parameters->device );
    }
    else
    {
        const PaAlsaStreamInfo *streamInfo = parameters->hostApiSpecificStreamInfo;

        PA_UNLESS( parameters->device == paUseHostApiSpecificDeviceSpecification, paInvalidDevice );
        PA_UNLESS( streamInfo->size == sizeof (PaAlsaStreamInfo) && streamInfo->version == 1,
                paIncompatibleHostApiSpecificStreamInfo );
        PA_UNLESS( streamInfo->deviceString != NULL, paInvalidDevice );

        /* Skip further checking */
        return paNoError;
    }

    assert( deviceInfo );
    assert( parameters->hostApiSpecificStreamInfo == NULL );
    maxChans = ( StreamDirection_In == mode ? deviceInfo->baseDeviceInfo.maxInputChannels :
        deviceInfo->baseDeviceInfo.maxOutputChannels );
    PA_UNLESS( parameters->channelCount <= maxChans, paInvalidChannelCount );

error:
    return result;
}

/* Given an open stream, what sample formats are available? */
static PaSampleFormat GetAvailableFormats( snd_pcm_t *pcm )
{
    PaSampleFormat available = 0;
    snd_pcm_hw_params_t *hwParams;
    alsa_snd_pcm_hw_params_alloca( &hwParams );

    alsa_snd_pcm_hw_params_any( pcm, hwParams );

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT ) >= 0)
        available |= paFloat32;

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S32 ) >= 0)
        available |= paInt32;

#ifdef PA_LITTLE_ENDIAN
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_3LE ) >= 0)
        available |= paInt24;
#elif defined PA_BIG_ENDIAN
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_3BE ) >= 0)
        available |= paInt24;
#endif

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S16 ) >= 0)
        available |= paInt16;

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U8 ) >= 0)
        available |= paUInt8;

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S8 ) >= 0)
        available |= paInt8;

    return available;
}

/* Output to console all formats supported by device */
static void LogAllAvailableFormats( snd_pcm_t *pcm )
{
    PaSampleFormat available = 0;
    snd_pcm_hw_params_t *hwParams;
    alsa_snd_pcm_hw_params_alloca( &hwParams );

    alsa_snd_pcm_hw_params_any( pcm, hwParams );

    PA_DEBUG(( " --- Supported Formats ---\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S8 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S8\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U8 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U8\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S16_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S16_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S16_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S16_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U16_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U16_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U16_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U16_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S24_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S24_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U24_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U24_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U24_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U24_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT64_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT64_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT64_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT64_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_IEC958_SUBFRAME_LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_IEC958_SUBFRAME_LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_IEC958_SUBFRAME_BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_IEC958_SUBFRAME_BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_MU_LAW ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_MU_LAW\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_A_LAW ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_A_LAW\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_IMA_ADPCM ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_IMA_ADPCM\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_MPEG ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_MPEG\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_GSM ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_GSM\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_SPECIAL ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_SPECIAL\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S24_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S24_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U24_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U24_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U24_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U24_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S20_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S20_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S20_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S20_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U20_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U20_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U20_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U20_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S18_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S18_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S18_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S18_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U18_3LE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U18_3LE\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U18_3BE ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U18_3BE\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S16 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S16\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U16 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U16\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S24 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S24\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U24 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U24\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_S32 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_S32\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_U32 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_U32\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT\n" ));
    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_FLOAT64 ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_FLOAT64\n" ));

    if( alsa_snd_pcm_hw_params_test_format( pcm, hwParams, SND_PCM_FORMAT_IEC958_SUBFRAME ) >= 0)
        PA_DEBUG(( "SND_PCM_FORMAT_IEC958_SUBFRAME\n" ));

    PA_DEBUG(( " -------------------------\n" ));
}

static snd_pcm_format_t Pa2AlsaFormat( PaSampleFormat paFormat )
{
    switch( paFormat )
    {
        case paFloat32:
            return SND_PCM_FORMAT_FLOAT;

        case paInt16:
            return SND_PCM_FORMAT_S16;

        case paInt24:
#ifdef PA_LITTLE_ENDIAN
            return SND_PCM_FORMAT_S24_3LE;
#elif defined PA_BIG_ENDIAN
            return SND_PCM_FORMAT_S24_3BE;
#endif

        case paInt32:
            return SND_PCM_FORMAT_S32;

        case paInt8:
            return SND_PCM_FORMAT_S8;

        case paUInt8:
            return SND_PCM_FORMAT_U8;

        default:
            return SND_PCM_FORMAT_UNKNOWN;
    }
}

/** Open an ALSA pcm handle.
 *
 * The device to be open can be specified by name in a custom PaAlsaStreamInfo struct, or it will be by
 * the Portaudio device number supplied in the stream parameters.
 */
static PaError AlsaOpen( const PaUtilHostApiRepresentation *hostApi, const PaStreamParameters *params, StreamDirection
        streamDir, snd_pcm_t **pcm )
{
    PaError result = paNoError;
    int ret;
    const char* deviceName = "";
    const PaAlsaDeviceInfo *deviceInfo = NULL;
    PaAlsaStreamInfo *streamInfo = (PaAlsaStreamInfo *)params->hostApiSpecificStreamInfo;

    if( !streamInfo )
    {
        deviceInfo = GetDeviceInfo( hostApi, params->device );
        deviceName = deviceInfo->alsaName;
    }
    else
        deviceName = streamInfo->deviceString;

    PA_DEBUG(( "%s: Opening device %s\n", __FUNCTION__, deviceName ));
    if( (ret = OpenPcm( pcm, deviceName, streamDir == StreamDirection_In ? SND_PCM_STREAM_CAPTURE : SND_PCM_STREAM_PLAYBACK,
                    SND_PCM_NONBLOCK, 1 )) < 0 )
    {
        /* Not to be closed */
        *pcm = NULL;
        ENSURE_( ret, -EBUSY == ret ? paDeviceUnavailable : paBadIODeviceCombination );
    }
    ENSURE_( alsa_snd_pcm_nonblock( *pcm, 0 ), paUnanticipatedHostError );

end:
    return result;

error:
    goto end;
}

static PaError TestParameters( const PaUtilHostApiRepresentation *hostApi, const PaStreamParameters *parameters,
        double sampleRate, StreamDirection streamDir )
{
    PaError result = paNoError;
    snd_pcm_t *pcm = NULL;
    PaSampleFormat availableFormats;
    /* We are able to adapt to a number of channels less than what the device supports */
    unsigned int numHostChannels;
    PaSampleFormat hostFormat;
    snd_pcm_hw_params_t *hwParams;
    alsa_snd_pcm_hw_params_alloca( &hwParams );

    if( !parameters->hostApiSpecificStreamInfo )
    {
        const PaAlsaDeviceInfo *devInfo = GetDeviceInfo( hostApi, parameters->device );
        numHostChannels = PA_MAX( parameters->channelCount, StreamDirection_In == streamDir ?
                devInfo->minInputChannels : devInfo->minOutputChannels );
    }
    else
        numHostChannels = parameters->channelCount;

    PA_ENSURE( AlsaOpen( hostApi, parameters, streamDir, &pcm ) );

    alsa_snd_pcm_hw_params_any( pcm, hwParams );

    if( SetApproximateSampleRate( pcm, hwParams, sampleRate ) < 0 )
    {
        result = paInvalidSampleRate;
        goto error;
    }

    if( alsa_snd_pcm_hw_params_set_channels( pcm, hwParams, numHostChannels ) < 0 )
    {
        result = paInvalidChannelCount;
        goto error;
    }

    /* See if we can find a best possible match */
    availableFormats = GetAvailableFormats( pcm );
    PA_ENSURE( hostFormat = PaUtil_SelectClosestAvailableFormat( availableFormats, parameters->sampleFormat ) );

    /* Some specific hardware (reported: Audio8 DJ) can fail with assertion during this step. */
    ENSURE_( alsa_snd_pcm_hw_params_set_format( pcm, hwParams, Pa2AlsaFormat( hostFormat ) ), paUnanticipatedHostError );

    {
        /* It happens that this call fails because the device is busy */
        int ret = 0;
        if( ( ret = alsa_snd_pcm_hw_params( pcm, hwParams ) ) < 0 )
        {
            if( -EINVAL == ret )
            {
                /* Don't know what to return here */
                result = paBadIODeviceCombination;
                goto error;
            }
            else if( -EBUSY == ret )
            {
                result = paDeviceUnavailable;
                PA_DEBUG(( "%s: Device is busy\n", __FUNCTION__ ));
            }
            else
            {
                result = paUnanticipatedHostError;
            }

            ENSURE_( ret, result );
        }
    }

end:
    if( pcm )
    {
        alsa_snd_pcm_close( pcm );
    }
    return result;

error:
    goto end;
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    int inputChannelCount = 0, outputChannelCount = 0;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaError result = paFormatIsSupported;

    if( inputParameters )
    {
        PA_ENSURE( ValidateParameters( inputParameters, hostApi, StreamDirection_In ) );

        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
    }

    if( outputParameters )
    {
        PA_ENSURE( ValidateParameters( outputParameters, hostApi, StreamDirection_Out ) );

        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
    }

    if( inputChannelCount )
    {
        if( ( result = TestParameters( hostApi, inputParameters, sampleRate, StreamDirection_In ) )
                != paNoError )
            goto error;
    }
    if ( outputChannelCount )
    {
        if( ( result = TestParameters( hostApi, outputParameters, sampleRate, StreamDirection_Out ) )
                != paNoError )
            goto error;
    }

    return paFormatIsSupported;

error:
    return result;
}


static PaError PaAlsaStreamComponent_Initialize( PaAlsaStreamComponent *self, PaAlsaHostApiRepresentation *alsaApi,
        const PaStreamParameters *params, StreamDirection streamDir, int callbackMode )
{
    PaError result = paNoError;
    PaSampleFormat userSampleFormat = params->sampleFormat, hostSampleFormat = paNoError;
    assert( params->channelCount > 0 );

    /* Make sure things have an initial value */
    memset( self, 0, sizeof (PaAlsaStreamComponent) );

    if( NULL == params->hostApiSpecificStreamInfo )
    {
        const PaAlsaDeviceInfo *devInfo = GetDeviceInfo( &alsaApi->baseHostApiRep, params->device );
        self->numHostChannels = PA_MAX( params->channelCount, StreamDirection_In == streamDir ? devInfo->minInputChannels
                : devInfo->minOutputChannels );
        self->deviceIsPlug = devInfo->isPlug;
        PA_DEBUG(( "%s: Host Chans %c %i\n", __FUNCTION__, streamDir == StreamDirection_In ? 'C' : 'P', self->numHostChannels ));
    }
    else
    {
        /* We're blissfully unaware of the minimum channelCount */
        self->numHostChannels = params->channelCount;
        /* Check if device name does not start with hw: to determine if it is a 'plug' device */
        if( strncmp( "hw:", ((PaAlsaStreamInfo *)params->hostApiSpecificStreamInfo)->deviceString, 3 ) != 0  )
            self->deviceIsPlug = 1; /* An Alsa plug device, not a direct hw device */
    }
    if( self->deviceIsPlug && alsaApi->alsaLibVersion < ALSA_VERSION_INT( 1, 0, 16 ) )
        self->useReventFix = 1; /* Prior to Alsa1.0.16, plug devices may stutter without this fix */

    self->device = params->device;

    PA_ENSURE( AlsaOpen( &alsaApi->baseHostApiRep, params, streamDir, &self->pcm ) );
    self->nfds = alsa_snd_pcm_poll_descriptors_count( self->pcm );

    PA_ENSURE( hostSampleFormat = PaUtil_SelectClosestAvailableFormat( GetAvailableFormats( self->pcm ), userSampleFormat ) );

    self->hostSampleFormat = hostSampleFormat;
    self->nativeFormat = Pa2AlsaFormat( hostSampleFormat );
    self->hostInterleaved = self->userInterleaved = !( userSampleFormat & paNonInterleaved );
    self->numUserChannels = params->channelCount;
    self->streamDir = streamDir;
    self->canMmap = 0;
    self->nonMmapBuffer = NULL;
    self->nonMmapBufferSize = 0;

    if( !callbackMode && !self->userInterleaved )
    {
        /* Pre-allocate non-interleaved user provided buffers */
        PA_UNLESS( self->userBuffers = PaUtil_AllocateMemory( sizeof (void *) * self->numUserChannels ),
                paInsufficientMemory );
    }

error:

    /* Log all available formats. */
    if ( hostSampleFormat == paSampleFormatNotSupported )
    {
        LogAllAvailableFormats( self->pcm );
        PA_DEBUG(( "%s: Please provide the log output to PortAudio developers, your hardware does not have any sample format implemented yet.\n", __FUNCTION__ ));
    }

    return result;
}

static void PaAlsaStreamComponent_Terminate( PaAlsaStreamComponent *self )
{
    alsa_snd_pcm_close( self->pcm );
    PaUtil_FreeMemory( self->userBuffers ); /* (Ptr can be NULL; PaUtil_FreeMemory includes a NULL check) */
    PaUtil_FreeMemory( self->nonMmapBuffer );
}

/*
static int nearbyint_(float value) {
    if(  value - (int)value > .5 )
        return (int)ceil( value );
    return (int)floor( value );
}
*/

/** Initiate configuration, preparing for determining a period size suitable for both capture and playback components.
 *
 */
static PaError PaAlsaStreamComponent_InitialConfigure( PaAlsaStreamComponent *self, const PaStreamParameters *params,
        int primeBuffers, snd_pcm_hw_params_t *hwParams, double *sampleRate )
{
    /* Configuration consists of setting all of ALSA's parameters.
     * These parameters come in two flavors: hardware parameters
     * and software paramters.  Hardware parameters will affect
     * the way the device is initialized, software parameters
     * affect the way ALSA interacts with me, the user-level client.
     */

    PaError result = paNoError;
    snd_pcm_access_t accessMode, alternateAccessMode;
    int dir = 0;
    snd_pcm_t *pcm = self->pcm;
    double sr = *sampleRate;
    unsigned int minPeriods = 2;

    /* self->framesPerPeriod = framesPerHostBuffer; */

    /* ... fill up the configuration space with all possibile
     * combinations of parameters this device will accept */
    ENSURE_( alsa_snd_pcm_hw_params_any( pcm, hwParams ), paUnanticipatedHostError );

    ENSURE_( alsa_snd_pcm_hw_params_set_periods_integer( pcm, hwParams ), paUnanticipatedHostError );
    /* I think there should be at least 2 periods (even though ALSA doesn't appear to enforce this) */
    dir = 0;
    ENSURE_( alsa_snd_pcm_hw_params_set_periods_min( pcm, hwParams, &minPeriods, &dir ), paUnanticipatedHostError );

    if( self->userInterleaved )
    {
        accessMode          = SND_PCM_ACCESS_MMAP_INTERLEAVED;
        alternateAccessMode = SND_PCM_ACCESS_MMAP_NONINTERLEAVED;

        /* test if MMAP supported */
        self->canMmap = alsa_snd_pcm_hw_params_test_access( pcm, hwParams, accessMode ) >= 0 ||
                        alsa_snd_pcm_hw_params_test_access( pcm, hwParams, alternateAccessMode ) >= 0;

        PA_DEBUG(( "%s: device MMAP SND_PCM_ACCESS_MMAP_INTERLEAVED: %s\n", __FUNCTION__, ( alsa_snd_pcm_hw_params_test_access( pcm, hwParams, accessMode ) >= 0 ? "YES" : "NO" ) ));
        PA_DEBUG(( "%s: device MMAP SND_PCM_ACCESS_MMAP_NONINTERLEAVED: %s\n", __FUNCTION__, ( alsa_snd_pcm_hw_params_test_access( pcm, hwParams, alternateAccessMode ) >= 0 ? "YES" : "NO" ) ));

        if( !self->canMmap )
        {
            accessMode          = SND_PCM_ACCESS_RW_INTERLEAVED;
            alternateAccessMode = SND_PCM_ACCESS_RW_NONINTERLEAVED;
        }
    }
    else
    {
        accessMode          = SND_PCM_ACCESS_MMAP_NONINTERLEAVED;
        alternateAccessMode = SND_PCM_ACCESS_MMAP_INTERLEAVED;

        /* test if MMAP supported */
        self->canMmap = alsa_snd_pcm_hw_params_test_access( pcm, hwParams, accessMode ) >= 0 ||
                        alsa_snd_pcm_hw_params_test_access( pcm, hwParams, alternateAccessMode ) >= 0;

        PA_DEBUG((" %s: device MMAP SND_PCM_ACCESS_MMAP_NONINTERLEAVED: %s\n", __FUNCTION__, ( alsa_snd_pcm_hw_params_test_access( pcm, hwParams, accessMode ) >= 0 ? "YES" : "NO" ) ));
        PA_DEBUG(( "%s: device MMAP SND_PCM_ACCESS_MMAP_INTERLEAVED: %s\n", __FUNCTION__, ( alsa_snd_pcm_hw_params_test_access( pcm, hwParams, alternateAccessMode ) >= 0 ? "YES" : "NO" ) ));

        if( !self->canMmap )
        {
            accessMode          = SND_PCM_ACCESS_RW_NONINTERLEAVED;
            alternateAccessMode = SND_PCM_ACCESS_RW_INTERLEAVED;
        }
    }

    PA_DEBUG(( "%s: device can MMAP: %s\n", __FUNCTION__, ( self->canMmap ? "YES" : "NO" ) ));

    /* If requested access mode fails, try alternate mode */
    if( alsa_snd_pcm_hw_params_set_access( pcm, hwParams, accessMode ) < 0 )
    {
        int err = 0;
        if( ( err = alsa_snd_pcm_hw_params_set_access( pcm, hwParams, alternateAccessMode )) < 0 )
        {
            result = paUnanticipatedHostError;
            PaUtil_SetLastHostErrorInfo( paALSA, err, alsa_snd_strerror( err ) );
            goto error;
        }
        /* Flip mode */
        self->hostInterleaved = !self->userInterleaved;
    }

    /* Some specific hardware (reported: Audio8 DJ) can fail with assertion during this step. */
    ENSURE_( alsa_snd_pcm_hw_params_set_format( pcm, hwParams, self->nativeFormat ), paUnanticipatedHostError );

    if( ( result = SetApproximateSampleRate( pcm, hwParams, sr )) != paUnanticipatedHostError )
    {
        ENSURE_( GetExactSampleRate( hwParams, &sr ), paUnanticipatedHostError );
        if( result == paInvalidSampleRate ) /* From the SetApproximateSampleRate() call above */
        { /* The sample rate was returned as 'out of tolerance' of the one requested */
            PA_DEBUG(( "%s: Wanted %.3f, closest sample rate was %.3f\n", __FUNCTION__, sampleRate, sr ));
            PA_ENSURE( paInvalidSampleRate );
        }
    }
    else
    {
       PA_ENSURE( paUnanticipatedHostError );
    }

    ENSURE_( alsa_snd_pcm_hw_params_set_channels( pcm, hwParams, self->numHostChannels ), paInvalidChannelCount );

    *sampleRate = sr;

end:
    return result;

error:
    /* No particular action */
    goto end;
}

/** Finish the configuration of the component's ALSA device.
 *
 * As part of this method, the component's alsaBufferSize attribute will be set.
 * @param latency: The latency for this component.
 */
static PaError PaAlsaStreamComponent_FinishConfigure( PaAlsaStreamComponent *self, snd_pcm_hw_params_t* hwParams,
        const PaStreamParameters *params, int primeBuffers, double sampleRate, PaTime* latency )
{
    PaError result = paNoError;
    snd_pcm_sw_params_t* swParams;
    snd_pcm_uframes_t bufSz = 0;
    *latency = -1.;

    alsa_snd_pcm_sw_params_alloca( &swParams );

    bufSz = params->suggestedLatency * sampleRate + self->framesPerPeriod;
    ENSURE_( alsa_snd_pcm_hw_params_set_buffer_size_near( self->pcm, hwParams, &bufSz ), paUnanticipatedHostError );

    /* Set the parameters! */
    {
        int r = alsa_snd_pcm_hw_params( self->pcm, hwParams );
#ifdef PA_ENABLE_DEBUG_OUTPUT
        if( r < 0 )
        {
            snd_output_t *output = NULL;
            alsa_snd_output_stdio_attach( &output, stderr, 0 );
            alsa_snd_pcm_hw_params_dump( hwParams, output );
        }
#endif
        ENSURE_( r, paUnanticipatedHostError );
    }
    if( alsa_snd_pcm_hw_params_get_buffer_size != NULL )
    {
        ENSURE_( alsa_snd_pcm_hw_params_get_buffer_size( hwParams, &self->alsaBufferSize ), paUnanticipatedHostError );
    }
    else
    {
        self->alsaBufferSize = bufSz;
    }

    /* Latency in seconds */
    *latency = (self->alsaBufferSize - self->framesPerPeriod) / sampleRate;

    /* Now software parameters... */
    ENSURE_( alsa_snd_pcm_sw_params_current( self->pcm, swParams ), paUnanticipatedHostError );

    ENSURE_( alsa_snd_pcm_sw_params_set_start_threshold( self->pcm, swParams, self->framesPerPeriod ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_sw_params_set_stop_threshold( self->pcm, swParams, self->alsaBufferSize ), paUnanticipatedHostError );

    /* Silence buffer in the case of underrun */
    if( !primeBuffers ) /* XXX: Make sense? */
    {
        snd_pcm_uframes_t boundary;
        ENSURE_( alsa_snd_pcm_sw_params_get_boundary( swParams, &boundary ), paUnanticipatedHostError );
        ENSURE_( alsa_snd_pcm_sw_params_set_silence_threshold( self->pcm, swParams, 0 ), paUnanticipatedHostError );
        ENSURE_( alsa_snd_pcm_sw_params_set_silence_size( self->pcm, swParams, boundary ), paUnanticipatedHostError );
    }

    ENSURE_( alsa_snd_pcm_sw_params_set_avail_min( self->pcm, swParams, self->framesPerPeriod ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_sw_params_set_xfer_align( self->pcm, swParams, 1 ), paUnanticipatedHostError );
    ENSURE_( alsa_snd_pcm_sw_params_set_tstamp_mode( self->pcm, swParams, SND_PCM_TSTAMP_ENABLE ), paUnanticipatedHostError );

    /* Set the parameters! */
    ENSURE_( alsa_snd_pcm_sw_params( self->pcm, swParams ), paUnanticipatedHostError );

error:
    return result;
}

static PaError PaAlsaStream_Initialize( PaAlsaStream *self, PaAlsaHostApiRepresentation *alsaApi, const PaStreamParameters *inParams,
        const PaStreamParameters *outParams, double sampleRate, unsigned long framesPerUserBuffer, PaStreamCallback callback,
        PaStreamFlags streamFlags, void *userData )
{
    PaError result = paNoError;
    assert( self );

    memset( self, 0, sizeof( PaAlsaStream ) );

    if( NULL != callback )
    {
        PaUtil_InitializeStreamRepresentation( &self->streamRepresentation,
                                               &alsaApi->callbackStreamInterface,
                                               callback, userData );
        self->callbackMode = 1;
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &self->streamRepresentation,
                                               &alsaApi->blockingStreamInterface,
                                               NULL, userData );
    }

    self->framesPerUserBuffer = framesPerUserBuffer;
    self->neverDropInput = streamFlags & paNeverDropInput;
    /* XXX: Ignore paPrimeOutputBuffersUsingStreamCallback untill buffer priming is fully supported in pa_process.c */
    /*
    if( outParams & streamFlags & paPrimeOutputBuffersUsingStreamCallback )
        self->primeBuffers = 1;
        */
    memset( &self->capture, 0, sizeof (PaAlsaStreamComponent) );
    memset( &self->playback, 0, sizeof (PaAlsaStreamComponent) );
    if( inParams )
    {
        PA_ENSURE( PaAlsaStreamComponent_Initialize( &self->capture, alsaApi, inParams, StreamDirection_In, NULL != callback ) );
    }
    if( outParams )
    {
        PA_ENSURE( PaAlsaStreamComponent_Initialize( &self->playback, alsaApi, outParams, StreamDirection_Out, NULL != callback ) );
    }

    assert( self->capture.nfds || self->playback.nfds );

    PA_UNLESS( self->pfds = (struct pollfd*)PaUtil_AllocateMemory( ( self->capture.nfds +
                    self->playback.nfds ) * sizeof( struct pollfd ) ), paInsufficientMemory );

    PaUtil_InitializeCpuLoadMeasurer( &self->cpuLoadMeasurer, sampleRate );
    ASSERT_CALL_( PaUnixMutex_Initialize( &self->stateMtx ), paNoError );

error:
    return result;
}

/** Free resources associated with stream, and eventually stream itself.
 *
 * Frees allocated memory, and terminates individual StreamComponents.
 */
static void PaAlsaStream_Terminate( PaAlsaStream *self )
{
    assert( self );

    if( self->capture.pcm )
    {
        PaAlsaStreamComponent_Terminate( &self->capture );
    }
    if( self->playback.pcm )
    {
        PaAlsaStreamComponent_Terminate( &self->playback );
    }

    PaUtil_FreeMemory( self->pfds );
    ASSERT_CALL_( PaUnixMutex_Terminate( &self->stateMtx ), paNoError );

    PaUtil_FreeMemory( self );
}

/** Calculate polling timeout
 *
 * @param frames Time to wait
 * @return Polling timeout in milliseconds
 */
static int CalculatePollTimeout( const PaAlsaStream *stream, unsigned long frames )
{
    assert( stream->streamRepresentation.streamInfo.sampleRate > 0.0 );
    /* Period in msecs, rounded up */
    return (int)ceil( 1000 * frames / stream->streamRepresentation.streamInfo.sampleRate );
}

/** Align value in backward direction.
 *
 * @param v: Value to align.
 * @param align: Alignment.
 */
static unsigned long PaAlsa_AlignBackward(unsigned long v, unsigned long align)
{
    return ( v - ( align ? v % align : 0 ) );
}

/** Align value in forward direction.
 *
 * @param v: Value to align.
 * @param align: Alignment.
 */
static unsigned long PaAlsa_AlignForward(unsigned long v, unsigned long align)
{
    unsigned long remainder = ( align ? ( v % align ) : 0);
    return ( remainder != 0 ? v + ( align - remainder ) : v );
}

/** Get size of host buffer maintained from the number of user frames, sample rate and suggested latency. Minimum double buffering
 *  is maintained to allow 100% CPU usage inside user callback.
 *
 * @param userFramesPerBuffer: User buffer size in number of frames.
 * @param suggestedLatency: User provided desired latency.
 * @param sampleRate: Sample rate.
 */
static unsigned long PaAlsa_GetFramesPerHostBuffer(unsigned long userFramesPerBuffer, PaTime suggestedLatency, double sampleRate)
{
    unsigned long frames = userFramesPerBuffer + PA_MAX( userFramesPerBuffer, (unsigned long)( suggestedLatency * sampleRate ) );
    return frames;
}

/** Determine size per host buffer.
 *
 * During this method call, the component's framesPerPeriod attribute gets computed, and the corresponding period size
 * gets configured for the device.
 * @param accurate: If the configured period size is non-integer, this will be set to 0.
 */
static PaError PaAlsaStreamComponent_DetermineFramesPerBuffer( PaAlsaStreamComponent* self, const PaStreamParameters* params,
        unsigned long framesPerUserBuffer, double sampleRate, snd_pcm_hw_params_t* hwParams, int* accurate )
{
    PaError result = paNoError;
    unsigned long bufferSize, framesPerHostBuffer;
    int dir = 0;

    /* Calculate host buffer size */
    bufferSize = PaAlsa_GetFramesPerHostBuffer(framesPerUserBuffer, params->suggestedLatency, sampleRate);

    /* Log */
    PA_DEBUG(( "%s: user-buffer (frames)           = %lu\n", __FUNCTION__, framesPerUserBuffer ));
    PA_DEBUG(( "%s: user-buffer (sec)              = %f\n",  __FUNCTION__, (double)(framesPerUserBuffer / sampleRate) ));
    PA_DEBUG(( "%s: suggested latency (sec)        = %f\n",  __FUNCTION__, params->suggestedLatency ));
    PA_DEBUG(( "%s: suggested host buffer (frames) = %lu\n", __FUNCTION__, bufferSize ));
    PA_DEBUG(( "%s: suggested host buffer (sec)    = %f\n",  __FUNCTION__, (double)(bufferSize / sampleRate) ));

#ifdef PA_ALSA_USE_OBSOLETE_HOST_BUFFER_CALC

    if( framesPerUserBuffer != paFramesPerBufferUnspecified )
    {
        /* Preferably the host buffer size should be a multiple of the user buffer size */

        if( bufferSize > framesPerUserBuffer )
        {
            snd_pcm_uframes_t remainder = bufferSize % framesPerUserBuffer;
            if( remainder > framesPerUserBuffer / 2. )
                bufferSize += framesPerUserBuffer - remainder;
            else
                bufferSize -= remainder;

            assert( bufferSize % framesPerUserBuffer == 0 );
        }
        else if( framesPerUserBuffer % bufferSize != 0 )
        {
            /*  Find a good compromise between user specified latency and buffer size */
            if( bufferSize > framesPerUserBuffer * .75 )
            {
                bufferSize = framesPerUserBuffer;
            }
            else
            {
                snd_pcm_uframes_t newSz = framesPerUserBuffer;
                while( newSz / 2 >= bufferSize )
                {
                    if( framesPerUserBuffer % (newSz / 2) != 0 )
                    {
                        /* No use dividing any further */
                        break;
                    }
                    newSz /= 2;
                }
                bufferSize = newSz;
            }

            assert( framesPerUserBuffer % bufferSize == 0 );
        }
    }

#endif

    {
        unsigned numPeriods = numPeriods_, maxPeriods = 0, minPeriods = numPeriods_;

        /* It may be that the device only supports 2 periods for instance */
        dir = 0;
        ENSURE_( alsa_snd_pcm_hw_params_get_periods_min( hwParams, &minPeriods, &dir ), paUnanticipatedHostError );
        ENSURE_( alsa_snd_pcm_hw_params_get_periods_max( hwParams, &maxPeriods, &dir ), paUnanticipatedHostError );
        assert( maxPeriods > 1 );

        /* Clamp to min/max */
        numPeriods = PA_MIN(maxPeriods, PA_MAX(minPeriods, numPeriods));

        PA_DEBUG(( "%s: periods min = %lu, max = %lu, req = %lu \n", __FUNCTION__, minPeriods, maxPeriods, numPeriods ));

#ifndef PA_ALSA_USE_OBSOLETE_HOST_BUFFER_CALC

        /* Calculate period size */
        framesPerHostBuffer = (bufferSize / numPeriods);

        /* Align & test size */
        if( framesPerUserBuffer != paFramesPerBufferUnspecified )
        {
            /* Align to user buffer size */
            framesPerHostBuffer = PaAlsa_AlignForward(framesPerHostBuffer, framesPerUserBuffer);

            /* Test (borrowed from older implementation) */
            if( framesPerHostBuffer < framesPerUserBuffer )
            {
                assert( framesPerUserBuffer % framesPerHostBuffer == 0 );
                if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer, 0 ) < 0 )
                {
                    if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer * 2, 0 ) == 0 )
                        framesPerHostBuffer *= 2;
                    else if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer / 2, 0 ) == 0 )
                        framesPerHostBuffer /= 2;
                }
            }
            else
            {
                assert( framesPerHostBuffer % framesPerUserBuffer == 0 );
                if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer, 0 ) < 0 )
                {
                    if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer + framesPerUserBuffer, 0 ) == 0 )
                        framesPerHostBuffer += framesPerUserBuffer;
                    else if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer - framesPerUserBuffer, 0 ) == 0 )
                        framesPerHostBuffer -= framesPerUserBuffer;
                }
            }
        }
#endif

#ifdef PA_ALSA_USE_OBSOLETE_HOST_BUFFER_CALC

        if( framesPerUserBuffer != paFramesPerBufferUnspecified )
        {
            /* Try to get a power-of-two of the user buffer size. */
            framesPerHostBuffer = framesPerUserBuffer;
            if( framesPerHostBuffer < bufferSize )
            {
                while( bufferSize / framesPerHostBuffer > numPeriods )
                {
                    framesPerHostBuffer *= 2;
                }
                /* One extra period is preferrable to one less (should be more robust) */
                if( bufferSize / framesPerHostBuffer < numPeriods )
                {
                    framesPerHostBuffer /= 2;
                }
            }
            else
            {
                while( bufferSize / framesPerHostBuffer < numPeriods )
                {
                    if( framesPerUserBuffer % ( framesPerHostBuffer / 2 ) != 0 )
                    {
                        /* Can't be divided any further */
                        break;
                    }
                    framesPerHostBuffer /= 2;
                }
            }

            if( framesPerHostBuffer < framesPerUserBuffer )
            {
                assert( framesPerUserBuffer % framesPerHostBuffer == 0 );
                if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer, 0 ) < 0 )
                {
                    if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer * 2, 0 ) == 0 )
                        framesPerHostBuffer *= 2;
                    else if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer / 2, 0 ) == 0 )
                        framesPerHostBuffer /= 2;
                }
            }
            else
            {
                assert( framesPerHostBuffer % framesPerUserBuffer == 0 );
                if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer, 0 ) < 0 )
                {
                    if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer + framesPerUserBuffer, 0 ) == 0 )
                        framesPerHostBuffer += framesPerUserBuffer;
                    else if( alsa_snd_pcm_hw_params_test_period_size( self->pcm, hwParams, framesPerHostBuffer - framesPerUserBuffer, 0 ) == 0 )
                        framesPerHostBuffer -= framesPerUserBuffer;
                }
            }
        }
        else
        {
            framesPerHostBuffer = bufferSize / numPeriods;
        }

        /* non-mmap mode needs a reasonably-sized buffer or it'll stutter */
        if( !self->canMmap && framesPerHostBuffer < 2048 )
            framesPerHostBuffer = 2048;
#endif
        PA_DEBUG(( "%s: suggested host buffer period   = %lu \n", __FUNCTION__, framesPerHostBuffer ));
    }

    {
        /* Get min/max period sizes and adjust our chosen */
        snd_pcm_uframes_t min = 0, max = 0, minmax_diff;
        ENSURE_( alsa_snd_pcm_hw_params_get_period_size_min( hwParams, &min, NULL ), paUnanticipatedHostError );
        ENSURE_( alsa_snd_pcm_hw_params_get_period_size_max( hwParams, &max, NULL ), paUnanticipatedHostError );
        minmax_diff = max - min;

        if( framesPerHostBuffer < min )
        {
            PA_DEBUG(( "%s: The determined period size (%lu) is less than minimum (%lu)\n", __FUNCTION__, framesPerHostBuffer, min ));
            framesPerHostBuffer = (( minmax_diff == 2 ) ? min + 1 : min );
        }
        else if( framesPerHostBuffer > max )
        {
            PA_DEBUG(( "%s: The determined period size (%lu) is greater than maximum (%lu)\n", __FUNCTION__, framesPerHostBuffer, max ));
            framesPerHostBuffer = (( minmax_diff == 2 ) ? max - 1 : max );
        }

        PA_DEBUG(( "%s: device period minimum          = %lu\n", __FUNCTION__, min ));
        PA_DEBUG(( "%s: device period maximum          = %lu\n", __FUNCTION__, max ));
        PA_DEBUG(( "%s: host buffer period             = %lu\n", __FUNCTION__, framesPerHostBuffer ));
        PA_DEBUG(( "%s: host buffer period latency     = %f\n", __FUNCTION__, (double)( framesPerHostBuffer / sampleRate ) ));

        /* Try setting period size */
        dir = 0;
        ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( self->pcm, hwParams, &framesPerHostBuffer, &dir ), paUnanticipatedHostError );
        if( dir != 0 )
        {
            PA_DEBUG(( "%s: The configured period size is non-integer.\n", __FUNCTION__, dir ));
            *accurate = 0;
        }
    }

    /* Set result */
    self->framesPerPeriod = framesPerHostBuffer;

error:
    return result;
}

/* We need to determine how many frames per host buffer (period) to use.  Our
 * goals are to provide the best possible performance, but also to
 * honor the requested latency settings as closely as we can. Therefore this
 * decision is based on:
 *
 *   - the period sizes that playback and/or capture support.  The
 *     host buffer size has to be one of these.
 *   - the number of periods that playback and/or capture support.
 *
 * We want to make period_size*(num_periods-1) to be as close as possible
 * to latency*rate for both playback and capture.
 *
 * This method will determine suitable period sizes for capture and playback handles, and report the maximum number of
 * frames per host buffer. The latter is relevant, in case we should be so unfortunate that the period size differs
 * between capture and playback. If this should happen, the stream's hostBufferSizeMode attribute will be set to
 * paUtilBoundedHostBufferSize, because the best we can do is limit the size of individual host buffers to the upper
 * bound. The size of host buffers scheduled for processing should only matter if the user has specified a buffer size,
 * but when he/she does we must strive for an optimal configuration. By default we'll opt for a fixed host buffer size,
 * which should be fine if the period size is the same for capture and playback. In general, if there is a specified user
 * buffer size, this method tries it best to determine a period size which is a multiple of the user buffer size.
 *
 * The framesPerPeriod attributes of the individual capture and playback components of the stream are set to corresponding
 * values determined here. Since these should be reported as
 *
 * This is one of those blocks of code that will just take a lot of
 * refinement to be any good.
 *
 * In the full-duplex case it is possible that the routine was unable
 * to find a number of frames per buffer acceptable to both devices
 * TODO: Implement an algorithm to find the value closest to acceptance
 * by both devices, to minimize difference between period sizes?
 *
 * @param determinedFramesPerHostBuffer: The determined host buffer size.
 */
static PaError PaAlsaStream_DetermineFramesPerBuffer( PaAlsaStream* self, double sampleRate, const PaStreamParameters* inputParameters,
        const PaStreamParameters* outputParameters, unsigned long framesPerUserBuffer, snd_pcm_hw_params_t* hwParamsCapture,
        snd_pcm_hw_params_t* hwParamsPlayback, PaUtilHostBufferSizeMode* hostBufferSizeMode )
{
    PaError result = paNoError;
    unsigned long framesPerHostBuffer = 0;
    int dir = 0;
    int accurate = 1;
    unsigned numPeriods = numPeriods_;

    if( self->capture.pcm && self->playback.pcm )
    {
        if( framesPerUserBuffer == paFramesPerBufferUnspecified )
        {
            /* Come up with a common desired latency */
            snd_pcm_uframes_t desiredBufSz, e, minPeriodSize, maxPeriodSize, optimalPeriodSize, periodSize,
                              minCapture, minPlayback, maxCapture, maxPlayback;

            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_get_period_size_min( hwParamsCapture, &minCapture, &dir ), paUnanticipatedHostError );
            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_get_period_size_min( hwParamsPlayback, &minPlayback, &dir ), paUnanticipatedHostError );
            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_get_period_size_max( hwParamsCapture, &maxCapture, &dir ), paUnanticipatedHostError );
            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_get_period_size_max( hwParamsPlayback, &maxPlayback, &dir ), paUnanticipatedHostError );
            minPeriodSize = PA_MAX( minPlayback, minCapture );
            maxPeriodSize = PA_MIN( maxPlayback, maxCapture );
            PA_UNLESS( minPeriodSize <= maxPeriodSize, paBadIODeviceCombination );

            desiredBufSz = (snd_pcm_uframes_t)( PA_MIN( outputParameters->suggestedLatency, inputParameters->suggestedLatency )
                    * sampleRate );
            /* Clamp desiredBufSz */
            {
                snd_pcm_uframes_t maxBufferSize;
                snd_pcm_uframes_t maxBufferSizeCapture, maxBufferSizePlayback;
                ENSURE_( alsa_snd_pcm_hw_params_get_buffer_size_max( hwParamsCapture, &maxBufferSizeCapture ), paUnanticipatedHostError );
                ENSURE_( alsa_snd_pcm_hw_params_get_buffer_size_max( hwParamsPlayback, &maxBufferSizePlayback ), paUnanticipatedHostError );
                maxBufferSize = PA_MIN( maxBufferSizeCapture, maxBufferSizePlayback );

                desiredBufSz = PA_MIN( desiredBufSz, maxBufferSize );
            }

            /* Find the closest power of 2 */
            e = ilogb( minPeriodSize );
            if( minPeriodSize & ( minPeriodSize - 1 ) )
                e += 1;
            periodSize = (snd_pcm_uframes_t)pow( 2, e );

            while( periodSize <= maxPeriodSize )
            {
                if( alsa_snd_pcm_hw_params_test_period_size( self->playback.pcm, hwParamsPlayback, periodSize, 0 ) >= 0 &&
                        alsa_snd_pcm_hw_params_test_period_size( self->capture.pcm, hwParamsCapture, periodSize, 0 ) >= 0 )
                {
                    /* OK! */
                    break;
                }

                periodSize *= 2;
            }

            optimalPeriodSize = PA_MAX( desiredBufSz / numPeriods, minPeriodSize );
            optimalPeriodSize = PA_MIN( optimalPeriodSize, maxPeriodSize );

            /* Find the closest power of 2 */
            e = ilogb( optimalPeriodSize );
            if( optimalPeriodSize & (optimalPeriodSize - 1) )
                e += 1;
            optimalPeriodSize = (snd_pcm_uframes_t)pow( 2, e );

            while( optimalPeriodSize >= periodSize )
            {
                if( alsa_snd_pcm_hw_params_test_period_size( self->capture.pcm, hwParamsCapture, optimalPeriodSize, 0 )
                        >= 0 && alsa_snd_pcm_hw_params_test_period_size( self->playback.pcm, hwParamsPlayback,
                            optimalPeriodSize, 0 ) >= 0 )
                {
                    break;
                }
                optimalPeriodSize /= 2;
            }

            if( optimalPeriodSize > periodSize )
                periodSize = optimalPeriodSize;

            if( periodSize <= maxPeriodSize )
            {
                /* Looks good, the periodSize _should_ be acceptable by both devices */
                ENSURE_( alsa_snd_pcm_hw_params_set_period_size( self->capture.pcm, hwParamsCapture, periodSize, 0 ),
                        paUnanticipatedHostError );
                ENSURE_( alsa_snd_pcm_hw_params_set_period_size( self->playback.pcm, hwParamsPlayback, periodSize, 0 ),
                        paUnanticipatedHostError );
                self->capture.framesPerPeriod = self->playback.framesPerPeriod = periodSize;
                framesPerHostBuffer = periodSize;
            }
            else
            {
                /* Unable to find a common period size, oh well */
                optimalPeriodSize = PA_MAX( desiredBufSz / numPeriods, minPeriodSize );
                optimalPeriodSize = PA_MIN( optimalPeriodSize, maxPeriodSize );

                self->capture.framesPerPeriod = optimalPeriodSize;
                dir = 0;
                ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( self->capture.pcm, hwParamsCapture, &self->capture.framesPerPeriod, &dir ),
                        paUnanticipatedHostError );
                self->playback.framesPerPeriod = optimalPeriodSize;
                dir = 0;
                ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( self->playback.pcm, hwParamsPlayback, &self->playback.framesPerPeriod, &dir ),
                        paUnanticipatedHostError );
                framesPerHostBuffer = PA_MAX( self->capture.framesPerPeriod, self->playback.framesPerPeriod );
                *hostBufferSizeMode = paUtilBoundedHostBufferSize;
            }
        }
        else
        {
            /* We choose the simple route and determine a suitable number of frames per buffer for one component of
             * the stream, then we hope that this will work for the other component too (it should!).
             */

            unsigned maxPeriods = 0;
            PaAlsaStreamComponent* first = &self->capture, * second = &self->playback;
            const PaStreamParameters* firstStreamParams = inputParameters;
            snd_pcm_hw_params_t* firstHwParams = hwParamsCapture, * secondHwParams = hwParamsPlayback;

            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_get_periods_max( hwParamsPlayback, &maxPeriods, &dir ), paUnanticipatedHostError );
            if( maxPeriods < numPeriods )
            {
                /* The playback component is trickier to get right, try that first */
                first = &self->playback;
                second = &self->capture;
                firstStreamParams = outputParameters;
                firstHwParams = hwParamsPlayback;
                secondHwParams = hwParamsCapture;
            }

            PA_ENSURE( PaAlsaStreamComponent_DetermineFramesPerBuffer( first, firstStreamParams, framesPerUserBuffer,
                        sampleRate, firstHwParams, &accurate ) );

            second->framesPerPeriod = first->framesPerPeriod;
            dir = 0;
            ENSURE_( alsa_snd_pcm_hw_params_set_period_size_near( second->pcm, secondHwParams, &second->framesPerPeriod, &dir ),
                    paUnanticipatedHostError );
            if( self->capture.framesPerPeriod == self->playback.framesPerPeriod )
            {
                framesPerHostBuffer = self->capture.framesPerPeriod;
            }
            else
            {
                framesPerHostBuffer = PA_MAX( self->capture.framesPerPeriod, self->playback.framesPerPeriod );
                *hostBufferSizeMode = paUtilBoundedHostBufferSize;
            }
        }
    }
    else    /* half-duplex is a slightly simpler case */
    {
        if( self->capture.pcm )
        {
            PA_ENSURE( PaAlsaStreamComponent_DetermineFramesPerBuffer( &self->capture, inputParameters, framesPerUserBuffer,
                        sampleRate, hwParamsCapture, &accurate) );
            framesPerHostBuffer = self->capture.framesPerPeriod;
        }
        else
        {
            assert( self->playback.pcm );
            PA_ENSURE( PaAlsaStreamComponent_DetermineFramesPerBuffer( &self->playback, outputParameters, framesPerUserBuffer,
                        sampleRate, hwParamsPlayback, &accurate ) );
            framesPerHostBuffer = self->playback.framesPerPeriod;
        }
    }

    PA_UNLESS( framesPerHostBuffer != 0, paInternalError );
    self->maxFramesPerHostBuffer = framesPerHostBuffer;

    if( !self->playback.canMmap || !accurate )
    {
        /* Don't know the exact size per host buffer */
        *hostBufferSizeMode = paUtilBoundedHostBufferSize;
        /* Raise upper bound */
        if( !accurate )
            ++self->maxFramesPerHostBuffer;
    }

error:
    return result;
}

/** Set up ALSA stream parameters.
 *
 */
static PaError PaAlsaStream_Configure( PaAlsaStream *self, const PaStreamParameters *inParams, const PaStreamParameters*
        outParams, double sampleRate, unsigned long framesPerUserBuffer, double* inputLatency, double* outputLatency,
        PaUtilHostBufferSizeMode* hostBufferSizeMode )
{
    PaError result = paNoError;
    double realSr = sampleRate;
    snd_pcm_hw_params_t* hwParamsCapture, * hwParamsPlayback;

    alsa_snd_pcm_hw_params_alloca( &hwParamsCapture );
    alsa_snd_pcm_hw_params_alloca( &hwParamsPlayback );

    if( self->capture.pcm )
        PA_ENSURE( PaAlsaStreamComponent_InitialConfigure( &self->capture, inParams, self->primeBuffers, hwParamsCapture,
                    &realSr ) );
    if( self->playback.pcm )
        PA_ENSURE( PaAlsaStreamComponent_InitialConfigure( &self->playback, outParams, self->primeBuffers, hwParamsPlayback,
                    &realSr ) );

    PA_ENSURE( PaAlsaStream_DetermineFramesPerBuffer( self, realSr, inParams, outParams, framesPerUserBuffer,
                hwParamsCapture, hwParamsPlayback, hostBufferSizeMode ) );

    if( self->capture.pcm )
    {
        assert( self->capture.framesPerPeriod != 0 );
        PA_ENSURE( PaAlsaStreamComponent_FinishConfigure( &self->capture, hwParamsCapture, inParams, self->primeBuffers, realSr,
                    inputLatency ) );
        PA_DEBUG(( "%s: Capture period size: %lu, latency: %f\n", __FUNCTION__, self->capture.framesPerPeriod, *inputLatency ));
    }
    if( self->playback.pcm )
    {
        assert( self->playback.framesPerPeriod != 0 );
        PA_ENSURE( PaAlsaStreamComponent_FinishConfigure( &self->playback, hwParamsPlayback, outParams, self->primeBuffers, realSr,
                    outputLatency ) );
        PA_DEBUG(( "%s: Playback period size: %lu, latency: %f\n", __FUNCTION__, self->playback.framesPerPeriod, *outputLatency ));
    }

    /* Should be exact now */
    self->streamRepresentation.streamInfo.sampleRate = realSr;

    /* this will cause the two streams to automatically start/stop/prepare in sync.
     * We only need to execute these operations on one of the pair.
     * A: We don't want to do this on a blocking stream.
     */
    if( self->callbackMode && self->capture.pcm && self->playback.pcm )
    {
        int err = alsa_snd_pcm_link( self->capture.pcm, self->playback.pcm );
        if( err == 0 )
            self->pcmsSynced = 1;
        else
            PA_DEBUG(( "%s: Unable to sync pcms: %s\n", __FUNCTION__, alsa_snd_strerror( err ) ));
    }

    {
        unsigned long minFramesPerHostBuffer = PA_MIN( self->capture.pcm ? self->capture.framesPerPeriod : ULONG_MAX,
            self->playback.pcm ? self->playback.framesPerPeriod : ULONG_MAX );
        self->pollTimeout = CalculatePollTimeout( self, minFramesPerHostBuffer );    /* Period in msecs, rounded up */

        /* Time before watchdog unthrottles realtime thread == 1/4 of period time in msecs */
        /* self->threading.throttledSleepTime = (unsigned long) (minFramesPerHostBuffer / sampleRate / 4 * 1000); */
    }

    if( self->callbackMode )
    {
        /* If the user expects a certain number of frames per callback we will either have to rely on block adaption
         * (framesPerHostBuffer is not an integer multiple of framesPerPeriod) or we can simply align the number
         * of host buffer frames with what the user specified */
        if( self->framesPerUserBuffer != paFramesPerBufferUnspecified )
        {
            /* self->alignFrames = 1; */

            /* Unless the ratio between number of host and user buffer frames is an integer we will have to rely
             * on block adaption */
        /*
            if( framesPerHostBuffer % framesPerPeriod != 0 || (self->capture.pcm && self->playback.pcm &&
                        self->capture.framesPerPeriod != self->playback.framesPerPeriod) )
                self->useBlockAdaption = 1;
            else
                self->alignFrames = 1;
        */
        }
    }

error:
    return result;
}

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback* callback,
                           void *userData )
{
    PaError result = paNoError;
    PaAlsaHostApiRepresentation *alsaHostApi = (PaAlsaHostApiRepresentation*)hostApi;
    PaAlsaStream *stream = NULL;
    PaSampleFormat hostInputSampleFormat = 0, hostOutputSampleFormat = 0;
    PaSampleFormat inputSampleFormat = 0, outputSampleFormat = 0;
    int numInputChannels = 0, numOutputChannels = 0;
    PaTime inputLatency, outputLatency;
    /* Operate with fixed host buffer size by default, since other modes will invariably lead to block adaption */
    /* XXX: Use Bounded by default? Output tends to get stuttery with Fixed ... */
    PaUtilHostBufferSizeMode hostBufferSizeMode = paUtilFixedHostBufferSize;

    if( ( streamFlags & paPlatformSpecificFlags ) != 0 )
        return paInvalidFlag;

    if( inputParameters )
    {
        PA_ENSURE( ValidateParameters( inputParameters, hostApi, StreamDirection_In ) );

        numInputChannels = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
    }
    if( outputParameters )
    {
        PA_ENSURE( ValidateParameters( outputParameters, hostApi, StreamDirection_Out ) );

        numOutputChannels = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
    }

    /* XXX: Why do we support this anyway? */
    if( framesPerBuffer == paFramesPerBufferUnspecified && getenv( "PA_ALSA_PERIODSIZE" ) != NULL )
    {
        PA_DEBUG(( "%s: Getting framesPerBuffer (Alsa period-size) from environment\n", __FUNCTION__ ));
        framesPerBuffer = atoi( getenv("PA_ALSA_PERIODSIZE") );
    }

    PA_UNLESS( stream = (PaAlsaStream*)PaUtil_AllocateMemory( sizeof(PaAlsaStream) ), paInsufficientMemory );
    PA_ENSURE( PaAlsaStream_Initialize( stream, alsaHostApi, inputParameters, outputParameters, sampleRate,
                framesPerBuffer, callback, streamFlags, userData ) );

    PA_ENSURE( PaAlsaStream_Configure( stream, inputParameters, outputParameters, sampleRate, framesPerBuffer,
                &inputLatency, &outputLatency, &hostBufferSizeMode ) );
    hostInputSampleFormat = stream->capture.hostSampleFormat | (!stream->capture.hostInterleaved ? paNonInterleaved : 0);
    hostOutputSampleFormat = stream->playback.hostSampleFormat | (!stream->playback.hostInterleaved ? paNonInterleaved : 0);

    PA_ENSURE( PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                    numInputChannels, inputSampleFormat, hostInputSampleFormat,
                    numOutputChannels, outputSampleFormat, hostOutputSampleFormat,
                    sampleRate, streamFlags, framesPerBuffer, stream->maxFramesPerHostBuffer,
                    hostBufferSizeMode, callback, userData ) );

    /* Ok, buffer processor is initialized, now we can deduce it's latency */
    if( numInputChannels > 0 )
        stream->streamRepresentation.streamInfo.inputLatency = inputLatency + (PaTime)(
                PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor ) / sampleRate);
    if( numOutputChannels > 0 )
        stream->streamRepresentation.streamInfo.outputLatency = outputLatency + (PaTime)(
                PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor ) / sampleRate);

    PA_DEBUG(( "%s: Stream: framesPerBuffer = %lu, maxFramesPerHostBuffer = %lu, latency i=%f, o=%f\n", __FUNCTION__, framesPerBuffer, stream->maxFramesPerHostBuffer, stream->streamRepresentation.streamInfo.inputLatency, stream->streamRepresentation.streamInfo.outputLatency));

    *s = (PaStream*)stream;

    return result;

error:
    if( stream )
    {
        PA_DEBUG(( "%s: Stream in error, terminating\n", __FUNCTION__ ));
        PaAlsaStream_Terminate( stream );
    }

    return result;
}

static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaAlsaStream *stream = (PaAlsaStream*)s;

    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );

    PaAlsaStream_Terminate( stream );

    return result;
}

static void SilenceBuffer( PaAlsaStream *stream )
{
    const snd_pcm_channel_area_t *areas;
    snd_pcm_uframes_t frames = (snd_pcm_uframes_t)alsa_snd_pcm_avail_update( stream->playback.pcm ), offset;

    alsa_snd_pcm_mmap_begin( stream->playback.pcm, &areas, &offset, &frames );
    alsa_snd_pcm_areas_silence( areas, offset, stream->playback.numHostChannels, frames, stream->playback.nativeFormat );
    alsa_snd_pcm_mmap_commit( stream->playback.pcm, offset, frames );
}

/** Start/prepare pcm(s) for streaming.
 *
 * Depending on whether the stream is in callback or blocking mode, we will respectively start or simply
 * prepare the playback pcm. If the buffer has _not_ been primed, we will in callback mode prepare and
 * silence the buffer before starting playback. In blocking mode we simply prepare, as the playback will
 * be started automatically as the user writes to output.
 *
 * The capture pcm, however, will simply be prepared and started.
 */
static PaError AlsaStart( PaAlsaStream *stream, int priming )
{
    PaError result = paNoError;

    if( stream->playback.pcm )
    {
        if( stream->callbackMode )
        {
            if( !priming )
            {
                /* Buffer isn't primed, so prepare and silence */
                ENSURE_( alsa_snd_pcm_prepare( stream->playback.pcm ), paUnanticipatedHostError );
                if( stream->playback.canMmap )
                    SilenceBuffer( stream );
            }
            if( stream->playback.canMmap )
                ENSURE_( alsa_snd_pcm_start( stream->playback.pcm ), paUnanticipatedHostError );
        }
        else
            ENSURE_( alsa_snd_pcm_prepare( stream->playback.pcm ), paUnanticipatedHostError );
    }
    if( stream->capture.pcm && !stream->pcmsSynced )
    {
        ENSURE_( alsa_snd_pcm_prepare( stream->capture.pcm ), paUnanticipatedHostError );
        /* For a blocking stream we want to start capture as well, since nothing will happen otherwise */
        ENSURE_( alsa_snd_pcm_start( stream->capture.pcm ), paUnanticipatedHostError );
    }

end:
    return result;
error:
    goto end;
}

/** Utility function for determining if pcms are in running state.
 *
 */
#if 0
static int IsRunning( PaAlsaStream *stream )
{
    int result = 0;

    PA_ENSURE( PaUnixMutex_Lock( &stream->stateMtx ) );
    if( stream->capture.pcm )
    {
        snd_pcm_state_t capture_state = alsa_snd_pcm_state( stream->capture.pcm );

        if( capture_state == SND_PCM_STATE_RUNNING || capture_state == SND_PCM_STATE_XRUN
                || capture_state == SND_PCM_STATE_DRAINING )
        {
            result = 1;
            goto end;
        }
    }

    if( stream->playback.pcm )
    {
        snd_pcm_state_t playback_state = alsa_snd_pcm_state( stream->playback.pcm );

        if( playback_state == SND_PCM_STATE_RUNNING || playback_state == SND_PCM_STATE_XRUN
                || playback_state == SND_PCM_STATE_DRAINING )
        {
            result = 1;
            goto end;
        }
    }

end:
    ASSERT_CALL_( PaUnixMutex_Unlock( &stream->stateMtx ), paNoError );
    return result;
error:
    goto error;
}
#endif

static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaAlsaStream* stream = (PaAlsaStream*)s;
    int streamStarted = 0;  /* So we can know whether we need to take the stream down */

    /* Ready the processor */
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );

    /* Set now, so we can test for activity further down */
    stream->isActive = 1;

    if( stream->callbackMode )
    {
        PA_ENSURE( PaUnixThread_New( &stream->thread, &CallbackThreadFunc, stream, 1., stream->rtSched ) );
    }
    else
    {
        PA_ENSURE( AlsaStart( stream, 0 ) );
        streamStarted = 1;
    }

end:
    return result;
error:
    if( streamStarted )
    {
        AbortStream( stream );
    }
    stream->isActive = 0;

    goto end;
}

/** Stop PCM handle, either softly or abruptly.
 */
static PaError AlsaStop( PaAlsaStream *stream, int abort )
{
    PaError result = paNoError;
    /* XXX: alsa_snd_pcm_drain tends to lock up, avoid it until we find out more */
    abort = 1;
    /*
    if( stream->capture.pcm && !strcmp( Pa_GetDeviceInfo( stream->capture.device )->name,
                "dmix" ) )
    {
        abort = 1;
    }
    else if( stream->playback.pcm && !strcmp( Pa_GetDeviceInfo( stream->playback.device )->name,
                "dmix" ) )
    {
        abort = 1;
    }
    */

    if( abort )
    {
        if( stream->playback.pcm )
        {
            ENSURE_( alsa_snd_pcm_drop( stream->playback.pcm ), paUnanticipatedHostError );
        }
        if( stream->capture.pcm && !stream->pcmsSynced )
        {
            ENSURE_( alsa_snd_pcm_drop( stream->capture.pcm ), paUnanticipatedHostError );
        }

        PA_DEBUG(( "%s: Dropped frames\n", __FUNCTION__ ));
    }
    else
    {
        if( stream->playback.pcm )
        {
            ENSURE_( alsa_snd_pcm_nonblock( stream->playback.pcm, 0 ), paUnanticipatedHostError );
            if( alsa_snd_pcm_drain( stream->playback.pcm ) < 0 )
            {
                PA_DEBUG(( "%s: Draining playback handle failed!\n", __FUNCTION__ ));
            }
        }
        if( stream->capture.pcm && !stream->pcmsSynced )
        {
            /* We don't need to retrieve any remaining frames */
            if( alsa_snd_pcm_drain( stream->capture.pcm ) < 0 )
            {
                PA_DEBUG(( "%s: Draining capture handle failed!\n", __FUNCTION__ ));
            }
        }
    }

end:
    return result;
error:
    goto end;
}

/** Stop or abort stream.
 *
 * If a stream is in callback mode we will have to inspect whether the background thread has
 * finished, or we will have to take it out. In either case we join the thread before
 * returning. In blocking mode, we simply tell ALSA to stop abruptly (abort) or finish
 * buffers (drain)
 *
 * Stream will be considered inactive (!PaAlsaStream::isActive) after a call to this function
 */
static PaError RealStop( PaAlsaStream *stream, int abort )
{
    PaError result = paNoError;

    /* First deal with the callback thread, cancelling and/or joining
     * it if necessary
     */
    if( stream->callbackMode )
    {
        PaError threadRes;
        stream->callbackAbort = abort;

        if( !abort )
        {
            PA_DEBUG(( "Stopping callback\n" ));
        }
        PA_ENSURE( PaUnixThread_Terminate( &stream->thread, !abort, &threadRes ) );
        if( threadRes != paNoError )
        {
            PA_DEBUG(( "Callback thread returned: %d\n", threadRes ));
        }
#if 0
        if( watchdogRes != paNoError )
            PA_DEBUG(( "Watchdog thread returned: %d\n", watchdogRes ));
#endif

        stream->callback_finished = 0;
    }
    else
    {
        PA_ENSURE( AlsaStop( stream, abort ) );
    }

    stream->isActive = 0;

end:
    return result;

error:
    goto end;
}

static PaError StopStream( PaStream *s )
{
    return RealStop( (PaAlsaStream *) s, 0 );
}

static PaError AbortStream( PaStream *s )
{
    return RealStop( (PaAlsaStream * ) s, 1 );
}

/** The stream is considered stopped before StartStream, or AFTER a call to Abort/StopStream (callback
 * returning !paContinue is not considered)
 *
 */
static PaError IsStreamStopped( PaStream *s )
{
    PaAlsaStream *stream = (PaAlsaStream *)s;

    /* callback_finished indicates we need to join callback thread (ie. in Abort/StopStream) */
    return !IsStreamActive( s ) && !stream->callback_finished;
}

static PaError IsStreamActive( PaStream *s )
{
    PaAlsaStream *stream = (PaAlsaStream*)s;
    return stream->isActive;
}

static PaTime GetStreamTime( PaStream *s )
{
    PaAlsaStream *stream = (PaAlsaStream*)s;

    snd_timestamp_t timestamp;
    snd_pcm_status_t* status;
    alsa_snd_pcm_status_alloca( &status );

    /* TODO: what if we have both?  does it really matter? */

    /* TODO: if running in callback mode, this will mean
     * libasound routines are being called from multiple threads.
     * need to verify that libasound is thread-safe. */

    if( stream->capture.pcm )
    {
        alsa_snd_pcm_status( stream->capture.pcm, status );
    }
    else if( stream->playback.pcm )
    {
        alsa_snd_pcm_status( stream->playback.pcm, status );
    }

    alsa_snd_pcm_status_get_tstamp( status, &timestamp );
    return timestamp.tv_sec + (PaTime)timestamp.tv_usec / 1e6;
}

static double GetStreamCpuLoad( PaStream* s )
{
    PaAlsaStream *stream = (PaAlsaStream*)s;

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}

/* Set the stream sample rate to a nominal value requested; allow only a defined tolerance range */
static int SetApproximateSampleRate( snd_pcm_t *pcm, snd_pcm_hw_params_t *hwParams, double sampleRate )
{
    PaError result = paNoError;
    unsigned int reqRate, setRate, deviation;

    assert( pcm && hwParams );

    /* The Alsa sample rate is set by integer value; also the actual rate may differ */
    reqRate = setRate = (unsigned int) sampleRate;

    ENSURE_( alsa_snd_pcm_hw_params_set_rate_near( pcm, hwParams, &setRate, NULL ), paUnanticipatedHostError );
    /* The value actually set will be put in 'setRate' (may be way off); check the deviation as a proportion
     * of the requested-rate with reference to the max-deviate-ratio (larger values allow less deviation) */
    deviation = abs( setRate - reqRate );
    if( deviation > 0 && deviation * RATE_MAX_DEVIATE_RATIO > reqRate )
        result = paInvalidSampleRate;

end:
    return result;

error:
    /* Log */
    {
        unsigned int _min = 0, _max = 0;
        int _dir = 0;
        ENSURE_( alsa_snd_pcm_hw_params_get_rate_min( hwParams, &_min, &_dir ), paUnanticipatedHostError );
        ENSURE_( alsa_snd_pcm_hw_params_get_rate_max( hwParams, &_max, &_dir ), paUnanticipatedHostError );
        PA_DEBUG(( "%s: SR min = %u, max = %u, req = %u\n", __FUNCTION__, _min, _max, reqRate ));
    }
    goto end;
}

/* Return exact sample rate in param sampleRate */
static int GetExactSampleRate( snd_pcm_hw_params_t *hwParams, double *sampleRate )
{
    unsigned int num, den = 1;
    int err;

    assert( hwParams );

    err = alsa_snd_pcm_hw_params_get_rate_numden( hwParams, &num, &den );
    *sampleRate = (double) num / den;

    return err;
}

/* Utility functions for blocking/callback interfaces */

/* Atomic restart of stream (we don't want the intermediate state visible) */
static PaError AlsaRestart( PaAlsaStream *stream )
{
    PaError result = paNoError;

    PA_ENSURE( PaUnixMutex_Lock( &stream->stateMtx ) );
    PA_ENSURE( AlsaStop( stream, 0 ) );
    PA_ENSURE( AlsaStart( stream, 0 ) );

    PA_DEBUG(( "%s: Restarted audio\n", __FUNCTION__ ));

error:
    PA_ENSURE( PaUnixMutex_Unlock( &stream->stateMtx ) );

    return result;
}

/** Recover from xrun state.
 *
 */
static PaError PaAlsaStream_HandleXrun( PaAlsaStream *self )
{
    PaError result = paNoError;
    snd_pcm_status_t *st;
    PaTime now = PaUtil_GetTime();
    snd_timestamp_t t;
    int restartAlsa = 0; /* do not restart Alsa by default */

    alsa_snd_pcm_status_alloca( &st );

    if( self->playback.pcm )
    {
        alsa_snd_pcm_status( self->playback.pcm, st );
        if( alsa_snd_pcm_status_get_state( st ) == SND_PCM_STATE_XRUN )
        {
            alsa_snd_pcm_status_get_trigger_tstamp( st, &t );
            self->underrun = now * 1000 - ( (PaTime)t.tv_sec * 1000 + (PaTime)t.tv_usec / 1000 );

            if( !self->playback.canMmap )
            {
                if( alsa_snd_pcm_recover( self->playback.pcm, -EPIPE, 0 ) < 0 )
                {
                    PA_DEBUG(( "%s: [playback] non-MMAP-PCM failed recovering from XRUN, will restart Alsa\n", __FUNCTION__ ));
                    ++ restartAlsa; /* did not manage to recover */
                }
            }
            else
                ++ restartAlsa; /* always restart MMAPed device */
        }
    }
    if( self->capture.pcm )
    {
        alsa_snd_pcm_status( self->capture.pcm, st );
        if( alsa_snd_pcm_status_get_state( st ) == SND_PCM_STATE_XRUN )
        {
            alsa_snd_pcm_status_get_trigger_tstamp( st, &t );
            self->overrun = now * 1000 - ((PaTime) t.tv_sec * 1000 + (PaTime) t.tv_usec / 1000);

            if (!self->capture.canMmap)
            {
                if (alsa_snd_pcm_recover( self->capture.pcm, -EPIPE, 0 ) < 0)
                {
                    PA_DEBUG(( "%s: [capture] non-MMAP-PCM failed recovering from XRUN, will restart Alsa\n", __FUNCTION__ ));
                    ++ restartAlsa; /* did not manage to recover */
                }
            }
            else
                ++ restartAlsa; /* always restart MMAPed device */
        }
    }

    if( restartAlsa )
    {
        PA_DEBUG(( "%s: restarting Alsa to recover from XRUN\n", __FUNCTION__ ));
        PA_ENSURE( AlsaRestart( self ) );
    }

end:
    return result;
error:
    goto end;
}

/** Decide if we should continue polling for specified direction, eventually adjust the poll timeout.
 *
 */
static PaError ContinuePoll( const PaAlsaStream *stream, StreamDirection streamDir, int *pollTimeout, int *continuePoll )
{
    PaError result = paNoError;
    snd_pcm_sframes_t delay, margin;
    int err;
    const PaAlsaStreamComponent *component = NULL, *otherComponent = NULL;

    *continuePoll = 1;

    if( StreamDirection_In == streamDir )
    {
        component = &stream->capture;
        otherComponent = &stream->playback;
    }
    else
    {
        component = &stream->playback;
        otherComponent = &stream->capture;
    }

    /* ALSA docs say that negative delay should indicate xrun, but in my experience alsa_snd_pcm_delay returns -EPIPE */
    if( ( err = alsa_snd_pcm_delay( otherComponent->pcm, &delay ) ) < 0 )
    {
        if( err == -EPIPE )
        {
            /* Xrun */
            *continuePoll = 0;
            goto error;
        }

        ENSURE_( err, paUnanticipatedHostError );
    }

    if( StreamDirection_Out == streamDir )
    {
        /* Number of eligible frames before capture overrun */
        delay = otherComponent->alsaBufferSize - delay;
    }
    margin = delay - otherComponent->framesPerPeriod / 2;

    if( margin < 0 )
    {
        PA_DEBUG(( "%s: Stopping poll for %s\n", __FUNCTION__, StreamDirection_In == streamDir ? "capture" : "playback" ));
        *continuePoll = 0;
    }
    else if( margin < otherComponent->framesPerPeriod )
    {
        *pollTimeout = CalculatePollTimeout( stream, margin );
        PA_DEBUG(( "%s: Trying to poll again for %s frames, pollTimeout: %d\n",
                    __FUNCTION__, StreamDirection_In == streamDir ? "capture" : "playback", *pollTimeout ));
    }

error:
    return result;
}

/* Callback interface */

static void OnExit( void *data )
{
    PaAlsaStream *stream = (PaAlsaStream *) data;

    assert( data );

    PaUtil_ResetCpuLoadMeasurer( &stream->cpuLoadMeasurer );

    stream->callback_finished = 1;  /* Let the outside world know stream was stopped in callback */
    PA_DEBUG(( "%s: Stopping ALSA handles\n", __FUNCTION__ ));
    AlsaStop( stream, stream->callbackAbort );

    PA_DEBUG(( "%s: Stoppage\n", __FUNCTION__ ));

    /* Eventually notify user all buffers have played */
    if( stream->streamRepresentation.streamFinishedCallback )
    {
        stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
    }
    stream->isActive = 0;
}

static void CalculateTimeInfo( PaAlsaStream *stream, PaStreamCallbackTimeInfo *timeInfo )
{
    snd_pcm_status_t *capture_status, *playback_status;
    snd_timestamp_t capture_timestamp, playback_timestamp;
    PaTime capture_time = 0., playback_time = 0.;

    alsa_snd_pcm_status_alloca( &capture_status );
    alsa_snd_pcm_status_alloca( &playback_status );

    if( stream->capture.pcm )
    {
        snd_pcm_sframes_t capture_delay;

        alsa_snd_pcm_status( stream->capture.pcm, capture_status );
        alsa_snd_pcm_status_get_tstamp( capture_status, &capture_timestamp );

        capture_time = capture_timestamp.tv_sec +
            ( (PaTime)capture_timestamp.tv_usec / 1000000.0 );
        timeInfo->currentTime = capture_time;

        capture_delay = alsa_snd_pcm_status_get_delay( capture_status );
        timeInfo->inputBufferAdcTime = timeInfo->currentTime -
            (PaTime)capture_delay / stream->streamRepresentation.streamInfo.sampleRate;
    }
    if( stream->playback.pcm )
    {
        snd_pcm_sframes_t playback_delay;

        alsa_snd_pcm_status( stream->playback.pcm, playback_status );
        alsa_snd_pcm_status_get_tstamp( playback_status, &playback_timestamp );

        playback_time = playback_timestamp.tv_sec +
            ((PaTime)playback_timestamp.tv_usec / 1000000.0);

        if( stream->capture.pcm ) /* Full duplex */
        {
            /* Hmm, we have both a playback and a capture timestamp.
             * Hopefully they are the same... */
            if( fabs( capture_time - playback_time ) > 0.01 )
                PA_DEBUG(( "Capture time and playback time differ by %f\n", fabs( capture_time-playback_time ) ));
        }
        else
            timeInfo->currentTime = playback_time;

        playback_delay = alsa_snd_pcm_status_get_delay( playback_status );
        timeInfo->outputBufferDacTime = timeInfo->currentTime +
            (PaTime)playback_delay / stream->streamRepresentation.streamInfo.sampleRate;
    }
}

/** Called after buffer processing is finished.
 *
 * A number of mmapped frames is committed, it is possible that an xrun has occurred in the meantime.
 *
 * @param numFrames The number of frames that has been processed
 * @param xrun Return whether an xrun has occurred
 */
static PaError PaAlsaStreamComponent_EndProcessing( PaAlsaStreamComponent *self, unsigned long numFrames, int *xrun )
{
    PaError result = paNoError;
    int res = 0;

    /* @concern FullDuplex It is possible that only one direction is marked ready after polling, and processed
     * afterwards
     */
    if( !self->ready )
        goto end;

    if( !self->canMmap && StreamDirection_Out == self->streamDir )
    {
        /* Play sound */
        if( self->hostInterleaved )
            res = alsa_snd_pcm_writei( self->pcm, self->nonMmapBuffer, numFrames );
        else
        {
            void *bufs[self->numHostChannels];
            int bufsize = alsa_snd_pcm_format_size( self->nativeFormat, self->framesPerPeriod + 1 );
            unsigned char *buffer = self->nonMmapBuffer;
            int i;
            for( i = 0; i < self->numHostChannels; ++i )
            {
                bufs[i] = buffer;
                buffer += bufsize;
            }
            res = alsa_snd_pcm_writen( self->pcm, bufs, numFrames );
        }
    }

    if( self->canMmap )
        res = alsa_snd_pcm_mmap_commit( self->pcm, self->offset, numFrames );

    if( res == -EPIPE || res == -ESTRPIPE )
    {
        *xrun = 1;
    }
    else
    {
        ENSURE_( res, paUnanticipatedHostError );
    }

end:
error:
    return result;
}

/* Extract buffer from channel area */
static unsigned char *ExtractAddress( const snd_pcm_channel_area_t *area, snd_pcm_uframes_t offset )
{
    return (unsigned char *) area->addr + ( area->first + offset * area->step ) / 8;
}

/** Do necessary adaption between user and host channels.
 *
    @concern ChannelAdaption Adapting between user and host channels can involve silencing unused channels and
    duplicating mono information if host outputs come in pairs.
 */
static PaError PaAlsaStreamComponent_DoChannelAdaption( PaAlsaStreamComponent *self, PaUtilBufferProcessor *bp, int numFrames )
{
    PaError result = paNoError;
    unsigned char *p;
    int i;
    int unusedChans = self->numHostChannels - self->numUserChannels;
    unsigned char *src, *dst;
    int convertMono = ( self->numHostChannels % 2 ) == 0 && ( self->numUserChannels % 2 ) != 0;

    assert( StreamDirection_Out == self->streamDir );

    if( self->hostInterleaved )
    {
        int swidth = alsa_snd_pcm_format_size( self->nativeFormat, 1 );
        unsigned char *buffer = self->canMmap ? ExtractAddress( self->channelAreas, self->offset ) : self->nonMmapBuffer;

        /* Start after the last user channel */
        p = buffer + self->numUserChannels * swidth;

        if( convertMono )
        {
            /* Convert the last user channel into stereo pair */
            src = buffer + ( self->numUserChannels - 1 ) * swidth;
            for( i = 0; i < numFrames; ++i )
            {
                dst = src + swidth;
                memcpy( dst, src, swidth );
                src += self->numHostChannels * swidth;
            }

            /* Don't touch the channel we just wrote to */
            p += swidth;
            --unusedChans;
        }

        if( unusedChans > 0 )
        {
            /* Silence unused output channels */
            for( i = 0; i < numFrames; ++i )
            {
                memset( p, 0, swidth * unusedChans );
                p += self->numHostChannels * swidth;
            }
        }
    }
    else
    {
        /* We extract the last user channel */
        if( convertMono )
        {
            ENSURE_( alsa_snd_pcm_area_copy( self->channelAreas + self->numUserChannels, self->offset, self->channelAreas +
                    ( self->numUserChannels - 1 ), self->offset, numFrames, self->nativeFormat ), paUnanticipatedHostError );
            --unusedChans;
        }
        if( unusedChans > 0 )
        {
            alsa_snd_pcm_areas_silence( self->channelAreas + ( self->numHostChannels - unusedChans ), self->offset, unusedChans, numFrames,
                    self->nativeFormat );
        }
    }

error:
    return result;
}

static PaError PaAlsaStream_EndProcessing( PaAlsaStream *self, unsigned long numFrames, int *xrunOccurred )
{
    PaError result = paNoError;
    int xrun = 0;

    if( self->capture.pcm )
    {
        PA_ENSURE( PaAlsaStreamComponent_EndProcessing( &self->capture, numFrames, &xrun ) );
    }
    if( self->playback.pcm )
    {
        if( self->playback.numHostChannels > self->playback.numUserChannels )
        {
            PA_ENSURE( PaAlsaStreamComponent_DoChannelAdaption( &self->playback, &self->bufferProcessor, numFrames ) );
        }
        PA_ENSURE( PaAlsaStreamComponent_EndProcessing( &self->playback, numFrames, &xrun ) );
    }

error:
    *xrunOccurred = xrun;
    return result;
}

/** Update the number of available frames.
 *
 */
static PaError PaAlsaStreamComponent_GetAvailableFrames( PaAlsaStreamComponent *self, unsigned long *numFrames, int *xrunOccurred )
{
    PaError result = paNoError;
    snd_pcm_sframes_t framesAvail = alsa_snd_pcm_avail_update( self->pcm );
    *xrunOccurred = 0;

    if( -EPIPE == framesAvail )
    {
        *xrunOccurred = 1;
        framesAvail = 0;
    }
    else
    {
        ENSURE_( framesAvail, paUnanticipatedHostError );
    }

    *numFrames = framesAvail;

error:
    return result;
}

/** Fill in pollfd objects.
 */
static PaError PaAlsaStreamComponent_BeginPolling( PaAlsaStreamComponent* self, struct pollfd* pfds )
{
    PaError result = paNoError;
    int ret = alsa_snd_pcm_poll_descriptors( self->pcm, pfds, self->nfds );
    (void)ret;  /* Prevent unused variable warning if asserts are turned off */
    assert( ret == self->nfds );

    self->ready = 0;

    return result;
}

/** Examine results from poll().
 *
 * @param pfds pollfds to inspect
 * @param shouldPoll Should we continue to poll
 * @param xrun Has an xrun occurred
 */
static PaError PaAlsaStreamComponent_EndPolling( PaAlsaStreamComponent* self, struct pollfd* pfds, int* shouldPoll, int* xrun )
{
    PaError result = paNoError;
    unsigned short revents;

    ENSURE_( alsa_snd_pcm_poll_descriptors_revents( self->pcm, pfds, self->nfds, &revents ), paUnanticipatedHostError );
    if( revents != 0 )
    {
        if( revents & POLLERR )
        {
            *xrun = 1;
        }
        else if( revents & POLLHUP )
        {
            *xrun = 1;
            PA_DEBUG(( "%s: revents has POLLHUP, processing as XRUN\n", __FUNCTION__ ));
        }
        else
            self->ready = 1;

        *shouldPoll = 0;
    }
    else /* (A zero revent occurred) */
        /* Work around an issue with Alsa older than 1.0.16 using some plugins (eg default with plug + dmix) where
         * POLLIN or POLLOUT are zeroed by Alsa-lib if _mmap_avail() is a few frames short of avail_min at period
         * boundary, possibly due to erratic dma interrupts at period boundary?  Treat as a valid event.
         */
        if( self->useReventFix )
        {
            self->ready = 1;
            *shouldPoll = 0;
        }

error:
    return result;
}

/** Return the number of available frames for this stream.
 *
 * @concern FullDuplex The minimum available for the two directions is calculated, it might be desirable to ignore
 * one direction however (not marked ready from poll), so this is controlled by queryCapture and queryPlayback.
 *
 * @param queryCapture Check available for capture
 * @param queryPlayback Check available for playback
 * @param available The returned number of frames
 * @param xrunOccurred Return whether an xrun has occurred
 */
static PaError PaAlsaStream_GetAvailableFrames( PaAlsaStream *self, int queryCapture, int queryPlayback, unsigned long
        *available, int *xrunOccurred )
{
    PaError result = paNoError;
    unsigned long captureFrames, playbackFrames;
    *xrunOccurred = 0;

    assert( queryCapture || queryPlayback );

    if( queryCapture )
    {
        assert( self->capture.pcm );
        PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( &self->capture, &captureFrames, xrunOccurred ) );
        if( *xrunOccurred )
        {
            goto end;
        }
    }
    if( queryPlayback )
    {
        assert( self->playback.pcm );
        PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( &self->playback, &playbackFrames, xrunOccurred ) );
        if( *xrunOccurred )
        {
            goto end;
        }
    }

    if( queryCapture && queryPlayback )
    {
        *available = PA_MIN( captureFrames, playbackFrames );
        /*PA_DEBUG(("capture: %lu, playback: %lu, combined: %lu\n", captureFrames, playbackFrames, *available));*/
    }
    else if( queryCapture )
    {
        *available = captureFrames;
    }
    else
    {
        *available = playbackFrames;
    }

end:
error:
    return result;
}

/** Wait for and report available buffer space from ALSA.
 *
 * Unless ALSA reports a minimum of frames available for I/O, we poll the ALSA filedescriptors for more.
 * Both of these operations can uncover xrun conditions.
 *
 * @concern Xruns Both polling and querying available frames can report an xrun condition.
 *
 * @param framesAvail Return the number of available frames
 * @param xrunOccurred Return whether an xrun has occurred
 */
static PaError PaAlsaStream_WaitForFrames( PaAlsaStream *self, unsigned long *framesAvail, int *xrunOccurred )
{
    PaError result = paNoError;
    int pollPlayback = self->playback.pcm != NULL, pollCapture = self->capture.pcm != NULL;
    int pollTimeout = self->pollTimeout;
    int xrun = 0, timeouts = 0;
    int pollResults;

    assert( self );
    assert( framesAvail );

    if( !self->callbackMode )
    {
        /* In blocking mode we will only wait if necessary */
        PA_ENSURE( PaAlsaStream_GetAvailableFrames( self, self->capture.pcm != NULL, self->playback.pcm != NULL,
                    framesAvail, &xrun ) );
        if( xrun )
        {
            goto end;
        }

        if( *framesAvail > 0 )
        {
            /* Mark pcms ready from poll */
            if( self->capture.pcm )
                self->capture.ready = 1;
            if( self->playback.pcm )
                self->playback.ready = 1;

            goto end;
        }
    }

    while( pollPlayback || pollCapture )
    {
        int totalFds = 0;
        struct pollfd *capturePfds = NULL, *playbackPfds = NULL;

#ifdef PTHREAD_CANCELED
        pthread_testcancel();
#endif
        if( pollCapture )
        {
            capturePfds = self->pfds;
            PA_ENSURE( PaAlsaStreamComponent_BeginPolling( &self->capture, capturePfds ) );
            totalFds += self->capture.nfds;
        }
        if( pollPlayback )
        {
            /* self->pfds is in effect an array of fds; if necessary, index past the capture fds */
            playbackPfds = self->pfds + (pollCapture ? self->capture.nfds : 0);
            PA_ENSURE( PaAlsaStreamComponent_BeginPolling( &self->playback, playbackPfds ) );
            totalFds += self->playback.nfds;
        }

#ifdef PTHREAD_CANCELED
        if( self->callbackMode )
        {
            /* To allow 'Abort' to terminate the callback thread, enable cancelability just for poll() (& disable after) */
            pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, NULL );
        }
#endif

        pollResults = poll( self->pfds, totalFds, pollTimeout );

#ifdef PTHREAD_CANCELED
        if( self->callbackMode )
        {
            pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
        }
#endif

        if( pollResults < 0 )
        {
            /*  XXX: Depend on preprocessor condition? */
            if( errno == EINTR )
            {
                /* gdb */
                Pa_Sleep( 1 ); /* avoid hot loop */
                continue;
            }

            /* TODO: Add macro for checking system calls */
            PA_ENSURE( paInternalError );
        }
        else if( pollResults == 0 )
        {
           /* Suspended, paused or failed device can provide 0 poll results. To avoid deadloop in such situation
            * we simply run counter 'timeouts' which detects 0 poll result and accumulates. As soon as 2048 timouts (around 2 seconds)
            * are achieved we simply fail function with paTimedOut to notify waiting methods that device is not capable
            * of providing audio data anymore and needs some corresponding recovery action.
            * Note that 'timeouts' is reset to 0 if poll() managed to return non 0 results.
            */

            /*PA_DEBUG(( "%s: poll == 0 results, timed out, %d times left\n", __FUNCTION__, 2048 - timeouts ));*/
            ++ timeouts;
            if( timeouts > 1 ) /* sometimes device times out, but normally once, so we do not sleep any time */
            {
                Pa_Sleep( 1 ); /* avoid hot loop */
            }
            /* not else ! */
            if( timeouts >= 2048 ) /* audio device not working, shall return error to notify waiters */
            {
                *framesAvail = 0; /* no frames available for processing */
                xrun = 1; /* try recovering device */

                PA_DEBUG(( "%s: poll timed out\n", __FUNCTION__, timeouts ));
                goto end;/*PA_ENSURE( paTimedOut );*/
            }
        }
        else if( pollResults > 0 )
        {
            /* reset timouts counter */
            timeouts = 0;

            /* check the return status of our pfds */
            if( pollCapture )
            {
                PA_ENSURE( PaAlsaStreamComponent_EndPolling( &self->capture, capturePfds, &pollCapture, &xrun ) );
            }
            if( pollPlayback )
            {
                PA_ENSURE( PaAlsaStreamComponent_EndPolling( &self->playback, playbackPfds, &pollPlayback, &xrun ) );
            }
            if( xrun )
            {
                break;
            }
        }

        /* @concern FullDuplex If only one of two pcms is ready we may want to compromise between the two.
         * If there is less than half a period's worth of samples left of frames in the other pcm's buffer we will
         * stop polling.
         */
        if( self->capture.pcm && self->playback.pcm )
        {
            if( pollCapture && !pollPlayback )
            {
                PA_ENSURE( ContinuePoll( self, StreamDirection_In, &pollTimeout, &pollCapture ) );
            }
            else if( pollPlayback && !pollCapture )
            {
                PA_ENSURE( ContinuePoll( self, StreamDirection_Out, &pollTimeout, &pollPlayback ) );
            }
        }
    }

    if( !xrun )
    {
        /* Get the number of available frames for the pcms that are marked ready.
         * @concern FullDuplex If only one direction is marked ready (from poll), the number of frames available for
         * the other direction is returned. Output is normally preferred over capture however, so capture frames may be
         * discarded to avoid overrun unless paNeverDropInput is specified.
         */
        int captureReady = self->capture.pcm ? self->capture.ready : 0,
            playbackReady = self->playback.pcm ? self->playback.ready : 0;
        PA_ENSURE( PaAlsaStream_GetAvailableFrames( self, captureReady, playbackReady, framesAvail, &xrun ) );

        if( self->capture.pcm && self->playback.pcm )
        {
            if( !self->playback.ready && !self->neverDropInput )
            {
                /* Drop input, a period's worth */
                assert( self->capture.ready );
                PaAlsaStreamComponent_EndProcessing( &self->capture, PA_MIN( self->capture.framesPerPeriod,
                            *framesAvail ), &xrun );
                *framesAvail = 0;
                self->capture.ready = 0;
            }
        }
        else if( self->capture.pcm )
            assert( self->capture.ready );
        else
            assert( self->playback.ready );
    }

end:
error:
    if( xrun )
    {
        /* Recover from the xrun state */
        PA_ENSURE( PaAlsaStream_HandleXrun( self ) );
        *framesAvail = 0;
    }
    else
    {
        if( 0 != *framesAvail )
        {
            /* If we're reporting frames eligible for processing, one of the handles better be ready */
            PA_UNLESS( self->capture.ready || self->playback.ready, paInternalError );
        }
    }
    *xrunOccurred = xrun;

    return result;
}

/** Register per-channel ALSA buffer information with buffer processor.
 *
 * Mmapped buffer space is acquired from ALSA, and registered with the buffer processor. Differences between the
 * number of host and user channels is taken into account.
 *
 * @param numFrames On entrance the number of requested frames, on exit the number of contiguously accessible frames.
 */
static PaError PaAlsaStreamComponent_RegisterChannels( PaAlsaStreamComponent* self, PaUtilBufferProcessor* bp,
        unsigned long* numFrames, int* xrun )
{
    PaError result = paNoError;
    const snd_pcm_channel_area_t *areas, *area;
    void (*setChannel)(PaUtilBufferProcessor *, unsigned int, void *, unsigned int) =
        StreamDirection_In == self->streamDir ? PaUtil_SetInputChannel : PaUtil_SetOutputChannel;
    unsigned char *buffer, *p;
    int i;
    unsigned long framesAvail;

    /* This _must_ be called before mmap_begin */
    PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( self, &framesAvail, xrun ) );
    if( *xrun )
    {
        *numFrames = 0;
        goto end;
    }

    if( self->canMmap )
    {
        ENSURE_( alsa_snd_pcm_mmap_begin( self->pcm, &areas, &self->offset, numFrames ), paUnanticipatedHostError );
        /* @concern ChannelAdaption Buffer address is recorded so we can do some channel adaption later */
        self->channelAreas = (snd_pcm_channel_area_t *)areas;
    }
    else
    {
        unsigned int bufferSize = self->numHostChannels * alsa_snd_pcm_format_size( self->nativeFormat, *numFrames );
        if( bufferSize > self->nonMmapBufferSize )
        {
            self->nonMmapBuffer = realloc( self->nonMmapBuffer, ( self->nonMmapBufferSize = bufferSize ) );
            if( !self->nonMmapBuffer )
            {
                result = paInsufficientMemory;
                goto error;
            }
        }
    }

    if( self->hostInterleaved )
    {
        int swidth = alsa_snd_pcm_format_size( self->nativeFormat, 1 );

        p = buffer = self->canMmap ? ExtractAddress( areas, self->offset ) : self->nonMmapBuffer;
        for( i = 0; i < self->numUserChannels; ++i )
        {
            /* We're setting the channels up to userChannels, but the stride will be hostChannels samples */
            setChannel( bp, i, p, self->numHostChannels );
            p += swidth;
        }
    }
    else
    {
        if( self->canMmap )
        {
            for( i = 0; i < self->numUserChannels; ++i )
            {
                area = areas + i;
                buffer = ExtractAddress( area, self->offset );
                setChannel( bp, i, buffer, 1 );
            }
        }
        else
        {
            unsigned int buf_per_ch_size = self->nonMmapBufferSize / self->numHostChannels;
            buffer = self->nonMmapBuffer;
            for( i = 0; i < self->numUserChannels; ++i )
            {
                setChannel( bp, i, buffer, 1 );
                buffer += buf_per_ch_size;
            }
        }
    }

    if( !self->canMmap && StreamDirection_In == self->streamDir )
    {
        /* Read sound */
        int res;
        if( self->hostInterleaved )
            res = alsa_snd_pcm_readi( self->pcm, self->nonMmapBuffer, *numFrames );
        else
        {
            void *bufs[self->numHostChannels];
            unsigned int buf_per_ch_size = self->nonMmapBufferSize / self->numHostChannels;
            unsigned char *buffer = self->nonMmapBuffer;
            int i;
            for( i = 0; i < self->numHostChannels; ++i )
            {
                bufs[i] = buffer;
                buffer += buf_per_ch_size;
            }
            res = alsa_snd_pcm_readn( self->pcm, bufs, *numFrames );
        }
        if( res == -EPIPE || res == -ESTRPIPE )
        {
            *xrun = 1;
            *numFrames = 0;
        }
    }

end:
error:
    return result;
}

/** Initiate buffer processing.
 *
 * ALSA buffers are registered with the PA buffer processor and the buffer size (in frames) set.
 *
 * @concern FullDuplex If both directions are being processed, the minimum amount of frames for the two directions is
 * calculated.
 *
 * @param numFrames On entrance the number of available frames, on exit the number of received frames
 * @param xrunOccurred Return whether an xrun has occurred
 */
static PaError PaAlsaStream_SetUpBuffers( PaAlsaStream* self, unsigned long* numFrames, int* xrunOccurred )
{
    PaError result = paNoError;
    unsigned long captureFrames = ULONG_MAX, playbackFrames = ULONG_MAX, commonFrames = 0;
    int xrun = 0;

    if( *xrunOccurred )
    {
        *numFrames = 0;
        return result;
    }
    /* If we got here at least one of the pcm's should be marked ready */
    PA_UNLESS( self->capture.ready || self->playback.ready, paInternalError );

    /* Extract per-channel ALSA buffer pointers and register them with the buffer processor.
     * It is possible that a direction is not marked ready however, because it is out of sync with the other.
     */
    if( self->capture.pcm && self->capture.ready )
    {
        captureFrames = *numFrames;
        PA_ENSURE( PaAlsaStreamComponent_RegisterChannels( &self->capture, &self->bufferProcessor, &captureFrames,
                    &xrun ) );
    }
    if( self->playback.pcm && self->playback.ready )
    {
        playbackFrames = *numFrames;
        PA_ENSURE( PaAlsaStreamComponent_RegisterChannels( &self->playback, &self->bufferProcessor, &playbackFrames,
                    &xrun ) );
    }
    if( xrun )
    {
        /* Nothing more to do */
        assert( 0 == commonFrames );
        goto end;
    }

    commonFrames = PA_MIN( captureFrames, playbackFrames );
    /* assert( commonFrames <= *numFrames ); */
    if( commonFrames > *numFrames )
    {
        /* Hmmm ... how come there are more frames available than we requested!? Blah. */
        PA_DEBUG(( "%s: Common available frames are reported to be more than number requested: %lu, %lu, callbackMode: %d\n", __FUNCTION__,
                    commonFrames, *numFrames, self->callbackMode ));
        if( self->capture.pcm )
        {
            PA_DEBUG(( "%s: captureFrames: %lu, capture.ready: %d\n", __FUNCTION__, captureFrames, self->capture.ready ));
        }
        if( self->playback.pcm )
        {
            PA_DEBUG(( "%s: playbackFrames: %lu, playback.ready: %d\n", __FUNCTION__, playbackFrames, self->playback.ready ));
        }

        commonFrames = 0;
        goto end;
    }

    /* Inform PortAudio of the number of frames we got.
     * @concern FullDuplex We might be experiencing underflow in either end; if its an input underflow, we go on
     * with output. If its output underflow however, depending on the paNeverDropInput flag, we may want to simply
     * discard the excess input or call the callback with paOutputOverflow flagged.
     */
    if( self->capture.pcm )
    {
        if( self->capture.ready )
        {
            PaUtil_SetInputFrameCount( &self->bufferProcessor, commonFrames );
        }
        else
        {
            /* We have input underflow */
            PaUtil_SetNoInput( &self->bufferProcessor );
        }
    }
    if( self->playback.pcm )
    {
        if( self->playback.ready )
        {
            PaUtil_SetOutputFrameCount( &self->bufferProcessor, commonFrames );
        }
        else
        {
            /* We have output underflow, but keeping input data (paNeverDropInput) */
            assert( self->neverDropInput );
            assert( self->capture.pcm != NULL );
            PA_DEBUG(( "%s: Setting output buffers to NULL\n", __FUNCTION__ ));
            PaUtil_SetNoOutput( &self->bufferProcessor );
        }
    }

end:
    *numFrames = commonFrames;
error:
    if( xrun )
    {
        PA_ENSURE( PaAlsaStream_HandleXrun( self ) );
        *numFrames = 0;
    }
    *xrunOccurred = xrun;

    return result;
}

/** Callback thread's function.
 *
 * Roughly, the workflow can be described in the following way: The number of available frames that can be processed
 * directly is obtained from ALSA, we then request as much directly accessible memory as possible within this amount
 * from ALSA. The buffer memory is registered with the PA buffer processor and processing is carried out with
 * PaUtil_EndBufferProcessing. Finally, the number of processed frames is reported to ALSA. The processing can
 * happen in several iterations untill we have consumed the known number of available frames (or an xrun is detected).
 */
static void *CallbackThreadFunc( void *userData )
{
    PaError result = paNoError;
    PaAlsaStream *stream = (PaAlsaStream*) userData;
    PaStreamCallbackTimeInfo timeInfo = {0, 0, 0};
    snd_pcm_sframes_t startThreshold = 0;
    int callbackResult = paContinue;
    PaStreamCallbackFlags cbFlags = 0;  /* We might want to keep state across iterations */
    int streamStarted = 0;

    assert( stream );
    /* Not implemented */
    assert( !stream->primeBuffers );

    /* Execute OnExit when exiting */
    pthread_cleanup_push( &OnExit, stream );
#ifdef PTHREAD_CANCELED
    /* 'Abort' will use thread cancellation to terminate the callback thread, but the Alsa-lib functions
     * are NOT cancel-safe, (and can end up in an inconsistent state).  So, disable cancelability for
     * the thread here, and just re-enable it for the poll() in PaAlsaStream_WaitForFrames(). */
    pthread_testcancel();
    pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
#endif

    /* @concern StreamStart If the output is being primed the output pcm needs to be prepared, otherwise the
     * stream is started immediately. The latter involves signaling the waiting main thread.
     */
    if( stream->primeBuffers )
    {
        snd_pcm_sframes_t avail;

        if( stream->playback.pcm )
            ENSURE_( alsa_snd_pcm_prepare( stream->playback.pcm ), paUnanticipatedHostError );
        if( stream->capture.pcm && !stream->pcmsSynced )
            ENSURE_( alsa_snd_pcm_prepare( stream->capture.pcm ), paUnanticipatedHostError );

        /* We can't be certain that the whole ring buffer is available for priming, but there should be
         * at least one period */
        avail = alsa_snd_pcm_avail_update( stream->playback.pcm );
        startThreshold = avail - (avail % stream->playback.framesPerPeriod);
        assert( startThreshold >= stream->playback.framesPerPeriod );
    }
    else
    {
        PA_ENSURE( PaUnixThread_PrepareNotify( &stream->thread ) );
        /* Buffer will be zeroed */
        PA_ENSURE( AlsaStart( stream, 0 ) );
        PA_ENSURE( PaUnixThread_NotifyParent( &stream->thread ) );

        streamStarted = 1;
    }

    while( 1 )
    {
        unsigned long framesAvail, framesGot;
        int xrun = 0;

#ifdef PTHREAD_CANCELED
        pthread_testcancel();
#endif

        /* @concern StreamStop if the main thread has requested a stop and the stream has not been effectively
         * stopped we signal this condition by modifying callbackResult (we'll want to flush buffered output).
         */
        if( PaUnixThread_StopRequested( &stream->thread ) && paContinue == callbackResult )
        {
            PA_DEBUG(( "Setting callbackResult to paComplete\n" ));
            callbackResult = paComplete;
        }

        if( paContinue != callbackResult )
        {
            stream->callbackAbort = ( paAbort == callbackResult );
            if( stream->callbackAbort ||
                    /** @concern BlockAdaption: Go on if adaption buffers are empty */
                    PaUtil_IsBufferProcessorOutputEmpty( &stream->bufferProcessor ) )
            {
                goto end;
            }

            PA_DEBUG(( "%s: Flushing buffer processor\n", __FUNCTION__ ));
            /* There is still buffered output that needs to be processed */
        }

        /* Wait for data to become available, this comes down to polling the ALSA file descriptors untill we have
         * a number of available frames.
         */
        PA_ENSURE( PaAlsaStream_WaitForFrames( stream, &framesAvail, &xrun ) );
        if( xrun )
        {
            assert( 0 == framesAvail );
            continue;

            /* XXX: Report xruns to the user? A situation is conceivable where the callback is never invoked due
             * to constant xruns, it might be desirable to notify the user of this.
             */
        }

        /* Consume buffer space. Once we have a number of frames available for consumption we must retrieve the
         * mmapped buffers from ALSA, this is contiguously accessible memory however, so we may receive smaller
         * portions at a time than is available as a whole. Therefore we should be prepared to process several
         * chunks successively. The buffers are passed to the PA buffer processor.
         */
        while( framesAvail > 0 )
        {
            xrun = 0;

            /** @concern Xruns Under/overflows are to be reported to the callback */
            if( stream->underrun > 0.0 )
            {
                cbFlags |= paOutputUnderflow;
                stream->underrun = 0.0;
            }
            if( stream->overrun > 0.0 )
            {
                cbFlags |= paInputOverflow;
                stream->overrun = 0.0;
            }
            if( stream->capture.pcm && stream->playback.pcm )
            {
                /** @concern FullDuplex It's possible that only one direction is being processed to avoid an
                 * under- or overflow, this should be reported correspondingly */
                if( !stream->capture.ready )
                {
                    cbFlags |= paInputUnderflow;
                    PA_DEBUG(( "%s: Input underflow\n", __FUNCTION__ ));
                }
                else if( !stream->playback.ready )
                {
                    cbFlags |= paOutputOverflow;
                    PA_DEBUG(( "%s: Output overflow\n", __FUNCTION__ ));
                }
            }

#if 0
            CallbackUpdate( &stream->threading );
#endif

            CalculateTimeInfo( stream, &timeInfo );
            PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, cbFlags );
            cbFlags = 0;

            /* CPU load measurement should include processing activity external to the stream callback */
            PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

            framesGot = framesAvail;
            if( paUtilFixedHostBufferSize == stream->bufferProcessor.hostBufferSizeMode )
            {
                /* We've committed to a fixed host buffer size, stick to that */
                framesGot = framesGot >= stream->maxFramesPerHostBuffer ? stream->maxFramesPerHostBuffer : 0;
            }
            else
            {
                /* We've committed to an upper bound on the size of host buffers */
                assert( paUtilBoundedHostBufferSize == stream->bufferProcessor.hostBufferSizeMode );
                framesGot = PA_MIN( framesGot, stream->maxFramesPerHostBuffer );
            }
            PA_ENSURE( PaAlsaStream_SetUpBuffers( stream, &framesGot, &xrun ) );
            /* Check the host buffer size against the buffer processor configuration */
            framesAvail -= framesGot;

            if( framesGot > 0 )
            {
                assert( !xrun );
                PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );
                PA_ENSURE( PaAlsaStream_EndProcessing( stream, framesGot, &xrun ) );
            }
            PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesGot );

            if( 0 == framesGot )
            {
                /* Go back to polling for more frames */
                break;
            }

            if( paContinue != callbackResult )
                break;
        }
    }

end:
    ; /* Hack to fix "label at end of compound statement" error caused by pthread_cleanup_pop(1) macro. */
    /* Match pthread_cleanup_push */
    pthread_cleanup_pop( 1 );

    PA_DEBUG(( "%s: Thread %d exiting\n ", __FUNCTION__, pthread_self() ));
    PaUnixThreading_EXIT( result );

error:
    PA_DEBUG(( "%s: Thread %d is canceled due to error %d\n ", __FUNCTION__, pthread_self(), result ));
    goto end;
}

/* Blocking interface */

static PaError ReadStream( PaStream* s, void *buffer, unsigned long frames )
{
    PaError result = paNoError;
    PaAlsaStream *stream = (PaAlsaStream*)s;
    unsigned long framesGot, framesAvail;
    void *userBuffer;
    snd_pcm_t *save = stream->playback.pcm;

    assert( stream );

    PA_UNLESS( stream->capture.pcm, paCanNotReadFromAnOutputOnlyStream );

    /* Disregard playback */
    stream->playback.pcm = NULL;

    if( stream->overrun > 0. )
    {
        result = paInputOverflowed;
        stream->overrun = 0.0;
    }

    if( stream->capture.userInterleaved )
    {
        userBuffer = buffer;
    }
    else
    {
        /* Copy channels into local array */
        userBuffer = stream->capture.userBuffers;
        memcpy( userBuffer, buffer, sizeof (void *) * stream->capture.numUserChannels );
    }

    /* Start stream if in prepared state */
    if( alsa_snd_pcm_state( stream->capture.pcm ) == SND_PCM_STATE_PREPARED )
    {
        ENSURE_( alsa_snd_pcm_start( stream->capture.pcm ), paUnanticipatedHostError );
    }

    while( frames > 0 )
    {
        int xrun = 0;
        PA_ENSURE( PaAlsaStream_WaitForFrames( stream, &framesAvail, &xrun ) );
        framesGot = PA_MIN( framesAvail, frames );

        PA_ENSURE( PaAlsaStream_SetUpBuffers( stream, &framesGot, &xrun ) );
        if( framesGot > 0 )
        {
            framesGot = PaUtil_CopyInput( &stream->bufferProcessor, &userBuffer, framesGot );
            PA_ENSURE( PaAlsaStream_EndProcessing( stream, framesGot, &xrun ) );
            frames -= framesGot;
        }
    }

end:
    stream->playback.pcm = save;
    return result;
error:
    goto end;
}

static PaError WriteStream( PaStream* s, const void *buffer, unsigned long frames )
{
    PaError result = paNoError;
    signed long err;
    PaAlsaStream *stream = (PaAlsaStream*)s;
    snd_pcm_uframes_t framesGot, framesAvail;
    const void *userBuffer;
    snd_pcm_t *save = stream->capture.pcm;

    assert( stream );

    PA_UNLESS( stream->playback.pcm, paCanNotWriteToAnInputOnlyStream );

    /* Disregard capture */
    stream->capture.pcm = NULL;

    if( stream->underrun > 0. )
    {
        result = paOutputUnderflowed;
        stream->underrun = 0.0;
    }

    if( stream->playback.userInterleaved )
        userBuffer = buffer;
    else /* Copy channels into local array */
    {
        userBuffer = stream->playback.userBuffers;
        memcpy( (void *)userBuffer, buffer, sizeof (void *) * stream->playback.numUserChannels );
    }

    while( frames > 0 )
    {
        int xrun = 0;
        snd_pcm_uframes_t hwAvail;

        PA_ENSURE( PaAlsaStream_WaitForFrames( stream, &framesAvail, &xrun ) );
        framesGot = PA_MIN( framesAvail, frames );

        PA_ENSURE( PaAlsaStream_SetUpBuffers( stream, &framesGot, &xrun ) );
        if( framesGot > 0 )
        {
            framesGot = PaUtil_CopyOutput( &stream->bufferProcessor, &userBuffer, framesGot );
            PA_ENSURE( PaAlsaStream_EndProcessing( stream, framesGot, &xrun ) );
            frames -= framesGot;
        }

        /* Start stream after one period of samples worth */

        /* Frames residing in buffer */
        PA_ENSURE( err = GetStreamWriteAvailable( stream ) );
        framesAvail = err;
        hwAvail = stream->playback.alsaBufferSize - framesAvail;

        if( alsa_snd_pcm_state( stream->playback.pcm ) == SND_PCM_STATE_PREPARED &&
                hwAvail >= stream->playback.framesPerPeriod )
        {
            ENSURE_( alsa_snd_pcm_start( stream->playback.pcm ), paUnanticipatedHostError );
        }
    }

end:
    stream->capture.pcm = save;
    return result;
error:
    goto end;
}

/* Return frames available for reading. In the event of an overflow, the capture pcm will be restarted */
static signed long GetStreamReadAvailable( PaStream* s )
{
    PaError result = paNoError;
    PaAlsaStream *stream = (PaAlsaStream*)s;
    unsigned long avail;
    int xrun;

    PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( &stream->capture, &avail, &xrun ) );
    if( xrun )
    {
        PA_ENSURE( PaAlsaStream_HandleXrun( stream ) );
        PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( &stream->capture, &avail, &xrun ) );
        if( xrun )
            PA_ENSURE( paInputOverflowed );
    }

    return (signed long)avail;

error:
    return result;
}

static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaError result = paNoError;
    PaAlsaStream *stream = (PaAlsaStream*)s;
    unsigned long avail;
    int xrun;

    PA_ENSURE( PaAlsaStreamComponent_GetAvailableFrames( &stream->playback, &avail, &xrun ) );
    if( xrun )
    {
        snd_pcm_sframes_t savail;

        PA_ENSURE( PaAlsaStream_HandleXrun( stream ) );
        savail = alsa_snd_pcm_avail_update( stream->playback.pcm );

        /* savail should not contain -EPIPE now, since PaAlsaStream_HandleXrun will only prepare the pcm */
        ENSURE_( savail, paUnanticipatedHostError );

        avail = (unsigned long) savail;
    }

    return (signed long)avail;

error:
    return result;
}

/* Extensions */

void PaAlsa_InitializeStreamInfo( PaAlsaStreamInfo *info )
{
    info->size = sizeof (PaAlsaStreamInfo);
    info->hostApiType = paALSA;
    info->version = 1;
    info->deviceString = NULL;
}

void PaAlsa_EnableRealtimeScheduling( PaStream *s, int enable )
{
    PaAlsaStream *stream = (PaAlsaStream *) s;
    stream->rtSched = enable;
}

#if 0
void PaAlsa_EnableWatchdog( PaStream *s, int enable )
{
    PaAlsaStream *stream = (PaAlsaStream *) s;
    stream->thread.useWatchdog = enable;
}
#endif

static PaError GetAlsaStreamPointer( PaStream* s, PaAlsaStream** stream )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation* hostApi;
    PaAlsaHostApiRepresentation* alsaHostApi;

    PA_ENSURE( PaUtil_ValidateStreamPointer( s ) );
    PA_ENSURE( PaUtil_GetHostApiRepresentation( &hostApi, paALSA ) );
    alsaHostApi = (PaAlsaHostApiRepresentation*)hostApi;

    PA_UNLESS( PA_STREAM_REP( s )->streamInterface == &alsaHostApi->callbackStreamInterface
            || PA_STREAM_REP( s )->streamInterface == &alsaHostApi->blockingStreamInterface,
        paIncompatibleStreamHostApi );

    *stream = (PaAlsaStream*)s;
error:
    return paNoError;
}

PaError PaAlsa_GetStreamInputCard( PaStream* s, int* card )
{
    PaAlsaStream *stream;
    PaError result = paNoError;
    snd_pcm_info_t* pcmInfo;

    PA_ENSURE( GetAlsaStreamPointer( s, &stream ) );

    /* XXX: More descriptive error? */
    PA_UNLESS( stream->capture.pcm, paDeviceUnavailable );

    alsa_snd_pcm_info_alloca( &pcmInfo );
    PA_ENSURE( alsa_snd_pcm_info( stream->capture.pcm, pcmInfo ) );
    *card = alsa_snd_pcm_info_get_card( pcmInfo );

error:
    return result;
}

PaError PaAlsa_GetStreamOutputCard( PaStream* s, int* card )
{
    PaAlsaStream *stream;
    PaError result = paNoError;
    snd_pcm_info_t* pcmInfo;

    PA_ENSURE( GetAlsaStreamPointer( s, &stream ) );

    /* XXX: More descriptive error? */
    PA_UNLESS( stream->playback.pcm, paDeviceUnavailable );

    alsa_snd_pcm_info_alloca( &pcmInfo );
    PA_ENSURE( alsa_snd_pcm_info( stream->playback.pcm, pcmInfo ) );
    *card = alsa_snd_pcm_info_get_card( pcmInfo );

error:
    return result;
}

PaError PaAlsa_SetRetriesBusy( int retries )
{
    busyRetries_ = retries;
    return paNoError;
}
#endif

#if 0
/*
 * $Id:$
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 * AudioScience HPI implementation by Fred Gleason, Ludwig Schwardt and
 * Eliot Blennerhassett
 *
 * Copyright (c) 2003 Fred Gleason <fredg@salemradiolabs.com>
 * Copyright (c) 2005,2006 Ludwig Schwardt <schwardt@sun.ac.za>
 * Copyright (c) 2011 Eliot Blennerhassett <eblennerhassett@audioscience.com>
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2008 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/*
 * Modification History
 * 12/2003 - Initial version
 * 09/2005 - v19 version [rewrite]
 */

/** @file
 @ingroup hostapi_src
 @brief Host API implementation supporting AudioScience cards
        via the Linux HPI interface.

 <h3>Overview</h3>

 This is a PortAudio implementation for the AudioScience HPI Audio API
 on the Linux platform. AudioScience makes a range of audio adapters customised
 for the broadcasting industry, with support for both Windows and Linux.
 More information on their products can be found on their website:

     http://www.audioscience.com

 Documentation for the HPI API can be found at:

     http://www.audioscience.com/internet/download/sdk/hpi_usermanual_html/html/index.html

 The Linux HPI driver itself (a kernel module + library) can be downloaded from:

     http://www.audioscience.com/internet/download/linux_drivers.htm

 <h3>Implementation strategy</h3>

 *Note* Ideally, AudioScience cards should be handled by the PortAudio ALSA
 implementation on Linux, as ALSA is the preferred Linux soundcard API. The existence
 of this host API implementation might therefore seem a bit flawed. Unfortunately, at
 the time of the creation of this implementation (June 2006), the PA ALSA implementation
 could not make use of the existing AudioScience ALSA driver. PA ALSA uses the
 "memory-mapped" (mmap) ALSA access mode to interact with the ALSA library, while the
 AudioScience ALSA driver only supports the "read-write" access mode. The appropriate
 solution to this problem is to add "read-write" support to PortAudio ALSA, thereby
 extending the range of soundcards it supports (AudioScience cards are not the only
 ones with this problem). Given the author's limited knowledge of ALSA and the
 simplicity of the HPI API, the second-best solution was born...

 The following mapping between HPI and PA was followed:
 HPI subsystem => PortAudio host API
 HPI adapter => nothing specific
 HPI stream => PortAudio device

 Each HPI stream is either input or output (not both), and can support
 different channel counts, sampling rates and sample formats. It is therefore
 a more natural fit to a PA device. A PA stream can therefore combine two
 HPI streams (one input and one output) into a "full-duplex" stream. These
 HPI streams can even be on different physical adapters. The two streams ought to be
 sample-synchronised when they reside on the same adapter, as most AudioScience adapters
 derive their ADC and DAC clocks from one master clock. When combining two adapters
 into one full-duplex stream, however, the use of a word clock connection between the
 adapters is strongly recommended.

 The HPI interface is inherently blocking, making use of read and write calls to
 transfer data between user buffers and driver buffers. The callback interface therefore
 requires a helper thread ("callback engine") which periodically transfers data (one thread
 per PA stream, in fact). The current implementation explicitly sleeps via Pa_Sleep() until
 enough samples can be transferred (select() or poll() would be better, but currently seems
 impossible...). The thread implementation makes use of the Unix thread helper functions
 and some pthread calls here and there. If a unified PA thread exists, this host API
 implementation might also compile on Windows, as this is the only real Linux-specific
 part of the code.

 There is no inherent fixed buffer size in the HPI interface, as in some other host APIs.
 The PortAudio implementation contains a buffer that is allocated during OpenStream and
 used to transfer data between the callback and the HPI driver buffer. The size of this
 buffer is quite flexible and is derived from latency suggestions and matched to the
 requested callback buffer size as far as possible. It can become quite huge, as the
 AudioScience cards are typically geared towards higher-latency applications and contain
 large hardware buffers.

 The HPI interface natively supports most common sample formats and sample rates (some
 conversion is done on the adapter itself).

 Stream time is measured based on the number of processed frames, which is adjusted by the
 number of frames currently buffered by the HPI driver.

 There is basic support for detecting overflow and underflow. The HPI interface does not
 explicitly indicate this, so thresholds on buffer levels are used in combination with
 stream state. Recovery from overflow and underflow is left to the PA client.

 Blocking streams are also implemented. It makes use of the same polling routines that
 the callback interface uses, in order to prevent the allocation of variable-sized
 buffers during reading and writing. The framesPerBuffer parameter is therefore still
 relevant, and this can be increased in the blocking case to improve efficiency.

 The implementation contains extensive reporting macros (slightly modified PA_ENSURE and
 PA_UNLESS versions) and a useful stream dump routine to provide debugging feedback.

 Output buffer priming via the user callback (i.e. paPrimeOutputBuffersUsingStreamCallback
 and friends) is not implemented yet. All output is primed with silence.
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>          /* strlen() */
#include <pthread.h>         /* pthreads and friends */
#include <assert.h>          /* assert */
#include <math.h>            /* ceil, floor */

#include <asihpi/hpi.h>      /* HPI API */

// (amalg) #include "portaudio.h"       /* PortAudio API */
// (amalg) #include "pa_util.h"         /* PA_DEBUG, other small utilities */
// (amalg) #include "pa_unix_util.h"    /* Unix threading utilities */
// (amalg) #include "pa_allocation.h"   /* Group memory allocation */
// (amalg) #include "pa_hostapi.h"      /* Host API structs */
// (amalg) #include "pa_stream.h"       /* Stream interface structs */
// (amalg) #include "pa_cpuload.h"      /* CPU load measurer */
// (amalg) #include "pa_process.h"      /* Buffer processor */
// (amalg) #include "pa_converters.h"   /* PaUtilZeroer */
// (amalg) #include "pa_debugprint.h"

/* -------------------------------------------------------------------------- */

/*
 * Defines
 */

/* Error reporting and assertions */

/** Evaluate expression, and return on any PortAudio errors */
#define PA_ENSURE_(expr) \
    do { \
        PaError paError = (expr); \
        if( UNLIKELY( paError < paNoError ) ) \
        { \
            PA_DEBUG(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = paError; \
            goto error; \
        } \
    } while (0);

/** Assert expression, else return the provided PaError */
#define PA_UNLESS_(expr, paError) \
    do { \
        if( UNLIKELY( (expr) == 0 ) ) \
        { \
            PA_DEBUG(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = (paError); \
            goto error; \
        } \
    } while( 0 );

/** Check return value of HPI function, and map it to PaError */
#define PA_ASIHPI_UNLESS_(expr, paError) \
    do { \
        hpi_err_t hpiError = (expr); \
        /* If HPI error occurred */ \
        if( UNLIKELY( hpiError ) ) \
        { \
	    char szError[256]; \
	    HPI_GetErrorText( hpiError, szError ); \
	    PA_DEBUG(( "HPI error %d occurred: %s\n", hpiError, szError )); \
	    /* This message will always be displayed, even if debug info is disabled */ \
            PA_DEBUG(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            if( (paError) == paUnanticipatedHostError ) \
	    { \
	        PA_DEBUG(( "Host error description: %s\n", szError )); \
	        /* PaUtil_SetLastHostErrorInfo should only be used in the main thread */ \
	        if( pthread_equal( pthread_self(), paUnixMainThread ) ) \
                { \
		    PaUtil_SetLastHostErrorInfo( paInDevelopment, hpiError, szError ); \
                } \
	    } \
	    /* If paNoError is specified, continue as usual */ \
            /* (useful if you only want to print out the debug messages above) */ \
	    if( (paError) < 0 ) \
	    { \
	        result = (paError); \
	        goto error; \
	    } \
        } \
    } while( 0 );

/** Report HPI error code and text */
#define PA_ASIHPI_REPORT_ERROR_(hpiErrorCode) \
    do { \
        char szError[256]; \
        HPI_GetErrorText( hpiError, szError ); \
        PA_DEBUG(( "HPI error %d occurred: %s\n", hpiError, szError )); \
        /* PaUtil_SetLastHostErrorInfo should only be used in the main thread */ \
        if( pthread_equal( pthread_self(), paUnixMainThread ) ) \
	{ \
	    PaUtil_SetLastHostErrorInfo( paInDevelopment, (hpiErrorCode), szError ); \
	} \
    } while( 0 );

/* Defaults */

/** Sample formats available natively on AudioScience hardware */
#define PA_ASIHPI_AVAILABLE_FORMATS_ (paFloat32 | paInt32 | paInt24 | paInt16 | paUInt8)
/** Enable background bus mastering (BBM) for buffer transfers, if available (see HPI docs) */
#define PA_ASIHPI_USE_BBM_ 1
/** Minimum number of frames in HPI buffer (for either data or available space).
 If buffer contains less data/space, it indicates xrun or completion. */
#define PA_ASIHPI_MIN_FRAMES_ 1152
/** Minimum polling interval in milliseconds, which determines minimum host buffer size */
#define PA_ASIHPI_MIN_POLLING_INTERVAL_ 10

/* -------------------------------------------------------------------------- */

/*
 * Structures
 */

/** Host API global data */
typedef struct PaAsiHpiHostApiRepresentation
{
    /* PortAudio "base class" - keep the baseRep first! (C-style inheritance) */
    PaUtilHostApiRepresentation baseHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;

    /* implementation specific data goes here */

    PaHostApiIndex hostApiIndex;
}
PaAsiHpiHostApiRepresentation;


/** Device data */
typedef struct PaAsiHpiDeviceInfo
{
    /* PortAudio "base class" - keep the baseRep first! (C-style inheritance) */
    /** Common PortAudio device information */
    PaDeviceInfo baseDeviceInfo;

    /* implementation specific data goes here */

    /** Adapter index */
    uint16_t adapterIndex;
    /** Adapter model number (hex) */
    uint16_t adapterType;
    /** Adapter HW/SW version */
    uint16_t adapterVersion;
    /** Adapter serial number */
    uint32_t adapterSerialNumber;
    /** Stream number */
    uint16_t streamIndex;
    /** 0=Input, 1=Output (HPI streams are either input or output but not both) */
    uint16_t streamIsOutput;
}
PaAsiHpiDeviceInfo;


/** Stream state as defined by PortAudio.
 It seems that the host API implementation has to keep track of the PortAudio stream state.
 Please note that this is NOT the same as the state of the underlying HPI stream. By separating
 these two concepts, a lot of flexibility is gained. There is a rough match between the two,
 of course, but forcing a precise match is difficult. For example, HPI_STATE_DRAINED can occur
 during the Active state of PortAudio (due to underruns) and also during CallBackFinished in
 the case of an output stream. Similarly, HPI_STATE_STOPPED mostly coincides with the Stopped
 PortAudio state, by may also occur in the CallbackFinished state when recording is finished.

 Here is a rough match-up:

 PortAudio state   =>     HPI state
 ---------------          ---------
 Active            =>     HPI_STATE_RECORDING, HPI_STATE_PLAYING, (HPI_STATE_DRAINED)
 Stopped           =>     HPI_STATE_STOPPED
 CallbackFinished  =>     HPI_STATE_STOPPED, HPI_STATE_DRAINED */
typedef enum PaAsiHpiStreamState
{
    paAsiHpiStoppedState=0,
    paAsiHpiActiveState=1,
    paAsiHpiCallbackFinishedState=2
}
PaAsiHpiStreamState;


/** Stream component data (associated with one direction, i.e. either input or output) */
typedef struct PaAsiHpiStreamComponent
{
    /** Device information (HPI handles, etc) */
    PaAsiHpiDeviceInfo *hpiDevice;
    /** Stream handle, as passed to HPI interface. */
    hpi_handle_t hpiStream;
    /** Stream format, as passed to HPI interface */
    struct hpi_format hpiFormat;
    /** Number of bytes per frame, derived from hpiFormat and saved for convenience */
    uint32_t bytesPerFrame;
    /** Size of hardware (on-card) buffer of stream in bytes */
    uint32_t hardwareBufferSize;
    /** Size of host (BBM) buffer of stream in bytes (if used) */
    uint32_t hostBufferSize;
    /** Upper limit on the utilization of output stream buffer (both hardware and host).
     This prevents large latencies in an output-only stream with a potentially huge buffer
     and a fast data generator, which would otherwise keep the hardware buffer filled to
     capacity. See also the "Hardware Buffering=off" option in the AudioScience WAV driver. */
    uint32_t outputBufferCap;
    /** Sample buffer (halfway station between HPI and buffer processor) */
    uint8_t *tempBuffer;
    /** Sample buffer size, in bytes */
    uint32_t tempBufferSize;
}
PaAsiHpiStreamComponent;


/** Stream data */
typedef struct PaAsiHpiStream
{
    /* PortAudio "base class" - keep the baseRep first! (C-style inheritance) */
    PaUtilStreamRepresentation baseStreamRep;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

    PaUtilAllocationGroup *allocations;

    /* implementation specific data goes here */

    /** Separate structs for input and output sides of stream */
    PaAsiHpiStreamComponent *input, *output;

    /** Polling interval (in milliseconds) */
    uint32_t pollingInterval;
    /** Are we running in callback mode? */
    int callbackMode;
    /** Number of frames to transfer at a time to/from HPI */
    unsigned long maxFramesPerHostBuffer;
    /** Indicates that the stream is in the paNeverDropInput mode */
    int neverDropInput;
    /** Contains copy of user buffers, used by blocking interface to transfer non-interleaved data.
     It went here instead of to each stream component, as the stream component buffer setup in
     PaAsiHpi_SetupBuffers doesn't know the stream details such as callbackMode.
     (Maybe a problem later if ReadStream and WriteStream happens concurrently on same stream.) */
    void **blockingUserBufferCopy;

    /* Thread-related variables */

    /** Helper thread which will deliver data to user callback */
    PaUnixThread thread;
    /** PortAudio stream state (Active/Stopped/CallbackFinished) */
    volatile sig_atomic_t state;
    /** Hard abort, i.e. drop frames? */
    volatile sig_atomic_t callbackAbort;
    /** True if stream stopped via exiting callback with paComplete/paAbort flag
     (as opposed to explicit call to StopStream/AbortStream) */
    volatile sig_atomic_t callbackFinished;
}
PaAsiHpiStream;


/** Stream state information, collected together for convenience */
typedef struct PaAsiHpiStreamInfo
{
    /** HPI stream state (HPI_STATE_STOPPED, HPI_STATE_PLAYING, etc.) */
    uint16_t state;
    /** Size (in bytes) of recording/playback data buffer in HPI driver */
    uint32_t bufferSize;
    /** Amount of data (in bytes) available in the buffer */
    uint32_t dataSize;
    /** Number of frames played/recorded since last stream reset */
    uint32_t frameCounter;
    /** Amount of data (in bytes) in hardware (on-card) buffer.
     This differs from dataSize if bus mastering (BBM) is used, which introduces another
     driver-level buffer to which dataSize/bufferSize then refers. */
    uint32_t auxDataSize;
    /** Total number of data frames currently buffered by HPI driver (host + hw buffers) */
    uint32_t totalBufferedData;
    /** Size of immediately available data (for input) or space (for output) in frames.
     This only checks the first-level buffer (typically host buffer). This amount can be
     transferred immediately. */
    uint32_t availableFrames;
    /** Indicates that hardware buffer is getting too full */
    int overflow;
    /** Indicates that hardware buffer is getting too empty */
    int underflow;
}
PaAsiHpiStreamInfo;

/* -------------------------------------------------------------------------- */

/*
 * Function prototypes
 */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

    /* The only exposed function in the entire host API implementation */
    PaError PaAsiHpi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );

/* Stream prototypes */
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream **s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError CloseStream( PaStream *s );
static PaError StartStream( PaStream *s );
static PaError StopStream( PaStream *s );
static PaError AbortStream( PaStream *s );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *s );
static PaTime GetStreamTime( PaStream *s );
static double GetStreamCpuLoad( PaStream *s );

/* Blocking prototypes */
static PaError ReadStream( PaStream *s, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream *s, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream *s );
static signed long GetStreamWriteAvailable( PaStream *s );

/* Callback prototypes */
static void *CallbackThreadFunc( void *userData );

/* Functions specific to this API */
static PaError PaAsiHpi_BuildDeviceList( PaAsiHpiHostApiRepresentation *hpiHostApi );
static uint16_t PaAsiHpi_PaToHpiFormat( PaSampleFormat paFormat );
static PaSampleFormat PaAsiHpi_HpiToPaFormat( uint16_t hpiFormat );
static PaError PaAsiHpi_CreateFormat( struct PaUtilHostApiRepresentation *hostApi,
                                      const PaStreamParameters *parameters, double sampleRate,
                                      PaAsiHpiDeviceInfo **hpiDevice, struct hpi_format *hpiFormat );
static PaError PaAsiHpi_OpenInput( struct PaUtilHostApiRepresentation *hostApi,
                                   const PaAsiHpiDeviceInfo *hpiDevice, const struct hpi_format *hpiFormat,
                                   hpi_handle_t *hpiStream );
static PaError PaAsiHpi_OpenOutput( struct PaUtilHostApiRepresentation *hostApi,
                                    const PaAsiHpiDeviceInfo *hpiDevice, const struct hpi_format *hpiFormat,
                                    hpi_handle_t *hpiStream );
static PaError PaAsiHpi_GetStreamInfo( PaAsiHpiStreamComponent *streamComp, PaAsiHpiStreamInfo *info );
static void PaAsiHpi_StreamComponentDump( PaAsiHpiStreamComponent *streamComp, PaAsiHpiStream *stream );
static void PaAsiHpi_StreamDump( PaAsiHpiStream *stream );
static PaError PaAsiHpi_SetupBuffers( PaAsiHpiStreamComponent *streamComp, uint32_t pollingInterval,
                                      unsigned long framesPerPaHostBuffer, PaTime suggestedLatency );
static PaError PaAsiHpi_PrimeOutputWithSilence( PaAsiHpiStream *stream );
static PaError PaAsiHpi_StartStream( PaAsiHpiStream *stream, int outputPrimed );
static PaError PaAsiHpi_StopStream( PaAsiHpiStream *stream, int abort );
static PaError PaAsiHpi_ExplicitStop( PaAsiHpiStream *stream, int abort );
static void PaAsiHpi_OnThreadExit( void *userData );
static PaError PaAsiHpi_WaitForFrames( PaAsiHpiStream *stream, unsigned long *framesAvail,
                                       PaStreamCallbackFlags *cbFlags );
static void PaAsiHpi_CalculateTimeInfo( PaAsiHpiStream *stream, PaStreamCallbackTimeInfo *timeInfo );
static PaError PaAsiHpi_BeginProcessing( PaAsiHpiStream* stream, unsigned long* numFrames,
        PaStreamCallbackFlags *cbFlags );
static PaError PaAsiHpi_EndProcessing( PaAsiHpiStream *stream, unsigned long numFrames,
                                       PaStreamCallbackFlags *cbFlags );

/* ==========================================================================
 * ============================= IMPLEMENTATION =============================
 * ========================================================================== */

/* --------------------------- Host API Interface --------------------------- */

/** Enumerate all PA devices (= HPI streams).
 This compiles a list of all HPI adapters, and registers a PA device for each input and
 output stream it finds. Most errors are ignored, as missing or erroneous devices are
 simply skipped.

 @param hpiHostApi Pointer to HPI host API struct

 @return PortAudio error code (only paInsufficientMemory in practice)
 */
static PaError PaAsiHpi_BuildDeviceList( PaAsiHpiHostApiRepresentation *hpiHostApi )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *hostApi = &hpiHostApi->baseHostApiRep;
    PaHostApiInfo *baseApiInfo = &hostApi->info;
    PaAsiHpiDeviceInfo *hpiDeviceList;
    int numAdapters;
    hpi_err_t hpiError = 0;
    int i, j, deviceCount = 0, deviceIndex = 0;

    assert( hpiHostApi );

    /* Errors not considered critical here (subsystem may report 0 devices), but report them */
    /* in debug mode. */
    PA_ASIHPI_UNLESS_( HPI_SubSysGetNumAdapters( NULL, &numAdapters), paNoError );

    for( i=0; i < numAdapters; ++i )
    {
        uint16_t inStreams, outStreams;
        uint16_t version;
        uint32_t serial;
        uint16_t type;
        uint32_t idx;

        hpiError = HPI_SubSysGetAdapter(NULL, i, &idx, &type);
        if (hpiError)
            continue;

        /* Try to open adapter */
        hpiError = HPI_AdapterOpen( NULL, idx );
        /* Report error and skip to next device on failure */
        if( hpiError )
        {
            PA_ASIHPI_REPORT_ERROR_( hpiError );
            continue;
        }
        hpiError = HPI_AdapterGetInfo( NULL, idx, &outStreams, &inStreams,
					&version, &serial, &type );
        /* Skip to next device on failure */
        if( hpiError )
        {
            PA_ASIHPI_REPORT_ERROR_( hpiError );
            continue;
        }
        else
        {
            /* Assign default devices if available and increment device count */
            if( (baseApiInfo->defaultInputDevice == paNoDevice) && (inStreams > 0) )
                baseApiInfo->defaultInputDevice = deviceCount;
            deviceCount += inStreams;
            if( (baseApiInfo->defaultOutputDevice == paNoDevice) && (outStreams > 0) )
                baseApiInfo->defaultOutputDevice = deviceCount;
            deviceCount += outStreams;
        }
    }

    /* Register any discovered devices */
    if( deviceCount > 0 )
    {
        /* Memory allocation */
        PA_UNLESS_( hostApi->deviceInfos = (PaDeviceInfo**) PaUtil_GroupAllocateMemory(
                                               hpiHostApi->allocations, sizeof(PaDeviceInfo*) * deviceCount ),
                    paInsufficientMemory );
        /* Allocate all device info structs in a contiguous block */
        PA_UNLESS_( hpiDeviceList = (PaAsiHpiDeviceInfo*) PaUtil_GroupAllocateMemory(
                                        hpiHostApi->allocations, sizeof(PaAsiHpiDeviceInfo) * deviceCount ),
                    paInsufficientMemory );

        /* Now query devices again for information */
        for( i=0; i < numAdapters; ++i )
        {
            uint16_t inStreams, outStreams;
            uint16_t version;
            uint32_t serial;
            uint16_t type;
            uint32_t idx;

            hpiError = HPI_SubSysGetAdapter( NULL, i, &idx, &type );
            if (hpiError)
                continue;

            /* Assume adapter is still open from previous round */
            hpiError = HPI_AdapterGetInfo( NULL, idx,
                                           &outStreams, &inStreams, &version, &serial, &type );
            /* Report error and skip to next device on failure */
            if( hpiError )
            {
                PA_ASIHPI_REPORT_ERROR_( hpiError );
                continue;
            }
            else
            {
                PA_DEBUG(( "Found HPI Adapter ID=%4X Idx=%d #In=%d #Out=%d S/N=%d HWver=%c%d DSPver=%03d\n",
                           type, idx, inStreams, outStreams, serial,
                           ((version>>3)&0xf)+'A',                  /* Hw version major */
                           version&0x7,                             /* Hw version minor */
                           ((version>>13)*100)+((version>>7)&0x3f)  /* DSP code version */
                         ));
            }

            /* First add all input streams as devices */
            for( j=0; j < inStreams; ++j )
            {
                PaAsiHpiDeviceInfo *hpiDevice = &hpiDeviceList[deviceIndex];
                PaDeviceInfo *baseDeviceInfo = &hpiDevice->baseDeviceInfo;
                char srcName[72];
                char *deviceName;

                memset( hpiDevice, 0, sizeof(PaAsiHpiDeviceInfo) );
                /* Set implementation-specific device details */
                hpiDevice->adapterIndex = idx;
                hpiDevice->adapterType = type;
                hpiDevice->adapterVersion = version;
                hpiDevice->adapterSerialNumber = serial;
                hpiDevice->streamIndex = j;
                hpiDevice->streamIsOutput = 0;
                /* Set common PortAudio device stats */
                baseDeviceInfo->structVersion = 2;
                /* Make sure name string is owned by API info structure */
                sprintf( srcName,
                         "Adapter %d (%4X) - Input Stream %d", i+1, type, j+1 );
                PA_UNLESS_( deviceName = (char *) PaUtil_GroupAllocateMemory(
                                             hpiHostApi->allocations, strlen(srcName) + 1 ), paInsufficientMemory );
                strcpy( deviceName, srcName );
                baseDeviceInfo->name = deviceName;
                baseDeviceInfo->hostApi = hpiHostApi->hostApiIndex;
                baseDeviceInfo->maxInputChannels = HPI_MAX_CHANNELS;
                baseDeviceInfo->maxOutputChannels = 0;
                /* Default latency values for interactive performance */
                baseDeviceInfo->defaultLowInputLatency = 0.01;
                baseDeviceInfo->defaultLowOutputLatency = -1.0;
                /* Default latency values for robust non-interactive applications (eg. playing sound files) */
                baseDeviceInfo->defaultHighInputLatency = 0.2;
                baseDeviceInfo->defaultHighOutputLatency = -1.0;
                /* HPI interface can actually handle any sampling rate to 1 Hz accuracy,
                * so this default is as good as any */
                baseDeviceInfo->defaultSampleRate = 44100;

                /* Store device in global PortAudio list */
                hostApi->deviceInfos[deviceIndex++] = (PaDeviceInfo *) hpiDevice;
            }

            /* Now add all output streams as devices (I know, the repetition is painful) */
            for( j=0; j < outStreams; ++j )
            {
                PaAsiHpiDeviceInfo *hpiDevice = &hpiDeviceList[deviceIndex];
                PaDeviceInfo *baseDeviceInfo = &hpiDevice->baseDeviceInfo;
                char srcName[72];
                char *deviceName;

                memset( hpiDevice, 0, sizeof(PaAsiHpiDeviceInfo) );
                /* Set implementation-specific device details */
                hpiDevice->adapterIndex = idx;
                hpiDevice->adapterType = type;
                hpiDevice->adapterVersion = version;
                hpiDevice->adapterSerialNumber = serial;
                hpiDevice->streamIndex = j;
                hpiDevice->streamIsOutput = 1;
                /* Set common PortAudio device stats */
                baseDeviceInfo->structVersion = 2;
                /* Make sure name string is owned by API info structure */
                sprintf( srcName,
                         "Adapter %d (%4X) - Output Stream %d", i+1, type, j+1 );
                PA_UNLESS_( deviceName = (char *) PaUtil_GroupAllocateMemory(
                                             hpiHostApi->allocations, strlen(srcName) + 1 ), paInsufficientMemory );
                strcpy( deviceName, srcName );
                baseDeviceInfo->name = deviceName;
                baseDeviceInfo->hostApi = hpiHostApi->hostApiIndex;
                baseDeviceInfo->maxInputChannels = 0;
                baseDeviceInfo->maxOutputChannels = HPI_MAX_CHANNELS;
                /* Default latency values for interactive performance. */
                baseDeviceInfo->defaultLowInputLatency = -1.0;
                baseDeviceInfo->defaultLowOutputLatency = 0.01;
                /* Default latency values for robust non-interactive applications (eg. playing sound files). */
                baseDeviceInfo->defaultHighInputLatency = -1.0;
                baseDeviceInfo->defaultHighOutputLatency = 0.2;
                /* HPI interface can actually handle any sampling rate to 1 Hz accuracy,
                * so this default is as good as any */
                baseDeviceInfo->defaultSampleRate = 44100;

                /* Store device in global PortAudio list */
                hostApi->deviceInfos[deviceIndex++] = (PaDeviceInfo *) hpiDevice;
            }
        }
    }

    /* Finally acknowledge checked devices */
    baseApiInfo->deviceCount = deviceIndex;

error:
    return result;
}


/** Initialize host API implementation.
 This is the only function exported beyond this file. It is called by PortAudio to initialize
 the host API. It stores API info, finds and registers all devices, and sets up callback and
 blocking interfaces.

 @param hostApi Pointer to host API struct

 @param hostApiIndex Index of current (HPI) host API

 @return PortAudio error code
 */
PaError PaAsiHpi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaAsiHpiHostApiRepresentation *hpiHostApi = NULL;
    PaHostApiInfo *baseApiInfo;

    /* Try to initialize HPI subsystem */
    if (!HPI_SubSysCreate())
    {
        /* the V19 development docs say that if an implementation
         * detects that it cannot be used, it should return a NULL
         * interface and paNoError */
        PA_DEBUG(( "Could not open HPI interface\n" ));

	*hostApi = NULL;
        return paNoError;
    }
    else
    {
        uint32_t hpiVersion;
        PA_ASIHPI_UNLESS_( HPI_SubSysGetVersionEx( NULL, &hpiVersion ), paUnanticipatedHostError );
        PA_DEBUG(( "HPI interface v%d.%02d.%02d\n",
                   hpiVersion >> 16,  (hpiVersion >> 8) & 0x0F, (hpiVersion & 0x0F) ));
    }

    /* Allocate host API structure */
    PA_UNLESS_( hpiHostApi = (PaAsiHpiHostApiRepresentation*) PaUtil_AllocateMemory(
                                 sizeof(PaAsiHpiHostApiRepresentation) ), paInsufficientMemory );
    PA_UNLESS_( hpiHostApi->allocations = PaUtil_CreateAllocationGroup(), paInsufficientMemory );

    hpiHostApi->hostApiIndex = hostApiIndex;

    *hostApi = &hpiHostApi->baseHostApiRep;
    baseApiInfo = &((*hostApi)->info);
    /* Fill in common API details */
    baseApiInfo->structVersion = 1;
    baseApiInfo->type = paAudioScienceHPI;
    baseApiInfo->name = "AudioScience HPI";
    baseApiInfo->deviceCount = 0;
    baseApiInfo->defaultInputDevice = paNoDevice;
    baseApiInfo->defaultOutputDevice = paNoDevice;

    PA_ENSURE_( PaAsiHpi_BuildDeviceList( hpiHostApi ) );

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &hpiHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &hpiHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    /* Store identity of main thread */
    PA_ENSURE_( PaUnixThreading_Initialize() );

    return result;
error:
    if (hpiHostApi)
        PaUtil_FreeMemory( hpiHostApi );
    return result;
}


/** Terminate host API implementation.
 This closes all HPI adapters and frees the HPI subsystem. It also frees the host API struct
 memory. It should be called once for every PaAsiHpi_Initialize call.

 @param Pointer to host API struct
 */
static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaAsiHpiHostApiRepresentation *hpiHostApi = (PaAsiHpiHostApiRepresentation*)hostApi;
    int i;
    PaError result = paNoError;

    if( hpiHostApi )
    {
        /* Get rid of HPI-specific structures */
        uint16_t lastAdapterIndex = HPI_MAX_ADAPTERS;
        /* Iterate through device list and close adapters */
        for( i=0; i < hostApi->info.deviceCount; ++i )
        {
            PaAsiHpiDeviceInfo *hpiDevice = (PaAsiHpiDeviceInfo *) hostApi->deviceInfos[ i ];
            /* Close adapter only if it differs from previous one */
            if( hpiDevice->adapterIndex != lastAdapterIndex )
            {
                /* Ignore errors (report only during debugging) */
                PA_ASIHPI_UNLESS_( HPI_AdapterClose( NULL,
                                                     hpiDevice->adapterIndex ), paNoError );
                lastAdapterIndex = hpiDevice->adapterIndex;
            }
        }
        /* Finally dismantle HPI subsystem */
        HPI_SubSysFree( NULL );

        if( hpiHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( hpiHostApi->allocations );
            PaUtil_DestroyAllocationGroup( hpiHostApi->allocations );
        }

        PaUtil_FreeMemory( hpiHostApi );
    }
error:
    return;
}


/** Converts PortAudio sample format to equivalent HPI format.

 @param paFormat PortAudio sample format

 @return HPI sample format
 */
static uint16_t PaAsiHpi_PaToHpiFormat( PaSampleFormat paFormat )
{
    /* Ignore interleaving flag */
    switch( paFormat & ~paNonInterleaved )
    {
    case paFloat32:
        return HPI_FORMAT_PCM32_FLOAT;

    case paInt32:
        return HPI_FORMAT_PCM32_SIGNED;

    case paInt24:
        return HPI_FORMAT_PCM24_SIGNED;

    case paInt16:
        return HPI_FORMAT_PCM16_SIGNED;

    case paUInt8:
        return HPI_FORMAT_PCM8_UNSIGNED;

        /* Default is 16-bit signed */
    case paInt8:
    default:
        return HPI_FORMAT_PCM16_SIGNED;
    }
}


/** Converts HPI sample format to equivalent PortAudio format.

 @param paFormat HPI sample format

 @return PortAudio sample format
 */
static PaSampleFormat PaAsiHpi_HpiToPaFormat( uint16_t hpiFormat )
{
    switch( hpiFormat )
    {
    case HPI_FORMAT_PCM32_FLOAT:
        return paFloat32;

    case HPI_FORMAT_PCM32_SIGNED:
        return paInt32;

    case HPI_FORMAT_PCM24_SIGNED:
        return paInt24;

    case HPI_FORMAT_PCM16_SIGNED:
        return paInt16;

    case HPI_FORMAT_PCM8_UNSIGNED:
        return paUInt8;

        /* Default is custom format (e.g. for HPI MP3 format) */
    default:
        return paCustomFormat;
    }
}


/** Creates HPI format struct based on PortAudio parameters.
 This also does some checks to see whether the desired format is valid, and whether
 the device allows it. This only checks the format of one half (input or output) of the
 PortAudio stream.

 @param hostApi Pointer to host API struct

 @param parameters Pointer to stream parameter struct

 @param sampleRate Desired sample rate

 @param hpiDevice Pointer to HPI device struct

 @param hpiFormat Resulting HPI format returned here

 @return PortAudio error code (typically indicating a problem with stream format)
 */
static PaError PaAsiHpi_CreateFormat( struct PaUtilHostApiRepresentation *hostApi,
                                      const PaStreamParameters *parameters, double sampleRate,
                                      PaAsiHpiDeviceInfo **hpiDevice, struct hpi_format *hpiFormat )
{
    int maxChannelCount = 0;
    PaSampleFormat hostSampleFormat = 0;
    hpi_err_t hpiError = 0;

    /* Unless alternate device specification is supported, reject the use of
       paUseHostApiSpecificDeviceSpecification */
    if( parameters->device == paUseHostApiSpecificDeviceSpecification )
        return paInvalidDevice;
    else
    {
        assert( parameters->device < hostApi->info.deviceCount );
        *hpiDevice = (PaAsiHpiDeviceInfo*) hostApi->deviceInfos[ parameters->device ];
    }

    /* Validate streamInfo - this implementation doesn't use custom stream info */
    if( parameters->hostApiSpecificStreamInfo )
        return paIncompatibleHostApiSpecificStreamInfo;

    /* Check that device can support channel count */
    if( (*hpiDevice)->streamIsOutput )
    {
        maxChannelCount = (*hpiDevice)->baseDeviceInfo.maxOutputChannels;
    }
    else
    {
        maxChannelCount = (*hpiDevice)->baseDeviceInfo.maxInputChannels;
    }
    if( (maxChannelCount == 0) || (parameters->channelCount > maxChannelCount) )
        return paInvalidChannelCount;

    /* All standard sample formats are supported by the buffer adapter,
       and this implementation doesn't support any custom sample formats */
    if( parameters->sampleFormat & paCustomFormat )
        return paSampleFormatNotSupported;

    /* Switch to closest HPI native format */
    hostSampleFormat = PaUtil_SelectClosestAvailableFormat(PA_ASIHPI_AVAILABLE_FORMATS_,
                       parameters->sampleFormat );
    /* Setup format + info objects */
    hpiError = HPI_FormatCreate( hpiFormat, (uint16_t)parameters->channelCount,
                                 PaAsiHpi_PaToHpiFormat( hostSampleFormat ),
                                 (uint32_t)sampleRate, 0, 0 );
    if( hpiError )
    {
        PA_ASIHPI_REPORT_ERROR_( hpiError );
        switch( hpiError )
        {
        case HPI_ERROR_INVALID_FORMAT:
            return paSampleFormatNotSupported;

        case HPI_ERROR_INVALID_SAMPLERATE:
        case HPI_ERROR_INCOMPATIBLE_SAMPLERATE:
            return paInvalidSampleRate;

        case HPI_ERROR_INVALID_CHANNELS:
            return paInvalidChannelCount;
        }
    }

    return paNoError;
}


/** Open HPI input stream with given format.
 This attempts to open HPI input stream with desired format. If the format is not supported
 or the device is unavailable, the stream is closed and a PortAudio error code is returned.

 @param hostApi Pointer to host API struct

 @param hpiDevice Pointer to HPI device struct

 @param hpiFormat Pointer to HPI format struct

 @return PortAudio error code (typically indicating a problem with stream format or device)
*/
static PaError PaAsiHpi_OpenInput( struct PaUtilHostApiRepresentation *hostApi,
                                   const PaAsiHpiDeviceInfo *hpiDevice, const struct hpi_format *hpiFormat,
                                   hpi_handle_t *hpiStream )
{
    PaAsiHpiHostApiRepresentation *hpiHostApi = (PaAsiHpiHostApiRepresentation*)hostApi;
    PaError result = paNoError;
    hpi_err_t hpiError = 0;

    /* Catch misplaced output devices, as they typically have 0 input channels */
    PA_UNLESS_( !hpiDevice->streamIsOutput, paInvalidChannelCount );
    /* Try to open input stream */
    PA_ASIHPI_UNLESS_( HPI_InStreamOpen( NULL, hpiDevice->adapterIndex,
                                         hpiDevice->streamIndex, hpiStream ), paDeviceUnavailable );
    /* Set input format (checking it in the process) */
    /* Could also use HPI_InStreamQueryFormat, but this economizes the process */
    hpiError = HPI_InStreamSetFormat( NULL, *hpiStream, (struct hpi_format*)hpiFormat );
    if( hpiError )
    {
        PA_ASIHPI_REPORT_ERROR_( hpiError );
        PA_ASIHPI_UNLESS_( HPI_InStreamClose( NULL, *hpiStream ), paNoError );
        switch( hpiError )
        {
        case HPI_ERROR_INVALID_FORMAT:
            return paSampleFormatNotSupported;

        case HPI_ERROR_INVALID_SAMPLERATE:
        case HPI_ERROR_INCOMPATIBLE_SAMPLERATE:
            return paInvalidSampleRate;

        case HPI_ERROR_INVALID_CHANNELS:
            return paInvalidChannelCount;

        default:
            /* In case anything else went wrong */
            return paInvalidDevice;
        }
    }

error:
    return result;
}


/** Open HPI output stream with given format.
 This attempts to open HPI output stream with desired format. If the format is not supported
 or the device is unavailable, the stream is closed and a PortAudio error code is returned.

 @param hostApi Pointer to host API struct

 @param hpiDevice Pointer to HPI device struct

 @param hpiFormat Pointer to HPI format struct

 @return PortAudio error code (typically indicating a problem with stream format or device)
*/
static PaError PaAsiHpi_OpenOutput( struct PaUtilHostApiRepresentation *hostApi,
                                    const PaAsiHpiDeviceInfo *hpiDevice, const struct hpi_format *hpiFormat,
                                    hpi_handle_t *hpiStream )
{
    PaAsiHpiHostApiRepresentation *hpiHostApi = (PaAsiHpiHostApiRepresentation*)hostApi;
    PaError result = paNoError;
    hpi_err_t hpiError = 0;

    /* Catch misplaced input devices, as they typically have 0 output channels */
    PA_UNLESS_( hpiDevice->streamIsOutput, paInvalidChannelCount );
    /* Try to open output stream */
    PA_ASIHPI_UNLESS_( HPI_OutStreamOpen( NULL, hpiDevice->adapterIndex,
                                          hpiDevice->streamIndex, hpiStream ), paDeviceUnavailable );

    /* Check output format (format is set on first write to output stream) */
    hpiError = HPI_OutStreamQueryFormat( NULL, *hpiStream, (struct hpi_format*)hpiFormat );
    if( hpiError )
    {
        PA_ASIHPI_REPORT_ERROR_( hpiError );
        PA_ASIHPI_UNLESS_( HPI_OutStreamClose( NULL, *hpiStream ), paNoError );
        switch( hpiError )
        {
        case HPI_ERROR_INVALID_FORMAT:
            return paSampleFormatNotSupported;

        case HPI_ERROR_INVALID_SAMPLERATE:
        case HPI_ERROR_INCOMPATIBLE_SAMPLERATE:
            return paInvalidSampleRate;

        case HPI_ERROR_INVALID_CHANNELS:
            return paInvalidChannelCount;

        default:
            /* In case anything else went wrong */
            return paInvalidDevice;
        }
    }

error:
    return result;
}


/** Checks whether the desired stream formats and devices are supported
 (for both input and output).
 This is done by actually opening the appropriate HPI streams and closing them again.

 @param hostApi Pointer to host API struct

 @param inputParameters Pointer to stream parameter struct for input side of stream

 @param outputParameters Pointer to stream parameter struct for output side of stream

 @param sampleRate Desired sample rate

 @return PortAudio error code (paFormatIsSupported on success)
 */
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaError result = paFormatIsSupported;
    PaAsiHpiHostApiRepresentation *hpiHostApi = (PaAsiHpiHostApiRepresentation*)hostApi;
    PaAsiHpiDeviceInfo *hpiDevice = NULL;
    struct hpi_format hpiFormat;

    /* Input stream */
    if( inputParameters )
    {
        hpi_handle_t hpiStream;
        PA_DEBUG(( "%s: Checking input params: dev=%d, sr=%d, chans=%d, fmt=%d\n",
                   __FUNCTION__, inputParameters->device, (int)sampleRate,
                   inputParameters->channelCount, inputParameters->sampleFormat ));
        /* Create and validate format */
        PA_ENSURE_( PaAsiHpi_CreateFormat( hostApi, inputParameters, sampleRate,
                                           &hpiDevice, &hpiFormat ) );
        /* Open stream to further check format */
        PA_ENSURE_( PaAsiHpi_OpenInput( hostApi, hpiDevice, &hpiFormat, &hpiStream ) );
        /* Close stream again */
        PA_ASIHPI_UNLESS_( HPI_InStreamClose( NULL, hpiStream ), paNoError );
    }

    /* Output stream */
    if( outputParameters )
    {
        hpi_handle_t hpiStream;
        PA_DEBUG(( "%s: Checking output params: dev=%d, sr=%d, chans=%d, fmt=%d\n",
                   __FUNCTION__, outputParameters->device, (int)sampleRate,
                   outputParameters->channelCount, outputParameters->sampleFormat ));
        /* Create and validate format */
        PA_ENSURE_( PaAsiHpi_CreateFormat( hostApi, outputParameters, sampleRate,
                                           &hpiDevice, &hpiFormat ) );
        /* Open stream to further check format */
        PA_ENSURE_( PaAsiHpi_OpenOutput( hostApi, hpiDevice, &hpiFormat, &hpiStream ) );
        /* Close stream again */
        PA_ASIHPI_UNLESS_( HPI_OutStreamClose( NULL, hpiStream ), paNoError );
    }

error:
    return result;
}

/* ---------------------------- Stream Interface ---------------------------- */

/** Obtain HPI stream information.
 This obtains info such as stream state and available data/space in buffers. It also
 estimates whether an underflow or overflow occurred.

 @param streamComp Pointer to stream component (input or output) to query

 @param info Pointer to stream info struct that will contain result

 @return PortAudio error code (either paNoError, paDeviceUnavailable or paUnanticipatedHostError)
 */
static PaError PaAsiHpi_GetStreamInfo( PaAsiHpiStreamComponent *streamComp, PaAsiHpiStreamInfo *info )
{
    PaError result = paDeviceUnavailable;
    uint16_t state;
    uint32_t bufferSize, dataSize, frameCounter, auxDataSize, threshold;
    uint32_t hwBufferSize, hwDataSize;

    assert( streamComp );
    assert( info );

    /* First blank the stream info struct, in case something goes wrong below.
       This saves the caller from initializing the struct. */
    info->state = 0;
    info->bufferSize = 0;
    info->dataSize = 0;
    info->frameCounter = 0;
    info->auxDataSize = 0;
    info->totalBufferedData = 0;
    info->availableFrames = 0;
    info->underflow = 0;
    info->overflow = 0;

    if( streamComp->hpiDevice && streamComp->hpiStream )
    {
        /* Obtain detailed stream info (either input or output) */
        if( streamComp->hpiDevice->streamIsOutput )
        {
            PA_ASIHPI_UNLESS_( HPI_OutStreamGetInfoEx( NULL,
                               streamComp->hpiStream,
                               &state, &bufferSize, &dataSize, &frameCounter,
                               &auxDataSize ), paUnanticipatedHostError );
        }
        else
        {
            PA_ASIHPI_UNLESS_( HPI_InStreamGetInfoEx( NULL,
                               streamComp->hpiStream,
                               &state, &bufferSize, &dataSize, &frameCounter,
                               &auxDataSize ), paUnanticipatedHostError );
        }
        /* Load stream info */
        info->state = state;
        info->bufferSize = bufferSize;
        info->dataSize = dataSize;
        info->frameCounter = frameCounter;
        info->auxDataSize = auxDataSize;
        /* Determine total buffered data */
        info->totalBufferedData = dataSize;
        if( streamComp->hostBufferSize > 0 )
            info->totalBufferedData += auxDataSize;
        info->totalBufferedData /= streamComp->bytesPerFrame;
        /* Determine immediately available frames */
        info->availableFrames = streamComp->hpiDevice->streamIsOutput ?
                                bufferSize - dataSize : dataSize;
        info->availableFrames /= streamComp->bytesPerFrame;
        /* Minimum space/data required in buffers */
        threshold = PA_MIN( streamComp->tempBufferSize,
                            streamComp->bytesPerFrame * PA_ASIHPI_MIN_FRAMES_ );
        /* Obtain hardware buffer stats first, to simplify things */
        hwBufferSize = streamComp->hardwareBufferSize;
        hwDataSize = streamComp->hostBufferSize > 0 ? auxDataSize : dataSize;
        /* Underflow is a bit tricky */
        info->underflow = streamComp->hpiDevice->streamIsOutput ?
                          /* Stream seems to start in drained state sometimes, so ignore initial underflow */
                          (frameCounter > 0) && ( (state == HPI_STATE_DRAINED) || (hwDataSize == 0) ) :
                          /* Input streams check the first-level (host) buffer for underflow */
                          (state != HPI_STATE_STOPPED) && (dataSize < threshold);
        /* Check for overflow in second-level (hardware) buffer for both input and output */
        info->overflow = (state != HPI_STATE_STOPPED) && (hwBufferSize - hwDataSize < threshold);

        return paNoError;
    }

error:
    return result;
}


/** Display stream component information for debugging purposes.

 @param streamComp Pointer to stream component (input or output) to query

 @param stream Pointer to stream struct which contains the component above
 */
static void PaAsiHpi_StreamComponentDump( PaAsiHpiStreamComponent *streamComp,
        PaAsiHpiStream *stream )
{
    PaAsiHpiStreamInfo streamInfo;

    assert( streamComp );
    assert( stream );

    /* Name of soundcard/device used by component */
    PA_DEBUG(( "device: %s\n", streamComp->hpiDevice->baseDeviceInfo.name ));
    /* Unfortunately some overlap between input and output here */
    if( streamComp->hpiDevice->streamIsOutput )
    {
        /* Settings on the user side (as experienced by user callback) */
        PA_DEBUG(( "user: %d-bit, %d ",
                   8*stream->bufferProcessor.bytesPerUserOutputSample,
                   stream->bufferProcessor.outputChannelCount));
        if( stream->bufferProcessor.userOutputIsInterleaved )
        {
            PA_DEBUG(( "interleaved channels, " ));
        }
        else
        {
            PA_DEBUG(( "non-interleaved channels, " ));
        }
        PA_DEBUG(( "%d frames/buffer, latency = %5.1f ms\n",
                   stream->bufferProcessor.framesPerUserBuffer,
                   1000*stream->baseStreamRep.streamInfo.outputLatency ));
        /* Settings on the host side (internal to PortAudio host API) */
        PA_DEBUG(( "host: %d-bit, %d interleaved channels, %d frames/buffer ",
                   8*stream->bufferProcessor.bytesPerHostOutputSample,
                   stream->bufferProcessor.outputChannelCount,
                   stream->bufferProcessor.framesPerHostBuffer ));
    }
    else
    {
        /* Settings on the user side (as experienced by user callback) */
        PA_DEBUG(( "user: %d-bit, %d ",
                   8*stream->bufferProcessor.bytesPerUserInputSample,
                   stream->bufferProcessor.inputChannelCount));
        if( stream->bufferProcessor.userInputIsInterleaved )
        {
            PA_DEBUG(( "interleaved channels, " ));
        }
        else
        {
            PA_DEBUG(( "non-interleaved channels, " ));
        }
        PA_DEBUG(( "%d frames/buffer, latency = %5.1f ms\n",
                   stream->bufferProcessor.framesPerUserBuffer,
                   1000*stream->baseStreamRep.streamInfo.inputLatency ));
        /* Settings on the host side (internal to PortAudio host API) */
        PA_DEBUG(( "host: %d-bit, %d interleaved channels, %d frames/buffer ",
                   8*stream->bufferProcessor.bytesPerHostInputSample,
                   stream->bufferProcessor.inputChannelCount,
                   stream->bufferProcessor.framesPerHostBuffer ));
    }
    switch( stream->bufferProcessor.hostBufferSizeMode )
    {
    case paUtilFixedHostBufferSize:
        PA_DEBUG(( "[fixed] " ));
        break;
    case paUtilBoundedHostBufferSize:
        PA_DEBUG(( "[bounded] " ));
        break;
    case paUtilUnknownHostBufferSize:
        PA_DEBUG(( "[unknown] " ));
        break;
    case paUtilVariableHostBufferSizePartialUsageAllowed:
        PA_DEBUG(( "[variable] " ));
        break;
    }
    PA_DEBUG(( "(%d max)\n", streamComp->tempBufferSize / streamComp->bytesPerFrame ));
    /* HPI hardware settings */
    PA_DEBUG(( "HPI: adapter %d stream %d, %d-bit, %d-channel, %d Hz\n",
               streamComp->hpiDevice->adapterIndex, streamComp->hpiDevice->streamIndex,
               8 * streamComp->bytesPerFrame / streamComp->hpiFormat.wChannels,
               streamComp->hpiFormat.wChannels,
               streamComp->hpiFormat.dwSampleRate ));
    /* Stream state and buffer levels */
    PA_DEBUG(( "HPI: " ));
    PaAsiHpi_GetStreamInfo( streamComp, &streamInfo );
    switch( streamInfo.state )
    {
    case HPI_STATE_STOPPED:
        PA_DEBUG(( "[STOPPED] " ));
        break;
    case HPI_STATE_PLAYING:
        PA_DEBUG(( "[PLAYING] " ));
        break;
    case HPI_STATE_RECORDING:
        PA_DEBUG(( "[RECORDING] " ));
        break;
    case HPI_STATE_DRAINED:
        PA_DEBUG(( "[DRAINED] " ));
        break;
    default:
        PA_DEBUG(( "[unknown state] " ));
        break;
    }
    if( streamComp->hostBufferSize )
    {
        PA_DEBUG(( "host = %d/%d B, ", streamInfo.dataSize, streamComp->hostBufferSize ));
        PA_DEBUG(( "hw = %d/%d (%d) B, ", streamInfo.auxDataSize,
                   streamComp->hardwareBufferSize, streamComp->outputBufferCap ));
    }
    else
    {
        PA_DEBUG(( "hw = %d/%d B, ", streamInfo.dataSize, streamComp->hardwareBufferSize ));
    }
    PA_DEBUG(( "count = %d", streamInfo.frameCounter ));
    if( streamInfo.overflow )
    {
        PA_DEBUG(( " [overflow]" ));
    }
    else if( streamInfo.underflow )
    {
        PA_DEBUG(( " [underflow]" ));
    }
    PA_DEBUG(( "\n" ));
}


/** Display stream information for debugging purposes.

 @param stream Pointer to stream to query
 */
static void PaAsiHpi_StreamDump( PaAsiHpiStream *stream )
{
    assert( stream );

    PA_DEBUG(( "\n------------------------- STREAM INFO FOR %p ---------------------------\n", stream ));
    /* General stream info (input+output) */
    if( stream->baseStreamRep.streamCallback )
    {
        PA_DEBUG(( "[callback] " ));
    }
    else
    {
        PA_DEBUG(( "[blocking] " ));
    }
    PA_DEBUG(( "sr=%d Hz, poll=%d ms, max %d frames/buf ",
               (int)stream->baseStreamRep.streamInfo.sampleRate,
               stream->pollingInterval, stream->maxFramesPerHostBuffer ));
    switch( stream->state )
    {
    case paAsiHpiStoppedState:
        PA_DEBUG(( "[stopped]\n" ));
        break;
    case paAsiHpiActiveState:
        PA_DEBUG(( "[active]\n" ));
        break;
    case paAsiHpiCallbackFinishedState:
        PA_DEBUG(( "[cb fin]\n" ));
        break;
    default:
        PA_DEBUG(( "[unknown state]\n" ));
        break;
    }
    if( stream->callbackMode )
    {
        PA_DEBUG(( "cb info: thread=%p, cbAbort=%d, cbFinished=%d\n",
                   stream->thread.thread, stream->callbackAbort, stream->callbackFinished ));
    }

    PA_DEBUG(( "----------------------------------- Input  ------------------------------------\n" ));
    if( stream->input )
    {
        PaAsiHpi_StreamComponentDump( stream->input, stream );
    }
    else
    {
        PA_DEBUG(( "*none*\n" ));
    }

    PA_DEBUG(( "----------------------------------- Output ------------------------------------\n" ));
    if( stream->output )
    {
        PaAsiHpi_StreamComponentDump( stream->output, stream );
    }
    else
    {
        PA_DEBUG(( "*none*\n" ));
    }
    PA_DEBUG(( "-------------------------------------------------------------------------------\n\n" ));

}


/** Determine buffer sizes and allocate appropriate stream buffers.
 This attempts to allocate a BBM (host) buffer for the HPI stream component (either input
 or output, as both have similar buffer needs). Not all AudioScience adapters support BBM,
 in which case the hardware buffer has to suffice. The size of the HPI host buffer is chosen
 as a multiple of framesPerPaHostBuffer, and also influenced by the suggested latency and the
 estimated minimum polling interval. The HPI host and hardware buffer sizes are stored, and an
 appropriate cap for the hardware buffer is also calculated. Finally, the temporary stream
 buffer which serves as the PortAudio host buffer for this implementation is allocated.
 This buffer contains an integer number of user buffers, to simplify buffer adaption in the
 buffer processor. The function returns paBufferTooBig if the HPI interface cannot allocate
 an HPI host buffer of the desired size.

 @param streamComp Pointer to stream component struct

 @param pollingInterval Polling interval for stream, in milliseconds

 @param framesPerPaHostBuffer Size of PortAudio host buffer, in frames

 @param suggestedLatency Suggested latency for stream component, in seconds

 @return PortAudio error code (possibly paBufferTooBig or paInsufficientMemory)
 */
static PaError PaAsiHpi_SetupBuffers( PaAsiHpiStreamComponent *streamComp, uint32_t pollingInterval,
                                      unsigned long framesPerPaHostBuffer, PaTime suggestedLatency )
{
    PaError result = paNoError;
    PaAsiHpiStreamInfo streamInfo;
    unsigned long hpiBufferSize = 0, paHostBufferSize = 0;

    assert( streamComp );
    assert( streamComp->hpiDevice );

    /* Obtain size of hardware buffer of HPI stream, since we will be activating BBM shortly
       and afterwards the buffer size will refer to the BBM (host-side) buffer.
       This is necessary to enable reliable detection of xruns. */
    PA_ENSURE_( PaAsiHpi_GetStreamInfo( streamComp, &streamInfo ) );
    streamComp->hardwareBufferSize = streamInfo.bufferSize;
    hpiBufferSize = streamInfo.bufferSize;

    /* Check if BBM (background bus mastering) is to be enabled */
    if( PA_ASIHPI_USE_BBM_ )
    {
        uint32_t bbmBufferSize = 0, preLatencyBufferSize = 0;
        hpi_err_t hpiError = 0;
        PaTime pollingOverhead;

        /* Check overhead of Pa_Sleep() call (minimum sleep duration in ms -> OS dependent) */
        pollingOverhead = PaUtil_GetTime();
        Pa_Sleep( 0 );
        pollingOverhead = 1000*(PaUtil_GetTime() - pollingOverhead);
        PA_DEBUG(( "polling overhead = %f ms (length of 0-second sleep)\n", pollingOverhead ));
        /* Obtain minimum recommended size for host buffer (in bytes) */
        PA_ASIHPI_UNLESS_( HPI_StreamEstimateBufferSize( &streamComp->hpiFormat,
                           pollingInterval + (uint32_t)ceil( pollingOverhead ),
                           &bbmBufferSize ), paUnanticipatedHostError );
        /* BBM places more stringent requirements on buffer size (see description */
        /* of HPI_StreamEstimateBufferSize in HPI API document) */
        bbmBufferSize *= 3;
        /* Make sure the BBM buffer contains multiple PA host buffers */
        if( bbmBufferSize < 3 * streamComp->bytesPerFrame * framesPerPaHostBuffer )
            bbmBufferSize = 3 * streamComp->bytesPerFrame * framesPerPaHostBuffer;
        /* Try to honor latency suggested by user by growing buffer (no decrease possible) */
        if( suggestedLatency > 0.0 )
        {
            PaTime bufferDuration = ((PaTime)bbmBufferSize) / streamComp->bytesPerFrame
                                    / streamComp->hpiFormat.dwSampleRate;
            /* Don't decrease buffer */
            if( bufferDuration < suggestedLatency )
            {
                /* Save old buffer size, to be retried if new size proves too big */
                preLatencyBufferSize = bbmBufferSize;
                bbmBufferSize = (uint32_t)ceil( suggestedLatency * streamComp->bytesPerFrame
                                            * streamComp->hpiFormat.dwSampleRate );
            }
        }
        /* Choose closest memory block boundary (HPI API document states that
        "a buffer size of Nx4096 - 20 makes the best use of memory"
        (under the entry for HPI_StreamEstimateBufferSize)) */
        bbmBufferSize = ((uint32_t)ceil((bbmBufferSize + 20)/4096.0))*4096 - 20;
        streamComp->hostBufferSize = bbmBufferSize;
        /* Allocate BBM host buffer (this enables bus mastering transfers in background) */
        if( streamComp->hpiDevice->streamIsOutput )
            hpiError = HPI_OutStreamHostBufferAllocate( NULL,
                       streamComp->hpiStream,
                       bbmBufferSize );
        else
            hpiError = HPI_InStreamHostBufferAllocate( NULL,
                       streamComp->hpiStream,
                       bbmBufferSize );
        if( hpiError )
        {
            /* Indicate that BBM is disabled */
            streamComp->hostBufferSize = 0;
            /* Retry with smaller buffer size (transfers will still work, but not via BBM) */
            if( hpiError == HPI_ERROR_INVALID_DATASIZE )
            {
                /* Retry BBM allocation with smaller size if requested latency proved too big */
                if( preLatencyBufferSize > 0 )
                {
                    PA_DEBUG(( "Retrying BBM allocation with smaller size (%d vs. %d bytes)\n",
                               preLatencyBufferSize, bbmBufferSize ));
                    bbmBufferSize = preLatencyBufferSize;
                    if( streamComp->hpiDevice->streamIsOutput )
                        hpiError = HPI_OutStreamHostBufferAllocate( NULL,
                                   streamComp->hpiStream,
                                   bbmBufferSize );
                    else
                        hpiError = HPI_InStreamHostBufferAllocate( NULL,
                                   streamComp->hpiStream,
                                   bbmBufferSize );
                    /* Another round of error checking */
                    if( hpiError )
                    {
                        PA_ASIHPI_REPORT_ERROR_( hpiError );
                        /* No escapes this time */
                        if( hpiError == HPI_ERROR_INVALID_DATASIZE )
                        {
                            result = paBufferTooBig;
                            goto error;
                        }
                        else if( hpiError != HPI_ERROR_INVALID_OPERATION )
                        {
                            result = paUnanticipatedHostError;
                            goto error;
                        }
                    }
                    else
                    {
                        streamComp->hostBufferSize = bbmBufferSize;
                        hpiBufferSize = bbmBufferSize;
                    }
                }
                else
                {
                    result = paBufferTooBig;
                    goto error;
                }
            }
            /* If BBM not supported, foreground transfers will be used, but not a show-stopper */
            /* Anything else is an error */
            else if (( hpiError != HPI_ERROR_INVALID_OPERATION ) &&
		     ( hpiError != HPI_ERROR_INVALID_FUNC ))
            {
                PA_ASIHPI_REPORT_ERROR_( hpiError );
                result = paUnanticipatedHostError;
                goto error;
            }
        }
        else
        {
            hpiBufferSize = bbmBufferSize;
        }
    }

    /* Final check of buffer size */
    paHostBufferSize = streamComp->bytesPerFrame * framesPerPaHostBuffer;
    if( hpiBufferSize < 3*paHostBufferSize )
    {
        result = paBufferTooBig;
        goto error;
    }
    /* Set cap on output buffer size, based on latency suggestions */
    if( streamComp->hpiDevice->streamIsOutput )
    {
        PaTime latency = suggestedLatency > 0.0 ? suggestedLatency :
                         streamComp->hpiDevice->baseDeviceInfo.defaultHighOutputLatency;
        streamComp->outputBufferCap =
            (uint32_t)ceil( latency * streamComp->bytesPerFrame * streamComp->hpiFormat.dwSampleRate );
        /* The cap should not be too small, to prevent underflow */
        if( streamComp->outputBufferCap < 4*paHostBufferSize )
            streamComp->outputBufferCap = 4*paHostBufferSize;
    }
    else
    {
        streamComp->outputBufferCap = 0;
    }
    /* Temp buffer size should be multiple of PA host buffer size (or 1x, if using fixed blocks) */
    streamComp->tempBufferSize = paHostBufferSize;
    /* Allocate temp buffer */
    PA_UNLESS_( streamComp->tempBuffer = (uint8_t *)PaUtil_AllocateMemory( streamComp->tempBufferSize ),
                paInsufficientMemory );
error:
    return result;
}


/** Opens PortAudio stream.
 This determines a suitable value for framesPerBuffer, if the user didn't specify it,
 based on the suggested latency. It then opens each requested stream direction with the
 appropriate stream format, and allocates the required stream buffers. It sets up the
 various PortAudio structures dealing with streams, and estimates the stream latency.

 See pa_hostapi.h for a list of validity guarantees made about OpenStream parameters.

 @param hostApi Pointer to host API struct

 @param s List of open streams, where successfully opened stream will go

 @param inputParameters Pointer to stream parameter struct for input side of stream

 @param outputParameters Pointer to stream parameter struct for output side of stream

 @param sampleRate Desired sample rate

 @param framesPerBuffer Desired number of frames per buffer passed to user callback
                        (or chunk size for blocking stream)

 @param streamFlags Stream flags

 @param streamCallback Pointer to user callback function (zero for blocking interface)

 @param userData Pointer to user data that will be passed to callback function along with data

 @return PortAudio error code
*/
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream **s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaAsiHpiHostApiRepresentation *hpiHostApi = (PaAsiHpiHostApiRepresentation*)hostApi;
    PaAsiHpiStream *stream = NULL;
    unsigned long framesPerHostBuffer = framesPerBuffer;
    int inputChannelCount = 0, outputChannelCount = 0;
    PaSampleFormat inputSampleFormat = 0, outputSampleFormat = 0;
    PaSampleFormat hostInputSampleFormat = 0, hostOutputSampleFormat = 0;
    PaTime maxSuggestedLatency = 0.0;

    /* Validate platform-specific flags -> none expected for HPI */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform-specific flag */

    /* Create blank stream structure */
    PA_UNLESS_( stream = (PaAsiHpiStream *)PaUtil_AllocateMemory( sizeof(PaAsiHpiStream) ),
                paInsufficientMemory );
    memset( stream, 0, sizeof(PaAsiHpiStream) );

    /* If the number of frames per buffer is unspecified, we have to come up with one. */
    if( framesPerHostBuffer == paFramesPerBufferUnspecified )
    {
        if( inputParameters )
            maxSuggestedLatency = inputParameters->suggestedLatency;
        if( outputParameters && (outputParameters->suggestedLatency > maxSuggestedLatency) )
            maxSuggestedLatency = outputParameters->suggestedLatency;
        /* Use suggested latency if available */
        if( maxSuggestedLatency > 0.0 )
            framesPerHostBuffer = (unsigned long)ceil( maxSuggestedLatency * sampleRate );
        else
            /* AudioScience cards like BIG buffers by default */
            framesPerHostBuffer = 4096;
    }
    /* Lower bounds on host buffer size, due to polling and HPI constraints */
    if( 1000.0*framesPerHostBuffer/sampleRate < PA_ASIHPI_MIN_POLLING_INTERVAL_ )
        framesPerHostBuffer = (unsigned long)ceil( sampleRate * PA_ASIHPI_MIN_POLLING_INTERVAL_ / 1000.0 );
    /*    if( framesPerHostBuffer < PA_ASIHPI_MIN_FRAMES_ )
            framesPerHostBuffer = PA_ASIHPI_MIN_FRAMES_; */
    /* Efficient if host buffer size is integer multiple of user buffer size */
    if( framesPerBuffer > 0 )
        framesPerHostBuffer = (unsigned long)ceil( (double)framesPerHostBuffer / framesPerBuffer ) * framesPerBuffer;
    /* Buffer should always be a multiple of 4 bytes to facilitate 32-bit PCI transfers.
     By keeping the frames a multiple of 4, this is ensured even for 8-bit mono sound. */
    framesPerHostBuffer = (framesPerHostBuffer / 4) * 4;
    /* Polling is based on time length (in milliseconds) of user-requested block size */
    stream->pollingInterval = (uint32_t)ceil( 1000.0*framesPerHostBuffer/sampleRate );
    assert( framesPerHostBuffer > 0 );

    /* Open underlying streams, check formats and allocate buffers */
    if( inputParameters )
    {
        /* Create blank stream component structure */
        PA_UNLESS_( stream->input = (PaAsiHpiStreamComponent *)PaUtil_AllocateMemory( sizeof(PaAsiHpiStreamComponent) ),
                    paInsufficientMemory );
        memset( stream->input, 0, sizeof(PaAsiHpiStreamComponent) );
        /* Create/validate format */
        PA_ENSURE_( PaAsiHpi_CreateFormat( hostApi, inputParameters, sampleRate,
                                           &stream->input->hpiDevice, &stream->input->hpiFormat ) );
        /* Open stream and set format */
        PA_ENSURE_( PaAsiHpi_OpenInput( hostApi, stream->input->hpiDevice, &stream->input->hpiFormat,
                                        &stream->input->hpiStream ) );
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        hostInputSampleFormat = PaAsiHpi_HpiToPaFormat( stream->input->hpiFormat.wFormat );
        stream->input->bytesPerFrame = inputChannelCount * Pa_GetSampleSize( hostInputSampleFormat );
        assert( stream->input->bytesPerFrame > 0 );
        /* Allocate host and temp buffers of appropriate size */
        PA_ENSURE_( PaAsiHpi_SetupBuffers( stream->input, stream->pollingInterval,
                                           framesPerHostBuffer, inputParameters->suggestedLatency ) );
    }
    if( outputParameters )
    {
        /* Create blank stream component structure */
        PA_UNLESS_( stream->output = (PaAsiHpiStreamComponent *)PaUtil_AllocateMemory( sizeof(PaAsiHpiStreamComponent) ),
                    paInsufficientMemory );
        memset( stream->output, 0, sizeof(PaAsiHpiStreamComponent) );
        /* Create/validate format */
        PA_ENSURE_( PaAsiHpi_CreateFormat( hostApi, outputParameters, sampleRate,
                                           &stream->output->hpiDevice, &stream->output->hpiFormat ) );
        /* Open stream and check format */
        PA_ENSURE_( PaAsiHpi_OpenOutput( hostApi, stream->output->hpiDevice,
                                         &stream->output->hpiFormat,
                                         &stream->output->hpiStream ) );
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        hostOutputSampleFormat = PaAsiHpi_HpiToPaFormat( stream->output->hpiFormat.wFormat );
        stream->output->bytesPerFrame = outputChannelCount * Pa_GetSampleSize( hostOutputSampleFormat );
        /* Allocate host and temp buffers of appropriate size */
        PA_ENSURE_( PaAsiHpi_SetupBuffers( stream->output, stream->pollingInterval,
                                           framesPerHostBuffer, outputParameters->suggestedLatency ) );
    }

    /* Determine maximum frames per host buffer (least common denominator of input/output) */
    if( inputParameters && outputParameters )
    {
        stream->maxFramesPerHostBuffer = PA_MIN( stream->input->tempBufferSize / stream->input->bytesPerFrame,
                                         stream->output->tempBufferSize / stream->output->bytesPerFrame );
    }
    else
    {
        stream->maxFramesPerHostBuffer = inputParameters ? stream->input->tempBufferSize / stream->input->bytesPerFrame
                                         : stream->output->tempBufferSize / stream->output->bytesPerFrame;
    }
    assert( stream->maxFramesPerHostBuffer > 0 );
    /* Initialize various other stream parameters */
    stream->neverDropInput = streamFlags & paNeverDropInput;
    stream->state = paAsiHpiStoppedState;

    /* Initialize either callback or blocking interface */
    if( streamCallback )
    {
        PaUtil_InitializeStreamRepresentation( &stream->baseStreamRep,
                                               &hpiHostApi->callbackStreamInterface,
                                               streamCallback, userData );
        stream->callbackMode = 1;
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &stream->baseStreamRep,
                                               &hpiHostApi->blockingStreamInterface,
                                               streamCallback, userData );
        /* Pre-allocate non-interleaved user buffer pointers for blocking interface */
        PA_UNLESS_( stream->blockingUserBufferCopy =
                        PaUtil_AllocateMemory( sizeof(void *) * PA_MAX( inputChannelCount, outputChannelCount ) ),
                    paInsufficientMemory );
        stream->callbackMode = 0;
    }
    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );

    /* Following pa_linux_alsa's lead, we operate with fixed host buffer size by default, */
    /* since other modes will invariably lead to block adaption (maybe Bounded better?) */
    PA_ENSURE_( PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                inputChannelCount, inputSampleFormat, hostInputSampleFormat,
                outputChannelCount, outputSampleFormat, hostOutputSampleFormat,
                sampleRate, streamFlags,
                framesPerBuffer, framesPerHostBuffer, paUtilFixedHostBufferSize,
                streamCallback, userData ) );

    stream->baseStreamRep.streamInfo.structVersion = 1;
    stream->baseStreamRep.streamInfo.sampleRate = sampleRate;
    /* Determine input latency from buffer processor and buffer sizes */
    if( stream->input )
    {
        PaTime bufferDuration = ( stream->input->hostBufferSize + stream->input->hardwareBufferSize )
                                / sampleRate / stream->input->bytesPerFrame;
        stream->baseStreamRep.streamInfo.inputLatency =
            bufferDuration +
            ((PaTime)PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor ) -
                stream->maxFramesPerHostBuffer) / sampleRate;
        assert( stream->baseStreamRep.streamInfo.inputLatency > 0.0 );
    }
    /* Determine output latency from buffer processor and buffer sizes */
    if( stream->output )
    {
        PaTime bufferDuration = ( stream->output->hostBufferSize + stream->output->hardwareBufferSize )
                                / sampleRate / stream->output->bytesPerFrame;
        /* Take buffer size cap into account (see PaAsiHpi_WaitForFrames) */
        if( !stream->input && (stream->output->outputBufferCap > 0) )
        {
            bufferDuration = PA_MIN( bufferDuration,
                                     stream->output->outputBufferCap / sampleRate / stream->output->bytesPerFrame );
        }
        stream->baseStreamRep.streamInfo.outputLatency =
            bufferDuration +
            ((PaTime)PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor ) -
                stream->maxFramesPerHostBuffer) / sampleRate;
        assert( stream->baseStreamRep.streamInfo.outputLatency > 0.0 );
    }

    /* Report stream info, for debugging purposes */
    PaAsiHpi_StreamDump( stream );

    /* Save initialized stream to PA stream list */
    *s = (PaStream*)stream;
    return result;

error:
    CloseStream( (PaStream*)stream );
    return result;
}


/** Close PortAudio stream.
 When CloseStream() is called, the multi-api layer ensures that the stream has already
 been stopped or aborted. This closes the underlying HPI streams and deallocates stream
 buffers and structs.

 @param s Pointer to PortAudio stream

 @return PortAudio error code
*/
static PaError CloseStream( PaStream *s )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;

    /* If stream is already gone, all is well */
    if( stream == NULL )
        return paNoError;

    /* Generic stream cleanup */
    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->baseStreamRep );

    /* Implementation-specific details - close internal streams */
    if( stream->input )
    {
        /* Close HPI stream (freeing BBM host buffer in the process, if used) */
        if( stream->input->hpiStream )
        {
            PA_ASIHPI_UNLESS_( HPI_InStreamClose( NULL,
                                                  stream->input->hpiStream ), paUnanticipatedHostError );
        }
        /* Free temp buffer and stream component */
        PaUtil_FreeMemory( stream->input->tempBuffer );
        PaUtil_FreeMemory( stream->input );
    }
    if( stream->output )
    {
        /* Close HPI stream (freeing BBM host buffer in the process, if used) */
        if( stream->output->hpiStream )
        {
            PA_ASIHPI_UNLESS_( HPI_OutStreamClose( NULL,
                                                   stream->output->hpiStream ), paUnanticipatedHostError );
        }
        /* Free temp buffer and stream component */
        PaUtil_FreeMemory( stream->output->tempBuffer );
        PaUtil_FreeMemory( stream->output );
    }

    PaUtil_FreeMemory( stream->blockingUserBufferCopy );
    PaUtil_FreeMemory( stream );

error:
    return result;
}


/** Prime HPI output stream with silence.
 This resets the output stream and uses PortAudio helper routines to fill the
 temp buffer with silence. It then writes two host buffers to the stream. This is supposed
 to be called before the stream is started. It has no effect on input-only streams.

 @param stream Pointer to stream struct

 @return PortAudio error code
 */
static PaError PaAsiHpi_PrimeOutputWithSilence( PaAsiHpiStream *stream )
{
    PaError result = paNoError;
    PaAsiHpiStreamComponent *out;
    PaUtilZeroer *zeroer;
    PaSampleFormat outputFormat;
    assert( stream );
    out = stream->output;
    /* Only continue if stream has output channels */
    if( !out )
        return result;
    assert( out->tempBuffer );

    /* Clear all existing data in hardware playback buffer */
    PA_ASIHPI_UNLESS_( HPI_OutStreamReset( NULL,
                                           out->hpiStream ), paUnanticipatedHostError );
    /* Fill temp buffer with silence */
    outputFormat = PaAsiHpi_HpiToPaFormat( out->hpiFormat.wFormat );
    zeroer = PaUtil_SelectZeroer( outputFormat );
    zeroer(out->tempBuffer, 1, out->tempBufferSize / Pa_GetSampleSize(outputFormat) );
    /* Write temp buffer to hardware fifo twice, to get started */
    PA_ASIHPI_UNLESS_( HPI_OutStreamWriteBuf( NULL, out->hpiStream,
                                              out->tempBuffer, out->tempBufferSize, &out->hpiFormat),
                                              paUnanticipatedHostError );
    PA_ASIHPI_UNLESS_( HPI_OutStreamWriteBuf( NULL, out->hpiStream,
                                              out->tempBuffer, out->tempBufferSize, &out->hpiFormat),
                                              paUnanticipatedHostError );
error:
    return result;
}


/** Start HPI streams (both input + output).
 This starts all HPI streams in the PortAudio stream. Output streams are first primed with
 silence, if required. After this call the PA stream is in the Active state.

 @todo Implement priming via the user callback

 @param stream Pointer to stream struct

 @param outputPrimed True if output is already primed (if false, silence will be loaded before starting)

 @return PortAudio error code
 */
static PaError PaAsiHpi_StartStream( PaAsiHpiStream *stream, int outputPrimed )
{
    PaError result = paNoError;

    if( stream->input )
    {
        PA_ASIHPI_UNLESS_( HPI_InStreamStart( NULL,
                                              stream->input->hpiStream ), paUnanticipatedHostError );
    }
    if( stream->output )
    {
        if( !outputPrimed )
        {
            /* Buffer isn't primed, so load stream with silence */
            PA_ENSURE_( PaAsiHpi_PrimeOutputWithSilence( stream ) );
        }
        PA_ASIHPI_UNLESS_( HPI_OutStreamStart( NULL,
                                               stream->output->hpiStream ), paUnanticipatedHostError );
    }
    stream->state = paAsiHpiActiveState;
    stream->callbackFinished = 0;

    /* Report stream info for debugging purposes */
    /*    PaAsiHpi_StreamDump( stream );   */

error:
    return result;
}


/** Start PortAudio stream.
 If the stream has a callback interface, this starts a helper thread to feed the user callback.
 The thread will then take care of starting the HPI streams, and this function will block
 until the streams actually start. In the case of a blocking interface, the HPI streams
 are simply started.

 @param s Pointer to PortAudio stream

 @return PortAudio error code
*/
static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;

    assert( stream );

    /* Ready the processor */
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );

    if( stream->callbackMode )
    {
        /* Create and start callback engine thread */
        /* Also waits 1 second for stream to be started by engine thread (otherwise aborts) */
        PA_ENSURE_( PaUnixThread_New( &stream->thread, &CallbackThreadFunc, stream, 1., 0 /*rtSched*/ ) );
    }
    else
    {
        PA_ENSURE_( PaAsiHpi_StartStream( stream, 0 ) );
    }

error:
    return result;
}


/** Stop HPI streams (input + output), either softly or abruptly.
 If abort is false, the function blocks until the output stream is drained, otherwise it
 stops immediately and discards data in the stream hardware buffers.

 This function is safe to call from the callback engine thread as well as the main thread.

 @param stream Pointer to stream struct

 @param abort True if samples in output buffer should be discarded (otherwise blocks until stream is done)

 @return PortAudio error code

 */
static PaError PaAsiHpi_StopStream( PaAsiHpiStream *stream, int abort )
{
    PaError result = paNoError;

    assert( stream );

    /* Input channels */
    if( stream->input )
    {
        PA_ASIHPI_UNLESS_( HPI_InStreamReset( NULL,
                                              stream->input->hpiStream ), paUnanticipatedHostError );
    }
    /* Output channels */
    if( stream->output )
    {
        if( !abort )
        {
            /* Wait until HPI output stream is drained */
            while( 1 )
            {
                PaAsiHpiStreamInfo streamInfo;
                PaTime timeLeft;

                /* Obtain number of samples waiting to be played */
                PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->output, &streamInfo ) );
                /* Check if stream is drained */
                if( (streamInfo.state != HPI_STATE_PLAYING) &&
                        (streamInfo.dataSize < stream->output->bytesPerFrame * PA_ASIHPI_MIN_FRAMES_) )
                    break;
                /* Sleep amount of time represented by remaining samples */
                timeLeft = 1000.0 * streamInfo.dataSize / stream->output->bytesPerFrame
                           / stream->baseStreamRep.streamInfo.sampleRate;
                Pa_Sleep( (long)ceil( timeLeft ) );
            }
        }
        PA_ASIHPI_UNLESS_( HPI_OutStreamReset( NULL,
                                               stream->output->hpiStream ), paUnanticipatedHostError );
    }

    /* Report stream info for debugging purposes */
    /*    PaAsiHpi_StreamDump( stream ); */

error:
    return result;
}


/** Stop or abort PortAudio stream.

 This function is used to explicitly stop the PortAudio stream (via StopStream/AbortStream),
 as opposed to the situation when the callback finishes with a result other than paContinue.
 If a stream is in callback mode we will have to inspect whether the background thread has
 finished, or we will have to take it out. In either case we join the thread before returning.
 In blocking mode, we simply tell HPI to stop abruptly (abort) or finish buffers (drain).
 The PortAudio stream will be in the Stopped state after a call to this function.

 Don't call this from the callback engine thread!

 @param stream Pointer to stream struct

 @param abort True if samples in output buffer should be discarded (otherwise blocks until stream is done)

 @return PortAudio error code
*/
static PaError PaAsiHpi_ExplicitStop( PaAsiHpiStream *stream, int abort )
{
    PaError result = paNoError;

    /* First deal with the callback thread, cancelling and/or joining it if necessary */
    if( stream->callbackMode )
    {
        PaError threadRes;
        stream->callbackAbort = abort;
        if( abort )
        {
            PA_DEBUG(( "Aborting callback\n" ));
        }
        else
        {
            PA_DEBUG(( "Stopping callback\n" ));
        }
        PA_ENSURE_( PaUnixThread_Terminate( &stream->thread, !abort, &threadRes ) );
        if( threadRes != paNoError )
        {
            PA_DEBUG(( "Callback thread returned: %d\n", threadRes ));
        }
    }
    else
    {
        PA_ENSURE_( PaAsiHpi_StopStream( stream, abort ) );
    }

    stream->state = paAsiHpiStoppedState;

error:
    return result;
}


/** Stop PortAudio stream.
 This blocks until the output buffers are drained.

 @param s Pointer to PortAudio stream

 @return PortAudio error code
*/
static PaError StopStream( PaStream *s )
{
    return PaAsiHpi_ExplicitStop( (PaAsiHpiStream *) s, 0 );
}


/** Abort PortAudio stream.
 This discards any existing data in output buffers and stops the stream immediately.

 @param s Pointer to PortAudio stream

 @return PortAudio error code
*/
static PaError AbortStream( PaStream *s )
{
    return PaAsiHpi_ExplicitStop( (PaAsiHpiStream * ) s, 1 );
}


/** Determine whether the stream is stopped.
 A stream is considered to be stopped prior to a successful call to StartStream and after
 a successful call to StopStream or AbortStream. If a stream callback returns a value other
 than paContinue the stream is NOT considered to be stopped (it is in CallbackFinished state).

 @param s Pointer to PortAudio stream

 @return Returns one (1) when the stream is stopped, zero (0) when the stream is running, or
         a PaErrorCode (which are always negative) if PortAudio is not initialized or an
         error is encountered.
*/
static PaError IsStreamStopped( PaStream *s )
{
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;

    assert( stream );
    return stream->state == paAsiHpiStoppedState ? 1 : 0;
}


/** Determine whether the stream is active.
 A stream is active after a successful call to StartStream(), until it becomes inactive either
 as a result of a call to StopStream() or AbortStream(), or as a result of a return value
 other than paContinue from the stream callback. In the latter case, the stream is considered
 inactive after the last buffer has finished playing.

 @param s Pointer to PortAudio stream

 @return Returns one (1) when the stream is active (i.e. playing or recording audio),
         zero (0) when not playing, or a PaErrorCode (which are always negative)
         if PortAudio is not initialized or an error is encountered.
*/
static PaError IsStreamActive( PaStream *s )
{
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;

    assert( stream );
    return stream->state == paAsiHpiActiveState ? 1 : 0;
}


/** Returns current stream time.
 This corresponds to the system clock. The clock should run continuously while the stream
 is open, i.e. between calls to OpenStream() and CloseStream(), therefore a frame counter
 is not good enough.

 @param s Pointer to PortAudio stream

 @return Stream time, in seconds
 */
static PaTime GetStreamTime( PaStream *s )
{
    return PaUtil_GetTime();
}


/** Returns CPU load.

 @param s Pointer to PortAudio stream

 @return CPU load (0.0 if blocking interface is used)
 */
static double GetStreamCpuLoad( PaStream *s )
{
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;

    return stream->callbackMode ? PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer ) : 0.0;
}

/* --------------------------- Callback Interface --------------------------- */

/** Exit routine which is called when callback thread quits.
 This takes care of stopping the HPI streams (either waiting for output to finish, or
 abruptly). It also calls the user-supplied StreamFinished callback, and sets the
 stream state to CallbackFinished if it was reached via a non-paContinue return from
 the user callback function.

 @param userData A pointer to an open stream previously created with Pa_OpenStream
 */
static void PaAsiHpi_OnThreadExit( void *userData )
{
    PaAsiHpiStream *stream = (PaAsiHpiStream *) userData;

    assert( stream );

    PaUtil_ResetCpuLoadMeasurer( &stream->cpuLoadMeasurer );

    PA_DEBUG(( "%s: Stopping HPI streams\n", __FUNCTION__ ));
    PaAsiHpi_StopStream( stream, stream->callbackAbort );
    PA_DEBUG(( "%s: Stoppage\n", __FUNCTION__ ));

    /* Eventually notify user all buffers have played */
    if( stream->baseStreamRep.streamFinishedCallback )
    {
        stream->baseStreamRep.streamFinishedCallback( stream->baseStreamRep.userData );
    }

    /* Unfortunately both explicit calls to Stop/AbortStream (leading to Stopped state)
     and implicit stops via paComplete/paAbort (leading to CallbackFinished state)
     end up here - need another flag to remind us which is the case */
    if( stream->callbackFinished )
        stream->state = paAsiHpiCallbackFinishedState;
}


/** Wait until there is enough frames to fill a host buffer.
 The routine attempts to sleep until at least a full host buffer can be retrieved from the
 input HPI stream and passed to the output HPI stream. It will first sleep until enough
 output space is available, as this is usually easily achievable. If it is an output-only
 stream, it will also sleep if the hardware buffer is too full, thereby throttling the
 filling of the output buffer and reducing output latency. The routine then blocks until
 enough input samples are available, unless this will cause an output underflow. In the
 process, input overflows and output underflows are indicated.

 @param stream Pointer to stream struct

 @param framesAvail Returns the number of available frames

 @param cbFlags Overflows and underflows indicated in here

 @return PortAudio error code (only paUnanticipatedHostError expected)
 */
static PaError PaAsiHpi_WaitForFrames( PaAsiHpiStream *stream, unsigned long *framesAvail,
                                       PaStreamCallbackFlags *cbFlags )
{
    PaError result = paNoError;
    double sampleRate;
    unsigned long framesTarget;
    uint32_t outputData = 0, outputSpace = 0, inputData = 0, framesLeft = 0;

    assert( stream );
    assert( stream->input || stream->output );

    sampleRate = stream->baseStreamRep.streamInfo.sampleRate;
    /* We have to come up with this much frames on both input and output */
    framesTarget = stream->bufferProcessor.framesPerHostBuffer;
    assert( framesTarget > 0 );

    while( 1 )
    {
        PaAsiHpiStreamInfo info;
        /* Check output first, as this takes priority in the default full-duplex mode */
        if( stream->output )
        {
            PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->output, &info ) );
            /* Wait until enough space is available in output buffer to receive a full block */
            if( info.availableFrames < framesTarget )
            {
                framesLeft = framesTarget - info.availableFrames;
                Pa_Sleep( (long)ceil( 1000 * framesLeft / sampleRate ) );
                continue;
            }
            /* Wait until the data in hardware buffer has dropped to a sensible level.
             Without this, the hardware buffer quickly fills up in the absence of an input
             stream to regulate its data rate (if data generation is fast). This leads to
             large latencies, as the AudioScience hardware buffers are humongous.
             This is similar to the default "Hardware Buffering=off" option in the
             AudioScience WAV driver. */
            if( !stream->input && (stream->output->outputBufferCap > 0) &&
                    ( info.totalBufferedData > stream->output->outputBufferCap / stream->output->bytesPerFrame ) )
            {
                framesLeft = info.totalBufferedData - stream->output->outputBufferCap / stream->output->bytesPerFrame;
                Pa_Sleep( (long)ceil( 1000 * framesLeft / sampleRate ) );
                continue;
            }
            outputData = info.totalBufferedData;
            outputSpace = info.availableFrames;
            /* Report output underflow to callback */
            if( info.underflow )
            {
                *cbFlags |= paOutputUnderflow;
            }
        }

        /* Now check input side */
        if( stream->input )
        {
            PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->input, &info ) );
            /* If a full block of samples hasn't been recorded yet, wait for it if possible */
            if( info.availableFrames < framesTarget )
            {
                framesLeft = framesTarget - info.availableFrames;
                /* As long as output is not disrupted in the process, wait for a full
                block of input samples */
                if( !stream->output || (outputData > framesLeft) )
                {
                    Pa_Sleep( (long)ceil( 1000 * framesLeft / sampleRate ) );
                    continue;
                }
            }
            inputData = info.availableFrames;
            /** @todo The paInputOverflow flag should be set in the callback containing the
             first input sample following the overflow. That means the block currently sitting
             at the fore-front of recording, i.e. typically the one containing the newest (last)
             sample in the HPI buffer system. This is most likely not the same as the current
             block of data being passed to the callback. The current overflow should ideally
             be noted in an overflow list of sorts, with an indication of when it should be
             reported. The trouble starts if there are several separate overflow incidents,
             given a big input buffer. Oh well, something to try out later... */
            if( info.overflow )
            {
                *cbFlags |= paInputOverflow;
            }
        }
        break;
    }
    /* Full-duplex stream */
    if( stream->input && stream->output )
    {
        if( outputSpace >= framesTarget )
            *framesAvail = outputSpace;
        /* If input didn't make the target, keep the output count instead (input underflow) */
        if( (inputData >= framesTarget) && (inputData < outputSpace) )
            *framesAvail = inputData;
    }
    else
    {
        *framesAvail = stream->input ? inputData : outputSpace;
    }

error:
    return result;
}


/** Obtain recording, current and playback timestamps of stream.
 The current time is determined by the system clock. This "now" timestamp occurs at the
 forefront of recording (and playback in the full-duplex case), which happens later than the
 input timestamp by an amount equal to the total number of recorded frames in the input buffer.
 The output timestamp indicates when the next generated sample will actually be played. This
 happens after all the samples currently in the output buffer are played. The output timestamp
 therefore follows the current timestamp by an amount equal to the number of frames yet to be
 played back in the output buffer.

 If the current timestamp is the present, the input timestamp is in the past and the output
 timestamp is in the future.

 @param stream Pointer to stream struct

 @param timeInfo Pointer to timeInfo struct that will contain timestamps
 */
static void PaAsiHpi_CalculateTimeInfo( PaAsiHpiStream *stream, PaStreamCallbackTimeInfo *timeInfo )
{
    PaAsiHpiStreamInfo streamInfo;
    double sampleRate;

    assert( stream );
    assert( timeInfo );
    sampleRate = stream->baseStreamRep.streamInfo.sampleRate;

    /* The current time ("now") is at the forefront of both recording and playback */
    timeInfo->currentTime = GetStreamTime( (PaStream *)stream );
    /* The last sample in the input buffer was recorded just now, so the first sample
     happened (number of recorded samples)/sampleRate ago */
    timeInfo->inputBufferAdcTime = timeInfo->currentTime;
    if( stream->input )
    {
        PaAsiHpi_GetStreamInfo( stream->input, &streamInfo );
        timeInfo->inputBufferAdcTime -= streamInfo.totalBufferedData / sampleRate;
    }
    /* The first of the outgoing samples will be played after all the samples in the output
     buffer is done */
    timeInfo->outputBufferDacTime = timeInfo->currentTime;
    if( stream->output )
    {
        PaAsiHpi_GetStreamInfo( stream->output, &streamInfo );
        timeInfo->outputBufferDacTime += streamInfo.totalBufferedData / sampleRate;
    }
}


/** Read from HPI input stream and register buffers.
 This reads data from the HPI input stream (if it exists) and registers the temp stream
 buffers of both input and output streams with the buffer processor. In the process it also
 handles input underflows in the full-duplex case.

 @param stream Pointer to stream struct

 @param numFrames On entrance the number of available frames, on exit the number of
                  received frames

 @param cbFlags Indicates overflows and underflows

 @return PortAudio error code
 */
static PaError PaAsiHpi_BeginProcessing( PaAsiHpiStream *stream, unsigned long *numFrames,
        PaStreamCallbackFlags *cbFlags )
{
    PaError result = paNoError;

    assert( stream );
    if( *numFrames > stream->maxFramesPerHostBuffer )
        *numFrames = stream->maxFramesPerHostBuffer;

    if( stream->input )
    {
        PaAsiHpiStreamInfo info;

        uint32_t framesToGet = *numFrames;

        /* Check for overflows and underflows yet again */
        PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->input, &info ) );
        if( info.overflow )
        {
            *cbFlags |= paInputOverflow;
        }
        /* Input underflow if less than expected number of samples pitch up */
        if( framesToGet > info.availableFrames )
        {
            PaUtilZeroer *zeroer;
            PaSampleFormat inputFormat;

            /* Never call an input-only stream with InputUnderflow set */
            if( stream->output )
                *cbFlags |= paInputUnderflow;
            framesToGet = info.availableFrames;
            /* Fill temp buffer with silence (to make up for missing input samples) */
            inputFormat = PaAsiHpi_HpiToPaFormat( stream->input->hpiFormat.wFormat );
            zeroer = PaUtil_SelectZeroer( inputFormat );
            zeroer(stream->input->tempBuffer, 1,
                   stream->input->tempBufferSize / Pa_GetSampleSize(inputFormat) );
        }

        /* Read block of data into temp buffer */
        PA_ASIHPI_UNLESS_( HPI_InStreamReadBuf( NULL,
                                             stream->input->hpiStream,
                                             stream->input->tempBuffer,
                                             framesToGet * stream->input->bytesPerFrame),
                           paUnanticipatedHostError );
        /* Register temp buffer with buffer processor (always FULL buffer) */
        PaUtil_SetInputFrameCount( &stream->bufferProcessor, *numFrames );
        /* HPI interface only allows interleaved channels */
        PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor,
                                            0, stream->input->tempBuffer,
                                            stream->input->hpiFormat.wChannels );
    }
    if( stream->output )
    {
        /* Register temp buffer with buffer processor */
        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, *numFrames );
        /* HPI interface only allows interleaved channels */
        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor,
                                             0, stream->output->tempBuffer,
                                             stream->output->hpiFormat.wChannels );
    }

error:
    return result;
}


/** Flush output buffers to HPI output stream.
 This completes the processing cycle by writing the temp buffer to the HPI interface.
 Additional output underflows are caught before data is written to the stream, as this
 action typically remedies the underflow and hides it in the process.

 @param stream Pointer to stream struct

 @param numFrames The number of frames to write to the output stream

 @param cbFlags Indicates overflows and underflows
 */
static PaError PaAsiHpi_EndProcessing( PaAsiHpiStream *stream, unsigned long numFrames,
                                       PaStreamCallbackFlags *cbFlags )
{
    PaError result = paNoError;

    assert( stream );

    if( stream->output )
    {
        PaAsiHpiStreamInfo info;
        /* Check for underflows after the (potentially time-consuming) callback */
        PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->output, &info ) );
        if( info.underflow )
        {
            *cbFlags |= paOutputUnderflow;
        }

        /* Write temp buffer to HPI stream */
        PA_ASIHPI_UNLESS_( HPI_OutStreamWriteBuf( NULL,
                                           stream->output->hpiStream,
                                           stream->output->tempBuffer,
                                           numFrames * stream->output->bytesPerFrame,
                                           &stream->output->hpiFormat),
                           paUnanticipatedHostError );
    }

error:
    return result;
}


/** Main callback engine.
 This function runs in a separate thread and does all the work of fetching audio data from
 the AudioScience card via the HPI interface, feeding it to the user callback via the buffer
 processor, and delivering the resulting output data back to the card via HPI calls.
 It is started and terminated when the PortAudio stream is started and stopped, and starts
 the HPI streams on startup.

 @param userData A pointer to an open stream previously created with Pa_OpenStream.
*/
static void *CallbackThreadFunc( void *userData )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream *) userData;
    int callbackResult = paContinue;

    assert( stream );

    /* Cleanup routine stops streams on thread exit */
    pthread_cleanup_push( &PaAsiHpi_OnThreadExit, stream );

    /* Start HPI streams and notify parent when we're done */
    PA_ENSURE_( PaUnixThread_PrepareNotify( &stream->thread ) );
    /* Buffer will be primed with silence */
    PA_ENSURE_( PaAsiHpi_StartStream( stream, 0 ) );
    PA_ENSURE_( PaUnixThread_NotifyParent( &stream->thread ) );

    /* MAIN LOOP */
    while( 1 )
    {
        PaStreamCallbackFlags cbFlags = 0;
        unsigned long framesAvail, framesGot;

        pthread_testcancel();

        /** @concern StreamStop if the main thread has requested a stop and the stream has not
        * been effectively stopped we signal this condition by modifying callbackResult
        * (we'll want to flush buffered output). */
        if( PaUnixThread_StopRequested( &stream->thread ) && (callbackResult == paContinue) )
        {
            PA_DEBUG(( "Setting callbackResult to paComplete\n" ));
            callbackResult = paComplete;
        }

        /* Start winding down thread if requested */
        if( callbackResult != paContinue )
        {
            stream->callbackAbort = (callbackResult == paAbort);
            if( stream->callbackAbort ||
                    /** @concern BlockAdaption: Go on if adaption buffers are empty */
                    PaUtil_IsBufferProcessorOutputEmpty( &stream->bufferProcessor ) )
            {
                goto end;
            }
            PA_DEBUG(( "%s: Flushing buffer processor\n", __FUNCTION__ ));
            /* There is still buffered output that needs to be processed */
        }

        /* SLEEP */
        /* Wait for data (or buffer space) to become available. This basically sleeps and
        polls the HPI interface until a full block of frames can be moved. */
        PA_ENSURE_( PaAsiHpi_WaitForFrames( stream, &framesAvail, &cbFlags ) );

        /* Consume buffer space. Once we have a number of frames available for consumption we
        must retrieve the data from the HPI interface and pass it to the PA buffer processor.
        We should be prepared to process several chunks successively. */
        while( framesAvail > 0 )
        {
            PaStreamCallbackTimeInfo timeInfo = {0, 0, 0};

            pthread_testcancel();

            framesGot = framesAvail;
            if( stream->bufferProcessor.hostBufferSizeMode == paUtilFixedHostBufferSize )
            {
                /* We've committed to a fixed host buffer size, stick to that */
                framesGot = framesGot >= stream->maxFramesPerHostBuffer ? stream->maxFramesPerHostBuffer : 0;
            }
            else
            {
                /* We've committed to an upper bound on the size of host buffers */
                assert( stream->bufferProcessor.hostBufferSizeMode == paUtilBoundedHostBufferSize );
                framesGot = PA_MIN( framesGot, stream->maxFramesPerHostBuffer );
            }

            /* Obtain buffer timestamps */
            PaAsiHpi_CalculateTimeInfo( stream, &timeInfo );
            PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, cbFlags );
            /* CPU load measurement should include processing activivity external to the stream callback */
            PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );
            if( framesGot > 0 )
            {
                /* READ FROM HPI INPUT STREAM */
                PA_ENSURE_( PaAsiHpi_BeginProcessing( stream, &framesGot, &cbFlags ) );
                /* Input overflow in a full-duplex stream makes for interesting times */
                if( stream->input && stream->output && (cbFlags & paInputOverflow) )
                {
                    /* Special full-duplex paNeverDropInput mode */
                    if( stream->neverDropInput )
                    {
                        PaUtil_SetNoOutput( &stream->bufferProcessor );
                        cbFlags |= paOutputOverflow;
                    }
                }
                /* CALL USER CALLBACK WITH INPUT DATA, AND OBTAIN OUTPUT DATA */
                PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );
                /* Clear overflow and underflow information (but PaAsiHpi_EndProcessing might
                still show up output underflow that will carry over to next round) */
                cbFlags = 0;
                /*  WRITE TO HPI OUTPUT STREAM */
                PA_ENSURE_( PaAsiHpi_EndProcessing( stream, framesGot, &cbFlags ) );
                /* Advance frame counter */
                framesAvail -= framesGot;
            }
            PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesGot );

            if( framesGot == 0 )
            {
                /* Go back to polling for more frames */
                break;

            }
            if( callbackResult != paContinue )
                break;
        }
    }

    /* This code is unreachable, but important to include regardless because it
     * is possibly a macro with a closing brace to match the opening brace in
     * pthread_cleanup_push() above.  The documentation states that they must
     * always occur in pairs. */
    pthread_cleanup_pop( 1 );

end:
    /* Indicates normal exit of callback, as opposed to the thread getting killed explicitly */
    stream->callbackFinished = 1;
    PA_DEBUG(( "%s: Thread %d exiting (callbackResult = %d)\n ",
               __FUNCTION__, pthread_self(), callbackResult ));
    /* Exit from thread and report any PortAudio error in the process */
    PaUnixThreading_EXIT( result );
error:
    goto end;
}

/* --------------------------- Blocking Interface --------------------------- */

/* As separate stream interfaces are used for blocking and callback streams, the following
 functions can be guaranteed to only be called for blocking streams. */

/** Read data from input stream.
 This reads the indicated number of frames into the supplied buffer from an input stream,
 and blocks until this is done.

 @param s Pointer to PortAudio stream

 @param buffer Pointer to buffer that will receive interleaved data (or an array of pointers
               to a buffer for each non-interleaved channel)

 @param frames Number of frames to read from stream

 @return PortAudio error code (also indicates overflow via paInputOverflowed)
 */
static PaError ReadStream( PaStream *s,
                           void *buffer,
                           unsigned long frames )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;
    PaAsiHpiStreamInfo info;
    void *userBuffer;

    assert( stream );
    PA_UNLESS_( stream->input, paCanNotReadFromAnOutputOnlyStream );

    /* Check for input overflow since previous call to ReadStream */
    PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->input, &info ) );
    if( info.overflow )
    {
        result = paInputOverflowed;
    }

    /* NB Make copy of user buffer pointers, since they are advanced by buffer processor */
    if( stream->bufferProcessor.userInputIsInterleaved )
    {
        userBuffer = buffer;
    }
    else
    {
        /* Copy channels into local array */
        userBuffer = stream->blockingUserBufferCopy;
        memcpy( userBuffer, buffer, sizeof (void *) * stream->input->hpiFormat.wChannels );
    }

    while( frames > 0 )
    {
        unsigned long framesGot, framesAvail;
        PaStreamCallbackFlags cbFlags = 0;

        PA_ENSURE_( PaAsiHpi_WaitForFrames( stream, &framesAvail, &cbFlags ) );
        framesGot = PA_MIN( framesAvail, frames );
        PA_ENSURE_( PaAsiHpi_BeginProcessing( stream, &framesGot, &cbFlags ) );

        if( framesGot > 0 )
        {
            framesGot = PaUtil_CopyInput( &stream->bufferProcessor, &userBuffer, framesGot );
            PA_ENSURE_( PaAsiHpi_EndProcessing( stream, framesGot, &cbFlags ) );
            /* Advance frame counter */
            frames -= framesGot;
        }
    }

error:
    return result;
}


/** Write data to output stream.
 This writes the indicated number of frames from the supplied buffer to an output stream,
 and blocks until this is done.

 @param s Pointer to PortAudio stream

 @param buffer Pointer to buffer that provides interleaved data (or an array of pointers
               to a buffer for each non-interleaved channel)

 @param frames Number of frames to write to stream

 @return PortAudio error code (also indicates underflow via paOutputUnderflowed)
 */
static PaError WriteStream( PaStream *s,
                            const void *buffer,
                            unsigned long frames )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;
    PaAsiHpiStreamInfo info;
    const void *userBuffer;

    assert( stream );
    PA_UNLESS_( stream->output, paCanNotWriteToAnInputOnlyStream );

    /* Check for output underflow since previous call to WriteStream */
    PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->output, &info ) );
    if( info.underflow )
    {
        result = paOutputUnderflowed;
    }

    /* NB Make copy of user buffer pointers, since they are advanced by buffer processor */
    if( stream->bufferProcessor.userOutputIsInterleaved )
    {
        userBuffer = buffer;
    }
    else
    {
        /* Copy channels into local array */
        userBuffer = stream->blockingUserBufferCopy;
        memcpy( (void *)userBuffer, buffer, sizeof (void *) * stream->output->hpiFormat.wChannels );
    }

    while( frames > 0 )
    {
        unsigned long framesGot, framesAvail;
        PaStreamCallbackFlags cbFlags = 0;

        PA_ENSURE_( PaAsiHpi_WaitForFrames( stream, &framesAvail, &cbFlags ) );
        framesGot = PA_MIN( framesAvail, frames );
        PA_ENSURE_( PaAsiHpi_BeginProcessing( stream, &framesGot, &cbFlags ) );

        if( framesGot > 0 )
        {
            framesGot = PaUtil_CopyOutput( &stream->bufferProcessor, &userBuffer, framesGot );
            PA_ENSURE_( PaAsiHpi_EndProcessing( stream, framesGot, &cbFlags ) );
            /* Advance frame counter */
            frames -= framesGot;
        }
    }

error:
    return result;
}


/** Number of frames that can be read from input stream without blocking.

 @param s Pointer to PortAudio stream

 @return Number of frames, or PortAudio error code
 */
static signed long GetStreamReadAvailable( PaStream *s )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;
    PaAsiHpiStreamInfo info;

    assert( stream );
    PA_UNLESS_( stream->input, paCanNotReadFromAnOutputOnlyStream );

    PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->input, &info ) );
    /* Round down to the nearest host buffer multiple */
    result = (info.availableFrames / stream->maxFramesPerHostBuffer) * stream->maxFramesPerHostBuffer;
    if( info.overflow )
    {
        result = paInputOverflowed;
    }

error:
    return result;
}


/** Number of frames that can be written to output stream without blocking.

 @param s Pointer to PortAudio stream

 @return Number of frames, or PortAudio error code
 */
static signed long GetStreamWriteAvailable( PaStream *s )
{
    PaError result = paNoError;
    PaAsiHpiStream *stream = (PaAsiHpiStream*)s;
    PaAsiHpiStreamInfo info;

    assert( stream );
    PA_UNLESS_( stream->output, paCanNotWriteToAnInputOnlyStream );

    PA_ENSURE_( PaAsiHpi_GetStreamInfo( stream->output, &info ) );
    /* Round down to the nearest host buffer multiple */
    result = (info.availableFrames / stream->maxFramesPerHostBuffer) * stream->maxFramesPerHostBuffer;
    if( info.underflow )
    {
        result = paOutputUnderflowed;
    }

error:
    return result;
}
#endif

#if PA_USE_ASIO
// This uses C++, not C!
// ****************************************************************************
// File:			IASIOThiscallResolver.h
// Description:     The IASIOThiscallResolver class implements the IASIO
//					interface and acts as a proxy to the real IASIO interface by
//                  calling through its vptr table using the thiscall calling
//                  convention. To put it another way, we interpose
//                  IASIOThiscallResolver between ASIO SDK code and the driver.
//                  This is necessary because most non-Microsoft compilers don't
//                  implement the thiscall calling convention used by IASIO.
//
//					iasiothiscallresolver.cpp contains the background of this
//					problem plus a technical description of the vptr
//                  manipulations.
//
//					In order to use this mechanism one simply has to add
//					iasiothiscallresolver.cpp to the list of files to compile
//                  and #include <iasiothiscallresolver.h>
//
//					Note that this #include must come after the other ASIO SDK
//                  #includes, for example:
//
//					#include <windows.h>
//					#include <asiosys.h>
//					#include <asio.h>
//					#include <asiodrivers.h>
//					#include <iasiothiscallresolver.h>
//
//					Actually the important thing is to #include
//                  <iasiothiscallresolver.h> after <asio.h>. We have
//                  incorporated a test to enforce this ordering.
//
//					The code transparently takes care of the interposition by
//                  using macro substitution to intercept calls to ASIOInit()
//                  and ASIOExit(). We save the original ASIO global
//                  "theAsioDriver" in our "that" variable, and then set
//                  "theAsioDriver" to equal our IASIOThiscallResolver instance.
//
// 					Whilst this method of resolving the thiscall problem requires
//					the addition of #include <iasiothiscallresolver.h> to client
//                  code it has the advantage that it does not break the terms
//                  of the ASIO licence by publishing it. We are NOT modifying
//                  any Steinberg code here, we are merely implementing the IASIO
//					interface in the same way that we would need to do if we
//					wished to provide an open source ASIO driver.
//
//					For compilation with MinGW -lole32 needs to be added to the
//                  linker options. For BORLAND, linking with Import32.lib is
//                  sufficient.
//
//					The dependencies are with: CoInitialize, CoUninitialize,
//					CoCreateInstance, CLSIDFromString - used by asiolist.cpp
//					and are required on Windows whether ThiscallResolver is used
//					or not.
//
//					Searching for the above strings in the root library path
//					of your compiler should enable the correct libraries to be
//					identified if they aren't immediately obvious.
//
//                  Note that the current implementation of IASIOThiscallResolver
//                  is not COM compliant - it does not correctly implement the
//                  IUnknown interface. Implementing it is not necessary because
//                  it is not called by parts of the ASIO SDK which call through
//                  theAsioDriver ptr. The IUnknown methods are implemented as
//                  assert(false) to ensure that the code fails if they are
//                  ever called.
// Restrictions:	None. Public Domain & Open Source distribute freely
//					You may use IASIOThiscallResolver commercially as well as
//                  privately.
//					You the user assume the responsibility for the use of the
//					files, binary or text, and there is no guarantee or warranty,
//					expressed or implied, including but not limited to the
//					implied warranties of merchantability and fitness for a
//					particular purpose. You assume all responsibility and agree
//					to hold no entity, copyright holder or distributors liable
//					for any loss of data or inaccurate representations of data
//					as a result of using IASIOThiscallResolver.
// Version:         1.4 Added separate macro CALL_THISCALL_1_DOUBLE from
//                  Andrew Baldwin, and volatile for whole gcc asm blocks,
//                  both for compatibility with newer gcc versions. Cleaned up
//                  Borland asm to use one less register.
//                  1.3 Switched to including assert.h for better compatibility.
//                  Wrapped entire .h and .cpp contents with a check for
//                  _MSC_VER to provide better compatibility with MS compilers.
//                  Changed Singleton implementation to use static instance
//                  instead of freestore allocated instance. Removed ASIOExit
//                  macro as it is no longer needed.
//                  1.2 Removed semicolons from ASIOInit and ASIOExit macros to
//                  allow them to be embedded in expressions (if statements).
//                  Cleaned up some comments. Removed combase.c dependency (it
//                  doesn't compile with BCB anyway) by stubbing IUnknown.
//                  1.1 Incorporated comments from Ross Bencina including things
//					such as changing name from ThiscallResolver to
//					IASIOThiscallResolver, tidying up the constructor, fixing
//					a bug in IASIOThiscallResolver::ASIOExit() and improving
//					portability through the use of conditional compilation
//					1.0 Initial working version.
// Created:			6/09/2003
// Authors:         Fraser Adams
//                  Ross Bencina
//                  Rene G. Ceballos
//                  Martin Fay
//                  Antti Silvast
//                  Andrew Baldwin
//
// ****************************************************************************


#ifndef included_iasiothiscallresolver_h
#define included_iasiothiscallresolver_h

// We only need IASIOThiscallResolver at all if we are on Win32. For other
// platforms we simply bypass the IASIOThiscallResolver definition to allow us
// to be safely #include'd whatever the platform to keep client code portable
#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) && !defined(_WIN64)


// If microsoft compiler we can call IASIO directly so IASIOThiscallResolver
// is not used.
#if !defined(_MSC_VER)


// The following is in order to ensure that this header is only included after
// the other ASIO headers (except for the case of iasiothiscallresolver.cpp).
// We need to do this because IASIOThiscallResolver works by eclipsing the
// original definition of ASIOInit() with a macro (see below).
#if !defined(iasiothiscallresolver_sourcefile)
	#if !defined(__ASIO_H)
	#error iasiothiscallresolver.h must be included AFTER asio.h
	#endif
#endif

#include <windows.h>
#include <asiodrvr.h> /* From ASIO SDK */


class IASIOThiscallResolver : public IASIO {
private:
	IASIO* that_; // Points to the real IASIO

	static IASIOThiscallResolver instance; // Singleton instance

	// Constructors - declared private so construction is limited to
    // our Singleton instance
    IASIOThiscallResolver();
	IASIOThiscallResolver(IASIO* that);
public:

    // Methods from the IUnknown interface. We don't fully implement IUnknown
    // because the ASIO SDK never calls these methods through theAsioDriver ptr.
    // These methods are implemented as assert(false).
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // Methods from the IASIO interface, implemented as forwarning calls to that.
	virtual ASIOBool init(void *sysHandle);
	virtual void getDriverName(char *name);
	virtual long getDriverVersion();
	virtual void getErrorMessage(char *string);
	virtual ASIOError start();
	virtual ASIOError stop();
	virtual ASIOError getChannels(long *numInputChannels, long *numOutputChannels);
	virtual ASIOError getLatencies(long *inputLatency, long *outputLatency);
	virtual ASIOError getBufferSize(long *minSize, long *maxSize, long *preferredSize, long *granularity);
	virtual ASIOError canSampleRate(ASIOSampleRate sampleRate);
	virtual ASIOError getSampleRate(ASIOSampleRate *sampleRate);
	virtual ASIOError setSampleRate(ASIOSampleRate sampleRate);
	virtual ASIOError getClockSources(ASIOClockSource *clocks, long *numSources);
	virtual ASIOError setClockSource(long reference);
	virtual ASIOError getSamplePosition(ASIOSamples *sPos, ASIOTimeStamp *tStamp);
	virtual ASIOError getChannelInfo(ASIOChannelInfo *info);
	virtual ASIOError createBuffers(ASIOBufferInfo *bufferInfos, long numChannels, long bufferSize, ASIOCallbacks *callbacks);
	virtual ASIOError disposeBuffers();
	virtual ASIOError controlPanel();
	virtual ASIOError future(long selector,void *opt);
	virtual ASIOError outputReady();

    // Class method, see ASIOInit() macro below.
    static ASIOError ASIOInit(ASIODriverInfo *info); // Delegates to ::ASIOInit
};


// Replace calls to ASIOInit with our interposing version.
// This macro enables us to perform thiscall resolution simply by #including
// <iasiothiscallresolver.h> after the asio #includes (this file _must_ be
// included _after_ the asio #includes)

#define ASIOInit(name) IASIOThiscallResolver::ASIOInit((name))


#endif /* !defined(_MSC_VER) */

#endif /* Win32 */

#endif /* included_iasiothiscallresolver_h */
/*
	IASIOThiscallResolver.cpp see the comments in iasiothiscallresolver.h for
    the top level description - this comment describes the technical details of
    the implementation.

    The latest version of this file is available from:
    http://www.audiomulch.com/~rossb/code/calliasio

    please email comments to Ross Bencina <rossb@audiomulch.com>

    BACKGROUND

    The IASIO interface declared in the Steinberg ASIO 2 SDK declares
    functions with no explicit calling convention. This causes MSVC++ to default
    to using the thiscall convention, which is a proprietary convention not
    implemented by some non-microsoft compilers - notably borland BCC,
    C++Builder, and gcc. MSVC++ is the defacto standard compiler used by
    Steinberg. As a result of this situation, the ASIO sdk will compile with
    any compiler, however attempting to execute the compiled code will cause a
    crash due to different default calling conventions on non-Microsoft
    compilers.

    IASIOThiscallResolver solves the problem by providing an adapter class that
    delegates to the IASIO interface using the correct calling convention
    (thiscall). Due to the lack of support for thiscall in the Borland and GCC
    compilers, the calls have been implemented in assembly language.

    A number of macros are defined for thiscall function calls with different
    numbers of parameters, with and without return values - it may be possible
    to modify the format of these macros to make them work with other inline
    assemblers.


    THISCALL DEFINITION

    A number of definitions of the thiscall calling convention are floating
    around the internet. The following definition has been validated against
    output from the MSVC++ compiler:

    For non-vararg functions, thiscall works as follows: the object (this)
    pointer is passed in ECX. All arguments are passed on the stack in
    right to left order. The return value is placed in EAX. The callee
    clears the passed arguments from the stack.


    FINDING FUNCTION POINTERS FROM AN IASIO POINTER

    The first field of a COM object is a pointer to its vtble. Thus a pointer
    to an object implementing the IASIO interface also points to a pointer to
    that object's vtbl. The vtble is a table of function pointers for all of
    the virtual functions exposed by the implemented interfaces.

    If we consider a variable declared as a pointer to IASO:

    IASIO *theAsioDriver

    theAsioDriver points to:

    object implementing IASIO
    {
        IASIOvtbl *vtbl
        other data
    }

    in other words, theAsioDriver points to a pointer to an IASIOvtbl

    vtbl points to a table of function pointers:

    IASIOvtbl ( interface IASIO : public IUnknown )
    {
    (IUnknown functions)
    0   virtual HRESULT STDMETHODCALLTYPE (*QueryInterface)(REFIID riid, void **ppv) = 0;
    4   virtual ULONG STDMETHODCALLTYPE (*AddRef)() = 0;
    8   virtual ULONG STDMETHODCALLTYPE (*Release)() = 0;      

    (IASIO functions)
    12	virtual ASIOBool (*init)(void *sysHandle) = 0;
    16	virtual void (*getDriverName)(char *name) = 0;
    20	virtual long (*getDriverVersion)() = 0;
    24	virtual void (*getErrorMessage)(char *string) = 0;
    28	virtual ASIOError (*start)() = 0;
    32	virtual ASIOError (*stop)() = 0;
    36	virtual ASIOError (*getChannels)(long *numInputChannels, long *numOutputChannels) = 0;
    40	virtual ASIOError (*getLatencies)(long *inputLatency, long *outputLatency) = 0;
    44	virtual ASIOError (*getBufferSize)(long *minSize, long *maxSize,
            long *preferredSize, long *granularity) = 0;
    48	virtual ASIOError (*canSampleRate)(ASIOSampleRate sampleRate) = 0;
    52	virtual ASIOError (*getSampleRate)(ASIOSampleRate *sampleRate) = 0;
    56	virtual ASIOError (*setSampleRate)(ASIOSampleRate sampleRate) = 0;
    60	virtual ASIOError (*getClockSources)(ASIOClockSource *clocks, long *numSources) = 0;
    64	virtual ASIOError (*setClockSource)(long reference) = 0;
    68	virtual ASIOError (*getSamplePosition)(ASIOSamples *sPos, ASIOTimeStamp *tStamp) = 0;
    72	virtual ASIOError (*getChannelInfo)(ASIOChannelInfo *info) = 0;
    76	virtual ASIOError (*createBuffers)(ASIOBufferInfo *bufferInfos, long numChannels,
            long bufferSize, ASIOCallbacks *callbacks) = 0;
    80	virtual ASIOError (*disposeBuffers)() = 0;
    84	virtual ASIOError (*controlPanel)() = 0;
    88	virtual ASIOError (*future)(long selector,void *opt) = 0;
    92	virtual ASIOError (*outputReady)() = 0;
    };

    The numbers in the left column show the byte offset of each function ptr
    from the beginning of the vtbl. These numbers are used in the code below
    to select different functions.

    In order to find the address of a particular function, theAsioDriver
    must first be dereferenced to find the value of the vtbl pointer:

    mov     eax, theAsioDriver
    mov     edx, [theAsioDriver]  // edx now points to vtbl[0]

    Then an offset must be added to the vtbl pointer to select a
    particular function, for example vtbl+44 points to the slot containing
    a pointer to the getBufferSize function.

    Finally vtbl+x must be dereferenced to obtain the value of the function
    pointer stored in that address:

    call    [edx+44]    // call the function pointed to by
                        // the value in the getBufferSize field of the vtbl


    SEE ALSO

    Martin Fay's OpenASIO DLL at http://www.martinfay.com solves the same
    problem by providing a new COM interface which wraps IASIO with an
    interface that uses portable calling conventions. OpenASIO must be compiled
    with MSVC, and requires that you ship the OpenASIO DLL with your
    application.

    
    ACKNOWLEDGEMENTS

    Ross Bencina: worked out the thiscall details above, wrote the original
    Borland asm macros, and a patch for asio.cpp (which is no longer needed).
    Thanks to Martin Fay for introducing me to the issues discussed here,
    and to Rene G. Ceballos for assisting with asm dumps from MSVC++.

    Antti Silvast: converted the original calliasio to work with gcc and NASM
    by implementing the asm code in a separate file.

	Fraser Adams: modified the original calliasio containing the Borland inline
    asm to add inline asm for gcc i.e. Intel syntax for Borland and AT&T syntax
    for gcc. This seems a neater approach for gcc than to have a separate .asm
    file and it means that we only need one version of the thiscall patch.

    Fraser Adams: rewrote the original calliasio patch in the form of the
    IASIOThiscallResolver class in order to avoid modifications to files from
    the Steinberg SDK, which may have had potential licence issues.

    Andrew Baldwin: contributed fixes for compatibility problems with more
    recent versions of the gcc assembler.
*/


// We only need IASIOThiscallResolver at all if we are on Win32. For other
// platforms we simply bypass the IASIOThiscallResolver definition to allow us
// to be safely #include'd whatever the platform to keep client code portable
#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) && !defined(_WIN64)


// If microsoft compiler we can call IASIO directly so IASIOThiscallResolver
// is not used.
#if !defined(_MSC_VER)


#include <new>
#include <assert.h>

// We have a mechanism in iasiothiscallresolver.h to ensure that asio.h is
// #include'd before it in client code, we do NOT want to do this test here.
#define iasiothiscallresolver_sourcefile 1
// (amalg) #include "iasiothiscallresolver.h"
#undef iasiothiscallresolver_sourcefile

// iasiothiscallresolver.h redefines ASIOInit for clients, but we don't want
// this macro defined in this translation unit.
#undef ASIOInit


// theAsioDriver is a global pointer to the current IASIO instance which the
// ASIO SDK uses to perform all actions on the IASIO interface. We substitute
// our own forwarding interface into this pointer.
extern IASIO* theAsioDriver;


// The following macros define the inline assembler for BORLAND first then gcc

#if defined(__BCPLUSPLUS__) || defined(__BORLANDC__)          


#define CALL_THISCALL_0( resultName, thisPtr, funcOffset )\
    void *this_ = (thisPtr);                                                \
    __asm {                                                                 \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
        mov     resultName, eax       ;                                     \
    }


#define CALL_VOID_THISCALL_1( thisPtr, funcOffset, param1 )\
    void *this_ = (thisPtr);                                                \
    __asm {                                                                 \
        mov     eax, param1           ;                                     \
        push    eax                   ;                                     \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
    }


#define CALL_THISCALL_1( resultName, thisPtr, funcOffset, param1 )\
    void *this_ = (thisPtr);                                                \
    __asm {                                                                 \
        mov     eax, param1           ;                                     \
        push    eax                   ;                                     \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
        mov     resultName, eax       ;                                     \
    }


#define CALL_THISCALL_1_DOUBLE( resultName, thisPtr, funcOffset, param1 )\
    void *this_ = (thisPtr);                                                \
    void *doubleParamPtr_ (&param1);                                        \
    __asm {                                                                 \
        mov     eax, doubleParamPtr_  ;                                     \
        push    [eax+4]               ;                                     \
        push    [eax]                 ;                                     \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
        mov     resultName, eax       ;                                     \
    }


#define CALL_THISCALL_2( resultName, thisPtr, funcOffset, param1, param2 )\
    void *this_ = (thisPtr);                                                \
    __asm {                                                                 \
        mov     eax, param2           ;                                     \
        push    eax                   ;                                     \
        mov     eax, param1           ;                                     \
        push    eax                   ;                                     \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
        mov     resultName, eax       ;                                     \
    }


#define CALL_THISCALL_4( resultName, thisPtr, funcOffset, param1, param2, param3, param4 )\
    void *this_ = (thisPtr);                                                \
    __asm {                                                                 \
        mov     eax, param4           ;                                     \
        push    eax                   ;                                     \
        mov     eax, param3           ;                                     \
        push    eax                   ;                                     \
        mov     eax, param2           ;                                     \
        push    eax                   ;                                     \
        mov     eax, param1           ;                                     \
        push    eax                   ;                                     \
        mov     ecx, this_            ;                                     \
        mov     eax, [ecx]            ;                                     \
        call    [eax+funcOffset]      ;                                     \
        mov     resultName, eax       ;                                     \
    }


#elif defined(__GNUC__)


#define CALL_THISCALL_0( resultName, thisPtr, funcOffset )                  \
    __asm__ __volatile__ ("movl (%1), %%edx\n\t"                            \
                          "call *"#funcOffset"(%%edx)\n\t"                  \
                          :"=a"(resultName) /* Output Operands */           \
                          :"c"(thisPtr)     /* Input Operands */            \
                          : "%edx" /* Clobbered Registers */                \
                         );                                                 \


#define CALL_VOID_THISCALL_1( thisPtr, funcOffset, param1 )                 \
    __asm__ __volatile__ ("pushl %0\n\t"                                    \
                          "movl (%1), %%edx\n\t"                            \
                          "call *"#funcOffset"(%%edx)\n\t"                  \
                          :                 /* Output Operands */           \
                          :"r"(param1),     /* Input Operands */            \
                           "c"(thisPtr)                                     \
                          : "%edx" /* Clobbered Registers */                \
                         );                                                 \


#define CALL_THISCALL_1( resultName, thisPtr, funcOffset, param1 )          \
    __asm__ __volatile__ ("pushl %1\n\t"                                    \
                          "movl (%2), %%edx\n\t"                            \
                          "call *"#funcOffset"(%%edx)\n\t"                  \
                          :"=a"(resultName) /* Output Operands */           \
                          :"r"(param1),     /* Input Operands */            \
                           "c"(thisPtr)                                     \
                          : "%edx" /* Clobbered Registers */                \
                          );                                                \


#define CALL_THISCALL_1_DOUBLE( resultName, thisPtr, funcOffset, param1 )   \
    do {                                                                    \
    double param1f64 = param1; /* Cast explicitly to double */              \
    double *param1f64Ptr = &param1f64; /* Make pointer to address */        \
     __asm__ __volatile__ ("pushl 4(%1)\n\t"                                \
                           "pushl (%1)\n\t"                                 \
                           "movl (%2), %%edx\n\t"                           \
                           "call *"#funcOffset"(%%edx);\n\t"                \
                           : "=a"(resultName) /* Output Operands */         \
                           : "r"(param1f64Ptr),  /* Input Operands */       \
                           "c"(thisPtr),                                    \
                           "m"(*param1f64Ptr) /* Using address */           \
                           : "%edx" /* Clobbered Registers */               \
                           );                                               \
    } while (0);                                                            \


#define CALL_THISCALL_2( resultName, thisPtr, funcOffset, param1, param2 )  \
    __asm__ __volatile__ ("pushl %1\n\t"                                    \
                          "pushl %2\n\t"                                    \
                          "movl (%3), %%edx\n\t"                            \
                          "call *"#funcOffset"(%%edx)\n\t"                  \
                          :"=a"(resultName) /* Output Operands */           \
                          :"r"(param2),     /* Input Operands */            \
                           "r"(param1),                                     \
                           "c"(thisPtr)                                     \
                          : "%edx" /* Clobbered Registers */                \
                          );                                                \


#define CALL_THISCALL_4( resultName, thisPtr, funcOffset, param1, param2, param3, param4 )\
    __asm__ __volatile__ ("pushl %1\n\t"                                    \
                          "pushl %2\n\t"                                    \
                          "pushl %3\n\t"                                    \
                          "pushl %4\n\t"                                    \
                          "movl (%5), %%edx\n\t"                            \
                          "call *"#funcOffset"(%%edx)\n\t"                  \
                          :"=a"(resultName) /* Output Operands */           \
                          :"r"(param4),     /* Input Operands  */           \
                           "r"(param3),                                     \
                           "r"(param2),                                     \
                           "r"(param1),                                     \
                           "c"(thisPtr)                                     \
                          : "%edx" /* Clobbered Registers */                \
                          );                                                \

#endif



// Our static singleton instance.
IASIOThiscallResolver IASIOThiscallResolver::instance;

// Constructor called to initialize static Singleton instance above. Note that
// it is important not to clear that_ incase it has already been set by the call
// to placement new in ASIOInit().
IASIOThiscallResolver::IASIOThiscallResolver()
{
}

// Constructor called from ASIOInit() below
IASIOThiscallResolver::IASIOThiscallResolver(IASIO* that)
: that_( that )
{
}

// Implement IUnknown methods as assert(false). IASIOThiscallResolver is not
// really a COM object, just a wrapper which will work with the ASIO SDK.
// If you wanted to use ASIO without the SDK you might want to implement COM
// aggregation in these methods.
HRESULT STDMETHODCALLTYPE IASIOThiscallResolver::QueryInterface(REFIID riid, void **ppv)
{
    (void)riid;     // suppress unused variable warning

    assert( false ); // this function should never be called by the ASIO SDK.

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE IASIOThiscallResolver::AddRef()
{
    assert( false ); // this function should never be called by the ASIO SDK.

    return 1;
}

ULONG STDMETHODCALLTYPE IASIOThiscallResolver::Release()
{
    assert( false ); // this function should never be called by the ASIO SDK.
    
    return 1;
}


// Implement the IASIO interface methods by performing the vptr manipulation
// described above then delegating to the real implementation.
ASIOBool IASIOThiscallResolver::init(void *sysHandle)
{
    ASIOBool result;
    CALL_THISCALL_1( result, that_, 12, sysHandle );
    return result;
}

void IASIOThiscallResolver::getDriverName(char *name)
{
    CALL_VOID_THISCALL_1( that_, 16, name );
}

long IASIOThiscallResolver::getDriverVersion()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 20 );
    return result;
}

void IASIOThiscallResolver::getErrorMessage(char *string)
{
     CALL_VOID_THISCALL_1( that_, 24, string );
}

ASIOError IASIOThiscallResolver::start()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 28 );
    return result;
}

ASIOError IASIOThiscallResolver::stop()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 32 );
    return result;
}

ASIOError IASIOThiscallResolver::getChannels(long *numInputChannels, long *numOutputChannels)
{
    ASIOBool result;
    CALL_THISCALL_2( result, that_, 36, numInputChannels, numOutputChannels );
    return result;
}

ASIOError IASIOThiscallResolver::getLatencies(long *inputLatency, long *outputLatency)
{
    ASIOBool result;
    CALL_THISCALL_2( result, that_, 40, inputLatency, outputLatency );
    return result;
}

ASIOError IASIOThiscallResolver::getBufferSize(long *minSize, long *maxSize,
        long *preferredSize, long *granularity)
{
    ASIOBool result;
    CALL_THISCALL_4( result, that_, 44, minSize, maxSize, preferredSize, granularity );
    return result;
}

ASIOError IASIOThiscallResolver::canSampleRate(ASIOSampleRate sampleRate)
{
    ASIOBool result;
    CALL_THISCALL_1_DOUBLE( result, that_, 48, sampleRate );
    return result;
}

ASIOError IASIOThiscallResolver::getSampleRate(ASIOSampleRate *sampleRate)
{
    ASIOBool result;
    CALL_THISCALL_1( result, that_, 52, sampleRate );
    return result;
}

ASIOError IASIOThiscallResolver::setSampleRate(ASIOSampleRate sampleRate)
{    
    ASIOBool result;
    CALL_THISCALL_1_DOUBLE( result, that_, 56, sampleRate );
    return result;
}

ASIOError IASIOThiscallResolver::getClockSources(ASIOClockSource *clocks, long *numSources)
{
    ASIOBool result;
    CALL_THISCALL_2( result, that_, 60, clocks, numSources );
    return result;
}

ASIOError IASIOThiscallResolver::setClockSource(long reference)
{
    ASIOBool result;
    CALL_THISCALL_1( result, that_, 64, reference );
    return result;
}

ASIOError IASIOThiscallResolver::getSamplePosition(ASIOSamples *sPos, ASIOTimeStamp *tStamp)
{
    ASIOBool result;
    CALL_THISCALL_2( result, that_, 68, sPos, tStamp );
    return result;
}

ASIOError IASIOThiscallResolver::getChannelInfo(ASIOChannelInfo *info)
{
    ASIOBool result;
    CALL_THISCALL_1( result, that_, 72, info );
    return result;
}

ASIOError IASIOThiscallResolver::createBuffers(ASIOBufferInfo *bufferInfos,
        long numChannels, long bufferSize, ASIOCallbacks *callbacks)
{
    ASIOBool result;
    CALL_THISCALL_4( result, that_, 76, bufferInfos, numChannels, bufferSize, callbacks );
    return result;
}

ASIOError IASIOThiscallResolver::disposeBuffers()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 80 );
    return result;
}

ASIOError IASIOThiscallResolver::controlPanel()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 84 );
    return result;
}

ASIOError IASIOThiscallResolver::future(long selector,void *opt)
{
    ASIOBool result;
    CALL_THISCALL_2( result, that_, 88, selector, opt );
    return result;
}

ASIOError IASIOThiscallResolver::outputReady()
{
    ASIOBool result;
    CALL_THISCALL_0( result, that_, 92 );
    return result;
}


// Implement our substitute ASIOInit() method
ASIOError IASIOThiscallResolver::ASIOInit(ASIODriverInfo *info)
{
    // To ensure that our instance's vptr is correctly constructed, even if
    // ASIOInit is called prior to main(), we explicitly call its constructor
    // (potentially over the top of an existing instance). Note that this is
    // pretty ugly, and is only safe because IASIOThiscallResolver has no
    // destructor and contains no objects with destructors.
    new((void*)&instance) IASIOThiscallResolver( theAsioDriver );

    // Interpose between ASIO client code and the real driver.
    theAsioDriver = &instance;

    // Note that we never need to switch theAsioDriver back to point to the
    // real driver because theAsioDriver is reset to zero in ASIOExit().

    // Delegate to the real ASIOInit
	return ::ASIOInit(info);
}


#endif /* !defined(_MSC_VER) */

#endif /* Win32 */

/*
 * $Id$
 * Portable Audio I/O Library for ASIO Drivers
 *
 * Author: Stephane Letz
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 2000-2002 Stephane Letz, Phil Burk, Ross Bencina
 * Blocking i/o implementation by Sven Fischer, Institute of Hearing
 * Technology and Audiology (www.hoertechnik-audiologie.de)
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/* Modification History

        08-03-01 First version : Stephane Letz
        08-06-01 Tweaks for PC, use C++, buffer allocation, Float32 to Int32 conversion : Phil Burk
        08-20-01 More conversion, PA_StreamTime, Pa_GetHostError : Stephane Letz
        08-21-01 PaUInt8 bug correction, implementation of ASIOSTFloat32LSB and ASIOSTFloat32MSB native formats : Stephane Letz
        08-24-01 MAX_INT32_FP hack, another Uint8 fix : Stephane and Phil
        08-27-01 Implementation of hostBufferSize < userBufferSize case, better management of the ouput buffer when
                 the stream is stopped : Stephane Letz
        08-28-01 Check the stream pointer for null in bufferSwitchTimeInfo, correct bug in bufferSwitchTimeInfo when
                 the stream is stopped : Stephane Letz
        10-12-01 Correct the PaHost_CalcNumHostBuffers function: computes FramesPerHostBuffer to be the lowest that
                 respect requested FramesPerUserBuffer and userBuffersPerHostBuffer : Stephane Letz
        10-26-01 Management of hostBufferSize and userBufferSize of any size : Stephane Letz
        10-27-01 Improve calculus of hostBufferSize to be multiple or divisor of userBufferSize if possible : Stephane and Phil
        10-29-01 Change MAX_INT32_FP to (2147483520.0f) to prevent roundup to 0x80000000 : Phil Burk
        10-31-01 Clear the ouput buffer and user buffers in PaHost_StartOutput, correct bug in GetFirstMultiple : Stephane Letz
        11-06-01 Rename functions : Stephane Letz
        11-08-01 New Pa_ASIO_Adaptor_Init function to init Callback adpatation variables, cleanup of Pa_ASIO_Callback_Input: Stephane Letz
        11-29-01 Break apart device loading to debug random failure in Pa_ASIO_QueryDeviceInfo ; Phil Burk
        01-03-02 Desallocate all resources in PaHost_Term for cases where Pa_CloseStream is not called properly :  Stephane Letz
        02-01-02 Cleanup, test of multiple-stream opening : Stephane Letz
        19-02-02 New Pa_ASIO_loadDriver that calls CoInitialize on each thread on Windows : Stephane Letz
        09-04-02 Correct error code management in PaHost_Term, removes various compiler warning : Stephane Letz
        12-04-02 Add Mac includes for <Devices.h> and <Timer.h> : Phil Burk
        13-04-02 Removes another compiler warning : Stephane Letz
        30-04-02 Pa_ASIO_QueryDeviceInfo bug correction, memory allocation checking, better error handling : D Viens, P Burk, S Letz
        12-06-02 Rehashed into new multi-api infrastructure, added support for all ASIO sample formats : Ross Bencina
        18-06-02 Added pa_asio.h, PaAsio_GetAvailableLatencyValues() : Ross B.
        21-06-02 Added SelectHostBufferSize() which selects host buffer size based on user latency parameters : Ross Bencina
        ** NOTE  maintanance history is now stored in CVS **
*/

/** @file
    @ingroup hostapi_src

    Note that specific support for paInputUnderflow, paOutputOverflow and
    paNeverDropInput is not necessary or possible with this driver due to the
    synchronous full duplex double-buffered architecture of ASIO.
*/


#include <stdio.h>
#include <assert.h>
#include <string.h>
//#include <values.h>
#include <new>

#include <windows.h>
#include <mmsystem.h>

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_asio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_debugprint.h"
// (amalg) #include "pa_ringbuffer.h"

// (amalg) #include "pa_win_coinitialize.h"

/* This version of pa_asio.cpp is currently only targetted at Win32,
   It would require a few tweaks to work with pre-OS X Macintosh.
   To make configuration easier, we define WIN32 here to make sure
   that the ASIO SDK knows this is Win32.
*/
#ifndef WIN32
#define WIN32
#endif

// (amalg) #include "asiosys.h"
// (amalg) #include "asio.h"
// (amalg) #include "asiodrivers.h"
// (amalg) #include "iasiothiscallresolver.h"

/*
#if MAC
#include <Devices.h>
#include <Timer.h>
#include <Math64.h>
#else
*/
/*
#include <math.h>
#include <windows.h>
#include <mmsystem.h>
*/
/*
#endif
*/


/* winmm.lib is needed for timeGetTime() (this is in winmm.a if you're using gcc) */
#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
#pragma comment(lib, "winmm.lib")
#endif


/* external reference to ASIO SDK's asioDrivers.

 This is a bit messy because we want to explicitly manage 
 allocation/deallocation of this structure, but some layers of the SDK 
 which we currently use (eg the implementation in asio.cpp) still
 use this global version.

 For now we keep it in sync with our local instance in the host
 API representation structure, but later we should be able to remove
 all dependence on it.
*/
extern AsioDrivers* asioDrivers;


/* We are trying to be compatible with CARBON but this has not been thoroughly tested. */
/* not tested at all since new V19 code was introduced. */
#define CARBON_COMPATIBLE  (0)


/* prototypes for functions declared in this file */

extern "C" PaError PaAsio_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex );
static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );

/* Blocking i/o callback function. */
static int BlockingIoPaCallback(const void                     *inputBuffer    ,
                                      void                     *outputBuffer   ,
                                      unsigned long             framesPerBuffer,
                                const PaStreamCallbackTimeInfo *timeInfo       ,
                                      PaStreamCallbackFlags     statusFlags    ,
                                      void                     *userData       );

/* our ASIO callback functions */

static void bufferSwitch(long index, ASIOBool processNow);
static ASIOTime *bufferSwitchTimeInfo(ASIOTime *timeInfo, long index, ASIOBool processNow);
static void sampleRateChanged(ASIOSampleRate sRate);
static long asioMessages(long selector, long value, void* message, double* opt);

static ASIOCallbacks asioCallbacks_ =
    { bufferSwitch, sampleRateChanged, asioMessages, bufferSwitchTimeInfo };


#define PA_ASIO_SET_LAST_HOST_ERROR( errorCode, errorText ) \
    PaUtil_SetLastHostErrorInfo( paASIO, errorCode, errorText )


static void PaAsio_SetLastSystemError( DWORD errorCode )
{
    LPVOID lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
    );
    PaUtil_SetLastHostErrorInfo( paASIO, errorCode, (const char*)lpMsgBuf );
    LocalFree( lpMsgBuf );
}

#define PA_ASIO_SET_LAST_SYSTEM_ERROR( errorCode ) \
    PaAsio_SetLastSystemError( errorCode )


static const char* PaAsio_GetAsioErrorText( ASIOError asioError )
{
    const char *result;

    switch( asioError ){
        case ASE_OK:
        case ASE_SUCCESS:           result = "Success"; break;
        case ASE_NotPresent:        result = "Hardware input or output is not present or available"; break;
        case ASE_HWMalfunction:     result = "Hardware is malfunctioning"; break;
        case ASE_InvalidParameter:  result = "Input parameter invalid"; break;
        case ASE_InvalidMode:       result = "Hardware is in a bad mode or used in a bad mode"; break;
        case ASE_SPNotAdvancing:    result = "Hardware is not running when sample position is inquired"; break;
        case ASE_NoClock:           result = "Sample clock or rate cannot be determined or is not present"; break;
        case ASE_NoMemory:          result = "Not enough memory for completing the request"; break;
        default:                    result = "Unknown ASIO error"; break;
    }

    return result;
}


#define PA_ASIO_SET_LAST_ASIO_ERROR( asioError ) \
    PaUtil_SetLastHostErrorInfo( paASIO, asioError, PaAsio_GetAsioErrorText( asioError ) )




// Atomic increment and decrement operations
#if MAC
    /* need to be implemented on Mac */
    inline long PaAsio_AtomicIncrement(volatile long* v) {return ++(*const_cast<long*>(v));}
    inline long PaAsio_AtomicDecrement(volatile long* v) {return --(*const_cast<long*>(v));}
#elif WINDOWS
    inline long PaAsio_AtomicIncrement(volatile long* v) {return InterlockedIncrement(const_cast<long*>(v));}
    inline long PaAsio_AtomicDecrement(volatile long* v) {return InterlockedDecrement(const_cast<long*>(v));}
#endif



typedef struct PaAsioDriverInfo
{
    ASIODriverInfo asioDriverInfo;
    long inputChannelCount, outputChannelCount;
    long bufferMinSize, bufferMaxSize, bufferPreferredSize, bufferGranularity;
    bool postOutput;
}
PaAsioDriverInfo;


/* PaAsioHostApiRepresentation - host api datastructure specific to this implementation */

typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;

    PaWinUtilComInitializationResult comInitializationResult;

    AsioDrivers *asioDrivers;
    void *systemSpecific;
    
    /* the ASIO C API only allows one ASIO driver to be open at a time,
        so we keep track of whether we have the driver open here, and
        use this information to return errors from OpenStream if the
        driver is already open.

        openAsioDeviceIndex will be PaNoDevice if there is no device open
        and a valid pa_asio (not global) device index otherwise.

        openAsioDriverInfo is populated with the driver info for the
        currently open device (if any)
    */
    PaDeviceIndex openAsioDeviceIndex;
    PaAsioDriverInfo openAsioDriverInfo;
}
PaAsioHostApiRepresentation;


/*
    Retrieve <driverCount> driver names from ASIO, returned in a char**
    allocated in <group>.
*/
static char **GetAsioDriverNames( PaAsioHostApiRepresentation *asioHostApi, PaUtilAllocationGroup *group, long driverCount )
{
    char **result = 0;
    int i;

    result =(char**)PaUtil_GroupAllocateMemory(
            group, sizeof(char*) * driverCount );
    if( !result )
        goto error;

    result[0] = (char*)PaUtil_GroupAllocateMemory(
            group, 32 * driverCount );
    if( !result[0] )
        goto error;

    for( i=0; i<driverCount; ++i )
        result[i] = result[0] + (32 * i);

    asioHostApi->asioDrivers->getDriverNames( result, driverCount );

error:
    return result;
}


static PaSampleFormat AsioSampleTypeToPaNativeSampleFormat(ASIOSampleType type)
{
    switch (type) {
        case ASIOSTInt16MSB:
        case ASIOSTInt16LSB:
                return paInt16;

        case ASIOSTFloat32MSB:
        case ASIOSTFloat32LSB:
        case ASIOSTFloat64MSB:
        case ASIOSTFloat64LSB:
                return paFloat32;

        case ASIOSTInt32MSB:
        case ASIOSTInt32LSB:
        case ASIOSTInt32MSB16:
        case ASIOSTInt32LSB16:
        case ASIOSTInt32MSB18:
        case ASIOSTInt32MSB20:
        case ASIOSTInt32MSB24:
        case ASIOSTInt32LSB18:
        case ASIOSTInt32LSB20:
        case ASIOSTInt32LSB24:
                return paInt32;

        case ASIOSTInt24MSB:
        case ASIOSTInt24LSB:
                return paInt24;

        default:
                return paCustomFormat;
    }
}

void AsioSampleTypeLOG(ASIOSampleType type)
{
    switch (type) {
        case ASIOSTInt16MSB:  PA_DEBUG(("ASIOSTInt16MSB\n"));  break;
        case ASIOSTInt16LSB:  PA_DEBUG(("ASIOSTInt16LSB\n"));  break;
        case ASIOSTFloat32MSB:PA_DEBUG(("ASIOSTFloat32MSB\n"));break;
        case ASIOSTFloat32LSB:PA_DEBUG(("ASIOSTFloat32LSB\n"));break;
        case ASIOSTFloat64MSB:PA_DEBUG(("ASIOSTFloat64MSB\n"));break;
        case ASIOSTFloat64LSB:PA_DEBUG(("ASIOSTFloat64LSB\n"));break;
        case ASIOSTInt32MSB:  PA_DEBUG(("ASIOSTInt32MSB\n"));  break;
        case ASIOSTInt32LSB:  PA_DEBUG(("ASIOSTInt32LSB\n"));  break;
        case ASIOSTInt32MSB16:PA_DEBUG(("ASIOSTInt32MSB16\n"));break;
        case ASIOSTInt32LSB16:PA_DEBUG(("ASIOSTInt32LSB16\n"));break;
        case ASIOSTInt32MSB18:PA_DEBUG(("ASIOSTInt32MSB18\n"));break;
        case ASIOSTInt32MSB20:PA_DEBUG(("ASIOSTInt32MSB20\n"));break;
        case ASIOSTInt32MSB24:PA_DEBUG(("ASIOSTInt32MSB24\n"));break;
        case ASIOSTInt32LSB18:PA_DEBUG(("ASIOSTInt32LSB18\n"));break;
        case ASIOSTInt32LSB20:PA_DEBUG(("ASIOSTInt32LSB20\n"));break;
        case ASIOSTInt32LSB24:PA_DEBUG(("ASIOSTInt32LSB24\n"));break;
        case ASIOSTInt24MSB:  PA_DEBUG(("ASIOSTInt24MSB\n"));  break;
        case ASIOSTInt24LSB:  PA_DEBUG(("ASIOSTInt24LSB\n"));  break;
        default:              PA_DEBUG(("Custom Format%d\n",type));break;

    }
}

static int BytesPerAsioSample( ASIOSampleType sampleType )
{
    switch (sampleType) {
        case ASIOSTInt16MSB:
        case ASIOSTInt16LSB:
            return 2;

        case ASIOSTFloat64MSB:
        case ASIOSTFloat64LSB:
            return 8;

        case ASIOSTFloat32MSB:
        case ASIOSTFloat32LSB:
        case ASIOSTInt32MSB:
        case ASIOSTInt32LSB:
        case ASIOSTInt32MSB16:
        case ASIOSTInt32LSB16:
        case ASIOSTInt32MSB18:
        case ASIOSTInt32MSB20:
        case ASIOSTInt32MSB24:
        case ASIOSTInt32LSB18:
        case ASIOSTInt32LSB20:
        case ASIOSTInt32LSB24:
            return 4;

        case ASIOSTInt24MSB:
        case ASIOSTInt24LSB:
            return 3;

        default:
            return 0;
    }
}


static void Swap16( void *buffer, long shift, long count )
{
    unsigned short *p = (unsigned short*)buffer;
    unsigned short temp;
    (void) shift; /* unused parameter */

    while( count-- )
    {
        temp = *p;
        *p++ = (unsigned short)((temp<<8) | (temp>>8));
    }
}

static void Swap24( void *buffer, long shift, long count )
{
    unsigned char *p = (unsigned char*)buffer;
    unsigned char temp;
    (void) shift; /* unused parameter */

    while( count-- )
    {
        temp = *p;
        *p = *(p+2);
        *(p+2) = temp;
        p += 3;
    }
}

#define PA_SWAP32_( x ) ((x>>24) | ((x>>8)&0xFF00) | ((x<<8)&0xFF0000) | (x<<24));

static void Swap32( void *buffer, long shift, long count )
{
    unsigned long *p = (unsigned long*)buffer;
    unsigned long temp;
    (void) shift; /* unused parameter */

    while( count-- )
    {
        temp = *p;
        *p++ = PA_SWAP32_( temp);
    }
}

static void SwapShiftLeft32( void *buffer, long shift, long count )
{
    unsigned long *p = (unsigned long*)buffer;
    unsigned long temp;

    while( count-- )
    {
        temp = *p;
        temp = PA_SWAP32_( temp);
        *p++ = temp << shift;
    }
}

static void ShiftRightSwap32( void *buffer, long shift, long count )
{
    unsigned long *p = (unsigned long*)buffer;
    unsigned long temp;

    while( count-- )
    {
        temp = *p >> shift;
        *p++ = PA_SWAP32_( temp);
    }
}

static void ShiftLeft32( void *buffer, long shift, long count )
{
    unsigned long *p = (unsigned long*)buffer;
    unsigned long temp;

    while( count-- )
    {
        temp = *p;
        *p++ = temp << shift;
    }
}

static void ShiftRight32( void *buffer, long shift, long count )
{
    unsigned long *p = (unsigned long*)buffer;
    unsigned long temp;

    while( count-- )
    {
        temp = *p;
        *p++ = temp >> shift;
    }
}

#define PA_SWAP_( x, y ) temp=x; x = y; y = temp;

static void Swap64ConvertFloat64ToFloat32( void *buffer, long shift, long count )
{
    double *in = (double*)buffer;
    float *out = (float*)buffer;
    unsigned char *p;
    unsigned char temp;
    (void) shift; /* unused parameter */

    while( count-- )
    {
        p = (unsigned char*)in;
        PA_SWAP_( p[0], p[7] );
        PA_SWAP_( p[1], p[6] );
        PA_SWAP_( p[2], p[5] );
        PA_SWAP_( p[3], p[4] );

        *out++ = (float) (*in++);
    }
}

static void ConvertFloat64ToFloat32( void *buffer, long shift, long count )
{
    double *in = (double*)buffer;
    float *out = (float*)buffer;
    (void) shift; /* unused parameter */

    while( count-- )
        *out++ = (float) (*in++);
}

static void ConvertFloat32ToFloat64Swap64( void *buffer, long shift, long count )
{
    float *in = ((float*)buffer) + (count-1);
    double *out = ((double*)buffer) + (count-1);
    unsigned char *p;
    unsigned char temp;
    (void) shift; /* unused parameter */

    while( count-- )
    {
        *out = *in--;

        p = (unsigned char*)out;
        PA_SWAP_( p[0], p[7] );
        PA_SWAP_( p[1], p[6] );
        PA_SWAP_( p[2], p[5] );
        PA_SWAP_( p[3], p[4] );

        out--;
    }
}

static void ConvertFloat32ToFloat64( void *buffer, long shift, long count )
{
    float *in = ((float*)buffer) + (count-1);
    double *out = ((double*)buffer) + (count-1);
    (void) shift; /* unused parameter */

    while( count-- )
        *out-- = *in--;
}

#ifdef MAC
#define PA_MSB_IS_NATIVE_
#undef PA_LSB_IS_NATIVE_
#endif

#ifdef WINDOWS
#undef PA_MSB_IS_NATIVE_
#define PA_LSB_IS_NATIVE_
#endif

typedef void PaAsioBufferConverter( void *, long, long );

static void SelectAsioToPaConverter( ASIOSampleType type, PaAsioBufferConverter **converter, long *shift )
{
    *shift = 0;
    *converter = 0;

    switch (type) {
        case ASIOSTInt16MSB:
            /* dest: paInt16, no conversion necessary, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap16;
            #endif
            break;
        case ASIOSTInt16LSB:
            /* dest: paInt16, no conversion necessary, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap16;
            #endif
            break;
        case ASIOSTFloat32MSB:
            /* dest: paFloat32, no conversion necessary, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTFloat32LSB:
            /* dest: paFloat32, no conversion necessary, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTFloat64MSB:
            /* dest: paFloat32, in-place conversion to/from float32, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap64ConvertFloat64ToFloat32;
            #else
                *converter = ConvertFloat64ToFloat32;
            #endif
            break;
        case ASIOSTFloat64LSB:
            /* dest: paFloat32, in-place conversion to/from float32, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap64ConvertFloat64ToFloat32;
            #else
                *converter = ConvertFloat64ToFloat32;
            #endif
            break;
        case ASIOSTInt32MSB:
            /* dest: paInt32, no conversion necessary, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTInt32LSB:
            /* dest: paInt32, no conversion necessary, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTInt32MSB16:
            /* dest: paInt32, 16 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 16;
            break;
        case ASIOSTInt32MSB18:
            /* dest: paInt32, 14 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 14;
            break;
        case ASIOSTInt32MSB20:
            /* dest: paInt32, 12 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 12;
            break;
        case ASIOSTInt32MSB24:
            /* dest: paInt32, 8 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 8;
            break;
        case ASIOSTInt32LSB16:
            /* dest: paInt32, 16 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 16;
            break;
        case ASIOSTInt32LSB18:
            /* dest: paInt32, 14 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 14;
            break;
        case ASIOSTInt32LSB20:
            /* dest: paInt32, 12 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 12;
            break;
        case ASIOSTInt32LSB24:
            /* dest: paInt32, 8 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = SwapShiftLeft32;
            #else
                *converter = ShiftLeft32;
            #endif
            *shift = 8;
            break;
        case ASIOSTInt24MSB:
            /* dest: paInt24, no conversion necessary, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap24;
            #endif
            break;
        case ASIOSTInt24LSB:
            /* dest: paInt24, no conversion necessary, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap24;
            #endif
            break;
    }
}


static void SelectPaToAsioConverter( ASIOSampleType type, PaAsioBufferConverter **converter, long *shift )
{
    *shift = 0;
    *converter = 0;

    switch (type) {
        case ASIOSTInt16MSB:
            /* src: paInt16, no conversion necessary, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap16;
            #endif
            break;
        case ASIOSTInt16LSB:
            /* src: paInt16, no conversion necessary, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap16;
            #endif
            break;
        case ASIOSTFloat32MSB:
            /* src: paFloat32, no conversion necessary, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTFloat32LSB:
            /* src: paFloat32, no conversion necessary, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTFloat64MSB:
            /* src: paFloat32, in-place conversion to/from float32, possible byte swap*/
            #ifdef PA_LSB_IS_NATIVE_
                *converter = ConvertFloat32ToFloat64Swap64;
            #else
                *converter = ConvertFloat32ToFloat64;
            #endif
            break;
        case ASIOSTFloat64LSB:
            /* src: paFloat32, in-place conversion to/from float32, possible byte swap*/
            #ifdef PA_MSB_IS_NATIVE_
                *converter = ConvertFloat32ToFloat64Swap64;
            #else
                *converter = ConvertFloat32ToFloat64;
            #endif
            break;
        case ASIOSTInt32MSB:
            /* src: paInt32, no conversion necessary, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTInt32LSB:
            /* src: paInt32, no conversion necessary, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap32;
            #endif
            break;
        case ASIOSTInt32MSB16:
            /* src: paInt32, 16 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 16;
            break;
        case ASIOSTInt32MSB18:
            /* src: paInt32, 14 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 14;
            break;
        case ASIOSTInt32MSB20:
            /* src: paInt32, 12 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 12;
            break;
        case ASIOSTInt32MSB24:
            /* src: paInt32, 8 bit shift, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 8;
            break;
        case ASIOSTInt32LSB16:
            /* src: paInt32, 16 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 16;
            break;
        case ASIOSTInt32LSB18:
            /* src: paInt32, 14 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 14;
            break;
        case ASIOSTInt32LSB20:
            /* src: paInt32, 12 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 12;
            break;
        case ASIOSTInt32LSB24:
            /* src: paInt32, 8 bit shift, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = ShiftRightSwap32;
            #else
                *converter = ShiftRight32;
            #endif
            *shift = 8;
            break;
        case ASIOSTInt24MSB:
            /* src: paInt24, no conversion necessary, possible byte swap */
            #ifdef PA_LSB_IS_NATIVE_
                *converter = Swap24;
            #endif
            break;
        case ASIOSTInt24LSB:
            /* src: paInt24, no conversion necessary, possible byte swap */
            #ifdef PA_MSB_IS_NATIVE_
                *converter = Swap24;
            #endif
            break;
    }
}


typedef struct PaAsioDeviceInfo
{
    PaDeviceInfo commonDeviceInfo;
    long minBufferSize;
    long maxBufferSize;
    long preferredBufferSize;
    long bufferGranularity;

    ASIOChannelInfo *asioChannelInfos;
}
PaAsioDeviceInfo;


PaError PaAsio_GetAvailableBufferSizes( PaDeviceIndex device,
        long *minBufferSizeFrames, long *maxBufferSizeFrames, long *preferredBufferSizeFrames, long *granularity )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi;
    PaDeviceIndex hostApiDevice;

    result = PaUtil_GetHostApiRepresentation( &hostApi, paASIO );

    if( result == paNoError )
    {
        result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDevice, device, hostApi );

        if( result == paNoError )
        {
            PaAsioDeviceInfo *asioDeviceInfo =
                    (PaAsioDeviceInfo*)hostApi->deviceInfos[hostApiDevice];

            *minBufferSizeFrames = asioDeviceInfo->minBufferSize;
            *maxBufferSizeFrames = asioDeviceInfo->maxBufferSize;
            *preferredBufferSizeFrames = asioDeviceInfo->preferredBufferSize;
            *granularity = asioDeviceInfo->bufferGranularity;
        }
    }

    return result;
}

/* Unload whatever we loaded in LoadAsioDriver().
*/
static void UnloadAsioDriver( void )
{
	ASIOExit();
}

/*
    load the asio driver named by <driverName> and return statistics about
    the driver in info. If no error occurred, the driver will remain open
    and must be closed by the called by calling UnloadAsioDriver() - if an error
    is returned the driver will already be unloaded.
*/
static PaError LoadAsioDriver( PaAsioHostApiRepresentation *asioHostApi, const char *driverName,
        PaAsioDriverInfo *driverInfo, void *systemSpecific )
{
    PaError result = paNoError;
    ASIOError asioError;
    int asioIsInitialized = 0;

    if( !asioHostApi->asioDrivers->loadDriver( const_cast<char*>(driverName) ) )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_HOST_ERROR( 0, "Failed to load ASIO driver" );
        goto error;
    }

    memset( &driverInfo->asioDriverInfo, 0, sizeof(ASIODriverInfo) );
    driverInfo->asioDriverInfo.asioVersion = 2;
    driverInfo->asioDriverInfo.sysRef = systemSpecific;
    if( (asioError = ASIOInit( &driverInfo->asioDriverInfo )) != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        goto error;
    }
    else
    {
        asioIsInitialized = 1;
    }

    if( (asioError = ASIOGetChannels(&driverInfo->inputChannelCount,
            &driverInfo->outputChannelCount)) != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        goto error;
    }

    if( (asioError = ASIOGetBufferSize(&driverInfo->bufferMinSize,
            &driverInfo->bufferMaxSize, &driverInfo->bufferPreferredSize,
            &driverInfo->bufferGranularity)) != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        goto error;
    }

    if( ASIOOutputReady() == ASE_OK )
        driverInfo->postOutput = true;
    else
        driverInfo->postOutput = false;

    return result;

error:
    if( asioIsInitialized )
	{
		ASIOExit();
	}

    return result;
}


#define PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_     13   /* must be the same number of elements as in the array below */
static ASIOSampleRate defaultSampleRateSearchOrder_[]
     = {44100.0, 48000.0, 32000.0, 24000.0, 22050.0, 88200.0, 96000.0,
        192000.0, 16000.0, 12000.0, 11025.0, 9600.0, 8000.0 };


static PaError InitPaDeviceInfoFromAsioDriver( PaAsioHostApiRepresentation *asioHostApi, 
        const char *driverName, int driverIndex,
        PaDeviceInfo *deviceInfo, PaAsioDeviceInfo *asioDeviceInfo )
{
    PaError result = paNoError;

    /* Due to the headless design of the ASIO API, drivers are free to write over data given to them (like M-Audio
       drivers f.i.). This is an attempt to overcome that. */
    union _tag_local {
        PaAsioDriverInfo info;
        char _padding[4096];
    } paAsioDriver;

    asioDeviceInfo->asioChannelInfos = 0; /* we check this below to handle error cleanup */

    result = LoadAsioDriver( asioHostApi, driverName, &paAsioDriver.info, asioHostApi->systemSpecific );
    if( result == paNoError )
    {
        PA_DEBUG(("PaAsio_Initialize: drv:%d name = %s\n",  driverIndex,deviceInfo->name));
        PA_DEBUG(("PaAsio_Initialize: drv:%d inputChannels       = %d\n", driverIndex, paAsioDriver.info.inputChannelCount));
        PA_DEBUG(("PaAsio_Initialize: drv:%d outputChannels      = %d\n", driverIndex, paAsioDriver.info.outputChannelCount));
        PA_DEBUG(("PaAsio_Initialize: drv:%d bufferMinSize       = %d\n", driverIndex, paAsioDriver.info.bufferMinSize));
        PA_DEBUG(("PaAsio_Initialize: drv:%d bufferMaxSize       = %d\n", driverIndex, paAsioDriver.info.bufferMaxSize));
        PA_DEBUG(("PaAsio_Initialize: drv:%d bufferPreferredSize = %d\n", driverIndex, paAsioDriver.info.bufferPreferredSize));
        PA_DEBUG(("PaAsio_Initialize: drv:%d bufferGranularity   = %d\n", driverIndex, paAsioDriver.info.bufferGranularity));

        deviceInfo->maxInputChannels  = paAsioDriver.info.inputChannelCount;
        deviceInfo->maxOutputChannels = paAsioDriver.info.outputChannelCount;

        deviceInfo->defaultSampleRate = 0.;
        bool foundDefaultSampleRate = false;
        for( int j=0; j < PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_; ++j )
        {
            ASIOError asioError = ASIOCanSampleRate( defaultSampleRateSearchOrder_[j] );
            if( asioError != ASE_NoClock && asioError != ASE_NotPresent )
            {
                deviceInfo->defaultSampleRate = defaultSampleRateSearchOrder_[j];
                foundDefaultSampleRate = true;
                break;
            }
        }

        PA_DEBUG(("PaAsio_Initialize: drv:%d defaultSampleRate = %f\n", driverIndex, deviceInfo->defaultSampleRate));

        if( foundDefaultSampleRate ){

            /* calculate default latency values from bufferPreferredSize
                for default low latency, and bufferMaxSize
                for default high latency.
                use the default sample rate to convert from samples to
                seconds. Without knowing what sample rate the user will
                use this is the best we can do.
            */

            double defaultLowLatency =
                    paAsioDriver.info.bufferPreferredSize / deviceInfo->defaultSampleRate;

            deviceInfo->defaultLowInputLatency = defaultLowLatency;
            deviceInfo->defaultLowOutputLatency = defaultLowLatency;

            double defaultHighLatency =
                    paAsioDriver.info.bufferMaxSize / deviceInfo->defaultSampleRate;

            if( defaultHighLatency < defaultLowLatency )
                defaultHighLatency = defaultLowLatency; /* just in case the driver returns something strange */ 
                    
            deviceInfo->defaultHighInputLatency = defaultHighLatency;
            deviceInfo->defaultHighOutputLatency = defaultHighLatency;
            
        }else{

            deviceInfo->defaultLowInputLatency = 0.;
            deviceInfo->defaultLowOutputLatency = 0.;
            deviceInfo->defaultHighInputLatency = 0.;
            deviceInfo->defaultHighOutputLatency = 0.;
        }

        PA_DEBUG(("PaAsio_Initialize: drv:%d defaultLowInputLatency = %f\n", driverIndex, deviceInfo->defaultLowInputLatency));
        PA_DEBUG(("PaAsio_Initialize: drv:%d defaultLowOutputLatency = %f\n", driverIndex, deviceInfo->defaultLowOutputLatency));
        PA_DEBUG(("PaAsio_Initialize: drv:%d defaultHighInputLatency = %f\n", driverIndex, deviceInfo->defaultHighInputLatency));
        PA_DEBUG(("PaAsio_Initialize: drv:%d defaultHighOutputLatency = %f\n", driverIndex, deviceInfo->defaultHighOutputLatency));

        asioDeviceInfo->minBufferSize = paAsioDriver.info.bufferMinSize;
        asioDeviceInfo->maxBufferSize = paAsioDriver.info.bufferMaxSize;
        asioDeviceInfo->preferredBufferSize = paAsioDriver.info.bufferPreferredSize;
        asioDeviceInfo->bufferGranularity = paAsioDriver.info.bufferGranularity;


        asioDeviceInfo->asioChannelInfos = (ASIOChannelInfo*)PaUtil_GroupAllocateMemory(
                asioHostApi->allocations,
                sizeof(ASIOChannelInfo) * (deviceInfo->maxInputChannels
                        + deviceInfo->maxOutputChannels) );
        if( !asioDeviceInfo->asioChannelInfos )
        {
            result = paInsufficientMemory;
            goto error_unload;
        }

        int a;

        for( a=0; a < deviceInfo->maxInputChannels; ++a ){
            asioDeviceInfo->asioChannelInfos[a].channel = a;
            asioDeviceInfo->asioChannelInfos[a].isInput = ASIOTrue;
            ASIOError asioError = ASIOGetChannelInfo( &asioDeviceInfo->asioChannelInfos[a] );
            if( asioError != ASE_OK )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
                goto error_unload;
            }
        }

        for( a=0; a < deviceInfo->maxOutputChannels; ++a ){
            int b = deviceInfo->maxInputChannels + a;
            asioDeviceInfo->asioChannelInfos[b].channel = a;
            asioDeviceInfo->asioChannelInfos[b].isInput = ASIOFalse;
            ASIOError asioError = ASIOGetChannelInfo( &asioDeviceInfo->asioChannelInfos[b] );
            if( asioError != ASE_OK )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
                goto error_unload;
            }
        }

        /* unload the driver */
        UnloadAsioDriver();
    }

    return result;

error_unload:
    UnloadAsioDriver();

    if( asioDeviceInfo->asioChannelInfos ){
        PaUtil_GroupFreeMemory( asioHostApi->allocations, asioDeviceInfo->asioChannelInfos );
        asioDeviceInfo->asioChannelInfos = 0;
    }

    return result;
}


/* we look up IsDebuggerPresent at runtime incase it isn't present (on Win95 for example) */
typedef BOOL (WINAPI *IsDebuggerPresentPtr)(VOID);
IsDebuggerPresentPtr IsDebuggerPresent_ = 0;
//FARPROC IsDebuggerPresent_ = 0; // this is the current way to do it apparently according to davidv

PaError PaAsio_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    int i, driverCount;
    PaAsioHostApiRepresentation *asioHostApi;
    PaAsioDeviceInfo *deviceInfoArray;
    char **names;
    asioHostApi = (PaAsioHostApiRepresentation*)PaUtil_AllocateMemory( sizeof(PaAsioHostApiRepresentation) );
    if( !asioHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }

    memset( asioHostApi, 0, sizeof(PaAsioHostApiRepresentation) ); /* ensure all fields are zeroed. especially asioHostApi->allocations */

    /*
        We initialize COM ourselves here and uninitialize it in Terminate().
        This should be the only COM initialization needed in this module.

        The ASIO SDK may also initialize COM but since we want to reduce dependency
        on the ASIO SDK we manage COM initialization ourselves.

        There used to be code that initialized COM in other situations
        such as when creating a Stream. This made PA work when calling Pa_CreateStream
        from a non-main thread. However we currently consider initialization 
        of COM in non-main threads to be the caller's responsibility.
    */
    result = PaWinUtil_CoInitialize( paASIO, &asioHostApi->comInitializationResult );
    if( result != paNoError )
    {
        goto error;
    }

    asioHostApi->asioDrivers = 0; /* avoid surprises in our error handler below */

    asioHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !asioHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Allocate the AsioDrivers() driver list (class from ASIO SDK) */
    try
    {
        asioHostApi->asioDrivers = new AsioDrivers(); /* invokes CoInitialize(0) in AsioDriverList::AsioDriverList */
    } 
    catch (std::bad_alloc)
    {
        asioHostApi->asioDrivers = 0;
    }
    /* some implementations of new (ie MSVC, see http://support.microsoft.com/?kbid=167733)
       don't throw std::bad_alloc, so we also explicitly test for a null return. */
    if( asioHostApi->asioDrivers == 0 )
    {
        result = paInsufficientMemory;
        goto error;
    }

    asioDrivers = asioHostApi->asioDrivers; /* keep SDK global in sync until we stop depending on it */

    asioHostApi->systemSpecific = 0;
    asioHostApi->openAsioDeviceIndex = paNoDevice;

    *hostApi = &asioHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;

    (*hostApi)->info.type = paASIO;
    (*hostApi)->info.name = "ASIO";
    (*hostApi)->info.deviceCount = 0;

    #ifdef WINDOWS
        /* use desktop window as system specific ptr */
        asioHostApi->systemSpecific = GetDesktopWindow();
    #endif

    /* driverCount is the number of installed drivers - not necessarily
        the number of installed physical devices. */
    #if MAC
        driverCount = asioHostApi->asioDrivers->getNumFragments();
    #elif WINDOWS
        driverCount = asioHostApi->asioDrivers->asioGetNumDev();
    #endif

    if( driverCount > 0 )
    {
        names = GetAsioDriverNames( asioHostApi, asioHostApi->allocations, driverCount );
        if( !names )
        {
            result = paInsufficientMemory;
            goto error;
        }


        /* allocate enough space for all drivers, even if some aren't installed */

        (*hostApi)->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
                asioHostApi->allocations, sizeof(PaDeviceInfo*) * driverCount );
        if( !(*hostApi)->deviceInfos )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all device info structs in a contiguous block */
        deviceInfoArray = (PaAsioDeviceInfo*)PaUtil_GroupAllocateMemory(
                asioHostApi->allocations, sizeof(PaAsioDeviceInfo) * driverCount );
        if( !deviceInfoArray )
        {
            result = paInsufficientMemory;
            goto error;
        }

        IsDebuggerPresent_ = (IsDebuggerPresentPtr)GetProcAddress( LoadLibraryA( "Kernel32.dll" ), "IsDebuggerPresent" );

        for( i=0; i < driverCount; ++i )
        {
            PA_DEBUG(("ASIO names[%d]:%s\n",i,names[i]));

            // Since portaudio opens ALL ASIO drivers, and no one else does that,
            // we face fact that some drivers were not meant for it, drivers which act
            // like shells on top of REAL drivers, for instance.
            // so we get duplicate handles, locks and other problems.
            // so lets NOT try to load any such wrappers. 
            // The ones i [davidv] know of so far are:

            if (   strcmp (names[i],"ASIO DirectX Full Duplex Driver") == 0
                || strcmp (names[i],"ASIO Multimedia Driver")          == 0
                || strncmp(names[i],"Premiere",8)                      == 0   //"Premiere Elements Windows Sound 1.0"
                || strncmp(names[i],"Adobe",5)                         == 0   //"Adobe Default Windows Sound 1.5"
               )
            {
                PA_DEBUG(("BLACKLISTED!!!\n"));
                continue;
            }


            if( IsDebuggerPresent_ && IsDebuggerPresent_() )  
            {
                /* ASIO Digidesign Driver uses PACE copy protection which quits out
                   if a debugger is running. So we don't load it if a debugger is running. */
                if( strcmp(names[i], "ASIO Digidesign Driver") == 0 )  
                {
                    PA_DEBUG(("BLACKLISTED!!! ASIO Digidesign Driver would quit the debugger\n"));  
                    continue;
                }  
            }  


            /* Attempt to init device info from the asio driver... */
            {
                PaAsioDeviceInfo *asioDeviceInfo = &deviceInfoArray[ (*hostApi)->info.deviceCount ];
                PaDeviceInfo *deviceInfo = &asioDeviceInfo->commonDeviceInfo;

                deviceInfo->structVersion = 2;
                deviceInfo->hostApi = hostApiIndex;

                deviceInfo->name = names[i];

                if( InitPaDeviceInfoFromAsioDriver( asioHostApi, names[i], i, deviceInfo, asioDeviceInfo ) == paNoError )
                {
                    (*hostApi)->deviceInfos[ (*hostApi)->info.deviceCount ] = deviceInfo;
                    ++(*hostApi)->info.deviceCount;
                }
				else
				{
                    PA_DEBUG(("Skipping ASIO device:%s\n",names[i]));
                    continue;
                }
            }
        }
    }

    if( (*hostApi)->info.deviceCount > 0 )
    {
        (*hostApi)->info.defaultInputDevice = 0;
        (*hostApi)->info.defaultOutputDevice = 0;
    }
    else
    {
        (*hostApi)->info.defaultInputDevice = paNoDevice;
        (*hostApi)->info.defaultOutputDevice = paNoDevice;
    }


    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &asioHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &asioHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    return result;

error:
    if( asioHostApi )
    {
        if( asioHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( asioHostApi->allocations );
            PaUtil_DestroyAllocationGroup( asioHostApi->allocations );
        }

        delete asioHostApi->asioDrivers;
        asioDrivers = 0; /* keep SDK global in sync until we stop depending on it */

        PaWinUtil_CoUninitialize( paASIO, &asioHostApi->comInitializationResult );

        PaUtil_FreeMemory( asioHostApi );
    }

    return result;
}


static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaAsioHostApiRepresentation *asioHostApi = (PaAsioHostApiRepresentation*)hostApi;

    /*
        IMPLEMENT ME:
            - clean up any resources not handled by the allocation group (need to review if there are any)
    */

    if( asioHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( asioHostApi->allocations );
        PaUtil_DestroyAllocationGroup( asioHostApi->allocations );
    }

    delete asioHostApi->asioDrivers;
    asioDrivers = 0; /* keep SDK global in sync until we stop depending on it */

    PaWinUtil_CoUninitialize( paASIO, &asioHostApi->comInitializationResult );

    PaUtil_FreeMemory( asioHostApi );
}


static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaError result = paNoError;
    PaAsioHostApiRepresentation *asioHostApi = (PaAsioHostApiRepresentation*)hostApi;
    PaAsioDriverInfo *driverInfo = &asioHostApi->openAsioDriverInfo;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaDeviceIndex asioDeviceIndex;                                  
    ASIOError asioError;
    
    if( inputParameters && outputParameters )
    {
        /* full duplex ASIO stream must use the same device for input and output */

        if( inputParameters->device != outputParameters->device )
            return paBadIODeviceCombination;
    }
    
    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if( inputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;
            
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        asioDeviceIndex = inputParameters->device;

        /* validate inputStreamInfo */
        /** @todo do more validation here */
        // if( inputParameters->hostApiSpecificStreamInfo )
        //    return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if( outputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;
            
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        asioDeviceIndex = outputParameters->device;

        /* validate outputStreamInfo */
        /** @todo do more validation here */
        // if( outputParameters->hostApiSpecificStreamInfo )
        //    return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        outputChannelCount = 0;
    }



    /* if an ASIO device is open we can only get format information for the currently open device */

    if( asioHostApi->openAsioDeviceIndex != paNoDevice 
            && asioHostApi->openAsioDeviceIndex != asioDeviceIndex )
    {
        return paDeviceUnavailable;
    }


    /* NOTE: we load the driver and use its current settings
        rather than the ones in our device info structure which may be stale */

    /* open the device if it's not already open */
    if( asioHostApi->openAsioDeviceIndex == paNoDevice )
    {
        result = LoadAsioDriver( asioHostApi, asioHostApi->inheritedHostApiRep.deviceInfos[ asioDeviceIndex ]->name,
                driverInfo, asioHostApi->systemSpecific );
        if( result != paNoError )
            return result;
    }

    /* check that input device can support inputChannelCount */
    if( inputChannelCount > 0 )
    {
        if( inputChannelCount > driverInfo->inputChannelCount )
        {
            result = paInvalidChannelCount;
            goto done;
        }
    }

    /* check that output device can support outputChannelCount */
    if( outputChannelCount )
    {
        if( outputChannelCount > driverInfo->outputChannelCount )
        {
            result = paInvalidChannelCount;
            goto done;
        }
    }
    
    /* query for sample rate support */
    asioError = ASIOCanSampleRate( sampleRate );
    if( asioError == ASE_NoClock || asioError == ASE_NotPresent )
    {
        result = paInvalidSampleRate;
        goto done;
    }

done:
    /* close the device if it wasn't already open */
    if( asioHostApi->openAsioDeviceIndex == paNoDevice )
    {
        UnloadAsioDriver(); /* not sure if we should check for errors here */
    }

    if( result == paNoError )
        return paFormatIsSupported;
    else
        return result;
}



/** A data structure specifically for storing blocking i/o related data. */
typedef struct PaAsioStreamBlockingState
{
    int stopFlag; /**< Flag indicating that block processing is to be stopped. */

    unsigned long writeBuffersRequested; /**< The number of available output buffers, requested by the #WriteStream() function. */
    unsigned long readFramesRequested;   /**< The number of available input frames, requested by the #ReadStream() function. */

    int writeBuffersRequestedFlag; /**< Flag to indicate that #WriteStream() has requested more output buffers to be available. */
    int readFramesRequestedFlag;   /**< Flag to indicate that #ReadStream() requires more input frames to be available. */

    HANDLE writeBuffersReadyEvent; /**< Event to signal that requested output buffers are available. */
    HANDLE readFramesReadyEvent;   /**< Event to signal that requested input frames are available. */

    void *writeRingBufferData; /**< The actual ring buffer memory, used by the output ring buffer. */
    void *readRingBufferData;  /**< The actual ring buffer memory, used by the input ring buffer. */

    PaUtilRingBuffer writeRingBuffer; /**< Frame-aligned blocking i/o ring buffer to store output data (interleaved user format). */
    PaUtilRingBuffer readRingBuffer;  /**< Frame-aligned blocking i/o ring buffer to store input data (interleaved user format). */

    long writeRingBufferInitialFrames; /**< The initial number of silent frames within the output ring buffer. */

    const void **writeStreamBuffer; /**< Temp buffer, used by #WriteStream() for handling non-interleaved data. */
    void **readStreamBuffer; /**< Temp buffer, used by #ReadStream() for handling non-interleaved data. */

    PaUtilBufferProcessor bufferProcessor; /**< Buffer processor, used to handle the blocking i/o ring buffers. */

    int outputUnderflowFlag; /**< Flag to signal an output underflow from within the callback function. */
    int inputOverflowFlag; /**< Flag to signal an input overflow from within the callback function. */
}
PaAsioStreamBlockingState;



/* PaAsioStream - a stream data structure specifically for this implementation */

typedef struct PaAsioStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

    PaAsioHostApiRepresentation *asioHostApi;
    unsigned long framesPerHostCallback;

    /* ASIO driver info  - these may not be needed for the life of the stream,
        but store them here until we work out how format conversion is going
        to work. */

    ASIOBufferInfo *asioBufferInfos;
    ASIOChannelInfo *asioChannelInfos;
    long asioInputLatencyFrames, asioOutputLatencyFrames; // actual latencies returned by asio

    long inputChannelCount, outputChannelCount;
    bool postOutput;

    void **bufferPtrs; /* this is carved up for inputBufferPtrs and outputBufferPtrs */
    void **inputBufferPtrs[2];
    void **outputBufferPtrs[2];

    PaAsioBufferConverter *inputBufferConverter;
    long inputShift;
    PaAsioBufferConverter *outputBufferConverter;
    long outputShift;

    volatile bool stopProcessing;
    int stopPlayoutCount;
    HANDLE completedBuffersPlayedEvent;

    bool streamFinishedCallbackCalled;
    int isStopped;
    volatile int isActive;
    volatile bool zeroOutput; /* all future calls to the callback will output silence */

    volatile long reenterCount;
    volatile long reenterError;

    PaStreamCallbackFlags callbackFlags;

    PaAsioStreamBlockingState *blockingState; /**< Blocking i/o data struct, or NULL when using callback interface. */
}
PaAsioStream;

static PaAsioStream *theAsioStream = 0; /* due to ASIO sdk limitations there can be only one stream */


static void ZeroOutputBuffers( PaAsioStream *stream, long index )
{
    int i;

    for( i=0; i < stream->outputChannelCount; ++i )
    {
        void *buffer = stream->asioBufferInfos[ i + stream->inputChannelCount ].buffers[index];

        int bytesPerSample = BytesPerAsioSample( stream->asioChannelInfos[ i + stream->inputChannelCount ].type );

        memset( buffer, 0, stream->framesPerHostCallback * bytesPerSample );
    }
}


/* return the next power of two >= x. 
   Returns the input parameter if it is already a power of two. 
   http://stackoverflow.com/questions/364985/algorithm-for-finding-the-smallest-power-of-two-thats-greater-or-equal-to-a-giv 
*/
static unsigned long NextPowerOfTwo( unsigned long x )
{
    --x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    /* If you needed to deal with numbers > 2^32 the following would be needed. 
       For latencies, we don't deal with values this large. 
     x |= x >> 16;
    */

    return x + 1;
}


static unsigned long SelectHostBufferSizeForUnspecifiedUserFramesPerBuffer( 
        unsigned long targetBufferingLatencyFrames, PaAsioDriverInfo *driverInfo )
{
	/* Choose a host buffer size based only on targetBufferingLatencyFrames and the 
	   device's supported buffer sizes. Always returns a valid value.
	*/

	unsigned long result;

	if( targetBufferingLatencyFrames <= (unsigned long)driverInfo->bufferMinSize )
    {
        result = driverInfo->bufferMinSize;
    }
    else if( targetBufferingLatencyFrames >= (unsigned long)driverInfo->bufferMaxSize )
    {
        result = driverInfo->bufferMaxSize;
    }
    else
    {
		if( driverInfo->bufferGranularity == 0 ) /* single fixed host buffer size */
        {
            /* The documentation states that bufferGranularity should be zero 
               when bufferMinSize, bufferMaxSize and bufferPreferredSize are the 
               same. We assume that is the case.
            */

            result = driverInfo->bufferPreferredSize;
        }
		else if( driverInfo->bufferGranularity == -1 ) /* power-of-two */
        {
		    /* We assume bufferMinSize and bufferMaxSize are powers of two. */

            result = NextPowerOfTwo( targetBufferingLatencyFrames );

            if( result < (unsigned long)driverInfo->bufferMinSize )
                result = driverInfo->bufferMinSize;

            if( result > (unsigned long)driverInfo->bufferMaxSize )
                result = driverInfo->bufferMaxSize;
        }
        else /* modulo bufferGranularity */
        {
            /* round up to the next multiple of granularity */
            unsigned long n = (targetBufferingLatencyFrames + driverInfo->bufferGranularity - 1) 
                    / driverInfo->bufferGranularity;
            
            result = n * driverInfo->bufferGranularity;

            if( result < (unsigned long)driverInfo->bufferMinSize )
                result = driverInfo->bufferMinSize;

            if( result > (unsigned long)driverInfo->bufferMaxSize )
                result = driverInfo->bufferMaxSize;
        }
    }

	return result;
}


static unsigned long SelectHostBufferSizeForSpecifiedUserFramesPerBuffer( 
        unsigned long targetBufferingLatencyFrames, unsigned long userFramesPerBuffer,
        PaAsioDriverInfo *driverInfo )
{
	/* Select a host buffer size conforming to targetBufferingLatencyFrames 
	   and the device's supported buffer sizes.
	   The return value will always be a multiple of userFramesPerBuffer. 
	   If a valid buffer size can not be found the function returns 0.

	   The current implementation uses a simple iterative search for clarity.
	   Feel free to suggest a closed form solution.
	*/
	unsigned long result = 0;

	assert( userFramesPerBuffer != 0 );
	
	if( driverInfo->bufferGranularity == 0 ) /* single fixed host buffer size */
    {
        /* The documentation states that bufferGranularity should be zero 
           when bufferMinSize, bufferMaxSize and bufferPreferredSize are the 
           same. We assume that is the case.
        */

		if( (driverInfo->bufferPreferredSize % userFramesPerBuffer) == 0 )
			result = driverInfo->bufferPreferredSize;
    }
	else if( driverInfo->bufferGranularity == -1 ) /* power-of-two */
    {
		/* We assume bufferMinSize and bufferMaxSize are powers of two. */

        /* Search all powers of two in the range [bufferMinSize,bufferMaxSize] 
           for multiples of userFramesPerBuffer. We prefer the first multiple
           that is equal or greater than targetBufferingLatencyFrames, or  
           failing that, the largest multiple less than 
           targetBufferingLatencyFrames.
        */
        unsigned long x = (unsigned long)driverInfo->bufferMinSize; 
		do {
			if( (x % userFramesPerBuffer) == 0 )
			{
                /* any multiple of userFramesPerBuffer is acceptable */
				result = x;
				if( result >= targetBufferingLatencyFrames )
					break; /* stop. a value >= to targetBufferingLatencyFrames is ideal. */
			}

			x *= 2;
		} while( x <= (unsigned long)driverInfo->bufferMaxSize );
    }
    else /* modulo granularity */
    {
		/* We assume bufferMinSize is a multiple of bufferGranularity. */

        /* Search all multiples of bufferGranularity in the range 
           [bufferMinSize,bufferMaxSize] for multiples of userFramesPerBuffer. 
           We prefer the first multiple that is equal or greater than 
           targetBufferingLatencyFrames, or failing that, the largest multiple  
           less than targetBufferingLatencyFrames.
        */
		unsigned long x = (unsigned long)driverInfo->bufferMinSize; 
		do {
			if( (x % userFramesPerBuffer) == 0 )
			{
                /* any multiple of userFramesPerBuffer is acceptable */
				result = x;
				if( result >= targetBufferingLatencyFrames )
					break; /* stop. a value >= to targetBufferingLatencyFrames is ideal. */
			}

			x += driverInfo->bufferGranularity;
		} while( x <= (unsigned long)driverInfo->bufferMaxSize );
    }

	return result;
}


static unsigned long SelectHostBufferSize( 
        unsigned long targetBufferingLatencyFrames, 
        unsigned long userFramesPerBuffer, PaAsioDriverInfo *driverInfo )
{
    unsigned long result = 0;

    /* We select a host buffer size based on the following requirements 
       (in priority order):

        1. The host buffer size must be permissible according to the ASIO 
           driverInfo buffer size constraints (min, max, granularity or 
           powers-of-two).

        2. If the user specifies a non-zero framesPerBuffer parameter 
           (userFramesPerBuffer here) the host buffer should be a multiple of 
           this (subject to the constraints in (1) above).

           [NOTE: Where no permissible host buffer size is a multiple of 
           userFramesPerBuffer, we choose a value as if userFramesPerBuffer were 
           zero (i.e. we ignore it). This strategy is open for review ~ perhaps 
           there are still "more optimal" buffer sizes related to 
           userFramesPerBuffer that we could use.]

        3. The host buffer size should be greater than or equal to 
           targetBufferingLatencyFrames, subject to (1) and (2) above. Where it 
           is not possible to select a host buffer size equal or greater than 
           targetBufferingLatencyFrames, the highest buffer size conforming to  
           (1) and (2) should be chosen.
    */

	if( userFramesPerBuffer != 0 )
	{
		/* userFramesPerBuffer is specified, try to find a buffer size that's 
           a multiple of it */
		result = SelectHostBufferSizeForSpecifiedUserFramesPerBuffer( 
                targetBufferingLatencyFrames, userFramesPerBuffer, driverInfo );
	}

	if( result == 0 )
	{
		/* either userFramesPerBuffer was not specified, or we couldn't find a 
           host buffer size that is a multiple of it. Select a host buffer size 
           according to targetBufferingLatencyFrames and the ASIO driverInfo 
           buffer size constraints.
	     */
		result = SelectHostBufferSizeForUnspecifiedUserFramesPerBuffer( 
                targetBufferingLatencyFrames, driverInfo );
	}

	return result;
}


/* returns channelSelectors if present */

static PaError ValidateAsioSpecificStreamInfo(
        const PaStreamParameters *streamParameters,
        const PaAsioStreamInfo *streamInfo,
        int deviceChannelCount,
        int **channelSelectors )
{
    if( streamInfo )
    {
        if( streamInfo->size != sizeof( PaAsioStreamInfo )
                || streamInfo->version != 1 )
        {
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        if( streamInfo->flags & paAsioUseChannelSelectors )
            *channelSelectors = streamInfo->channelSelectors;

        if( !(*channelSelectors) )
            return paIncompatibleHostApiSpecificStreamInfo;

        for( int i=0; i < streamParameters->channelCount; ++i ){
             if( (*channelSelectors)[i] < 0
                    || (*channelSelectors)[i] >= deviceChannelCount ){
                return paInvalidChannelCount;
             }           
        }
    }

    return paNoError;
}


static bool IsUsingExternalClockSource()
{
    bool result = false;
    ASIOError asioError;
    ASIOClockSource clocks[32];
    long numSources=32;

    /* davidv: listing ASIO Clock sources. there is an ongoing investigation by
       me about whether or not to call ASIOSetSampleRate if an external Clock is
       used. A few drivers expected different things here */
    
    asioError = ASIOGetClockSources(clocks, &numSources);
    if( asioError != ASE_OK ){
        PA_DEBUG(("ERROR: ASIOGetClockSources: %s\n", PaAsio_GetAsioErrorText(asioError) ));
    }else{
        PA_DEBUG(("INFO ASIOGetClockSources listing %d clocks\n", numSources ));
        for (int i=0;i<numSources;++i){
            PA_DEBUG(("ASIOClockSource%d %s current:%d\n", i, clocks[i].name, clocks[i].isCurrentSource ));
           
            if (clocks[i].isCurrentSource)
                result = true;
        }
    }

    return result;
}


static PaError ValidateAndSetSampleRate( double sampleRate )
{
    PaError result = paNoError;
    ASIOError asioError;

    // check that the device supports the requested sample rate 

    asioError = ASIOCanSampleRate( sampleRate );
    PA_DEBUG(("ASIOCanSampleRate(%f):%d\n", sampleRate, asioError ));

    if( asioError != ASE_OK )
    {
        result = paInvalidSampleRate;
        PA_DEBUG(("ERROR: ASIOCanSampleRate: %s\n", PaAsio_GetAsioErrorText(asioError) ));
        goto error;
    }

    // retrieve the current sample rate, we only change to the requested
    // sample rate if the device is not already in that rate.

    ASIOSampleRate oldRate;
    asioError = ASIOGetSampleRate(&oldRate);
    if( asioError != ASE_OK )
    {
        result = paInvalidSampleRate;
        PA_DEBUG(("ERROR: ASIOGetSampleRate: %s\n", PaAsio_GetAsioErrorText(asioError) ));
        goto error;
    }
    PA_DEBUG(("ASIOGetSampleRate:%f\n",oldRate));

    if (oldRate != sampleRate){
        /* Set sample rate */

        PA_DEBUG(("before ASIOSetSampleRate(%f)\n",sampleRate));

        /*
            If you have problems with some drivers when externally clocked, 
            try switching on the following line and commenting out the one after it.
            See IsUsingExternalClockSource() for more info.
        */
        //if( IsUsingExternalClockSource() ){
        if( false ){
            asioError = ASIOSetSampleRate( 0 );
        }else{
            asioError = ASIOSetSampleRate( sampleRate );
        }
        if( asioError != ASE_OK )
        {
            result = paInvalidSampleRate;
            PA_DEBUG(("ERROR: ASIOSetSampleRate: %s\n", PaAsio_GetAsioErrorText(asioError) ));
            goto error;
        }
        PA_DEBUG(("after ASIOSetSampleRate(%f)\n",sampleRate));
    }
    else
    {
        PA_DEBUG(("No Need to change SR\n"));
    }

error:
    return result;
}


/* see pa_hostapi.h for a list of validity guarantees made about OpenStream  parameters */

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaAsioHostApiRepresentation *asioHostApi = (PaAsioHostApiRepresentation*)hostApi;
    PaAsioStream *stream = 0;
    PaAsioStreamInfo *inputStreamInfo, *outputStreamInfo;
    unsigned long framesPerHostBuffer;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
    unsigned long suggestedInputLatencyFrames;
    unsigned long suggestedOutputLatencyFrames;
    PaDeviceIndex asioDeviceIndex;
    ASIOError asioError;
    int asioIsInitialized = 0;
    int asioBuffersCreated = 0;
    int completedBuffersPlayedEventInited = 0;
    int i;
    PaAsioDriverInfo *driverInfo;
    int *inputChannelSelectors = 0;
    int *outputChannelSelectors = 0;

    /* Are we using blocking i/o interface? */
    int usingBlockingIo = ( !streamCallback ) ? TRUE : FALSE;
    /* Blocking i/o stuff */
    long lBlockingBufferSize     = 0; /* Desired ring buffer size in samples. */
    long lBlockingBufferSizePow2 = 0; /* Power-of-2 rounded ring buffer size. */
    long lBytesPerFrame          = 0; /* Number of bytes per input/output frame. */
    int blockingWriteBuffersReadyEventInitialized = 0; /* Event init flag. */
    int blockingReadFramesReadyEventInitialized   = 0; /* Event init flag. */

    int callbackBufferProcessorInited = FALSE;
    int blockingBufferProcessorInited = FALSE;

    /* unless we move to using lower level ASIO calls, we can only have
        one device open at a time */
    if( asioHostApi->openAsioDeviceIndex != paNoDevice )
    {
        PA_DEBUG(("OpenStream paDeviceUnavailable\n"));
        return paDeviceUnavailable;
    }

    assert( theAsioStream == 0 );

    if( inputParameters && outputParameters )
    {
        /* full duplex ASIO stream must use the same device for input and output */

        if( inputParameters->device != outputParameters->device )
        {
            PA_DEBUG(("OpenStream paBadIODeviceCombination\n"));
            return paBadIODeviceCombination;
        }
    }

    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        suggestedInputLatencyFrames = (unsigned long)((inputParameters->suggestedLatency * sampleRate)+0.5f);

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        asioDeviceIndex = inputParameters->device;

        PaAsioDeviceInfo *asioDeviceInfo = (PaAsioDeviceInfo*)hostApi->deviceInfos[asioDeviceIndex];

        /* validate hostApiSpecificStreamInfo */
        inputStreamInfo = (PaAsioStreamInfo*)inputParameters->hostApiSpecificStreamInfo;
        result = ValidateAsioSpecificStreamInfo( inputParameters, inputStreamInfo,
            asioDeviceInfo->commonDeviceInfo.maxInputChannels,
            &inputChannelSelectors
        );
        if( result != paNoError ) return result;
    }
    else
    {
        inputChannelCount = 0;
        inputSampleFormat = 0;
        suggestedInputLatencyFrames = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        suggestedOutputLatencyFrames = (unsigned long)((outputParameters->suggestedLatency * sampleRate)+0.5f);

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        asioDeviceIndex = outputParameters->device;

        PaAsioDeviceInfo *asioDeviceInfo = (PaAsioDeviceInfo*)hostApi->deviceInfos[asioDeviceIndex];

        /* validate hostApiSpecificStreamInfo */
        outputStreamInfo = (PaAsioStreamInfo*)outputParameters->hostApiSpecificStreamInfo;
        result = ValidateAsioSpecificStreamInfo( outputParameters, outputStreamInfo,
            asioDeviceInfo->commonDeviceInfo.maxOutputChannels,
            &outputChannelSelectors
        );
        if( result != paNoError ) return result;
    }
    else
    {
        outputChannelCount = 0;
        outputSampleFormat = 0;
        suggestedOutputLatencyFrames = 0;
    }

    driverInfo = &asioHostApi->openAsioDriverInfo;

    /* NOTE: we load the driver and use its current settings
        rather than the ones in our device info structure which may be stale */

    result = LoadAsioDriver( asioHostApi, asioHostApi->inheritedHostApiRep.deviceInfos[ asioDeviceIndex ]->name,
            driverInfo, asioHostApi->systemSpecific );
    if( result == paNoError )
        asioIsInitialized = 1;
    else{
        PA_DEBUG(("OpenStream ERROR1 - LoadAsioDriver returned %d\n", result));
        goto error;
    }

    /* check that input device can support inputChannelCount */
    if( inputChannelCount > 0 )
    {
        if( inputChannelCount > driverInfo->inputChannelCount )
        {
            result = paInvalidChannelCount;
            PA_DEBUG(("OpenStream ERROR2\n"));
            goto error;
        }
    }

    /* check that output device can support outputChannelCount */
    if( outputChannelCount )
    {
        if( outputChannelCount > driverInfo->outputChannelCount )
        {
            result = paInvalidChannelCount;
            PA_DEBUG(("OpenStream ERROR3\n"));
            goto error;
        }
    }

    result = ValidateAndSetSampleRate( sampleRate );
    if( result != paNoError )
        goto error;

    /*
        IMPLEMENT ME:
            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported
    */

    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 ){
        PA_DEBUG(("OpenStream invalid flags!!\n"));
        return paInvalidFlag; /* unexpected platform specific flag */
    }


    stream = (PaAsioStream*)PaUtil_AllocateMemory( sizeof(PaAsioStream) );
    if( !stream )
    {
        result = paInsufficientMemory;
        PA_DEBUG(("OpenStream ERROR5\n"));
        goto error;
    }
    stream->blockingState = NULL; /* Blocking i/o not initialized, yet. */


    stream->completedBuffersPlayedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( stream->completedBuffersPlayedEvent == NULL )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
        PA_DEBUG(("OpenStream ERROR6\n"));
        goto error;
    }
    completedBuffersPlayedEventInited = 1;


    stream->asioBufferInfos = 0; /* for deallocation in error */
    stream->asioChannelInfos = 0; /* for deallocation in error */
    stream->bufferPtrs = 0; /* for deallocation in error */

    /* Using blocking i/o interface... */
    if( usingBlockingIo )
    {
        /* Blocking i/o is implemented by running callback mode, using a special blocking i/o callback. */
        streamCallback = BlockingIoPaCallback; /* Setup PA to use the ASIO blocking i/o callback. */
        userData       = &theAsioStream;       /* The callback user data will be the PA ASIO stream. */
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &asioHostApi->blockingStreamInterface, streamCallback, userData );
    }
    else /* Using callback interface... */
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &asioHostApi->callbackStreamInterface, streamCallback, userData );
    }


    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );


    stream->asioBufferInfos = (ASIOBufferInfo*)PaUtil_AllocateMemory(
            sizeof(ASIOBufferInfo) * (inputChannelCount + outputChannelCount) );
    if( !stream->asioBufferInfos )
    {
        result = paInsufficientMemory;
        PA_DEBUG(("OpenStream ERROR7\n"));
        goto error;
    }


    for( i=0; i < inputChannelCount; ++i )
    {
        ASIOBufferInfo *info = &stream->asioBufferInfos[i];

        info->isInput = ASIOTrue;

        if( inputChannelSelectors ){
            // inputChannelSelectors values have already been validated in
            // ValidateAsioSpecificStreamInfo() above
            info->channelNum = inputChannelSelectors[i];
        }else{
            info->channelNum = i;
        }

        info->buffers[0] = info->buffers[1] = 0;
    }

    for( i=0; i < outputChannelCount; ++i ){
        ASIOBufferInfo *info = &stream->asioBufferInfos[inputChannelCount+i];

        info->isInput = ASIOFalse;

        if( outputChannelSelectors ){
            // outputChannelSelectors values have already been validated in
            // ValidateAsioSpecificStreamInfo() above
            info->channelNum = outputChannelSelectors[i];
        }else{
            info->channelNum = i;
        }
        
        info->buffers[0] = info->buffers[1] = 0;
    }


    /* Using blocking i/o interface... */
    if( usingBlockingIo )
    {
/** @todo REVIEW selection of host buffer size for blocking i/o */

        framesPerHostBuffer = SelectHostBufferSize( 0, framesPerBuffer, driverInfo );

    }
    else /* Using callback interface... */
    {
        /* Select the host buffer size based on user framesPerBuffer and the
           maximum of suggestedInputLatencyFrames and 
           suggestedOutputLatencyFrames.

           We should subtract any fixed known driver latency from 
           suggestedLatencyFrames before computing the host buffer size.
           However, the ASIO API doesn't provide a method for determining fixed 
           latencies independent of the host buffer size. ASIOGetLatencies()  
           only returns latencies after the buffer size has been configured, so 
           we can't reliably use it to determine fixed latencies here.

           We could set the preferred buffer size and then subtract it from
           the values returned from ASIOGetLatencies, but this would not be 100%
           reliable, so we don't do it.
        */

        unsigned long targetBufferingLatencyFrames = 
                (( suggestedInputLatencyFrames > suggestedOutputLatencyFrames )
                ? suggestedInputLatencyFrames 
                : suggestedOutputLatencyFrames);

        framesPerHostBuffer = SelectHostBufferSize( targetBufferingLatencyFrames, 
                framesPerBuffer, driverInfo );
    }


    PA_DEBUG(("PaAsioOpenStream: framesPerHostBuffer :%d\n",  framesPerHostBuffer));

    asioError = ASIOCreateBuffers( stream->asioBufferInfos,
            inputChannelCount+outputChannelCount,
            framesPerHostBuffer, &asioCallbacks_ );

    if( asioError != ASE_OK
            && framesPerHostBuffer != (unsigned long)driverInfo->bufferPreferredSize )
    {
        PA_DEBUG(("ERROR: ASIOCreateBuffers: %s\n", PaAsio_GetAsioErrorText(asioError) ));
        /*
            Some buggy drivers (like the Hoontech DSP24) give incorrect
            [min, preferred, max] values They should work with the preferred size
            value, thus if Pa_ASIO_CreateBuffers fails with the hostBufferSize
            computed in SelectHostBufferSize, we try again with the preferred size.
        */

        framesPerHostBuffer = driverInfo->bufferPreferredSize;

        PA_DEBUG(("PaAsioOpenStream: CORRECTED framesPerHostBuffer :%d\n",  framesPerHostBuffer));

        ASIOError asioError2 = ASIOCreateBuffers( stream->asioBufferInfos,
                inputChannelCount+outputChannelCount,
                 framesPerHostBuffer, &asioCallbacks_ );
        if( asioError2 == ASE_OK )
            asioError = ASE_OK;
    }

    if( asioError != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        PA_DEBUG(("OpenStream ERROR9\n"));
        goto error;
    }

    asioBuffersCreated = 1;

    stream->asioChannelInfos = (ASIOChannelInfo*)PaUtil_AllocateMemory(
            sizeof(ASIOChannelInfo) * (inputChannelCount + outputChannelCount) );
    if( !stream->asioChannelInfos )
    {
        result = paInsufficientMemory;
        PA_DEBUG(("OpenStream ERROR10\n"));
        goto error;
    }

    for( i=0; i < inputChannelCount + outputChannelCount; ++i )
    {
        stream->asioChannelInfos[i].channel = stream->asioBufferInfos[i].channelNum;
        stream->asioChannelInfos[i].isInput = stream->asioBufferInfos[i].isInput;
        asioError = ASIOGetChannelInfo( &stream->asioChannelInfos[i] );
        if( asioError != ASE_OK )
        {
            result = paUnanticipatedHostError;
            PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
            PA_DEBUG(("OpenStream ERROR11\n"));
            goto error;
        }
    }

    stream->bufferPtrs = (void**)PaUtil_AllocateMemory(
            2 * sizeof(void*) * (inputChannelCount + outputChannelCount) );
    if( !stream->bufferPtrs )
    {
        result = paInsufficientMemory;
        PA_DEBUG(("OpenStream ERROR12\n"));
        goto error;
    }

    if( inputChannelCount > 0 )
    {
        stream->inputBufferPtrs[0] = stream-> bufferPtrs;
        stream->inputBufferPtrs[1] = &stream->bufferPtrs[inputChannelCount];

        for( i=0; i<inputChannelCount; ++i )
        {
            stream->inputBufferPtrs[0][i] = stream->asioBufferInfos[i].buffers[0];
            stream->inputBufferPtrs[1][i] = stream->asioBufferInfos[i].buffers[1];
        }
    }
    else
    {
        stream->inputBufferPtrs[0] = 0;
        stream->inputBufferPtrs[1] = 0;
    }

    if( outputChannelCount > 0 )
    {
        stream->outputBufferPtrs[0] = &stream->bufferPtrs[inputChannelCount*2];
        stream->outputBufferPtrs[1] = &stream->bufferPtrs[inputChannelCount*2 + outputChannelCount];

        for( i=0; i<outputChannelCount; ++i )
        {
            stream->outputBufferPtrs[0][i] = stream->asioBufferInfos[inputChannelCount+i].buffers[0];
            stream->outputBufferPtrs[1][i] = stream->asioBufferInfos[inputChannelCount+i].buffers[1];
        }
    }
    else
    {
        stream->outputBufferPtrs[0] = 0;
        stream->outputBufferPtrs[1] = 0;
    }

    if( inputChannelCount > 0 )
    {
        /* FIXME: assume all channels use the same type for now 
        
            see: "ASIO devices with multiple sample formats are unsupported"
            http://www.portaudio.com/trac/ticket/106
        */
        ASIOSampleType inputType = stream->asioChannelInfos[0].type;

        PA_DEBUG(("ASIO Input  type:%d",inputType));
        AsioSampleTypeLOG(inputType);
        hostInputSampleFormat = AsioSampleTypeToPaNativeSampleFormat( inputType );

        SelectAsioToPaConverter( inputType, &stream->inputBufferConverter, &stream->inputShift );
    }
    else
    {
        hostInputSampleFormat = 0;
        stream->inputBufferConverter = 0;
    }

    if( outputChannelCount > 0 )
    {
        /* FIXME: assume all channels use the same type for now 
        
            see: "ASIO devices with multiple sample formats are unsupported"
            http://www.portaudio.com/trac/ticket/106
        */
        ASIOSampleType outputType = stream->asioChannelInfos[inputChannelCount].type;

        PA_DEBUG(("ASIO Output type:%d",outputType));
        AsioSampleTypeLOG(outputType);
        hostOutputSampleFormat = AsioSampleTypeToPaNativeSampleFormat( outputType );

        SelectPaToAsioConverter( outputType, &stream->outputBufferConverter, &stream->outputShift );
    }
    else
    {
        hostOutputSampleFormat = 0;
        stream->outputBufferConverter = 0;
    }

    /* Values returned by ASIOGetLatencies() include the latency introduced by 
       the ASIO double buffer. */
    ASIOGetLatencies( &stream->asioInputLatencyFrames, &stream->asioOutputLatencyFrames );


    /* Using blocking i/o interface... */
    if( usingBlockingIo )
    {
        /* Allocate the blocking i/o input ring buffer memory. */
        stream->blockingState = (PaAsioStreamBlockingState*)PaUtil_AllocateMemory( sizeof(PaAsioStreamBlockingState) );
        if( !stream->blockingState )
        {
            result = paInsufficientMemory;
            PA_DEBUG(("ERROR! Blocking i/o interface struct allocation failed in OpenStream()\n"));
            goto error;
        }

        /* Initialize blocking i/o interface struct. */
        stream->blockingState->readFramesReadyEvent   = NULL; /* Uninitialized, yet. */
        stream->blockingState->writeBuffersReadyEvent = NULL; /* Uninitialized, yet. */
        stream->blockingState->readRingBufferData     = NULL; /* Uninitialized, yet. */
        stream->blockingState->writeRingBufferData    = NULL; /* Uninitialized, yet. */
        stream->blockingState->readStreamBuffer       = NULL; /* Uninitialized, yet. */
        stream->blockingState->writeStreamBuffer      = NULL; /* Uninitialized, yet. */
        stream->blockingState->stopFlag               = TRUE; /* Not started, yet. */


        /* If the user buffer is unspecified */
        if( framesPerBuffer == paFramesPerBufferUnspecified )
        {
            /* Make the user buffer the same size as the host buffer. */
            framesPerBuffer = framesPerHostBuffer;
        }


        /* Initialize callback buffer processor. */
        result = PaUtil_InitializeBufferProcessor( &stream->bufferProcessor               ,
                                                    inputChannelCount                     ,
                                                    inputSampleFormat & ~paNonInterleaved , /* Ring buffer. */
                                                    (hostInputSampleFormat | paNonInterleaved), /* Host format. */
                                                    outputChannelCount                    ,
                                                    outputSampleFormat & ~paNonInterleaved, /* Ring buffer. */
                                                    (hostOutputSampleFormat | paNonInterleaved), /* Host format. */
                                                    sampleRate                            ,
                                                    streamFlags                           ,
                                                    framesPerBuffer                       , /* Frames per ring buffer block. */
                                                    framesPerHostBuffer                   , /* Frames per asio buffer. */
                                                    paUtilFixedHostBufferSize             ,
                                                    streamCallback                        ,
                                                    userData                               );
        if( result != paNoError ){
            PA_DEBUG(("OpenStream ERROR13\n"));
            goto error;
        }
        callbackBufferProcessorInited = TRUE;

        /* Initialize the blocking i/o buffer processor. */
        result = PaUtil_InitializeBufferProcessor(&stream->blockingState->bufferProcessor,
                                                   inputChannelCount                     ,
                                                   inputSampleFormat                     , /* User format. */
                                                   inputSampleFormat & ~paNonInterleaved , /* Ring buffer. */
                                                   outputChannelCount                    ,
                                                   outputSampleFormat                    , /* User format. */
                                                   outputSampleFormat & ~paNonInterleaved, /* Ring buffer. */
                                                   sampleRate                            ,
                                                   paClipOff | paDitherOff               , /* Don't use dither nor clipping. */
                                                   framesPerBuffer                       , /* Frames per user buffer. */
                                                   framesPerBuffer                       , /* Frames per ring buffer block. */
                                                   paUtilBoundedHostBufferSize           ,
                                                   NULL, NULL                            );/* No callback! */
        if( result != paNoError ){
            PA_DEBUG(("ERROR! Blocking i/o buffer processor initialization failed in OpenStream()\n"));
            goto error;
        }
        blockingBufferProcessorInited = TRUE;

        /* If input is requested. */
        if( inputChannelCount )
        {
            /* Create the callback sync-event. */
            stream->blockingState->readFramesReadyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
            if( stream->blockingState->readFramesReadyEvent == NULL )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
                PA_DEBUG(("ERROR! Blocking i/o \"read frames ready\" event creation failed in OpenStream()\n"));
                goto error;
            }
            blockingReadFramesReadyEventInitialized = 1;


            /* Create pointer buffer to access non-interleaved data in ReadStream() */
            stream->blockingState->readStreamBuffer = (void**)PaUtil_AllocateMemory( sizeof(void*) * inputChannelCount );
            if( !stream->blockingState->readStreamBuffer )
            {
                result = paInsufficientMemory;
                PA_DEBUG(("ERROR! Blocking i/o read stream buffer allocation failed in OpenStream()\n"));
                goto error;
            }

            /* The ring buffer should store as many data blocks as needed
               to achieve the requested latency. Whereas it must be large
               enough to store at least two complete data blocks.

               1) Determine the amount of latency to be added to the
                  prefered ASIO latency.
               2) Make sure we have at lest one additional latency frame.
               3) Divide the number of frames by the desired block size to
                  get the number (rounded up to pure integer) of blocks to
                  be stored in the buffer.
               4) Add one additional block for block processing and convert
                  to samples frames.
               5) Get the next larger (or equal) power-of-two buffer size.
             */
            lBlockingBufferSize = suggestedInputLatencyFrames - stream->asioInputLatencyFrames;
            lBlockingBufferSize = (lBlockingBufferSize > 0) ? lBlockingBufferSize : 1;
            lBlockingBufferSize = (lBlockingBufferSize + framesPerBuffer - 1) / framesPerBuffer;
            lBlockingBufferSize = (lBlockingBufferSize + 1) * framesPerBuffer;

            /* Get the next larger or equal power-of-two buffersize. */
            lBlockingBufferSizePow2 = 1;
            while( lBlockingBufferSize > (lBlockingBufferSizePow2<<=1) );
            lBlockingBufferSize = lBlockingBufferSizePow2;

            /* Compute total intput latency in seconds */
            stream->streamRepresentation.streamInfo.inputLatency =
                (double)( PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor               )
                        + PaUtil_GetBufferProcessorInputLatencyFrames(&stream->blockingState->bufferProcessor)
                        + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer
                        + stream->asioInputLatencyFrames )
                / sampleRate;

            /* The code below prints the ASIO latency which doesn't include
               the buffer processor latency nor the blocking i/o latency. It
               reports the added latency separately.
            */
            PA_DEBUG(("PaAsio : ASIO InputLatency = %ld (%ld ms),\n         added buffProc:%ld (%ld ms),\n         added blocking:%ld (%ld ms)\n",
                stream->asioInputLatencyFrames,
                (long)( stream->asioInputLatencyFrames * (1000.0 / sampleRate) ),
                PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor),
                (long)( PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor) * (1000.0 / sampleRate) ),
                PaUtil_GetBufferProcessorInputLatencyFrames(&stream->blockingState->bufferProcessor) + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer,
                (long)( (PaUtil_GetBufferProcessorInputLatencyFrames(&stream->blockingState->bufferProcessor) + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer) * (1000.0 / sampleRate) )
                ));

            /* Determine the size of ring buffer in bytes. */
            lBytesPerFrame = inputChannelCount * Pa_GetSampleSize(inputSampleFormat );

            /* Allocate the blocking i/o input ring buffer memory. */
            stream->blockingState->readRingBufferData = (void*)PaUtil_AllocateMemory( lBlockingBufferSize * lBytesPerFrame );
            if( !stream->blockingState->readRingBufferData )
            {
                result = paInsufficientMemory;
                PA_DEBUG(("ERROR! Blocking i/o input ring buffer allocation failed in OpenStream()\n"));
                goto error;
            }

            /* Initialize the input ring buffer struct. */
            PaUtil_InitializeRingBuffer( &stream->blockingState->readRingBuffer    ,
                                          lBytesPerFrame                           ,
                                          lBlockingBufferSize                      ,
                                          stream->blockingState->readRingBufferData );
        }

        /* If output is requested. */
        if( outputChannelCount )
        {
            stream->blockingState->writeBuffersReadyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
            if( stream->blockingState->writeBuffersReadyEvent == NULL )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
                PA_DEBUG(("ERROR! Blocking i/o \"write buffers ready\" event creation failed in OpenStream()\n"));
                goto error;
            }
            blockingWriteBuffersReadyEventInitialized = 1;

            /* Create pointer buffer to access non-interleaved data in WriteStream() */
            stream->blockingState->writeStreamBuffer = (const void**)PaUtil_AllocateMemory( sizeof(const void*) * outputChannelCount );
            if( !stream->blockingState->writeStreamBuffer )
            {
                result = paInsufficientMemory;
                PA_DEBUG(("ERROR! Blocking i/o write stream buffer allocation failed in OpenStream()\n"));
                goto error;
            }

            /* The ring buffer should store as many data blocks as needed
               to achieve the requested latency. Whereas it must be large
               enough to store at least two complete data blocks.

               1) Determine the amount of latency to be added to the
                  prefered ASIO latency.
               2) Make sure we have at lest one additional latency frame.
               3) Divide the number of frames by the desired block size to
                  get the number (rounded up to pure integer) of blocks to
                  be stored in the buffer.
               4) Add one additional block for block processing and convert
                  to samples frames.
               5) Get the next larger (or equal) power-of-two buffer size.
             */
            lBlockingBufferSize = suggestedOutputLatencyFrames - stream->asioOutputLatencyFrames;
            lBlockingBufferSize = (lBlockingBufferSize > 0) ? lBlockingBufferSize : 1;
            lBlockingBufferSize = (lBlockingBufferSize + framesPerBuffer - 1) / framesPerBuffer;
            lBlockingBufferSize = (lBlockingBufferSize + 1) * framesPerBuffer;

            /* The buffer size (without the additional block) corresponds
               to the initial number of silent samples in the output ring
               buffer. */
            stream->blockingState->writeRingBufferInitialFrames = lBlockingBufferSize - framesPerBuffer;

            /* Get the next larger or equal power-of-two buffersize. */
            lBlockingBufferSizePow2 = 1;
            while( lBlockingBufferSize > (lBlockingBufferSizePow2<<=1) );
            lBlockingBufferSize = lBlockingBufferSizePow2;

            /* Compute total output latency in seconds */
            stream->streamRepresentation.streamInfo.outputLatency =
                (double)( PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor)
                        + PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->blockingState->bufferProcessor)
                        + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer
                        + stream->asioOutputLatencyFrames )
                / sampleRate;

            /* The code below prints the ASIO latency which doesn't include
               the buffer processor latency nor the blocking i/o latency. It
               reports the added latency separately.
            */
            PA_DEBUG(("PaAsio : ASIO OutputLatency = %ld (%ld ms),\n         added buffProc:%ld (%ld ms),\n         added blocking:%ld (%ld ms)\n",
                stream->asioOutputLatencyFrames,
                (long)( stream->asioOutputLatencyFrames * (1000.0 / sampleRate) ),
                PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor),
                (long)( PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor) * (1000.0 / sampleRate) ),
                PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->blockingState->bufferProcessor) + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer,
                (long)( (PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->blockingState->bufferProcessor) + (lBlockingBufferSize / framesPerBuffer - 1) * framesPerBuffer) * (1000.0 / sampleRate) )
                ));

            /* Determine the size of ring buffer in bytes. */
            lBytesPerFrame = outputChannelCount * Pa_GetSampleSize(outputSampleFormat);

            /* Allocate the blocking i/o output ring buffer memory. */
            stream->blockingState->writeRingBufferData = (void*)PaUtil_AllocateMemory( lBlockingBufferSize * lBytesPerFrame );
            if( !stream->blockingState->writeRingBufferData )
            {
                result = paInsufficientMemory;
                PA_DEBUG(("ERROR! Blocking i/o output ring buffer allocation failed in OpenStream()\n"));
                goto error;
            }

            /* Initialize the output ring buffer struct. */
            PaUtil_InitializeRingBuffer( &stream->blockingState->writeRingBuffer    ,
                                          lBytesPerFrame                            ,
                                          lBlockingBufferSize                       ,
                                          stream->blockingState->writeRingBufferData );
        }

        stream->streamRepresentation.streamInfo.sampleRate = sampleRate;


    }
    else /* Using callback interface... */
    {
        result =  PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                        inputChannelCount, inputSampleFormat, (hostInputSampleFormat | paNonInterleaved),
                        outputChannelCount, outputSampleFormat, (hostOutputSampleFormat | paNonInterleaved),
                        sampleRate, streamFlags, framesPerBuffer,
                        framesPerHostBuffer, paUtilFixedHostBufferSize,
                        streamCallback, userData );
        if( result != paNoError ){
            PA_DEBUG(("OpenStream ERROR13\n"));
            goto error;
        }
        callbackBufferProcessorInited = TRUE;

        stream->streamRepresentation.streamInfo.inputLatency =
                (double)( PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor)
                    + stream->asioInputLatencyFrames) / sampleRate;   // seconds
        stream->streamRepresentation.streamInfo.outputLatency =
                (double)( PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor)
                    + stream->asioOutputLatencyFrames) / sampleRate; // seconds
        stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

        // the code below prints the ASIO latency which doesn't include the
        // buffer processor latency. it reports the added latency separately
        PA_DEBUG(("PaAsio : ASIO InputLatency = %ld (%ld ms), added buffProc:%ld (%ld ms)\n",
                stream->asioInputLatencyFrames,
                (long)((stream->asioInputLatencyFrames*1000)/ sampleRate),  
                PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor),
                (long)((PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor)*1000)/ sampleRate)
                ));

        PA_DEBUG(("PaAsio : ASIO OuputLatency = %ld (%ld ms), added buffProc:%ld (%ld ms)\n",
                stream->asioOutputLatencyFrames,
                (long)((stream->asioOutputLatencyFrames*1000)/ sampleRate), 
                PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor),
                (long)((PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor)*1000)/ sampleRate)
                ));
    }

    stream->asioHostApi = asioHostApi;
    stream->framesPerHostCallback = framesPerHostBuffer;

    stream->inputChannelCount = inputChannelCount;
    stream->outputChannelCount = outputChannelCount;
    stream->postOutput = driverInfo->postOutput;
    stream->isStopped = 1;
    stream->isActive = 0;
    
    asioHostApi->openAsioDeviceIndex = asioDeviceIndex;

    theAsioStream = stream;
    *s = (PaStream*)stream;

    return result;

error:
    PA_DEBUG(("goto errored\n"));
    if( stream )
    {
        if( stream->blockingState )
        {
            if( blockingBufferProcessorInited )
                PaUtil_TerminateBufferProcessor( &stream->blockingState->bufferProcessor );

            if( stream->blockingState->writeRingBufferData )
                PaUtil_FreeMemory( stream->blockingState->writeRingBufferData );
            if( stream->blockingState->writeStreamBuffer )
                PaUtil_FreeMemory( stream->blockingState->writeStreamBuffer );
            if( blockingWriteBuffersReadyEventInitialized )
                CloseHandle( stream->blockingState->writeBuffersReadyEvent );

            if( stream->blockingState->readRingBufferData )
                PaUtil_FreeMemory( stream->blockingState->readRingBufferData );
            if( stream->blockingState->readStreamBuffer )
                PaUtil_FreeMemory( stream->blockingState->readStreamBuffer );
            if( blockingReadFramesReadyEventInitialized )
                CloseHandle( stream->blockingState->readFramesReadyEvent );

            PaUtil_FreeMemory( stream->blockingState );
        }

        if( callbackBufferProcessorInited )
            PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );

        if( completedBuffersPlayedEventInited )
            CloseHandle( stream->completedBuffersPlayedEvent );

        if( stream->asioBufferInfos )
            PaUtil_FreeMemory( stream->asioBufferInfos );

        if( stream->asioChannelInfos )
            PaUtil_FreeMemory( stream->asioChannelInfos );

        if( stream->bufferPtrs )
            PaUtil_FreeMemory( stream->bufferPtrs );

        PaUtil_FreeMemory( stream );
    }

    if( asioBuffersCreated )
        ASIODisposeBuffers();

    if( asioIsInitialized )
	{
		UnloadAsioDriver();
	}
    return result;
}


/*
    When CloseStream() is called, the multi-api layer ensures that
    the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaAsioStream *stream = (PaAsioStream*)s;

    /*
        IMPLEMENT ME:
            - additional stream closing + cleanup
    */

    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );

    stream->asioHostApi->openAsioDeviceIndex = paNoDevice;

    CloseHandle( stream->completedBuffersPlayedEvent );

    /* Using blocking i/o interface... */
    if( stream->blockingState )
    {
        PaUtil_TerminateBufferProcessor( &stream->blockingState->bufferProcessor );

        if( stream->inputChannelCount ) {
            PaUtil_FreeMemory( stream->blockingState->readRingBufferData );
            PaUtil_FreeMemory( stream->blockingState->readStreamBuffer  );
            CloseHandle( stream->blockingState->readFramesReadyEvent );
        }
        if( stream->outputChannelCount ) {
            PaUtil_FreeMemory( stream->blockingState->writeRingBufferData );
            PaUtil_FreeMemory( stream->blockingState->writeStreamBuffer );
            CloseHandle( stream->blockingState->writeBuffersReadyEvent );
        }

        PaUtil_FreeMemory( stream->blockingState );
    }

    PaUtil_FreeMemory( stream->asioBufferInfos );
    PaUtil_FreeMemory( stream->asioChannelInfos );
    PaUtil_FreeMemory( stream->bufferPtrs );
    PaUtil_FreeMemory( stream );

    ASIODisposeBuffers();
    UnloadAsioDriver();

    theAsioStream = 0;

    return result;
}


static void bufferSwitch(long index, ASIOBool directProcess)
{
//TAKEN FROM THE ASIO SDK

    // the actual processing callback.
    // Beware that this is normally in a seperate thread, hence be sure that
    // you take care about thread synchronization. This is omitted here for
    // simplicity.

    // as this is a "back door" into the bufferSwitchTimeInfo a timeInfo needs
    // to be created though it will only set the timeInfo.samplePosition and
    // timeInfo.systemTime fields and the according flags

    ASIOTime  timeInfo;
    memset( &timeInfo, 0, sizeof (timeInfo) );

    // get the time stamp of the buffer, not necessary if no
    // synchronization to other media is required
    if( ASIOGetSamplePosition(&timeInfo.timeInfo.samplePosition, &timeInfo.timeInfo.systemTime) == ASE_OK)
            timeInfo.timeInfo.flags = kSystemTimeValid | kSamplePositionValid;

    // Call the real callback
    bufferSwitchTimeInfo( &timeInfo, index, directProcess );
}


// conversion from 64 bit ASIOSample/ASIOTimeStamp to double float
#if NATIVE_INT64
    #define ASIO64toDouble(a)  (a)
#else
    const double twoRaisedTo32 = 4294967296.;
    #define ASIO64toDouble(a)  ((a).lo + (a).hi * twoRaisedTo32)
#endif

static ASIOTime *bufferSwitchTimeInfo( ASIOTime *timeInfo, long index, ASIOBool directProcess )
{
    // the actual processing callback.
    // Beware that this is normally in a seperate thread, hence be sure that
    // you take care about thread synchronization.


    /* The SDK says the following about the directProcess flag:
        suggests to the host whether it should immediately start processing
        (directProcess == ASIOTrue), or whether its process should be deferred
        because the call comes from a very low level (for instance, a high level
        priority interrupt), and direct processing would cause timing instabilities for
        the rest of the system. If in doubt, directProcess should be set to ASIOFalse.

        We just ignore directProcess. This could cause incompatibilities with
        drivers which really don't want the audio processing to occur in this
        callback, but none have been identified yet.
    */

    (void) directProcess; /* suppress unused parameter warning */

#if 0
    // store the timeInfo for later use
    asioDriverInfo.tInfo = *timeInfo;

    // get the time stamp of the buffer, not necessary if no
    // synchronization to other media is required

    if (timeInfo->timeInfo.flags & kSystemTimeValid)
            asioDriverInfo.nanoSeconds = ASIO64toDouble(timeInfo->timeInfo.systemTime);
    else
            asioDriverInfo.nanoSeconds = 0;

    if (timeInfo->timeInfo.flags & kSamplePositionValid)
            asioDriverInfo.samples = ASIO64toDouble(timeInfo->timeInfo.samplePosition);
    else
            asioDriverInfo.samples = 0;

    if (timeInfo->timeCode.flags & kTcValid)
            asioDriverInfo.tcSamples = ASIO64toDouble(timeInfo->timeCode.timeCodeSamples);
    else
            asioDriverInfo.tcSamples = 0;

    // get the system reference time
    asioDriverInfo.sysRefTime = get_sys_reference_time();
#endif

#if 0
    // a few debug messages for the Windows device driver developer
    // tells you the time when driver got its interrupt and the delay until the app receives
    // the event notification.
    static double last_samples = 0;
    char tmp[128];
    sprintf (tmp, "diff: %d / %d ms / %d ms / %d samples                 \n", asioDriverInfo.sysRefTime - (long)(asioDriverInfo.nanoSeconds / 1000000.0), asioDriverInfo.sysRefTime, (long)(asioDriverInfo.nanoSeconds / 1000000.0), (long)(asioDriverInfo.samples - last_samples));
    OutputDebugString (tmp);
    last_samples = asioDriverInfo.samples;
#endif


    if( !theAsioStream )
        return 0L;

    // protect against reentrancy
    if( PaAsio_AtomicIncrement(&theAsioStream->reenterCount) )
    {
        theAsioStream->reenterError++;
        //DBUG(("bufferSwitchTimeInfo : reentrancy detection = %d\n", asioDriverInfo.reenterError));
        return 0L;
    }

    int buffersDone = 0;
    
    do
    {
        if( buffersDone > 0 )
        {
            // this is a reentered buffer, we missed processing it on time
            // set the input overflow and output underflow flags as appropriate
            
            if( theAsioStream->inputChannelCount > 0 )
                theAsioStream->callbackFlags |= paInputOverflow;
                
            if( theAsioStream->outputChannelCount > 0 )
                theAsioStream->callbackFlags |= paOutputUnderflow;
        }
        else
        {
            if( theAsioStream->zeroOutput )
            {
                ZeroOutputBuffers( theAsioStream, index );

                // Finally if the driver supports the ASIOOutputReady() optimization,
                // do it here, all data are in place
                if( theAsioStream->postOutput )
                    ASIOOutputReady();

                if( theAsioStream->stopProcessing )
                {
                    if( theAsioStream->stopPlayoutCount < 2 )
                    {
                        ++theAsioStream->stopPlayoutCount;
                        if( theAsioStream->stopPlayoutCount == 2 )
                        {
                            theAsioStream->isActive = 0;
                            if( theAsioStream->streamRepresentation.streamFinishedCallback != 0 )
                                theAsioStream->streamRepresentation.streamFinishedCallback( theAsioStream->streamRepresentation.userData );
                            theAsioStream->streamFinishedCallbackCalled = true;
                            SetEvent( theAsioStream->completedBuffersPlayedEvent );
                        }
                    }
                }
            }
            else
            {

#if 0
/*
    see: "ASIO callback underflow/overflow buffer slip detection doesn't work"
    http://www.portaudio.com/trac/ticket/110
*/

// test code to try to detect slip conditions... these may work on some systems
// but neither of them work on the RME Digi96

// check that sample delta matches buffer size (otherwise we must have skipped
// a buffer.
static double last_samples = -512;
double samples;
//if( timeInfo->timeCode.flags & kTcValid )
//    samples = ASIO64toDouble(timeInfo->timeCode.timeCodeSamples);
//else
    samples = ASIO64toDouble(timeInfo->timeInfo.samplePosition);
int delta = samples - last_samples;
//printf( "%d\n", delta);
last_samples = samples;

if( delta > theAsioStream->framesPerHostCallback )
{
    if( theAsioStream->inputChannelCount > 0 )
        theAsioStream->callbackFlags |= paInputOverflow;

    if( theAsioStream->outputChannelCount > 0 )
        theAsioStream->callbackFlags |= paOutputUnderflow;
}

// check that the buffer index is not the previous index (which would indicate
// that a buffer was skipped.
static int previousIndex = 1;
if( index == previousIndex )
{
    if( theAsioStream->inputChannelCount > 0 )
        theAsioStream->callbackFlags |= paInputOverflow;

    if( theAsioStream->outputChannelCount > 0 )
        theAsioStream->callbackFlags |= paOutputUnderflow;
}
previousIndex = index;
#endif

                int i;

                PaUtil_BeginCpuLoadMeasurement( &theAsioStream->cpuLoadMeasurer );

                PaStreamCallbackTimeInfo paTimeInfo;

                // asio systemTime is supposed to be measured according to the same
                // clock as timeGetTime
                paTimeInfo.currentTime = (ASIO64toDouble( timeInfo->timeInfo.systemTime ) * .000000001);

                /* patch from Paul Boege */
                paTimeInfo.inputBufferAdcTime = paTimeInfo.currentTime -
                    ((double)theAsioStream->asioInputLatencyFrames/theAsioStream->streamRepresentation.streamInfo.sampleRate);

                paTimeInfo.outputBufferDacTime = paTimeInfo.currentTime +
                    ((double)theAsioStream->asioOutputLatencyFrames/theAsioStream->streamRepresentation.streamInfo.sampleRate);

                /* old version is buggy because the buffer processor also adds in its latency to the time parameters
                paTimeInfo.inputBufferAdcTime = paTimeInfo.currentTime - theAsioStream->streamRepresentation.streamInfo.inputLatency;
                paTimeInfo.outputBufferDacTime = paTimeInfo.currentTime + theAsioStream->streamRepresentation.streamInfo.outputLatency;
                */

/* Disabled! Stopping and re-starting the stream causes an input overflow / output underflow. S.Fischer */
#if 0
// detect underflows by checking inter-callback time > 2 buffer period
static double previousTime = -1;
if( previousTime > 0 ){

    double delta = paTimeInfo.currentTime - previousTime;

    if( delta >= 2. * (theAsioStream->framesPerHostCallback / theAsioStream->streamRepresentation.streamInfo.sampleRate) ){
        if( theAsioStream->inputChannelCount > 0 )
            theAsioStream->callbackFlags |= paInputOverflow;

        if( theAsioStream->outputChannelCount > 0 )
            theAsioStream->callbackFlags |= paOutputUnderflow;
    }
}
previousTime = paTimeInfo.currentTime;
#endif

                // note that the above input and output times do not need to be
                // adjusted for the latency of the buffer processor -- the buffer
                // processor handles that.

                if( theAsioStream->inputBufferConverter )
                {
                    for( i=0; i<theAsioStream->inputChannelCount; i++ )
                    {
                        theAsioStream->inputBufferConverter( theAsioStream->inputBufferPtrs[index][i],
                                theAsioStream->inputShift, theAsioStream->framesPerHostCallback );
                    }
                }

                PaUtil_BeginBufferProcessing( &theAsioStream->bufferProcessor, &paTimeInfo, theAsioStream->callbackFlags );

                /* reset status flags once they've been passed to the callback */
                theAsioStream->callbackFlags = 0;

                PaUtil_SetInputFrameCount( &theAsioStream->bufferProcessor, 0 /* default to host buffer size */ );
                for( i=0; i<theAsioStream->inputChannelCount; ++i )
                    PaUtil_SetNonInterleavedInputChannel( &theAsioStream->bufferProcessor, i, theAsioStream->inputBufferPtrs[index][i] );

                PaUtil_SetOutputFrameCount( &theAsioStream->bufferProcessor, 0 /* default to host buffer size */ );
                for( i=0; i<theAsioStream->outputChannelCount; ++i )
                    PaUtil_SetNonInterleavedOutputChannel( &theAsioStream->bufferProcessor, i, theAsioStream->outputBufferPtrs[index][i] );

                int callbackResult;
                if( theAsioStream->stopProcessing )
                    callbackResult = paComplete;
                else
                    callbackResult = paContinue;
                unsigned long framesProcessed = PaUtil_EndBufferProcessing( &theAsioStream->bufferProcessor, &callbackResult );

                if( theAsioStream->outputBufferConverter )
                {
                    for( i=0; i<theAsioStream->outputChannelCount; i++ )
                    {
                        theAsioStream->outputBufferConverter( theAsioStream->outputBufferPtrs[index][i],
                                theAsioStream->outputShift, theAsioStream->framesPerHostCallback );
                    }
                }

                PaUtil_EndCpuLoadMeasurement( &theAsioStream->cpuLoadMeasurer, framesProcessed );

                // Finally if the driver supports the ASIOOutputReady() optimization,
                // do it here, all data are in place
                if( theAsioStream->postOutput )
                    ASIOOutputReady();

                if( callbackResult == paContinue )
                {
                    /* nothing special to do */
                }
                else if( callbackResult == paAbort )
                {
                    /* finish playback immediately  */
                    theAsioStream->isActive = 0;
                    if( theAsioStream->streamRepresentation.streamFinishedCallback != 0 )
                        theAsioStream->streamRepresentation.streamFinishedCallback( theAsioStream->streamRepresentation.userData );
                    theAsioStream->streamFinishedCallbackCalled = true;
                    SetEvent( theAsioStream->completedBuffersPlayedEvent );
                    theAsioStream->zeroOutput = true;
                }
                else /* paComplete or other non-zero value indicating complete */
                {
                    /* Finish playback once currently queued audio has completed. */
                    theAsioStream->stopProcessing = true;

                    if( PaUtil_IsBufferProcessorOutputEmpty( &theAsioStream->bufferProcessor ) )
                    {
                        theAsioStream->zeroOutput = true;
                        theAsioStream->stopPlayoutCount = 0;
                    }
                }
            }
        }
        
        ++buffersDone;
    }while( PaAsio_AtomicDecrement(&theAsioStream->reenterCount) >= 0 );

    return 0L;
}


static void sampleRateChanged(ASIOSampleRate sRate)
{
    // TAKEN FROM THE ASIO SDK
    // do whatever you need to do if the sample rate changed
    // usually this only happens during external sync.
    // Audio processing is not stopped by the driver, actual sample rate
    // might not have even changed, maybe only the sample rate status of an
    // AES/EBU or S/PDIF digital input at the audio device.
    // You might have to update time/sample related conversion routines, etc.

    (void) sRate; /* unused parameter */
    PA_DEBUG( ("sampleRateChanged : %d \n", sRate));
}

static long asioMessages(long selector, long value, void* message, double* opt)
{
// TAKEN FROM THE ASIO SDK
    // currently the parameters "value", "message" and "opt" are not used.
    long ret = 0;

    (void) message; /* unused parameters */
    (void) opt;

    PA_DEBUG( ("asioMessages : %d , %d \n", selector, value));

    switch(selector)
    {
        case kAsioSelectorSupported:
            if(value == kAsioResetRequest
            || value == kAsioEngineVersion
            || value == kAsioResyncRequest
            || value == kAsioLatenciesChanged
            // the following three were added for ASIO 2.0, you don't necessarily have to support them
            || value == kAsioSupportsTimeInfo
            || value == kAsioSupportsTimeCode
            || value == kAsioSupportsInputMonitor)
                    ret = 1L;
            break;

        case kAsioBufferSizeChange:
            //printf("kAsioBufferSizeChange \n");
            break;

        case kAsioResetRequest:
            // defer the task and perform the reset of the driver during the next "safe" situation
            // You cannot reset the driver right now, as this code is called from the driver.
            // Reset the driver is done by completely destruct is. I.e. ASIOStop(), ASIODisposeBuffers(), Destruction
            // Afterwards you initialize the driver again.

            /*FIXME: commented the next line out

                see: "PA/ASIO ignores some driver notifications it probably shouldn't"
                http://www.portaudio.com/trac/ticket/108
            */
            //asioDriverInfo.stopped;  // In this sample the processing will just stop
            ret = 1L;
            break;

        case kAsioResyncRequest:
            // This informs the application, that the driver encountered some non fatal data loss.
            // It is used for synchronization purposes of different media.
            // Added mainly to work around the Win16Mutex problems in Windows 95/98 with the
            // Windows Multimedia system, which could loose data because the Mutex was hold too long
            // by another thread.
            // However a driver can issue it in other situations, too.
            ret = 1L;
            break;

        case kAsioLatenciesChanged:
            // This will inform the host application that the drivers were latencies changed.
            // Beware, it this does not mean that the buffer sizes have changed!
            // You might need to update internal delay data.
            ret = 1L;
            //printf("kAsioLatenciesChanged \n");
            break;

        case kAsioEngineVersion:
            // return the supported ASIO version of the host application
            // If a host applications does not implement this selector, ASIO 1.0 is assumed
            // by the driver
            ret = 2L;
            break;

        case kAsioSupportsTimeInfo:
            // informs the driver wether the asioCallbacks.bufferSwitchTimeInfo() callback
            // is supported.
            // For compatibility with ASIO 1.0 drivers the host application should always support
            // the "old" bufferSwitch method, too.
            ret = 1;
            break;

        case kAsioSupportsTimeCode:
            // informs the driver wether application is interested in time code info.
            // If an application does not need to know about time code, the driver has less work
            // to do.
            ret = 0;
            break;
    }
    return ret;
}


static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaAsioStream *stream = (PaAsioStream*)s;
    PaAsioStreamBlockingState *blockingState = stream->blockingState;
    ASIOError asioError;

    if( stream->outputChannelCount > 0 )
    {
        ZeroOutputBuffers( stream, 0 );
        ZeroOutputBuffers( stream, 1 );
    }

    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );
    stream->stopProcessing = false;
    stream->zeroOutput = false;

    /* Reentrancy counter initialisation */
    stream->reenterCount = -1;
    stream->reenterError = 0;

    stream->callbackFlags = 0;

    if( ResetEvent( stream->completedBuffersPlayedEvent ) == 0 )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
    }


    /* Using blocking i/o interface... */
    if( blockingState )
    {
        /* Reset blocking i/o buffer processor. */
        PaUtil_ResetBufferProcessor( &blockingState->bufferProcessor );

        /* If we're about to process some input data. */
        if( stream->inputChannelCount )
        {
            /* Reset callback-ReadStream sync event. */
            if( ResetEvent( blockingState->readFramesReadyEvent ) == 0 )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
            }

            /* Flush blocking i/o ring buffer. */
            PaUtil_FlushRingBuffer( &blockingState->readRingBuffer );
            (*blockingState->bufferProcessor.inputZeroer)( blockingState->readRingBuffer.buffer, 1, blockingState->bufferProcessor.inputChannelCount * blockingState->readRingBuffer.bufferSize );
        }

        /* If we're about to process some output data. */
        if( stream->outputChannelCount )
        {
            /* Reset callback-WriteStream sync event. */
            if( ResetEvent( blockingState->writeBuffersReadyEvent ) == 0 )
            {
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
            }

            /* Flush blocking i/o ring buffer. */
            PaUtil_FlushRingBuffer( &blockingState->writeRingBuffer );
            (*blockingState->bufferProcessor.outputZeroer)( blockingState->writeRingBuffer.buffer, 1, blockingState->bufferProcessor.outputChannelCount * blockingState->writeRingBuffer.bufferSize );

            /* Initialize the output ring buffer to "silence". */
            PaUtil_AdvanceRingBufferWriteIndex( &blockingState->writeRingBuffer, blockingState->writeRingBufferInitialFrames );
        }

        /* Clear requested frames / buffers count. */
        blockingState->writeBuffersRequested     = 0;
        blockingState->readFramesRequested       = 0;
        blockingState->writeBuffersRequestedFlag = FALSE;
        blockingState->readFramesRequestedFlag   = FALSE;
        blockingState->outputUnderflowFlag       = FALSE;
        blockingState->inputOverflowFlag         = FALSE;
        blockingState->stopFlag                  = FALSE;
    }


    if( result == paNoError )
    {
        assert( theAsioStream == stream ); /* theAsioStream should be set correctly in OpenStream */

        /* initialize these variables before the callback has a chance to be invoked */
        stream->isStopped = 0;
        stream->isActive = 1;
        stream->streamFinishedCallbackCalled = false;

        asioError = ASIOStart();
        if( asioError != ASE_OK )
        {
            stream->isStopped = 1;
            stream->isActive = 0;

            result = paUnanticipatedHostError;
            PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        }
    }

    return result;
}

static void EnsureCallbackHasCompleted( PaAsioStream *stream )
{
    // make sure that the callback is not still in-flight after ASIOStop()
    // returns. This has been observed to happen on the Hoontech DSP24 for
    // example.
    int count = 2000;  // only wait for 2 seconds, rather than hanging.
    while( stream->reenterCount != -1 && count > 0 )
    {
        Sleep(1);
        --count;
    }
}

static PaError StopStream( PaStream *s )
{
    PaError result = paNoError;
    PaAsioStream *stream = (PaAsioStream*)s;
    PaAsioStreamBlockingState *blockingState = stream->blockingState;
    ASIOError asioError;

    if( stream->isActive )
    {
        /* If blocking i/o output is in use */
        if( blockingState && stream->outputChannelCount )
        {
            /* Request the whole output buffer to be available. */
            blockingState->writeBuffersRequested = blockingState->writeRingBuffer.bufferSize;
            /* Signalize that additional buffers are need. */
            blockingState->writeBuffersRequestedFlag = TRUE;
            /* Set flag to indicate the playback is to be stopped. */
            blockingState->stopFlag = TRUE;

            /* Wait until requested number of buffers has been freed. Time
               out after twice the blocking i/o ouput buffer could have
               been consumed. */
            DWORD timeout = (DWORD)( 2 * blockingState->writeRingBuffer.bufferSize * 1000
                                       / stream->streamRepresentation.streamInfo.sampleRate );
            DWORD waitResult = WaitForSingleObject( blockingState->writeBuffersReadyEvent, timeout );

            /* If something seriously went wrong... */
            if( waitResult == WAIT_FAILED )
            {
                PA_DEBUG(("WaitForSingleObject() failed in StopStream()\n"));
                result = paUnanticipatedHostError;
                PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
            }
            else if( waitResult == WAIT_TIMEOUT )
            {
                PA_DEBUG(("WaitForSingleObject() timed out in StopStream()\n"));
                result = paTimedOut;
            }
        }

        stream->stopProcessing = true;

        /* wait for the stream to finish playing out enqueued buffers.
            timeout after four times the stream latency.

            @todo should use a better time out value - if the user buffer
            length is longer than the asio buffer size then that should
            be taken into account.
        */
        if( WaitForSingleObject( stream->completedBuffersPlayedEvent,
                (DWORD)(stream->streamRepresentation.streamInfo.outputLatency * 1000. * 4.) )
                    == WAIT_TIMEOUT )
        {
            PA_DEBUG(("WaitForSingleObject() timed out in StopStream()\n" ));
        }
    }

    asioError = ASIOStop();
    if( asioError == ASE_OK )
    {
        EnsureCallbackHasCompleted( stream );
    }
    else
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
    }

    stream->isStopped = 1;
    stream->isActive = 0;

    if( !stream->streamFinishedCallbackCalled )
    {
        if( stream->streamRepresentation.streamFinishedCallback != 0 )
            stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
    }

    return result;
}

static PaError AbortStream( PaStream *s )
{
    PaError result = paNoError;
    PaAsioStream *stream = (PaAsioStream*)s;
    ASIOError asioError;

    stream->zeroOutput = true;

    asioError = ASIOStop();
    if( asioError == ASE_OK )
    {
        EnsureCallbackHasCompleted( stream );
    }
    else
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
    }

    stream->isStopped = 1;
    stream->isActive = 0;

    if( !stream->streamFinishedCallbackCalled )
    {
        if( stream->streamRepresentation.streamFinishedCallback != 0 )
            stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
    }

    return result;
}


static PaError IsStreamStopped( PaStream *s )
{
    PaAsioStream *stream = (PaAsioStream*)s;
    
    return stream->isStopped;
}


static PaError IsStreamActive( PaStream *s )
{
    PaAsioStream *stream = (PaAsioStream*)s;

    return stream->isActive;
}


static PaTime GetStreamTime( PaStream *s )
{
    (void) s; /* unused parameter */

    return (double)timeGetTime() * .001;
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaAsioStream *stream = (PaAsioStream*)s;

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}


/*
    As separate stream interfaces are used for blocking and callback
    streams, the following functions can be guaranteed to only be called
    for blocking streams.
*/

static PaError ReadStream( PaStream      *s     ,
                           void          *buffer,
                           unsigned long  frames )
{
    PaError result = paNoError; /* Initial return value. */
    PaAsioStream *stream = (PaAsioStream*)s; /* The PA ASIO stream. */

    /* Pointer to the blocking i/o data struct. */
    PaAsioStreamBlockingState *blockingState = stream->blockingState;

    /* Get blocking i/o buffer processor and ring buffer pointers. */
    PaUtilBufferProcessor *pBp = &blockingState->bufferProcessor;
    PaUtilRingBuffer      *pRb = &blockingState->readRingBuffer;

    /* Ring buffer segment(s) used for writing. */
    void *pRingBufferData1st = NULL; /* First segment. (Mandatory) */
    void *pRingBufferData2nd = NULL; /* Second segment. (Optional) */

    /* Number of frames per ring buffer segment. */
    long lRingBufferSize1st = 0; /* First segment. (Mandatory) */
    long lRingBufferSize2nd = 0; /* Second segment. (Optional) */

    /* Get number of frames to be processed per data block. */
    unsigned long lFramesPerBlock = stream->bufferProcessor.framesPerUserBuffer;
    /* Actual number of frames that has been copied into the ring buffer. */
    unsigned long lFramesCopied = 0;
    /* The number of remaining unprocessed dtat frames. */
    unsigned long lFramesRemaining = frames;

    /* Copy the input argument to avoid pointer increment! */
    const void *userBuffer;
    unsigned int i; /* Just a counter. */

    /* About the time, needed to process 8 data blocks. */
    DWORD timeout = (DWORD)( 8 * lFramesPerBlock * 1000 / stream->streamRepresentation.streamInfo.sampleRate );
    DWORD waitResult = 0;


    /* Check if the stream is still available ready to gather new data. */
    if( blockingState->stopFlag || !stream->isActive )
    {
        PA_DEBUG(("Warning! Stream no longer available for reading in ReadStream()\n"));
        result = paStreamIsStopped;
        return result;
    }

    /* If the stream is a input stream. */
    if( stream->inputChannelCount )
    {
        /* Prepare buffer access. */
        if( !pBp->userOutputIsInterleaved )
        {
            userBuffer = blockingState->readStreamBuffer;
            for( i = 0; i<pBp->inputChannelCount; ++i )
            {
                ((void**)userBuffer)[i] = ((void**)buffer)[i];
            }
        } /* Use the unchanged buffer. */
        else { userBuffer = buffer; }

        do /* Internal block processing for too large user data buffers. */
        {
            /* Get the size of the current data block to be processed. */
            lFramesPerBlock =(lFramesPerBlock < lFramesRemaining)
                            ? lFramesPerBlock : lFramesRemaining;
            /* Use predefined block size for as long there are enough
               buffers available, thereafter reduce the processing block
               size to match the number of remaining buffers. So the final
               data block is processed although it may be incomplete. */

            /* If the available amount of data frames is insufficient. */
            if( PaUtil_GetRingBufferReadAvailable(pRb) < (long) lFramesPerBlock )
            {
                /* Make sure, the event isn't already set! */
                /* ResetEvent( blockingState->readFramesReadyEvent ); */

                /* Set the number of requested buffers. */
                blockingState->readFramesRequested = lFramesPerBlock;

                /* Signalize that additional buffers are need. */
                blockingState->readFramesRequestedFlag = TRUE;

                /* Wait until requested number of buffers has been freed. */
                waitResult = WaitForSingleObject( blockingState->readFramesReadyEvent, timeout );

                /* If something seriously went wrong... */
                if( waitResult == WAIT_FAILED )
                {
                    PA_DEBUG(("WaitForSingleObject() failed in ReadStream()\n"));
                    result = paUnanticipatedHostError;
                    PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
                    return result;
                }
                else if( waitResult == WAIT_TIMEOUT )
                {
                    PA_DEBUG(("WaitForSingleObject() timed out in ReadStream()\n"));

                    /* If block processing has stopped, abort! */
                    if( blockingState->stopFlag ) { return result = paStreamIsStopped; }

                    /* If a timeout is encountered, give up eventually. */
                    return result = paTimedOut;
                }
            }
            /* Now, the ring buffer contains the required amount of data
               frames.
               (Therefor we don't need to check the return argument of
               PaUtil_GetRingBufferReadRegions(). ;-) )
            */

            /* Retrieve pointer(s) to the ring buffer's current write
               position(s). If the first buffer segment is too small to
               store the requested number of bytes, an additional second
               segment is returned. Otherwise, i.e. if the first segment
               is large enough, the second segment's pointer will be NULL.
            */
            PaUtil_GetRingBufferReadRegions(pRb                ,
                                            lFramesPerBlock    ,
                                            &pRingBufferData1st,
                                            &lRingBufferSize1st,
                                            &pRingBufferData2nd,
                                            &lRingBufferSize2nd);

            /* Set number of frames to be copied from the ring buffer. */
            PaUtil_SetInputFrameCount( pBp, lRingBufferSize1st ); 
            /* Setup ring buffer access. */
            PaUtil_SetInterleavedInputChannels(pBp               ,  /* Buffer processor. */
                                               0                 ,  /* The first channel's index. */
                                               pRingBufferData1st,  /* First ring buffer segment. */
                                               0                 ); /* Use all available channels. */

            /* If a second ring buffer segment is required. */
            if( lRingBufferSize2nd ) {
                /* Set number of frames to be copied from the ring buffer. */
                PaUtil_Set2ndInputFrameCount( pBp, lRingBufferSize2nd );
                /* Setup ring buffer access. */
                PaUtil_Set2ndInterleavedInputChannels(pBp               ,  /* Buffer processor. */
                                                      0                 ,  /* The first channel's index. */
                                                      pRingBufferData2nd,  /* Second ring buffer segment. */
                                                      0                 ); /* Use all available channels. */
            }

            /* Let the buffer processor handle "copy and conversion" and
               update the ring buffer indices manually. */
            lFramesCopied = PaUtil_CopyInput( pBp, &buffer, lFramesPerBlock );
            PaUtil_AdvanceRingBufferReadIndex( pRb, lFramesCopied );

            /* Decrease number of unprocessed frames. */
            lFramesRemaining -= lFramesCopied;

        } /* Continue with the next data chunk. */
        while( lFramesRemaining );


        /* If there has been an input overflow within the callback */
        if( blockingState->inputOverflowFlag )
        {
            blockingState->inputOverflowFlag = FALSE;

            /* Return the corresponding error code. */
            result = paInputOverflowed;
        }

    } /* If this is not an input stream. */
    else {
        result = paCanNotReadFromAnOutputOnlyStream;
    }

    return result;
}

static PaError WriteStream( PaStream      *s     ,
                            const void    *buffer,
                            unsigned long  frames )
{
    PaError result = paNoError; /* Initial return value. */
    PaAsioStream *stream = (PaAsioStream*)s; /* The PA ASIO stream. */

    /* Pointer to the blocking i/o data struct. */
    PaAsioStreamBlockingState *blockingState = stream->blockingState;

    /* Get blocking i/o buffer processor and ring buffer pointers. */
    PaUtilBufferProcessor *pBp = &blockingState->bufferProcessor;
    PaUtilRingBuffer      *pRb = &blockingState->writeRingBuffer;

    /* Ring buffer segment(s) used for writing. */
    void *pRingBufferData1st = NULL; /* First segment. (Mandatory) */
    void *pRingBufferData2nd = NULL; /* Second segment. (Optional) */

    /* Number of frames per ring buffer segment. */
    long lRingBufferSize1st = 0; /* First segment. (Mandatory) */
    long lRingBufferSize2nd = 0; /* Second segment. (Optional) */

    /* Get number of frames to be processed per data block. */
    unsigned long lFramesPerBlock = stream->bufferProcessor.framesPerUserBuffer;
    /* Actual number of frames that has been copied into the ring buffer. */
    unsigned long lFramesCopied = 0;
    /* The number of remaining unprocessed dtat frames. */
    unsigned long lFramesRemaining = frames;

    /* About the time, needed to process 8 data blocks. */
    DWORD timeout = (DWORD)( 8 * lFramesPerBlock * 1000 / stream->streamRepresentation.streamInfo.sampleRate );
    DWORD waitResult = 0;

    /* Copy the input argument to avoid pointer increment! */
    const void *userBuffer;
    unsigned int i; /* Just a counter. */


    /* Check if the stream ist still available ready to recieve new data. */
    if( blockingState->stopFlag || !stream->isActive )
    {
        PA_DEBUG(("Warning! Stream no longer available for writing in WriteStream()\n"));
        result = paStreamIsStopped;
        return result;
    }

    /* If the stream is a output stream. */
    if( stream->outputChannelCount )
    {
        /* Prepare buffer access. */
        if( !pBp->userOutputIsInterleaved )
        {
            userBuffer = blockingState->writeStreamBuffer;
            for( i = 0; i<pBp->outputChannelCount; ++i )
            {
                ((const void**)userBuffer)[i] = ((const void**)buffer)[i];
            }
        } /* Use the unchanged buffer. */
        else { userBuffer = buffer; }


        do /* Internal block processing for too large user data buffers. */
        {
            /* Get the size of the current data block to be processed. */
            lFramesPerBlock =(lFramesPerBlock < lFramesRemaining)
                            ? lFramesPerBlock : lFramesRemaining;
            /* Use predefined block size for as long there are enough
               frames available, thereafter reduce the processing block
               size to match the number of remaining frames. So the final
               data block is processed although it may be incomplete. */

            /* If the available amount of buffers is insufficient. */
            if( PaUtil_GetRingBufferWriteAvailable(pRb) < (long) lFramesPerBlock )
            {
                /* Make sure, the event isn't already set! */
                /* ResetEvent( blockingState->writeBuffersReadyEvent ); */

                /* Set the number of requested buffers. */
                blockingState->writeBuffersRequested = lFramesPerBlock;

                /* Signalize that additional buffers are need. */
                blockingState->writeBuffersRequestedFlag = TRUE;

                /* Wait until requested number of buffers has been freed. */
                waitResult = WaitForSingleObject( blockingState->writeBuffersReadyEvent, timeout );

                /* If something seriously went wrong... */
                if( waitResult == WAIT_FAILED )
                {
                    PA_DEBUG(("WaitForSingleObject() failed in WriteStream()\n"));
                    result = paUnanticipatedHostError;
                    PA_ASIO_SET_LAST_SYSTEM_ERROR( GetLastError() );
                    return result;
                }
                else if( waitResult == WAIT_TIMEOUT )
                {
                    PA_DEBUG(("WaitForSingleObject() timed out in WriteStream()\n"));

                    /* If block processing has stopped, abort! */
                    if( blockingState->stopFlag ) { return result = paStreamIsStopped; }
                    
                    /* If a timeout is encountered, give up eventually. */
                    return result = paTimedOut;
                }
            }
            /* Now, the ring buffer contains the required amount of free
               space to store the provided number of data frames.
               (Therefor we don't need to check the return argument of
               PaUtil_GetRingBufferWriteRegions(). ;-) )
            */

            /* Retrieve pointer(s) to the ring buffer's current write
               position(s). If the first buffer segment is too small to
               store the requested number of bytes, an additional second
               segment is returned. Otherwise, i.e. if the first segment
               is large enough, the second segment's pointer will be NULL.
            */
            PaUtil_GetRingBufferWriteRegions(pRb                ,
                                             lFramesPerBlock    ,
                                             &pRingBufferData1st,
                                             &lRingBufferSize1st,
                                             &pRingBufferData2nd,
                                             &lRingBufferSize2nd);

            /* Set number of frames to be copied to the ring buffer. */
            PaUtil_SetOutputFrameCount( pBp, lRingBufferSize1st ); 
            /* Setup ring buffer access. */
            PaUtil_SetInterleavedOutputChannels(pBp               ,  /* Buffer processor. */
                                                0                 ,  /* The first channel's index. */
                                                pRingBufferData1st,  /* First ring buffer segment. */
                                                0                 ); /* Use all available channels. */

            /* If a second ring buffer segment is required. */
            if( lRingBufferSize2nd ) {
                /* Set number of frames to be copied to the ring buffer. */
                PaUtil_Set2ndOutputFrameCount( pBp, lRingBufferSize2nd );
                /* Setup ring buffer access. */
                PaUtil_Set2ndInterleavedOutputChannels(pBp               ,  /* Buffer processor. */
                                                       0                 ,  /* The first channel's index. */
                                                       pRingBufferData2nd,  /* Second ring buffer segment. */
                                                       0                 ); /* Use all available channels. */
            }

            /* Let the buffer processor handle "copy and conversion" and
               update the ring buffer indices manually. */
            lFramesCopied = PaUtil_CopyOutput( pBp, &userBuffer, lFramesPerBlock );
            PaUtil_AdvanceRingBufferWriteIndex( pRb, lFramesCopied );

            /* Decrease number of unprocessed frames. */
            lFramesRemaining -= lFramesCopied;

        } /* Continue with the next data chunk. */
        while( lFramesRemaining );


        /* If there has been an output underflow within the callback */
        if( blockingState->outputUnderflowFlag )
        {
            blockingState->outputUnderflowFlag = FALSE;

            /* Return the corresponding error code. */
            result = paOutputUnderflowed;
        }

    } /* If this is not an output stream. */
    else
    {
        result = paCanNotWriteToAnInputOnlyStream;
    }

    return result;
}


static signed long GetStreamReadAvailable( PaStream* s )
{
    PaAsioStream *stream = (PaAsioStream*)s;

    /* Call buffer utility routine to get the number of available frames. */
    return PaUtil_GetRingBufferReadAvailable( &stream->blockingState->readRingBuffer );
}


static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaAsioStream *stream = (PaAsioStream*)s;

    /* Call buffer utility routine to get the number of empty buffers. */
    return PaUtil_GetRingBufferWriteAvailable( &stream->blockingState->writeRingBuffer );
}


/* This routine will be called by the PortAudio engine when audio is needed.
** It may called at interrupt level on some machines so don't do anything
** that could mess up the system like calling malloc() or free().
*/
static int BlockingIoPaCallback(const void                     *inputBuffer    ,
                                      void                     *outputBuffer   ,
                                      unsigned long             framesPerBuffer,
                                const PaStreamCallbackTimeInfo *timeInfo       ,
                                      PaStreamCallbackFlags     statusFlags    ,
                                      void                     *userData       )
{
    PaError result = paNoError; /* Initial return value. */
    PaAsioStream *stream = *(PaAsioStream**)userData; /* The PA ASIO stream. */
    PaAsioStreamBlockingState *blockingState = stream->blockingState; /* Persume blockingState is valid, otherwise the callback wouldn't be running. */

    /* Get a pointer to the stream's blocking i/o buffer processor. */
    PaUtilBufferProcessor *pBp = &blockingState->bufferProcessor;
    PaUtilRingBuffer      *pRb = NULL;

    /* If output data has been requested. */
    if( stream->outputChannelCount )
    {
        /* If the callback input argument signalizes a output underflow,
           make sure the WriteStream() function knows about it, too! */
        if( statusFlags & paOutputUnderflowed ) {
            blockingState->outputUnderflowFlag = TRUE;
        }

        /* Access the corresponding ring buffer. */
        pRb = &blockingState->writeRingBuffer;

        /* If the blocking i/o buffer contains enough output data, */
        if( PaUtil_GetRingBufferReadAvailable(pRb) >= (long) framesPerBuffer )
        {
            /* Extract the requested data from the ring buffer. */
            PaUtil_ReadRingBuffer( pRb, outputBuffer, framesPerBuffer );
        }
        else /* If no output data is available :-( */
        {
            /* Signalize a write-buffer underflow. */
            blockingState->outputUnderflowFlag = TRUE;

            /* Fill the output buffer with silence. */
            (*pBp->outputZeroer)( outputBuffer, 1, pBp->outputChannelCount * framesPerBuffer );

            /* If playback is to be stopped */
            if( blockingState->stopFlag && PaUtil_GetRingBufferReadAvailable(pRb) < (long) framesPerBuffer )
            {
                /* Extract all the remaining data from the ring buffer,
                   whether it is a complete data block or not. */
                PaUtil_ReadRingBuffer( pRb, outputBuffer, PaUtil_GetRingBufferReadAvailable(pRb) );
            }
        }

        /* Set blocking i/o event? */
        if( blockingState->writeBuffersRequestedFlag && PaUtil_GetRingBufferWriteAvailable(pRb) >= (long) blockingState->writeBuffersRequested )
        {
            /* Reset buffer request. */
            blockingState->writeBuffersRequestedFlag = FALSE;
            blockingState->writeBuffersRequested     = 0;
            /* Signalize that requested buffers are ready. */
            SetEvent( blockingState->writeBuffersReadyEvent );
            /* What do we do if SetEvent() returns zero, i.e. the event
               could not be set? How to return errors from within the
               callback? - S.Fischer */
        }
    }

    /* If input data has been supplied. */
    if( stream->inputChannelCount )
    {
        /* If the callback input argument signalizes a input overflow,
           make sure the ReadStream() function knows about it, too! */
        if( statusFlags & paInputOverflowed ) {
            blockingState->inputOverflowFlag = TRUE;
        }

        /* Access the corresponding ring buffer. */
        pRb = &blockingState->readRingBuffer;

        /* If the blocking i/o buffer contains not enough input buffers */
        if( PaUtil_GetRingBufferWriteAvailable(pRb) < (long) framesPerBuffer )
        {
            /* Signalize a read-buffer overflow. */
            blockingState->inputOverflowFlag = TRUE;

            /* Remove some old data frames from the buffer. */
            PaUtil_AdvanceRingBufferReadIndex( pRb, framesPerBuffer );
        }

        /* Insert the current input data into the ring buffer. */
        PaUtil_WriteRingBuffer( pRb, inputBuffer, framesPerBuffer );

        /* Set blocking i/o event? */
        if( blockingState->readFramesRequestedFlag && PaUtil_GetRingBufferReadAvailable(pRb) >= (long) blockingState->readFramesRequested )
        {
            /* Reset buffer request. */
            blockingState->readFramesRequestedFlag = FALSE;
            blockingState->readFramesRequested     = 0;
            /* Signalize that requested buffers are ready. */
            SetEvent( blockingState->readFramesReadyEvent );
            /* What do we do if SetEvent() returns zero, i.e. the event
               could not be set? How to return errors from within the
               callback? - S.Fischer */
            /** @todo report an error with PA_DEBUG */
        }
    }

    return paContinue;
}


PaError PaAsio_ShowControlPanel( PaDeviceIndex device, void* systemSpecific )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *hostApi;
    PaDeviceIndex hostApiDevice;
    ASIODriverInfo asioDriverInfo;
    ASIOError asioError;
    int asioIsInitialized = 0;
    PaAsioHostApiRepresentation *asioHostApi;
    PaAsioDeviceInfo *asioDeviceInfo;
    PaWinUtilComInitializationResult comInitializationResult;

    /* initialize COM again here, we might be in another thread */
    result = PaWinUtil_CoInitialize( paASIO, &comInitializationResult );
    if( result != paNoError )
        return result;

    result = PaUtil_GetHostApiRepresentation( &hostApi, paASIO );
    if( result != paNoError )
        goto error;

    result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDevice, device, hostApi );
    if( result != paNoError )
        goto error;

    /*
        In theory we could proceed if the currently open device was the same
        one for which the control panel was requested, however  because the
        window pointer is not available until this function is called we
        currently need to call ASIOInit() again here, which of course can't be
        done safely while a stream is open.
    */

    asioHostApi = (PaAsioHostApiRepresentation*)hostApi;
    if( asioHostApi->openAsioDeviceIndex != paNoDevice )
    {
        result = paDeviceUnavailable;
        goto error;
    }

    asioDeviceInfo = (PaAsioDeviceInfo*)hostApi->deviceInfos[hostApiDevice];

    if( !asioHostApi->asioDrivers->loadDriver( const_cast<char*>(asioDeviceInfo->commonDeviceInfo.name) ) )
    {
        result = paUnanticipatedHostError;
        goto error;
    }

    /* CRUCIAL!!! */
    memset( &asioDriverInfo, 0, sizeof(ASIODriverInfo) );
    asioDriverInfo.asioVersion = 2;
    asioDriverInfo.sysRef = systemSpecific;
    asioError = ASIOInit( &asioDriverInfo );
    if( asioError != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        goto error;
    }
    else
    {
        asioIsInitialized = 1;
    }

PA_DEBUG(("PaAsio_ShowControlPanel: ASIOInit(): %s\n", PaAsio_GetAsioErrorText(asioError) ));
PA_DEBUG(("asioVersion: ASIOInit(): %ld\n",   asioDriverInfo.asioVersion )); 
PA_DEBUG(("driverVersion: ASIOInit(): %ld\n", asioDriverInfo.driverVersion )); 
PA_DEBUG(("Name: ASIOInit(): %s\n",           asioDriverInfo.name )); 
PA_DEBUG(("ErrorMessage: ASIOInit(): %s\n",   asioDriverInfo.errorMessage )); 

    asioError = ASIOControlPanel();
    if( asioError != ASE_OK )
    {
        PA_DEBUG(("PaAsio_ShowControlPanel: ASIOControlPanel(): %s\n", PaAsio_GetAsioErrorText(asioError) ));
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        goto error;
    }

PA_DEBUG(("PaAsio_ShowControlPanel: ASIOControlPanel(): %s\n", PaAsio_GetAsioErrorText(asioError) ));

    asioError = ASIOExit();
    if( asioError != ASE_OK )
    {
        result = paUnanticipatedHostError;
        PA_ASIO_SET_LAST_ASIO_ERROR( asioError );
        asioIsInitialized = 0;
        goto error;
    }

PA_DEBUG(("PaAsio_ShowControlPanel: ASIOExit(): %s\n", PaAsio_GetAsioErrorText(asioError) ));

    return result;

error:
    if( asioIsInitialized )
	{
		ASIOExit();
	}

    PaWinUtil_CoUninitialize( paASIO, &comInitializationResult );

    return result;
}


PaError PaAsio_GetInputChannelName( PaDeviceIndex device, int channelIndex,
        const char** channelName )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *hostApi;
    PaDeviceIndex hostApiDevice;
    PaAsioDeviceInfo *asioDeviceInfo;


    result = PaUtil_GetHostApiRepresentation( &hostApi, paASIO );
    if( result != paNoError )
        goto error;

    result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDevice, device, hostApi );
    if( result != paNoError )
        goto error;

    asioDeviceInfo = (PaAsioDeviceInfo*)hostApi->deviceInfos[hostApiDevice];

    if( channelIndex < 0 || channelIndex >= asioDeviceInfo->commonDeviceInfo.maxInputChannels ){
        result = paInvalidChannelCount;
        goto error;
    }

    *channelName = asioDeviceInfo->asioChannelInfos[channelIndex].name;

    return paNoError;
    
error:
    return result;
}


PaError PaAsio_GetOutputChannelName( PaDeviceIndex device, int channelIndex,
        const char** channelName )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *hostApi;
    PaDeviceIndex hostApiDevice;
    PaAsioDeviceInfo *asioDeviceInfo;


    result = PaUtil_GetHostApiRepresentation( &hostApi, paASIO );
    if( result != paNoError )
        goto error;

    result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDevice, device, hostApi );
    if( result != paNoError )
        goto error;

    asioDeviceInfo = (PaAsioDeviceInfo*)hostApi->deviceInfos[hostApiDevice];

    if( channelIndex < 0 || channelIndex >= asioDeviceInfo->commonDeviceInfo.maxOutputChannels ){
        result = paInvalidChannelCount;
        goto error;
    }

    *channelName = asioDeviceInfo->asioChannelInfos[
            asioDeviceInfo->commonDeviceInfo.maxInputChannels + channelIndex].name;

    return paNoError;
    
error:
    return result;
}


/* NOTE: the following functions are ASIO-stream specific, and are called directly
    by client code. We need to check for many more error conditions here because
    we don't have the benefit of pa_front.c's parameter checking.
*/

static PaError GetAsioStreamPointer( PaAsioStream **stream, PaStream *s )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi;
    PaAsioHostApiRepresentation *asioHostApi;
    
    result = PaUtil_ValidateStreamPointer( s );
    if( result != paNoError )
        return result;

    result = PaUtil_GetHostApiRepresentation( &hostApi, paASIO );
    if( result != paNoError )
        return result;

    asioHostApi = (PaAsioHostApiRepresentation*)hostApi;
    
    if( PA_STREAM_REP( s )->streamInterface == &asioHostApi->callbackStreamInterface
            || PA_STREAM_REP( s )->streamInterface == &asioHostApi->blockingStreamInterface )
    {
        /* s is an ASIO  stream */
        *stream = (PaAsioStream *)s;
        return paNoError;
    }
    else
    {
        return paIncompatibleStreamHostApi;
    }
}


PaError PaAsio_SetStreamSampleRate( PaStream* s, double sampleRate )
{
    PaAsioStream *stream;
    PaError result = GetAsioStreamPointer( &stream, s );
    if( result != paNoError )
        return result;

    if( stream != theAsioStream )
        return paBadStreamPtr;

    return ValidateAndSetSampleRate( sampleRate );
}
#endif

#if PA_USE_COREAUDIO
/*
 * Internal blocking interfaces for PortAudio Apple AUHAL implementation
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#ifndef PA_MAC_CORE_BLOCKING_H_
#define PA_MAC_CORE_BLOCKING_H_

// (amalg) #include "pa_ringbuffer.h"
// (amalg) #include "portaudio.h"
// (amalg) #include "pa_mac_core_utilities.h"

/*
 * Number of milliseconds to busy wait while waiting for data in blocking calls.
 */
#define PA_MAC_BLIO_BUSY_WAIT_SLEEP_INTERVAL (5)
/*
 * Define exactly one of these blocking methods
 * PA_MAC_BLIO_MUTEX is not actively maintained.
 */
#define PA_MAC_BLIO_BUSY_WAIT
/*
#define PA_MAC_BLIO_MUTEX
*/

typedef struct {
    PaUtilRingBuffer inputRingBuffer;
    PaUtilRingBuffer outputRingBuffer;
    ring_buffer_size_t ringBufferFrames;
    PaSampleFormat inputSampleFormat;
    size_t inputSampleSizeActual;
    size_t inputSampleSizePow2;
    PaSampleFormat outputSampleFormat;
    size_t outputSampleSizeActual;
    size_t outputSampleSizePow2;

    int inChan;
    int outChan;

    //PaStreamCallbackFlags statusFlags;
    uint32_t statusFlags;
    PaError errors;

    /* Here we handle blocking, using condition variables. */
#ifdef  PA_MAC_BLIO_MUTEX
    volatile bool isInputEmpty;
    pthread_mutex_t inputMutex;
    pthread_cond_t inputCond;

    volatile bool isOutputFull;
    pthread_mutex_t outputMutex;
    pthread_cond_t outputCond;
#endif
}
PaMacBlio;

/*
 * These functions operate on condition and related variables.
 */

PaError initializeBlioRingBuffers(
                                       PaMacBlio *blio,
                                       PaSampleFormat inputSampleFormat,
                                       PaSampleFormat outputSampleFormat,
                                       long ringBufferSizeInFrames,
                                       int inChan,
                                       int outChan );
PaError destroyBlioRingBuffers( PaMacBlio *blio );
PaError resetBlioRingBuffers( PaMacBlio *blio );

int BlioCallback(
        const void *input, void *output,
        unsigned long frameCount,
        const PaStreamCallbackTimeInfo* timeInfo,
        PaStreamCallbackFlags statusFlags,
        void *userData );

PaError waitUntilBlioWriteBufferIsEmpty( PaMacBlio *blio, double sampleRate,
                                        size_t framesPerBuffer );

#endif /*PA_MAC_CORE_BLOCKING_H_*/
/*
 * Internal interfaces for PortAudio Apple AUHAL implementation
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file pa_mac_core
 @ingroup hostapi_src
 @author Bjorn Roche
 @brief AUHAL implementation of PortAudio
*/

#ifndef PA_MAC_CORE_INTERNAL_H__
#define PA_MAC_CORE_INTERNAL_H__

#include <CoreAudio/CoreAudio.h>
#include <CoreServices/CoreServices.h>
#include <AudioUnit/AudioUnit.h>
#include <AudioToolbox/AudioToolbox.h>

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_ringbuffer.h"

// (amalg) #include "pa_mac_core_blocking.h"

/* function prototypes */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */

#define RING_BUFFER_ADVANCE_DENOMINATOR (4)

PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
signed long GetStreamReadAvailable( PaStream* stream );
signed long GetStreamWriteAvailable( PaStream* stream );
/* PaMacAUHAL - host api datastructure specific to this implementation */
typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;

    /* implementation specific data goes here */
    long devCount;
    AudioDeviceID *devIds; /*array of all audio devices*/
    AudioDeviceID defaultIn;
    AudioDeviceID defaultOut;
}
PaMacAUHAL;

typedef struct PaMacCoreDeviceProperties
{
    /* Values in Frames from property queries. */
    UInt32 safetyOffset;
    UInt32 bufferFrameSize;
    // UInt32 streamLatency; // Seems to be the same as deviceLatency!?
    UInt32 deviceLatency;
    /* Current device sample rate. May change! 
       These are initialized to the nominal device sample rate, 
       and updated with the actual sample rate, when/where available. 
       Note that these are the *device* sample rates, prior to any required 
       SR conversion. */
    Float64 sampleRate;
    Float64 samplePeriod; // reciprocal
}
PaMacCoreDeviceProperties;

/* stream data structure specifically for this implementation */
typedef struct PaMacCoreStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

    /* implementation specific data goes here */
    bool bufferProcessorIsInitialized;
    AudioUnit inputUnit;
    AudioUnit outputUnit;
    AudioDeviceID inputDevice;
    AudioDeviceID outputDevice;
    size_t userInChan;
    size_t userOutChan;
    size_t inputFramesPerBuffer;
    size_t outputFramesPerBuffer;
    PaMacBlio blio;
    /* We use this ring buffer when input and out devs are different. */
    PaUtilRingBuffer inputRingBuffer;
    /* We may need to do SR conversion on input. */
    AudioConverterRef inputSRConverter;
    /* We need to preallocate an inputBuffer for reading data. */
    AudioBufferList inputAudioBufferList;
    AudioTimeStamp startTime;
    /* FIXME: instead of volatile, these should be properly memory barriered */
    volatile uint32_t xrunFlags; /*PaStreamCallbackFlags*/
    volatile enum {
       STOPPED          = 0, /* playback is completely stopped,
                                and the user has called StopStream(). */
       CALLBACK_STOPPED = 1, /* callback has requested stop,
                                but user has not yet called StopStream(). */
       STOPPING         = 2, /* The stream is in the process of closing
                                because the user has called StopStream.
                                This state is just used internally;
                                externally it is indistinguishable from
                                ACTIVE.*/
       ACTIVE           = 3  /* The stream is active and running. */
    } state;
    double sampleRate;
    PaMacCoreDeviceProperties  inputProperties;
    PaMacCoreDeviceProperties  outputProperties;
    
	/* data updated by main thread and notifications, protected by timingInformationMutex */
	int timingInformationMutexIsInitialized;
	pthread_mutex_t timingInformationMutex;

    /* These are written by the PA thread or from CoreAudio callbacks. Protected by the mutex. */
    Float64 timestampOffsetCombined;
    Float64 timestampOffsetInputDevice;
    Float64 timestampOffsetOutputDevice;
	
	/* Offsets in seconds to be applied to Apple timestamps to convert them to PA timestamps.
     * While the io proc is active, the following values are only accessed and manipulated by the ioproc */
    Float64 timestampOffsetCombined_ioProcCopy;
    Float64 timestampOffsetInputDevice_ioProcCopy;
    Float64 timestampOffsetOutputDevice_ioProcCopy;
    
}
PaMacCoreStream;

#endif /* PA_MAC_CORE_INTERNAL_H__ */
/*
 * Helper and utility functions for pa_mac_core.c (Apple AUHAL implementation)
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#ifndef PA_MAC_CORE_UTILITIES_H__
#define PA_MAC_CORE_UTILITIES_H__

#include <pthread.h>
// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
#include <AudioUnit/AudioUnit.h>
#include <AudioToolbox/AudioToolbox.h>

#ifndef MIN
#define MIN(a, b)  (((a)<(b))?(a):(b))
#endif

#ifndef MAX
#define MAX(a, b)  (((a)<(b))?(b):(a))
#endif

#define ERR(mac_error) PaMacCore_SetError(mac_error, __LINE__, 1 ) 
#define WARNING(mac_error) PaMacCore_SetError(mac_error, __LINE__, 0 )


/* Help keep track of AUHAL element numbers */
#define INPUT_ELEMENT  (1)
#define OUTPUT_ELEMENT (0)

/* Normal level of debugging: fine for most apps that don't mind the occational warning being printf'ed */
/*
 */
#define MAC_CORE_DEBUG
#ifdef MAC_CORE_DEBUG
# define DBUG(MSG) do { printf("||PaMacCore (AUHAL)|| "); printf MSG ; fflush(stdout); } while(0)
#else
# define DBUG(MSG)
#endif

/* Verbose Debugging: useful for developement */
/*
#define MAC_CORE_VERBOSE_DEBUG
*/
#ifdef MAC_CORE_VERBOSE_DEBUG
# define VDBUG(MSG) do { printf("||PaMacCore (v )|| "); printf MSG ; fflush(stdout); } while(0)
#else
# define VDBUG(MSG)
#endif

/* Very Verbose Debugging: Traces every call. */
/*
#define MAC_CORE_VERY_VERBOSE_DEBUG
 */
#ifdef MAC_CORE_VERY_VERBOSE_DEBUG
# define VVDBUG(MSG) do { printf("||PaMacCore (vv)|| "); printf MSG ; fflush(stdout); } while(0)
#else
# define VVDBUG(MSG)
#endif





#define UNIX_ERR(err) PaMacCore_SetUnixError( err, __LINE__ )

PaError PaMacCore_SetUnixError( int err, int line );

/*
 * Translates MacOS generated errors into PaErrors
 */
PaError PaMacCore_SetError(OSStatus error, int line, int isError);

/*
 * This function computes an appropriate ring buffer size given
 * a requested latency (in seconds), sample rate and framesPerBuffer.
 *
 * The returned ringBufferSize is computed using the following
 * constraints:
 *   - it must be at least 4.
 *   - it must be at least 3x framesPerBuffer.
 *   - it must be at least 2x the suggestedLatency.
 *   - it must be a power of 2.
 * This function attempts to compute the minimum such size.
 *
 */
long computeRingBufferSize( const PaStreamParameters *inputParameters,
                                   const PaStreamParameters *outputParameters,
                                   long inputFramesPerBuffer,
                                   long outputFramesPerBuffer,
                                   double sampleRate );

OSStatus propertyProc(
    AudioDeviceID inDevice, 
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID, 
    void* inClientData );

/* sets the value of the given property and waits for the change to 
   be acknowledged, and returns the final value, which is not guaranteed
   by this function to be the same as the desired value. Obviously, this
   function can only be used for data whose input and output are the
   same size and format, and their size and format are known in advance.*/
PaError AudioDeviceSetPropertyNowAndWaitForChange(
    AudioDeviceID inDevice,
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID,
    UInt32 inPropertyDataSize, 
    const void *inPropertyData,
    void *outPropertyData );

/*
 * Sets the sample rate the HAL device.
 * if requireExact: set the sample rate or fail.
 *
 * otherwise      : set the exact sample rate.
 *             If that fails, check for available sample rates, and choose one
 *             higher than the requested rate. If there isn't a higher one,
 *             just use the highest available.
 */
PaError setBestSampleRateForDevice( const AudioDeviceID device,
                                    const bool isOutput,
                                    const bool requireExact,
                                    const Float64 desiredSrate );
/*
   Attempts to set the requestedFramesPerBuffer. If it can't set the exact
   value, it settles for something smaller if available. If nothing smaller
   is available, it uses the smallest available size.
   actualFramesPerBuffer will be set to the actual value on successful return.
   OK to pass NULL to actualFramesPerBuffer.
   The logic is very simmilar too setBestSampleRate only failure here is
   not usually catastrophic.
*/
PaError setBestFramesPerBuffer( const AudioDeviceID device,
                                const bool isOutput,
                                UInt32 requestedFramesPerBuffer, 
                                UInt32 *actualFramesPerBuffer );


/*********************
 *
 *  xrun handling
 *
 *********************/

OSStatus xrunCallback(
    AudioDeviceID inDevice, 
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID, 
    void* inClientData ) ;

/** returns zero on success or a unix style error code. */
int initializeXRunListenerList();
/** returns zero on success or a unix style error code. */
int destroyXRunListenerList();

/**Returns the list, so that it can be passed to CorAudio.*/
void *addToXRunListenerList( void *stream );
/**Returns the number of Listeners in the list remaining.*/
int removeFromXRunListenerList( void *stream );

#endif /* PA_MAC_CORE_UTILITIES_H__*/
/*
 * Implementation of the PortAudio API for Apple AUHAL
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file pa_mac_core
 @ingroup hostapi_src
 @author Bjorn Roche
 @brief AUHAL implementation of PortAudio
*/

/* FIXME: not all error conditions call PaUtil_SetLastHostErrorInfo()
 * PaMacCore_SetError() will do this.
 */

// (amalg) #include "pa_mac_core_internal.h"

#include <string.h> /* strlen(), memcmp() etc. */
#include <libkern/OSAtomic.h>

// (amalg) #include "pa_mac_core.h"
// (amalg) #include "pa_mac_core_utilities.h"
// (amalg) #include "pa_mac_core_blocking.h"


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
	
/* This is a reasonable size for a small buffer based on experience. */
#define PA_MAC_SMALL_BUFFER_SIZE    (64)
	
/* prototypes for functions declared in this file */
PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

/*
 * Function declared in pa_mac_core.h. Sets up a PaMacCoreStreamInfoStruct
 * with the requested flags and initializes channel map.
 */
void PaMacCore_SetupStreamInfo(  PaMacCoreStreamInfo *data, const unsigned long flags )
{
   bzero( data, sizeof( PaMacCoreStreamInfo ) );
   data->size = sizeof( PaMacCoreStreamInfo );
   data->hostApiType = paCoreAudio;
   data->version = 0x01;
   data->flags = flags;
   data->channelMap = NULL;
   data->channelMapSize = 0;
}

/*
 * Function declared in pa_mac_core.h. Adds channel mapping to a PaMacCoreStreamInfoStruct
 */
void PaMacCore_SetupChannelMap( PaMacCoreStreamInfo *data, const SInt32 * const channelMap, const unsigned long channelMapSize )
{
   data->channelMap = channelMap;
   data->channelMapSize = channelMapSize;
}
static char *channelName = NULL;
static int channelNameSize = 0;
static bool ensureChannelNameSize( int size )
{
   if( size >= channelNameSize ) {
      free( channelName );
      channelName = (char *) malloc( ( channelNameSize = size ) + 1 );
      if( !channelName ) {
         channelNameSize = 0;
         return false;
      }
   }
   return true;
}
/*
 * Function declared in pa_mac_core.h. retrives channel names.
 */
const char *PaMacCore_GetChannelName( int device, int channelIndex, bool input )
{
	struct PaUtilHostApiRepresentation *hostApi;
	PaError err;
	OSStatus error;
	err = PaUtil_GetHostApiRepresentation( &hostApi, paCoreAudio );
	assert(err == paNoError);
	if( err != paNoError )
		return NULL;
	PaMacAUHAL *macCoreHostApi = (PaMacAUHAL*)hostApi;
	AudioDeviceID hostApiDevice = macCoreHostApi->devIds[device];
	CFStringRef nameRef;
	
	/* First try with CFString */
	UInt32 size = sizeof(nameRef);
	error = AudioDeviceGetProperty( hostApiDevice,
								   channelIndex + 1,
								   input,
								   kAudioDevicePropertyChannelNameCFString,
								   &size,
								   &nameRef );
	if( error )
	{
		/* try the C String */
		size = 0;
		error = AudioDeviceGetPropertyInfo( hostApiDevice,
										   channelIndex + 1,
										   input,
										   kAudioDevicePropertyChannelName,
										   &size,
										   NULL);
		if( !error )
		{
			if( !ensureChannelNameSize( size ) )
				return NULL;
			
			error = AudioDeviceGetProperty( hostApiDevice,
										   channelIndex + 1,
										   input,
										   kAudioDevicePropertyChannelName,
										   &size,
										   channelName );
			
			
			if( !error )
				return channelName;
		}
		
		/* as a last-ditch effort, we use the device name and append the channel number. */
		nameRef = CFStringCreateWithFormat( NULL, NULL, CFSTR( "%s: %d"), hostApi->deviceInfos[device]->name, channelIndex + 1 );
		
		
		size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(nameRef), kCFStringEncodingUTF8);;
		if( !ensureChannelNameSize( size ) )
		{
			CFRelease( nameRef );
			return NULL;
		}
		CFStringGetCString( nameRef, channelName, size+1, kCFStringEncodingUTF8 );
		CFRelease( nameRef );
	}
	else
	{
		size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(nameRef), kCFStringEncodingUTF8);;
		if( !ensureChannelNameSize( size ) )
		{
			CFRelease( nameRef );
			return NULL;
		}
		CFStringGetCString( nameRef, channelName, size+1, kCFStringEncodingUTF8 );
		CFRelease( nameRef );
	}
	
	return channelName;
}

    
PaError PaMacCore_GetBufferSizeRange( PaDeviceIndex device,
                                      long *minBufferSizeFrames, long *maxBufferSizeFrames )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi;
    
    result = PaUtil_GetHostApiRepresentation( &hostApi, paCoreAudio );
    
    if( result == paNoError )
    {
        PaDeviceIndex hostApiDeviceIndex;
        result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDeviceIndex, device, hostApi );
        if( result == paNoError )
        {
            PaMacAUHAL *macCoreHostApi = (PaMacAUHAL*)hostApi;
            AudioDeviceID macCoreDeviceId = macCoreHostApi->devIds[hostApiDeviceIndex];
            AudioValueRange audioRange;
            UInt32 propSize = sizeof( audioRange );
            
            // return the size range for the output scope unless we only have inputs
            Boolean isInput = 0;
            if( macCoreHostApi->inheritedHostApiRep.deviceInfos[hostApiDeviceIndex]->maxOutputChannels == 0 )
                isInput = 1;
           
            result = WARNING(AudioDeviceGetProperty( macCoreDeviceId, 0, isInput, kAudioDevicePropertyBufferFrameSizeRange, &propSize, &audioRange ) );

            *minBufferSizeFrames = audioRange.mMinimum;
            *maxBufferSizeFrames = audioRange.mMaximum;
        }
    }
    
    return result;
}


AudioDeviceID PaMacCore_GetStreamInputDevice( PaStream* s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("PaMacCore_GetStreamInputHandle()\n"));

    return ( stream->inputDevice );
}

AudioDeviceID PaMacCore_GetStreamOutputDevice( PaStream* s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("PaMacCore_GetStreamOutputHandle()\n"));

    return ( stream->outputDevice );
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#define RING_BUFFER_ADVANCE_DENOMINATOR (4)

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static OSStatus AudioIOProc( void *inRefCon,
                               AudioUnitRenderActionFlags *ioActionFlags,
                               const AudioTimeStamp *inTimeStamp,
                               UInt32 inBusNumber,
                               UInt32 inNumberFrames,
                               AudioBufferList *ioData );
static double GetStreamCpuLoad( PaStream* stream );

static PaError GetChannelInfo( PaMacAUHAL *auhalHostApi,
                               PaDeviceInfo *deviceInfo,
                               AudioDeviceID macCoreDeviceId,
                               int isInput);

static PaError OpenAndSetupOneAudioUnit(
                                   const PaMacCoreStream *stream,
                                   const PaStreamParameters *inStreamParams,
                                   const PaStreamParameters *outStreamParams,
                                   const UInt32 requestedFramesPerBuffer,
                                   UInt32 *actualInputFramesPerBuffer,
                                   UInt32 *actualOutputFramesPerBuffer,
                                   const PaMacAUHAL *auhalHostApi,
                                   AudioUnit *audioUnit,
                                   AudioConverterRef *srConverter,
                                   AudioDeviceID *audioDevice,
                                   const double sampleRate,
                                   void *refCon );

/* for setting errors. */
#define PA_AUHAL_SET_LAST_HOST_ERROR( errorCode, errorText ) \
    PaUtil_SetLastHostErrorInfo( paCoreAudio, errorCode, errorText )

/*
 * Callback called when starting or stopping a stream.
 */
static void startStopCallback(
   void *               inRefCon,
   AudioUnit            ci,
   AudioUnitPropertyID  inID,
   AudioUnitScope       inScope,
   AudioUnitElement     inElement )
{
   PaMacCoreStream *stream = (PaMacCoreStream *) inRefCon;
   UInt32 isRunning;
   UInt32 size = sizeof( isRunning );
   OSStatus err;
   err = AudioUnitGetProperty( ci, kAudioOutputUnitProperty_IsRunning, inScope, inElement, &isRunning, &size );
   assert( !err );
   if( err )
      isRunning = false; //it's very unclear what to do in case of error here. There's no real way to notify the user, and crashing seems unreasonable.
   if( isRunning )
      return; //We are only interested in when we are stopping
   // -- if we are using 2 I/O units, we only need one notification!
   if( stream->inputUnit && stream->outputUnit && stream->inputUnit != stream->outputUnit && ci == stream->inputUnit )
      return;
   PaStreamFinishedCallback *sfc = stream->streamRepresentation.streamFinishedCallback;
   if( stream->state == STOPPING )
      stream->state = STOPPED ;
   if( sfc )
      sfc( stream->streamRepresentation.userData );
}


/*currently, this is only used in initialization, but it might be modified
  to be used when the list of devices changes.*/
static PaError gatherDeviceInfo(PaMacAUHAL *auhalHostApi)
{
    UInt32 size;
    UInt32 propsize;
    VVDBUG(("gatherDeviceInfo()\n"));
    /* -- free any previous allocations -- */
    if( auhalHostApi->devIds )
        PaUtil_GroupFreeMemory(auhalHostApi->allocations, auhalHostApi->devIds);
    auhalHostApi->devIds = NULL;

    /* -- figure out how many devices there are -- */
    AudioHardwareGetPropertyInfo( kAudioHardwarePropertyDevices,
                                  &propsize,
                                  NULL );
    auhalHostApi->devCount = propsize / sizeof( AudioDeviceID );

    VDBUG( ( "Found %ld device(s).\n", auhalHostApi->devCount ) );

    /* -- copy the device IDs -- */
    auhalHostApi->devIds = (AudioDeviceID *)PaUtil_GroupAllocateMemory(
                             auhalHostApi->allocations,
                             propsize );
    if( !auhalHostApi->devIds )
        return paInsufficientMemory;
    AudioHardwareGetProperty( kAudioHardwarePropertyDevices,
                                  &propsize,
                                  auhalHostApi->devIds );
#ifdef MAC_CORE_VERBOSE_DEBUG
    {
       int i;
       for( i=0; i<auhalHostApi->devCount; ++i )
          printf( "Device %d\t: %ld\n", i, auhalHostApi->devIds[i] );
    }
#endif

    size = sizeof(AudioDeviceID);
    auhalHostApi->defaultIn  = kAudioDeviceUnknown;
    auhalHostApi->defaultOut = kAudioDeviceUnknown;

    /* determine the default device. */
    /* I am not sure how these calls to AudioHardwareGetProperty()
       could fail, but in case they do, we use the first available
       device as the default. */
    if( 0 != AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
                     &size,
                     &auhalHostApi->defaultIn) ) {
       int i;
       auhalHostApi->defaultIn  = kAudioDeviceUnknown;
       VDBUG(("Failed to get default input device from OS."));
       VDBUG((" I will substitute the first available input Device."));
       for( i=0; i<auhalHostApi->devCount; ++i ) {
          PaDeviceInfo devInfo;
          if( 0 != GetChannelInfo( auhalHostApi, &devInfo,
                                   auhalHostApi->devIds[i], TRUE ) )
             if( devInfo.maxInputChannels ) {
                auhalHostApi->defaultIn = auhalHostApi->devIds[i];
                break;
             }
       }
    }   
    if( 0 != AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
                     &size,
                     &auhalHostApi->defaultOut) ) {
       int i;
       auhalHostApi->defaultIn  = kAudioDeviceUnknown;
       VDBUG(("Failed to get default output device from OS."));
       VDBUG((" I will substitute the first available output Device."));
       for( i=0; i<auhalHostApi->devCount; ++i ) {
          PaDeviceInfo devInfo;
          if( 0 != GetChannelInfo( auhalHostApi, &devInfo,
                                   auhalHostApi->devIds[i], FALSE ) )
             if( devInfo.maxOutputChannels ) {
                auhalHostApi->defaultOut = auhalHostApi->devIds[i];
                break;
             }
       }
    }   

    VDBUG( ( "Default in : %ld\n", auhalHostApi->defaultIn  ) );
    VDBUG( ( "Default out: %ld\n", auhalHostApi->defaultOut ) );

    return paNoError;
}

/* =================================================================================================== */
/**
 * @internal
 * @brief Clip the desired size against the allowed IO buffer size range for the device.
 */
static PaError ClipToDeviceBufferSize( AudioDeviceID macCoreDeviceId,
									int isInput, UInt32 desiredSize, UInt32 *allowedSize )
{
	UInt32 resultSize = desiredSize;
	AudioValueRange audioRange;
	UInt32 propSize = sizeof( audioRange );
	PaError err = WARNING(AudioDeviceGetProperty( macCoreDeviceId, 0, isInput, kAudioDevicePropertyBufferFrameSizeRange, &propSize, &audioRange ) );
	resultSize = MAX( resultSize, audioRange.mMinimum );
	resultSize = MIN( resultSize, audioRange.mMaximum );
	*allowedSize = resultSize;
	return err;
}

/* =================================================================================================== */
#if 0
static void DumpDeviceProperties( AudioDeviceID macCoreDeviceId,
                          int isInput )
{
    PaError err;
    int i;
    UInt32 propSize;
    UInt32 deviceLatency;
    UInt32 streamLatency;
    UInt32 bufferFrames;
    UInt32 safetyOffset;
    AudioStreamID streamIDs[128];
    
    printf("\n======= latency query : macCoreDeviceId = %d, isInput %d =======\n", (int)macCoreDeviceId, isInput );    
    
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyBufferFrameSize, &propSize, &bufferFrames));
    printf("kAudioDevicePropertyBufferFrameSize: err = %d, propSize = %d, value = %d\n", err, propSize, bufferFrames );
    
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertySafetyOffset, &propSize, &safetyOffset));
    printf("kAudioDevicePropertySafetyOffset: err = %d, propSize = %d, value = %d\n", err, propSize, safetyOffset );
    
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyLatency, &propSize, &deviceLatency));
    printf("kAudioDevicePropertyLatency: err = %d, propSize = %d, value = %d\n", err, propSize, deviceLatency );
    
    AudioValueRange audioRange;
    propSize = sizeof( audioRange );
    err = WARNING(AudioDeviceGetProperty( macCoreDeviceId, 0, isInput, kAudioDevicePropertyBufferFrameSizeRange, &propSize, &audioRange ) );
    printf("kAudioDevicePropertyBufferFrameSizeRange: err = %d, propSize = %u, minimum = %g\n", err, propSize, audioRange.mMinimum);
    printf("kAudioDevicePropertyBufferFrameSizeRange: err = %d, propSize = %u, maximum = %g\n", err, propSize, audioRange.mMaximum );
    
    /* Get the streams from the device and query their latency. */
    propSize = sizeof(streamIDs);
    err  = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreams, &propSize, &streamIDs[0]));
    int numStreams = propSize / sizeof(AudioStreamID);
    for( i=0; i<numStreams; i++ )
    {
        printf("Stream #%d = %d---------------------- \n", i, streamIDs[i] );
        
        propSize = sizeof(UInt32);
        err  = WARNING(AudioStreamGetProperty(streamIDs[i], 0, kAudioStreamPropertyLatency, &propSize, &streamLatency));
        printf("  kAudioStreamPropertyLatency: err = %d, propSize = %d, value = %d\n", err, propSize, streamLatency );
    }
}
#endif

/* =================================================================================================== */
/**
 * @internal
 * Calculate the fixed latency from the system and the device.
 * Sum of kAudioStreamPropertyLatency +
 *        kAudioDevicePropertySafetyOffset +
 *        kAudioDevicePropertyLatency
 *
 * Some useful info from Jeff Moore on latency.
 * http://osdir.com/ml/coreaudio-api/2010-01/msg00046.html
 * http://osdir.com/ml/coreaudio-api/2009-07/msg00140.html
 */
static PaError CalculateFixedDeviceLatency( AudioDeviceID macCoreDeviceId, int isInput, UInt32 *fixedLatencyPtr )
{
    PaError err;
    UInt32 propSize;
    UInt32 deviceLatency;
    UInt32 streamLatency;
    UInt32 safetyOffset;
    AudioStreamID streamIDs[1];
    
    // To get stream latency we have to get a streamID from the device.
    // We are only going to look at the first stream so only fetch one stream.
    propSize = sizeof(streamIDs);
    err  = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreams, &propSize, &streamIDs[0]));
    if( err != paNoError ) goto error;
    if( propSize == sizeof(AudioStreamID) )
    {        
        propSize = sizeof(UInt32);
        err  = WARNING(AudioStreamGetProperty(streamIDs[0], 0, kAudioStreamPropertyLatency, &propSize, &streamLatency));
    }
    
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertySafetyOffset, &propSize, &safetyOffset));
    if( err != paNoError ) goto error;
    
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyLatency, &propSize, &deviceLatency));
    if( err != paNoError ) goto error;

    *fixedLatencyPtr = deviceLatency + streamLatency + safetyOffset;
    return err;
error:
    return err;
}

/* =================================================================================================== */
static PaError CalculateDefaultDeviceLatencies( AudioDeviceID macCoreDeviceId,
                                               int isInput, UInt32 *lowLatencyFramesPtr,
                                               UInt32 *highLatencyFramesPtr )
{
    UInt32 propSize;
    UInt32 bufferFrames = 0;
    UInt32 fixedLatency = 0;
    UInt32 clippedMinBufferSize = 0;
    
    //DumpDeviceProperties( macCoreDeviceId, isInput );
    
    PaError err = CalculateFixedDeviceLatency( macCoreDeviceId, isInput, &fixedLatency );
    if( err != paNoError ) goto error;
    
    // For low latency use a small fixed size buffer clipped to the device range.
    err = ClipToDeviceBufferSize( macCoreDeviceId, isInput, PA_MAC_SMALL_BUFFER_SIZE, &clippedMinBufferSize );
    if( err != paNoError ) goto error;
    
    // For high latency use the default device buffer size.
    propSize = sizeof(UInt32);
    err = WARNING(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyBufferFrameSize, &propSize, &bufferFrames));
    if( err != paNoError ) goto error;
    
    *lowLatencyFramesPtr = fixedLatency + clippedMinBufferSize;
    *highLatencyFramesPtr = fixedLatency + bufferFrames;
    
    return err;
error:
    return err;
}

/* =================================================================================================== */

static PaError GetChannelInfo( PaMacAUHAL *auhalHostApi,
                               PaDeviceInfo *deviceInfo,
                               AudioDeviceID macCoreDeviceId,
                               int isInput)
{
    UInt32 propSize;
    PaError err = paNoError;
    UInt32 i;
    int numChannels = 0;
    AudioBufferList *buflist = NULL;
    
    VVDBUG(("GetChannelInfo()\n"));

    /* Get the number of channels from the stream configuration.
       Fail if we can't get this. */

    err = ERR(AudioDeviceGetPropertyInfo(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreamConfiguration, &propSize, NULL));
    if (err)
        return err;

    buflist = PaUtil_AllocateMemory(propSize);
    if( !buflist )
       return paInsufficientMemory;
    err = ERR(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreamConfiguration, &propSize, buflist));
    if (err)
        goto error;

    for (i = 0; i < buflist->mNumberBuffers; ++i)
        numChannels += buflist->mBuffers[i].mNumberChannels;

    if (isInput)
        deviceInfo->maxInputChannels = numChannels;
    else
        deviceInfo->maxOutputChannels = numChannels;
      
    if (numChannels > 0) /* do not try to retrieve the latency if there are no channels. */
    {
        /* Get the latency.  Don't fail if we can't get this. */
        /* default to something reasonable */
        deviceInfo->defaultLowInputLatency = .01;
        deviceInfo->defaultHighInputLatency = .10;
        deviceInfo->defaultLowOutputLatency = .01;
        deviceInfo->defaultHighOutputLatency = .10;        
        UInt32 lowLatencyFrames = 0;
        UInt32 highLatencyFrames = 0;
        err = CalculateDefaultDeviceLatencies( macCoreDeviceId, isInput, &lowLatencyFrames, &highLatencyFrames );
        if( err == 0 )
        {
            
            double lowLatencySeconds = lowLatencyFrames / deviceInfo->defaultSampleRate;
            double highLatencySeconds = highLatencyFrames / deviceInfo->defaultSampleRate;
            if (isInput)
            {
                deviceInfo->defaultLowInputLatency = lowLatencySeconds;
                deviceInfo->defaultHighInputLatency = highLatencySeconds;
            }
            else
            {
                deviceInfo->defaultLowOutputLatency = lowLatencySeconds;
                deviceInfo->defaultHighOutputLatency = highLatencySeconds;
            }
        }
    }
    PaUtil_FreeMemory( buflist );
    return paNoError;
 error:
    PaUtil_FreeMemory( buflist );
    return err;
}

/* =================================================================================================== */
static PaError InitializeDeviceInfo( PaMacAUHAL *auhalHostApi,
                                     PaDeviceInfo *deviceInfo,
                                     AudioDeviceID macCoreDeviceId,
                                     PaHostApiIndex hostApiIndex )
{
    Float64 sampleRate;
    char *name;
    PaError err = paNoError;
	CFStringRef nameRef;
    UInt32 propSize;

    VVDBUG(("InitializeDeviceInfo(): macCoreDeviceId=%ld\n", macCoreDeviceId));

    memset(deviceInfo, 0, sizeof(PaDeviceInfo));

    deviceInfo->structVersion = 2;
    deviceInfo->hostApi = hostApiIndex;
  
    /* Get the device name using CFString */
	propSize = sizeof(nameRef);
    err = ERR(AudioDeviceGetProperty(macCoreDeviceId, 0, 0, kAudioDevicePropertyDeviceNameCFString, &propSize, &nameRef));
    if (err)
    {
		/* Get the device name using c string.  Fail if we can't get it. */
		err = ERR(AudioDeviceGetPropertyInfo(macCoreDeviceId, 0, 0, kAudioDevicePropertyDeviceName, &propSize, NULL));
		if (err)
			return err;

		name = PaUtil_GroupAllocateMemory(auhalHostApi->allocations,propSize+1);
		if ( !name )
			return paInsufficientMemory;
		err = ERR(AudioDeviceGetProperty(macCoreDeviceId, 0, 0, kAudioDevicePropertyDeviceName, &propSize, name));
		if (err)
			return err;
	}
	else
	{
		/* valid CFString so we just allocate a c string big enough to contain the data */
		propSize = CFStringGetMaximumSizeForEncoding(CFStringGetLength(nameRef), kCFStringEncodingUTF8);
		name = PaUtil_GroupAllocateMemory(auhalHostApi->allocations, propSize+1);
		if ( !name )
		{
			CFRelease(nameRef);
			return paInsufficientMemory;
		}
		CFStringGetCString(nameRef, name, propSize+1, kCFStringEncodingUTF8);
		CFRelease(nameRef);
	}
    deviceInfo->name = name;

    /* Try to get the default sample rate.  Don't fail if we can't get this. */
    propSize = sizeof(Float64);
    err = ERR(AudioDeviceGetProperty(macCoreDeviceId, 0, 0, kAudioDevicePropertyNominalSampleRate, &propSize, &sampleRate));
    if (err)
        deviceInfo->defaultSampleRate = 0.0;
    else
        deviceInfo->defaultSampleRate = sampleRate;

    /* Get the maximum number of input and output channels.  Fail if we can't get this. */

    err = GetChannelInfo(auhalHostApi, deviceInfo, macCoreDeviceId, 1);
    if (err)
        return err;

    err = GetChannelInfo(auhalHostApi, deviceInfo, macCoreDeviceId, 0);
    if (err)
        return err;

    return paNoError;
}

PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    int i;
    PaMacAUHAL *auhalHostApi = NULL;
    PaDeviceInfo *deviceInfoArray;
    int unixErr;

    VVDBUG(("PaMacCore_Initialize(): hostApiIndex=%d\n", hostApiIndex));
	
	SInt32 major;
	SInt32 minor;
	Gestalt(gestaltSystemVersionMajor, &major);
	Gestalt(gestaltSystemVersionMinor, &minor);
	
	// Starting with 10.6 systems, the HAL notification thread is created internally
	if (major == 10 && minor >= 6) {
		CFRunLoopRef theRunLoop = NULL;
		AudioObjectPropertyAddress theAddress = { kAudioHardwarePropertyRunLoop, kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyElementMaster };
		OSStatus osErr = AudioObjectSetPropertyData (kAudioObjectSystemObject, &theAddress, 0, NULL, sizeof(CFRunLoopRef), &theRunLoop);
		if (osErr != noErr) {
			goto error;
		}
	}
	
    unixErr = initializeXRunListenerList();
    if( 0 != unixErr ) {
       return UNIX_ERR(unixErr);
    }

    auhalHostApi = (PaMacAUHAL*)PaUtil_AllocateMemory( sizeof(PaMacAUHAL) );
    if( !auhalHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }

    auhalHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !auhalHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }

    auhalHostApi->devIds = NULL;
    auhalHostApi->devCount = 0;

    /* get the info we need about the devices */
    result = gatherDeviceInfo( auhalHostApi );
    if( result != paNoError )
       goto error;

    *hostApi = &auhalHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paCoreAudio;
    (*hostApi)->info.name = "Core Audio";

    (*hostApi)->info.defaultInputDevice = paNoDevice;
    (*hostApi)->info.defaultOutputDevice = paNoDevice;

    (*hostApi)->info.deviceCount = 0;  

    if( auhalHostApi->devCount > 0 )
    {
        (*hostApi)->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
                auhalHostApi->allocations, sizeof(PaDeviceInfo*) * auhalHostApi->devCount);
        if( !(*hostApi)->deviceInfos )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all device info structs in a contiguous block */
        deviceInfoArray = (PaDeviceInfo*)PaUtil_GroupAllocateMemory(
                auhalHostApi->allocations, sizeof(PaDeviceInfo) * auhalHostApi->devCount );
        if( !deviceInfoArray )
        {
            result = paInsufficientMemory;
            goto error;
        }

        for( i=0; i < auhalHostApi->devCount; ++i )
        {
            int err;
            err = InitializeDeviceInfo( auhalHostApi, &deviceInfoArray[i],
                                      auhalHostApi->devIds[i],
                                      hostApiIndex );
            if (err == paNoError)
            { /* copy some info and set the defaults */
                (*hostApi)->deviceInfos[(*hostApi)->info.deviceCount] = &deviceInfoArray[i];
                if (auhalHostApi->devIds[i] == auhalHostApi->defaultIn)
                    (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
                if (auhalHostApi->devIds[i] == auhalHostApi->defaultOut)
                    (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
                (*hostApi)->info.deviceCount++;
            }
            else
            { /* there was an error. we need to shift the devices down, so we ignore this one */
                int j;
                auhalHostApi->devCount--;
                for( j=i; j<auhalHostApi->devCount; ++j )
                   auhalHostApi->devIds[j] = auhalHostApi->devIds[j+1];
                i--;
            }
        }
    }

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &auhalHostApi->callbackStreamInterface,
                                      CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped,
                                      IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable,
                                      PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &auhalHostApi->blockingStreamInterface,
                                      CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped,
                                      IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream,
                                      GetStreamReadAvailable,
                                      GetStreamWriteAvailable );

    return result;

error:
    if( auhalHostApi )
    {
        if( auhalHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( auhalHostApi->allocations );
            PaUtil_DestroyAllocationGroup( auhalHostApi->allocations );
        }
                
        PaUtil_FreeMemory( auhalHostApi );
    }
    return result;
}


static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    int unixErr;

    PaMacAUHAL *auhalHostApi = (PaMacAUHAL*)hostApi;

    VVDBUG(("Terminate()\n"));

    unixErr = destroyXRunListenerList();
    if( 0 != unixErr )
       UNIX_ERR(unixErr);

    /*
        IMPLEMENT ME:
            - clean up any resources not handled by the allocation group
        TODO: Double check that everything is handled by alloc group
    */

    if( auhalHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( auhalHostApi->allocations );
        PaUtil_DestroyAllocationGroup( auhalHostApi->allocations );
    }

    PaUtil_FreeMemory( auhalHostApi );
}


static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;

    VVDBUG(("IsFormatSupported(): in chan=%d, in fmt=%ld, out chan=%d, out fmt=%ld sampleRate=%g\n",
                inputParameters  ? inputParameters->channelCount  : -1,
                inputParameters  ? inputParameters->sampleFormat  : -1,
                outputParameters ? outputParameters->channelCount : -1,
                outputParameters ? outputParameters->sampleFormat : -1,
                (float) sampleRate ));
 
    /** These first checks are standard PA checks. We do some fancier checks
        later. */
    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if( inputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;
            
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
            return paInvalidChannelCount;
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if( outputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;
            
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support outputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
            return paInvalidChannelCount;

    }
    else
    {
        outputChannelCount = 0;
    }
 
    /* FEEDBACK */
    /*        I think the only way to check a given format SR combo is     */
    /*        to try opening it. This could be disruptive, is that Okay?   */
    /*        The alternative is to just read off available sample rates,  */
    /*        but this will not work %100 of the time (eg, a device that   */
    /*        supports N output at one rate but only N/2 at a higher rate.)*/

    /* The following code opens the device with the requested parameters to
       see if it works. */
    {
       PaError err;
       PaStream *s;
       err = OpenStream( hostApi, &s, inputParameters, outputParameters,
                           sampleRate, 1024, 0, (PaStreamCallback *)1, NULL );
       if( err != paNoError && err != paInvalidSampleRate )
          DBUG( ( "OpenStream @ %g returned: %d: %s\n",
                  (float) sampleRate, err, Pa_GetErrorText( err ) ) );
       if( err ) 
          return err;
       err = CloseStream( s );
       if( err ) {
          /* FEEDBACK: is this more serious? should we assert? */
          DBUG( ( "WARNING: could not close Stream. %d: %s\n",
                  err, Pa_GetErrorText( err ) ) );
       }
    }

    return paFormatIsSupported;
}

/* ================================================================================= */
static void InitializeDeviceProperties( PaMacCoreDeviceProperties *deviceProperties )
{
    memset( deviceProperties, 0, sizeof(PaMacCoreDeviceProperties) );
    deviceProperties->sampleRate = 1.0; // Better than random. Overwritten by actual values later on.
    deviceProperties->samplePeriod = 1.0 / deviceProperties->sampleRate;
}

static Float64 CalculateSoftwareLatencyFromProperties( PaMacCoreStream *stream, PaMacCoreDeviceProperties *deviceProperties )
{
    UInt32 latencyFrames = deviceProperties->bufferFrameSize + deviceProperties->deviceLatency + deviceProperties->safetyOffset;
    return latencyFrames * deviceProperties->samplePeriod; // same as dividing by sampleRate but faster
}

static Float64 CalculateHardwareLatencyFromProperties( PaMacCoreStream *stream, PaMacCoreDeviceProperties *deviceProperties )
{
    return deviceProperties->deviceLatency * deviceProperties->samplePeriod; // same as dividing by sampleRate but faster
}

/* Calculate values used to convert Apple timestamps into PA timestamps
 * from the device properties. The final results of this calculation
 * will be used in the audio callback function.
 */
static void UpdateTimeStampOffsets( PaMacCoreStream *stream )
{
    Float64 inputSoftwareLatency = 0.0;
    Float64 inputHardwareLatency = 0.0;
    Float64 outputSoftwareLatency = 0.0;
    Float64 outputHardwareLatency = 0.0;
    
    if( stream->inputUnit != NULL )
    {
        inputSoftwareLatency = CalculateSoftwareLatencyFromProperties( stream, &stream->inputProperties );
        inputHardwareLatency = CalculateHardwareLatencyFromProperties( stream, &stream->inputProperties );
    }    
    if( stream->outputUnit != NULL )
    {
        outputSoftwareLatency = CalculateSoftwareLatencyFromProperties( stream, &stream->outputProperties );
        outputHardwareLatency = CalculateHardwareLatencyFromProperties( stream, &stream->outputProperties );
    }    
    
    /* We only need a mutex around setting these variables as a group. */
	pthread_mutex_lock( &stream->timingInformationMutex );
    stream->timestampOffsetCombined = inputSoftwareLatency + outputSoftwareLatency;
    stream->timestampOffsetInputDevice = inputHardwareLatency;
    stream->timestampOffsetOutputDevice = outputHardwareLatency;
	pthread_mutex_unlock( &stream->timingInformationMutex );
}

/* ================================================================================= */

/* can be used to update from nominal or actual sample rate */
static OSStatus UpdateSampleRateFromDeviceProperty( PaMacCoreStream *stream, AudioDeviceID deviceID, Boolean isInput, AudioDevicePropertyID sampleRatePropertyID )
{
    PaMacCoreDeviceProperties * deviceProperties = isInput ? &stream->inputProperties : &stream->outputProperties;
	
	Float64 sampleRate = 0.0;
	UInt32 propSize = sizeof(Float64);
    OSStatus osErr = AudioDeviceGetProperty( deviceID, 0, isInput, sampleRatePropertyID, &propSize, &sampleRate);
	if( (osErr == noErr) && (sampleRate > 1000.0) ) /* avoid divide by zero if there's an error */
	{
        deviceProperties->sampleRate = sampleRate;
        deviceProperties->samplePeriod = 1.0 / sampleRate;
    }
    return osErr;
}

static OSStatus AudioDevicePropertyActualSampleRateListenerProc( AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput, AudioDevicePropertyID inPropertyID, void *inClientData )
{
	PaMacCoreStream *stream = (PaMacCoreStream*)inClientData;
    
    // Make sure the callback is operating on a stream that is still valid!
    assert( stream->streamRepresentation.magic == PA_STREAM_MAGIC );

	OSStatus osErr = UpdateSampleRateFromDeviceProperty( stream, inDevice, isInput, kAudioDevicePropertyActualSampleRate );
    if( osErr == noErr )
    {
        UpdateTimeStampOffsets( stream );
    }
    return osErr;
}

/* ================================================================================= */
static OSStatus QueryUInt32DeviceProperty( AudioDeviceID deviceID, Boolean isInput, AudioDevicePropertyID propertyID, UInt32 *outValue )
{
	UInt32 propertyValue = 0;
	UInt32 propertySize = sizeof(UInt32);
	OSStatus osErr = AudioDeviceGetProperty( deviceID, 0, isInput, propertyID, &propertySize, &propertyValue);
	if( osErr == noErr )
	{
        *outValue = propertyValue;
	}
    return osErr;
}

static OSStatus AudioDevicePropertyGenericListenerProc( AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput, AudioDevicePropertyID inPropertyID, void *inClientData )
{
    OSStatus osErr = noErr;
	PaMacCoreStream *stream = (PaMacCoreStream*)inClientData;
    
    // Make sure the callback is operating on a stream that is still valid!
    assert( stream->streamRepresentation.magic == PA_STREAM_MAGIC );
    
    PaMacCoreDeviceProperties *deviceProperties = isInput ? &stream->inputProperties : &stream->outputProperties;
    UInt32 *valuePtr = NULL;
    switch( inPropertyID )
    {
        case kAudioDevicePropertySafetyOffset:
            valuePtr = &deviceProperties->safetyOffset;
            break;
                        
        case kAudioDevicePropertyLatency:
            valuePtr = &deviceProperties->deviceLatency;
            break;
            
        case kAudioDevicePropertyBufferFrameSize:
            valuePtr = &deviceProperties->bufferFrameSize;
            break;            
    }
    if( valuePtr != NULL )
    {
        osErr = QueryUInt32DeviceProperty( inDevice, isInput, inPropertyID, valuePtr );
        if( osErr == noErr )
        {
            UpdateTimeStampOffsets( stream );
        }
    }
    return osErr;
}

/* ================================================================================= */
/*
 * Setup listeners in case device properties change during the run. */
static OSStatus SetupDevicePropertyListeners( PaMacCoreStream *stream, AudioDeviceID deviceID, Boolean isInput )
{
    OSStatus osErr = noErr;
    PaMacCoreDeviceProperties *deviceProperties = isInput ? &stream->inputProperties : &stream->outputProperties;
    
    if( (osErr = QueryUInt32DeviceProperty( deviceID, isInput,
                                           kAudioDevicePropertyLatency, &deviceProperties->deviceLatency )) != noErr ) return osErr;
    if( (osErr = QueryUInt32DeviceProperty( deviceID, isInput,
                                           kAudioDevicePropertyBufferFrameSize, &deviceProperties->bufferFrameSize )) != noErr ) return osErr;
    if( (osErr = QueryUInt32DeviceProperty( deviceID, isInput,
                                           kAudioDevicePropertySafetyOffset, &deviceProperties->safetyOffset )) != noErr ) return osErr;
    
    AudioDeviceAddPropertyListener( deviceID, 0, isInput, kAudioDevicePropertyActualSampleRate, 
                                   AudioDevicePropertyActualSampleRateListenerProc, stream );
    
    AudioDeviceAddPropertyListener( deviceID, 0, isInput, kAudioStreamPropertyLatency, 
                                   AudioDevicePropertyGenericListenerProc, stream );
    AudioDeviceAddPropertyListener( deviceID, 0, isInput, kAudioDevicePropertyBufferFrameSize, 
                                   AudioDevicePropertyGenericListenerProc, stream );
    AudioDeviceAddPropertyListener( deviceID, 0, isInput, kAudioDevicePropertySafetyOffset, 
                                   AudioDevicePropertyGenericListenerProc, stream );
    
    return osErr;
}

static void CleanupDevicePropertyListeners( PaMacCoreStream *stream, AudioDeviceID deviceID, Boolean isInput )
{    
    AudioDeviceRemovePropertyListener( deviceID, 0, isInput, kAudioDevicePropertyActualSampleRate, 
                                   AudioDevicePropertyActualSampleRateListenerProc );
    
    AudioDeviceRemovePropertyListener( deviceID, 0, isInput, kAudioDevicePropertyLatency, 
                                   AudioDevicePropertyGenericListenerProc );	
    AudioDeviceRemovePropertyListener( deviceID, 0, isInput, kAudioDevicePropertyBufferFrameSize, 
                                   AudioDevicePropertyGenericListenerProc );
    AudioDeviceRemovePropertyListener( deviceID, 0, isInput, kAudioDevicePropertySafetyOffset, 
                                   AudioDevicePropertyGenericListenerProc );
}

/* ================================================================================= */
static PaError OpenAndSetupOneAudioUnit(
                                   const PaMacCoreStream *stream,
                                   const PaStreamParameters *inStreamParams,
                                   const PaStreamParameters *outStreamParams,
                                   const UInt32 requestedFramesPerBuffer,
                                   UInt32 *actualInputFramesPerBuffer,
                                   UInt32 *actualOutputFramesPerBuffer,
                                   const PaMacAUHAL *auhalHostApi,
                                   AudioUnit *audioUnit,
                                   AudioConverterRef *srConverter,
                                   AudioDeviceID *audioDevice,
                                   const double sampleRate,
                                   void *refCon )
{
    ComponentDescription desc;
    Component comp;
    /*An Apple TN suggests using CAStreamBasicDescription, but that is C++*/
    AudioStreamBasicDescription desiredFormat;
    OSStatus result = noErr;
    PaError paResult = paNoError;
    int line = 0;
    UInt32 callbackKey;
    AURenderCallbackStruct rcbs;
    unsigned long macInputStreamFlags  = paMacCorePlayNice;
    unsigned long macOutputStreamFlags = paMacCorePlayNice;
    SInt32 const *inChannelMap = NULL;
    SInt32 const *outChannelMap = NULL;
    unsigned long inChannelMapSize = 0;
    unsigned long outChannelMapSize = 0;

    VVDBUG(("OpenAndSetupOneAudioUnit(): in chan=%d, in fmt=%ld, out chan=%d, out fmt=%ld, requestedFramesPerBuffer=%ld\n",
                inStreamParams  ? inStreamParams->channelCount  : -1,
                inStreamParams  ? inStreamParams->sampleFormat  : -1,
                outStreamParams ? outStreamParams->channelCount : -1,
                outStreamParams ? outStreamParams->sampleFormat : -1,
                requestedFramesPerBuffer ));

    /* -- handle the degenerate case  -- */
    if( !inStreamParams && !outStreamParams ) {
       *audioUnit = NULL;
       *audioDevice = kAudioDeviceUnknown;
       return paNoError;
    }

    /* -- get the user's api specific info, if they set any -- */
    if( inStreamParams && inStreamParams->hostApiSpecificStreamInfo )
    {
       macInputStreamFlags=
            ((PaMacCoreStreamInfo*)inStreamParams->hostApiSpecificStreamInfo)
                  ->flags;
       inChannelMap = ((PaMacCoreStreamInfo*)inStreamParams->hostApiSpecificStreamInfo)
                  ->channelMap;
       inChannelMapSize = ((PaMacCoreStreamInfo*)inStreamParams->hostApiSpecificStreamInfo)
                  ->channelMapSize;
    }
    if( outStreamParams && outStreamParams->hostApiSpecificStreamInfo )
    {
       macOutputStreamFlags=
            ((PaMacCoreStreamInfo*)outStreamParams->hostApiSpecificStreamInfo)
                  ->flags;
       outChannelMap = ((PaMacCoreStreamInfo*)outStreamParams->hostApiSpecificStreamInfo)
                  ->channelMap;
       outChannelMapSize = ((PaMacCoreStreamInfo*)outStreamParams->hostApiSpecificStreamInfo)
                  ->channelMapSize; 
    }
    /* Override user's flags here, if desired for testing. */

    /*
     * The HAL AU is a Mac OS style "component".
     * the first few steps deal with that.
     * Later steps work on a combination of Mac OS
     * components and the slightly lower level
     * HAL.
     */

    /* -- describe the output type AudioUnit -- */
    /*  Note: for the default AudioUnit, we could use the
     *  componentSubType value kAudioUnitSubType_DefaultOutput;
     *  but I don't think that's relevant here.
     */
    desc.componentType         = kAudioUnitType_Output;
    desc.componentSubType      = kAudioUnitSubType_HALOutput;
    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
    desc.componentFlags        = 0;
    desc.componentFlagsMask    = 0;
    /* -- find the component -- */
    comp = FindNextComponent( NULL, &desc );
    if( !comp )
    {
       DBUG( ( "AUHAL component not found." ) );
       *audioUnit = NULL;
       *audioDevice = kAudioDeviceUnknown;
       return paUnanticipatedHostError;
    }
    /* -- open it -- */
    result = OpenAComponent( comp, audioUnit );
    if( result )
    {
       DBUG( ( "Failed to open AUHAL component." ) );
       *audioUnit = NULL;
       *audioDevice = kAudioDeviceUnknown;
       return ERR( result );
    }
    /* -- prepare a little error handling logic / hackery -- */
#define ERR_WRAP(mac_err) do { result = mac_err ; line = __LINE__ ; if ( result != noErr ) goto error ; } while(0)

    /* -- if there is input, we have to explicitly enable input -- */
    if( inStreamParams )
    {
       UInt32 enableIO = 1;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                 kAudioOutputUnitProperty_EnableIO,
                 kAudioUnitScope_Input,
                 INPUT_ELEMENT,
                 &enableIO,
                 sizeof(enableIO) ) );
    }
    /* -- if there is no output, we must explicitly disable output -- */
    if( !outStreamParams )
    {
       UInt32 enableIO = 0;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                 kAudioOutputUnitProperty_EnableIO,
                 kAudioUnitScope_Output,
                 OUTPUT_ELEMENT,
                 &enableIO,
                 sizeof(enableIO) ) );
    }

    /* -- set the devices -- */
    /* make sure input and output are the same device if we are doing input and
       output. */
    if( inStreamParams && outStreamParams )
    {
       assert( outStreamParams->device == inStreamParams->device );
    }
    if( inStreamParams )
    {
       *audioDevice = auhalHostApi->devIds[inStreamParams->device] ;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                    kAudioOutputUnitProperty_CurrentDevice,
                    kAudioUnitScope_Global,
                    INPUT_ELEMENT,
                    audioDevice,
                    sizeof(AudioDeviceID) ) );
    }
    if( outStreamParams && outStreamParams != inStreamParams )
    {
       *audioDevice = auhalHostApi->devIds[outStreamParams->device] ;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                    kAudioOutputUnitProperty_CurrentDevice,
                    kAudioUnitScope_Global,
                    OUTPUT_ELEMENT,
                    audioDevice,
                    sizeof(AudioDeviceID) ) );
    }
    /* -- add listener for dropouts -- */
    result = AudioDeviceAddPropertyListener( *audioDevice,
                                             0,
                                             outStreamParams ? false : true,
                                             kAudioDeviceProcessorOverload,
                                             xrunCallback,
                                             addToXRunListenerList( (void *)stream ) ) ;
    if( result == kAudioHardwareIllegalOperationError ) {
       // -- already registered, we're good
    } else {
       // -- not already registered, just check for errors
       ERR_WRAP( result );
    }
    /* -- listen for stream start and stop -- */
    ERR_WRAP( AudioUnitAddPropertyListener( *audioUnit,
                                            kAudioOutputUnitProperty_IsRunning,
                                            startStopCallback,
                                            (void *)stream ) );

    /* -- set format -- */
    bzero( &desiredFormat, sizeof(desiredFormat) );
    desiredFormat.mFormatID         = kAudioFormatLinearPCM ;
    desiredFormat.mFormatFlags      = kAudioFormatFlagsNativeFloatPacked;
    desiredFormat.mFramesPerPacket  = 1;
    desiredFormat.mBitsPerChannel   = sizeof( float ) * 8;

    result = 0;
    /*  set device format first, but only touch the device if the user asked */
    if( inStreamParams ) {
       /*The callback never calls back if we don't set the FPB */
       /*This seems wierd, because I would think setting anything on the device
         would be disruptive.*/
       paResult = setBestFramesPerBuffer( *audioDevice, FALSE,
                                          requestedFramesPerBuffer,
                                          actualInputFramesPerBuffer );
       if( paResult ) goto error;
       if( macInputStreamFlags & paMacCoreChangeDeviceParameters ) {
          bool requireExact;
          requireExact=macInputStreamFlags & paMacCoreFailIfConversionRequired;
          paResult = setBestSampleRateForDevice( *audioDevice, FALSE,
                                                 requireExact, sampleRate );
          if( paResult ) goto error;
       }
       if( actualInputFramesPerBuffer && actualOutputFramesPerBuffer )
          *actualOutputFramesPerBuffer = *actualInputFramesPerBuffer ;
    }
    if( outStreamParams && !inStreamParams ) {
       /*The callback never calls back if we don't set the FPB */
       /*This seems wierd, because I would think setting anything on the device
         would be disruptive.*/
       paResult = setBestFramesPerBuffer( *audioDevice, TRUE,
                                          requestedFramesPerBuffer,
                                          actualOutputFramesPerBuffer );
       if( paResult ) goto error;
       if( macOutputStreamFlags & paMacCoreChangeDeviceParameters ) {
          bool requireExact;
          requireExact=macOutputStreamFlags & paMacCoreFailIfConversionRequired;
          paResult = setBestSampleRateForDevice( *audioDevice, TRUE,
                                                 requireExact, sampleRate );
          if( paResult ) goto error;
       }
    }

    /* -- set the quality of the output converter -- */
    if( outStreamParams ) {
       UInt32 value = kAudioConverterQuality_Max;
       switch( macOutputStreamFlags & 0x0700 ) {
       case 0x0100: /*paMacCore_ConversionQualityMin:*/
          value=kRenderQuality_Min;
          break;
       case 0x0200: /*paMacCore_ConversionQualityLow:*/
          value=kRenderQuality_Low;
          break;
       case 0x0300: /*paMacCore_ConversionQualityMedium:*/
          value=kRenderQuality_Medium;
          break;
       case 0x0400: /*paMacCore_ConversionQualityHigh:*/
          value=kRenderQuality_High;
          break;
       }
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                    kAudioUnitProperty_RenderQuality,
                    kAudioUnitScope_Global,
                    OUTPUT_ELEMENT,
                    &value,
                    sizeof(value) ) );
    }
    /* now set the format on the Audio Units. */
    if( outStreamParams )
    {
       desiredFormat.mSampleRate    =sampleRate;
       desiredFormat.mBytesPerPacket=sizeof(float)*outStreamParams->channelCount;
       desiredFormat.mBytesPerFrame =sizeof(float)*outStreamParams->channelCount;
       desiredFormat.mChannelsPerFrame = outStreamParams->channelCount;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                            kAudioUnitProperty_StreamFormat,
                            kAudioUnitScope_Input,
                            OUTPUT_ELEMENT,
                            &desiredFormat,
                            sizeof(AudioStreamBasicDescription) ) );
    }
    if( inStreamParams )
    {
       AudioStreamBasicDescription sourceFormat;
       UInt32 size = sizeof( AudioStreamBasicDescription );

       /* keep the sample rate of the device, or we confuse AUHAL */
       ERR_WRAP( AudioUnitGetProperty( *audioUnit,
                            kAudioUnitProperty_StreamFormat,
                            kAudioUnitScope_Input,
                            INPUT_ELEMENT,
                            &sourceFormat,
                            &size ) );
       desiredFormat.mSampleRate = sourceFormat.mSampleRate;
       desiredFormat.mBytesPerPacket=sizeof(float)*inStreamParams->channelCount;
       desiredFormat.mBytesPerFrame =sizeof(float)*inStreamParams->channelCount;
       desiredFormat.mChannelsPerFrame = inStreamParams->channelCount;
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                            kAudioUnitProperty_StreamFormat,
                            kAudioUnitScope_Output,
                            INPUT_ELEMENT,
                            &desiredFormat,
                            sizeof(AudioStreamBasicDescription) ) );
    }
    /* set the maximumFramesPerSlice */
    /* not doing this causes real problems
       (eg. the callback might not be called). The idea of setting both this
       and the frames per buffer on the device is that we'll be most likely
       to actually get the frame size we requested in the callback with the
       minimum latency. */
    if( outStreamParams ) {
       UInt32 size = sizeof( *actualOutputFramesPerBuffer );
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                            kAudioUnitProperty_MaximumFramesPerSlice,
                            kAudioUnitScope_Input,
                            OUTPUT_ELEMENT,
                            actualOutputFramesPerBuffer,
                            sizeof(*actualOutputFramesPerBuffer) ) );
       ERR_WRAP( AudioUnitGetProperty( *audioUnit,
                            kAudioUnitProperty_MaximumFramesPerSlice,
                            kAudioUnitScope_Global,
                            OUTPUT_ELEMENT,
                            actualOutputFramesPerBuffer,
                            &size ) );
    }
    if( inStreamParams ) {
       /*UInt32 size = sizeof( *actualInputFramesPerBuffer );*/
       ERR_WRAP( AudioUnitSetProperty( *audioUnit,
                            kAudioUnitProperty_MaximumFramesPerSlice,
                            kAudioUnitScope_Output,
                            INPUT_ELEMENT,
                            actualInputFramesPerBuffer,
                            sizeof(*actualInputFramesPerBuffer) ) );
/* Don't know why this causes problems
       ERR_WRAP( AudioUnitGetProperty( *audioUnit,
                            kAudioUnitProperty_MaximumFramesPerSlice,
                            kAudioUnitScope_Global, //Output,
                            INPUT_ELEMENT,
                            actualInputFramesPerBuffer,
                            &size ) );
*/
    }

    /* -- if we have input, we may need to setup an SR converter -- */
    /* even if we got the sample rate we asked for, we need to do
       the conversion in case another program changes the underlying SR. */
    /* FIXME: I think we need to monitor stream and change the converter if the incoming format changes. */
    if( inStreamParams ) {
       AudioStreamBasicDescription desiredFormat;
       AudioStreamBasicDescription sourceFormat;
       UInt32 sourceSize = sizeof( sourceFormat );
       bzero( &desiredFormat, sizeof(desiredFormat) );
       desiredFormat.mSampleRate       = sampleRate;
       desiredFormat.mFormatID         = kAudioFormatLinearPCM ;
       desiredFormat.mFormatFlags      = kAudioFormatFlagsNativeFloatPacked;
       desiredFormat.mFramesPerPacket  = 1;
       desiredFormat.mBitsPerChannel   = sizeof( float ) * 8;
       desiredFormat.mBytesPerPacket=sizeof(float)*inStreamParams->channelCount;
       desiredFormat.mBytesPerFrame =sizeof(float)*inStreamParams->channelCount;
       desiredFormat.mChannelsPerFrame = inStreamParams->channelCount;

       /* get the source format */
       ERR_WRAP( AudioUnitGetProperty(
                         *audioUnit,
                         kAudioUnitProperty_StreamFormat,
                         kAudioUnitScope_Output,
                         INPUT_ELEMENT,
                         &sourceFormat,
                         &sourceSize ) );

       if( desiredFormat.mSampleRate != sourceFormat.mSampleRate )
       {
          UInt32 value = kAudioConverterQuality_Max;
          switch( macInputStreamFlags & 0x0700 ) {
          case 0x0100: /*paMacCore_ConversionQualityMin:*/
             value=kAudioConverterQuality_Min;
             break;
          case 0x0200: /*paMacCore_ConversionQualityLow:*/
             value=kAudioConverterQuality_Low;
             break;
          case 0x0300: /*paMacCore_ConversionQualityMedium:*/
             value=kAudioConverterQuality_Medium;
             break;
          case 0x0400: /*paMacCore_ConversionQualityHigh:*/
             value=kAudioConverterQuality_High;
             break;
          }
          VDBUG(( "Creating sample rate converter for input"
                  " to convert from %g to %g\n",
                  (float)sourceFormat.mSampleRate,
                  (float)desiredFormat.mSampleRate ) );
          /* create our converter */
          ERR_WRAP( AudioConverterNew( 
                             &sourceFormat,
                             &desiredFormat,
                             srConverter ) );
          /* Set quality */
          ERR_WRAP( AudioConverterSetProperty(
                             *srConverter,
                             kAudioConverterSampleRateConverterQuality,
                             sizeof( value ),
                             &value ) );
       }
    }
    /* -- set IOProc (callback) -- */
    callbackKey = outStreamParams ? kAudioUnitProperty_SetRenderCallback
                                  : kAudioOutputUnitProperty_SetInputCallback ;
    rcbs.inputProc = AudioIOProc;
    rcbs.inputProcRefCon = refCon;
    ERR_WRAP( AudioUnitSetProperty(
                               *audioUnit,
                               callbackKey,
                               kAudioUnitScope_Output,
                               outStreamParams ? OUTPUT_ELEMENT : INPUT_ELEMENT,
                               &rcbs,
                               sizeof(rcbs)) );

    if( inStreamParams && outStreamParams && *srConverter )
           ERR_WRAP( AudioUnitSetProperty(
                               *audioUnit,
                               kAudioOutputUnitProperty_SetInputCallback,
                               kAudioUnitScope_Output,
                               INPUT_ELEMENT,
                               &rcbs,
                               sizeof(rcbs)) );

    /* channel mapping. */
    if(inChannelMap)
    {
        UInt32 mapSize = inChannelMapSize *sizeof(SInt32);

        //for each channel of desired input, map the channel from
        //the device's output channel.
        ERR_WRAP( AudioUnitSetProperty(*audioUnit,
                                kAudioOutputUnitProperty_ChannelMap,
                                kAudioUnitScope_Output,
                                INPUT_ELEMENT,
                                inChannelMap,
                                mapSize));
    }
    if(outChannelMap)
    {
        UInt32 mapSize = outChannelMapSize *sizeof(SInt32);

        //for each channel of desired output, map the channel from
        //the device's output channel.
        ERR_WRAP(AudioUnitSetProperty(*audioUnit,
                                kAudioOutputUnitProperty_ChannelMap,
                                kAudioUnitScope_Output,
                                OUTPUT_ELEMENT,
                                outChannelMap,
                                mapSize));
    }
    /* initialize the audio unit */
    ERR_WRAP( AudioUnitInitialize(*audioUnit) );

    if( inStreamParams && outStreamParams )
    {
        VDBUG( ("Opened device %ld for input and output.\n", *audioDevice ) );
    }
    else if( inStreamParams )
    {
        VDBUG( ("Opened device %ld for input.\n", *audioDevice ) );
    }
    else if( outStreamParams )
    {
        VDBUG( ("Opened device %ld for output.\n", *audioDevice ) );
    }
    return paNoError;
#undef ERR_WRAP

    error:
       CloseComponent( *audioUnit );
       *audioUnit = NULL;
       if( result )
          return PaMacCore_SetError( result, line, 1 );
       return paResult;
}

/* =================================================================================================== */

static UInt32 CalculateOptimalBufferSize( PaMacAUHAL *auhalHostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  UInt32 fixedInputLatency,
                                  UInt32 fixedOutputLatency,
                                  double sampleRate,
                                  UInt32 requestedFramesPerBuffer )
{
    UInt32 resultBufferSizeFrames = 0;  
    // Use maximum of suggested input and output latencies.
    if( inputParameters )
    {
        UInt32 suggestedLatencyFrames = inputParameters->suggestedLatency * sampleRate;
        // Calculate a buffer size assuming we are double buffered.
        SInt32 variableLatencyFrames = suggestedLatencyFrames - fixedInputLatency;
        // Prevent negative latency.
        variableLatencyFrames = MAX( variableLatencyFrames, 0 );       
        resultBufferSizeFrames = MAX( resultBufferSizeFrames, (UInt32) variableLatencyFrames );
    }
    if( outputParameters )
    {        
        UInt32 suggestedLatencyFrames = outputParameters->suggestedLatency * sampleRate;
        SInt32 variableLatencyFrames = suggestedLatencyFrames - fixedOutputLatency;
        variableLatencyFrames = MAX( variableLatencyFrames, 0 );
        resultBufferSizeFrames = MAX( resultBufferSizeFrames, (UInt32) variableLatencyFrames );
    }
    
    // can't have zero frames. code to round up to next user buffer requires non-zero
    resultBufferSizeFrames = MAX( resultBufferSizeFrames, 1 );
    
    if( requestedFramesPerBuffer != paFramesPerBufferUnspecified )
    {
        // make host buffer the next highest integer multiple of user frames per buffer
        UInt32 n = (resultBufferSizeFrames + requestedFramesPerBuffer - 1) / requestedFramesPerBuffer;
        resultBufferSizeFrames = n * requestedFramesPerBuffer;

        
        // FIXME: really we should be searching for a multiple of requestedFramesPerBuffer
        // that is >= suggested latency and also fits within device buffer min/max
        
    }else{
    	VDBUG( ("Block Size unspecified. Based on Latency, the user wants a Block Size near: %ld.\n",
            resultBufferSizeFrames ) );
    }
    
    // Clip to the capabilities of the device.
    if( inputParameters )
    {
        ClipToDeviceBufferSize( auhalHostApi->devIds[inputParameters->device],
                               true, // In the old code isInput was false!
                               resultBufferSizeFrames, &resultBufferSizeFrames );
    }
    if( outputParameters )
    {
        ClipToDeviceBufferSize( auhalHostApi->devIds[outputParameters->device],
                               false, resultBufferSizeFrames, &resultBufferSizeFrames );
    }
    VDBUG(("After querying hardware, setting block size to %ld.\n", resultBufferSizeFrames));

    return resultBufferSizeFrames;
}

/* =================================================================================================== */
/* see pa_hostapi.h for a list of validity guarantees made about OpenStream parameters */
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long requestedFramesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaMacAUHAL *auhalHostApi = (PaMacAUHAL*)hostApi;
    PaMacCoreStream *stream = 0;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
    UInt32 fixedInputLatency = 0;
    UInt32 fixedOutputLatency = 0;
    // Accumulate contributions to latency in these variables.
    UInt32 inputLatencyFrames = 0;
    UInt32 outputLatencyFrames = 0;
    UInt32 suggestedLatencyFramesPerBuffer = requestedFramesPerBuffer;
    
    VVDBUG(("OpenStream(): in chan=%d, in fmt=%ld, out chan=%d, out fmt=%ld SR=%g, FPB=%ld\n",
                inputParameters  ? inputParameters->channelCount  : -1,
                inputParameters  ? inputParameters->sampleFormat  : -1,
                outputParameters ? outputParameters->channelCount : -1,
                outputParameters ? outputParameters->sampleFormat : -1,
                (float) sampleRate,
                requestedFramesPerBuffer ));
    VDBUG( ("Opening Stream.\n") );
	
    /* These first few bits of code are from paSkeleton with few modifications. */
    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

		/* @todo Blocking read/write on Mac is not yet supported. */
		if( !streamCallback && inputSampleFormat & paNonInterleaved )
		{
			return paSampleFormatNotSupported;
		}
		
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
            return paInvalidChannelCount;

        /* Host supports interleaved float32 */
        hostInputSampleFormat = paFloat32;
    }
    else
    {
        inputChannelCount = 0;
        inputSampleFormat = hostInputSampleFormat = paFloat32; /* Surpress 'uninitialised var' warnings. */
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        
		/* @todo Blocking read/write on Mac is not yet supported. */
		if( !streamCallback && outputSampleFormat & paNonInterleaved )
		{
			return paSampleFormatNotSupported;
		}
		
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support inputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
            return paInvalidChannelCount;

        /* Host supports interleaved float32 */
        hostOutputSampleFormat = paFloat32;
    }
    else
    {
        outputChannelCount = 0;
        outputSampleFormat = hostOutputSampleFormat = paFloat32; /* Surpress 'uninitialized var' warnings. */
    }

    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform specific flag */

    stream = (PaMacCoreStream*)PaUtil_AllocateMemory( sizeof(PaMacCoreStream) );
    if( !stream )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* If we fail after this point, we my be left in a bad state, with
       some data structures setup and others not. So, first thing we
       do is initialize everything so that if we fail, we know what hasn't
       been touched.
     */
    bzero( stream, sizeof( PaMacCoreStream ) );
    
    /*
    stream->blio.inputRingBuffer.buffer = NULL;
    stream->blio.outputRingBuffer.buffer = NULL;
    stream->blio.inputSampleFormat = inputParameters?inputParameters->sampleFormat:0;
    stream->blio.inputSampleSize = computeSampleSizeFromFormat(stream->blio.inputSampleFormat);
    stream->blio.outputSampleFormat=outputParameters?outputParameters->sampleFormat:0;
    stream->blio.outputSampleSize = computeSampleSizeFromFormat(stream->blio.outputSampleFormat);
    */

    /* assert( streamCallback ) ; */ /* only callback mode is implemented */
    if( streamCallback )
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                        &auhalHostApi->callbackStreamInterface,
                                        streamCallback, userData );
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                        &auhalHostApi->blockingStreamInterface,
                                        BlioCallback, &stream->blio );
    }

    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );

    
    if( inputParameters )
    {
        CalculateFixedDeviceLatency( auhalHostApi->devIds[inputParameters->device], true, &fixedInputLatency );
        inputLatencyFrames += fixedInputLatency;
    }
    if( outputParameters )
    {        
        CalculateFixedDeviceLatency( auhalHostApi->devIds[outputParameters->device], false, &fixedOutputLatency );
        outputLatencyFrames += fixedOutputLatency;

    }
    
    suggestedLatencyFramesPerBuffer = CalculateOptimalBufferSize( auhalHostApi, inputParameters, outputParameters,
                                                                 fixedInputLatency, fixedOutputLatency,
                                                                 sampleRate, requestedFramesPerBuffer );
    if( requestedFramesPerBuffer == paFramesPerBufferUnspecified )
	{
        requestedFramesPerBuffer = suggestedLatencyFramesPerBuffer;
    }

    /* -- Now we actually open and setup streams. -- */
    if( inputParameters && outputParameters && outputParameters->device == inputParameters->device )
    { /* full duplex. One device. */
       UInt32 inputFramesPerBuffer  = (UInt32) stream->inputFramesPerBuffer;
       UInt32 outputFramesPerBuffer = (UInt32) stream->outputFramesPerBuffer;
       result = OpenAndSetupOneAudioUnit( stream,
                                          inputParameters,
                                          outputParameters,
                                          suggestedLatencyFramesPerBuffer,
                                          &inputFramesPerBuffer,
                                          &outputFramesPerBuffer,
                                          auhalHostApi,
                                          &(stream->inputUnit),
                                          &(stream->inputSRConverter),
                                          &(stream->inputDevice),
                                          sampleRate,
                                          stream );
       stream->inputFramesPerBuffer = inputFramesPerBuffer;
       stream->outputFramesPerBuffer = outputFramesPerBuffer;
       stream->outputUnit = stream->inputUnit;
       stream->outputDevice = stream->inputDevice;
       if( result != paNoError )
           goto error;
    }
    else
    { /* full duplex, different devices OR simplex */
       UInt32 outputFramesPerBuffer = (UInt32) stream->outputFramesPerBuffer;
       UInt32 inputFramesPerBuffer  = (UInt32) stream->inputFramesPerBuffer;
       result = OpenAndSetupOneAudioUnit( stream,
                                          NULL,
                                          outputParameters,
                                          suggestedLatencyFramesPerBuffer,
                                          NULL,
                                          &outputFramesPerBuffer,
                                          auhalHostApi,
                                          &(stream->outputUnit),
                                          NULL,
                                          &(stream->outputDevice),
                                          sampleRate,
                                          stream );
       if( result != paNoError )
           goto error;
       result = OpenAndSetupOneAudioUnit( stream,
                                          inputParameters,
                                          NULL,
                                          suggestedLatencyFramesPerBuffer,
                                          &inputFramesPerBuffer,
                                          NULL,
                                          auhalHostApi,
                                          &(stream->inputUnit),
                                          &(stream->inputSRConverter),
                                          &(stream->inputDevice),
                                          sampleRate,
                                          stream );
       if( result != paNoError )
           goto error;
       stream->inputFramesPerBuffer = inputFramesPerBuffer;
       stream->outputFramesPerBuffer = outputFramesPerBuffer;
    }
    
    inputLatencyFrames += stream->inputFramesPerBuffer;
    outputLatencyFrames += stream->outputFramesPerBuffer;
    
    if( stream->inputUnit ) {
       const size_t szfl = sizeof(float);
       /* setup the AudioBufferList used for input */
       bzero( &stream->inputAudioBufferList, sizeof( AudioBufferList ) );
       stream->inputAudioBufferList.mNumberBuffers = 1;
       stream->inputAudioBufferList.mBuffers[0].mNumberChannels
                 = inputChannelCount;
       stream->inputAudioBufferList.mBuffers[0].mDataByteSize
                 = stream->inputFramesPerBuffer*inputChannelCount*szfl;
       stream->inputAudioBufferList.mBuffers[0].mData
                 = (float *) calloc(
                               stream->inputFramesPerBuffer*inputChannelCount,
                               szfl );
       if( !stream->inputAudioBufferList.mBuffers[0].mData )
       {
          result = paInsufficientMemory;
          goto error;
       }
        
       /*
        * If input and output devs are different or we are doing SR conversion,
        * we also need a ring buffer to store input data while waiting for
        * output data.
        */
       if( (stream->outputUnit && (stream->inputUnit != stream->outputUnit))
           || stream->inputSRConverter )
       {
          /* May want the ringSize or initial position in
             ring buffer to depend somewhat on sample rate change */

          void *data;
          long ringSize;

          ringSize = computeRingBufferSize( inputParameters,
                                            outputParameters,
                                            stream->inputFramesPerBuffer,
                                            stream->outputFramesPerBuffer,
                                            sampleRate );
          /*ringSize <<= 4; *//*16x bigger, for testing */


          /*now, we need to allocate memory for the ring buffer*/
          data = calloc( ringSize, szfl*inputParameters->channelCount );
          if( !data )
          {
             result = paInsufficientMemory;
             goto error;
          }

          /* now we can initialize the ring buffer */
          result = PaUtil_InitializeRingBuffer( &stream->inputRingBuffer, szfl*inputParameters->channelCount, ringSize, data );
          if( result != 0 )
          {
              /* The only reason this should fail is if ringSize is not a power of 2, which we do not anticipate happening. */
              result = paUnanticipatedHostError;
              free(data);
              goto error;
          }

          /* advance the read point a little, so we are reading from the
             middle of the buffer */
          if( stream->outputUnit )
             PaUtil_AdvanceRingBufferWriteIndex( &stream->inputRingBuffer, ringSize / RING_BUFFER_ADVANCE_DENOMINATOR );
           
           // Just adds to input latency between input device and PA full duplex callback.
           inputLatencyFrames += ringSize;
       }
    }

    /* -- initialize Blio Buffer Processors -- */
    if( !streamCallback )
    {
       long ringSize;

       ringSize = computeRingBufferSize( inputParameters,
                                         outputParameters,
                                         stream->inputFramesPerBuffer,
                                         stream->outputFramesPerBuffer,
                                         sampleRate );
       result = initializeBlioRingBuffers( &stream->blio,
              inputParameters ? inputParameters->sampleFormat : 0,
              outputParameters ? outputParameters->sampleFormat : 0,
              ringSize,
              inputParameters ? inputChannelCount : 0,
              outputParameters ? outputChannelCount : 0 ) ;
       if( result != paNoError )
          goto error;
        
        inputLatencyFrames += ringSize;
        outputLatencyFrames += ringSize;
        
    }

    /* -- initialize Buffer Processor -- */
    {
       unsigned long maxHostFrames = stream->inputFramesPerBuffer;
       if( stream->outputFramesPerBuffer > maxHostFrames )
          maxHostFrames = stream->outputFramesPerBuffer;
       result = PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                 inputChannelCount, inputSampleFormat,
                 hostInputSampleFormat,
                 outputChannelCount, outputSampleFormat,
                 hostOutputSampleFormat,
                 sampleRate,
                 streamFlags,
                 requestedFramesPerBuffer,
                 /* If sample rate conversion takes place, the buffer size
                    will not be known. */
                 maxHostFrames,
                 stream->inputSRConverter
                              ? paUtilUnknownHostBufferSize
                              : paUtilBoundedHostBufferSize,
                 streamCallback ? streamCallback : BlioCallback,
                 streamCallback ? userData : &stream->blio );
       if( result != paNoError )
           goto error;
    }
    stream->bufferProcessorIsInitialized = TRUE;

    // Calculate actual latency from the sum of individual latencies.
    if( inputParameters ) 
    {
        inputLatencyFrames += PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor);
        stream->streamRepresentation.streamInfo.inputLatency = inputLatencyFrames / sampleRate;
    }
    else
    {
        stream->streamRepresentation.streamInfo.inputLatency = 0.0;
    }
    
    if( outputParameters ) 
    {
        outputLatencyFrames += PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor);
        stream->streamRepresentation.streamInfo.outputLatency = outputLatencyFrames / sampleRate;
    }
    else
    {
        stream->streamRepresentation.streamInfo.outputLatency = 0.0;
    }
    
    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

    stream->sampleRate = sampleRate;
    
    stream->userInChan  = inputChannelCount;
    stream->userOutChan = outputChannelCount;

    // Setup property listeners for timestamp and latency calculations.
	pthread_mutex_init( &stream->timingInformationMutex, NULL );
	stream->timingInformationMutexIsInitialized = 1;
    InitializeDeviceProperties( &stream->inputProperties );     // zeros the struct. doesn't actually init it to useful values
    InitializeDeviceProperties( &stream->outputProperties );    // zeros the struct. doesn't actually init it to useful values
	if( stream->outputUnit )
    {
        Boolean isInput = FALSE;
        
        // Start with the current values for the device properties.
        // Init with nominal sample rate. Use actual sample rate where available
        
        result = ERR( UpdateSampleRateFromDeviceProperty( 
                stream, stream->outputDevice, isInput, kAudioDevicePropertyNominalSampleRate )  );
        if( result )
            goto error; /* fail if we can't even get a nominal device sample rate */
        
        UpdateSampleRateFromDeviceProperty( stream, stream->outputDevice, isInput, kAudioDevicePropertyActualSampleRate );
        
        SetupDevicePropertyListeners( stream, stream->outputDevice, isInput );
    }
	if( stream->inputUnit )
    {
        Boolean isInput = TRUE;
       
        // as above
        result = ERR( UpdateSampleRateFromDeviceProperty( 
                stream, stream->inputDevice, isInput, kAudioDevicePropertyNominalSampleRate )  );
        if( result )
            goto error;
        
        UpdateSampleRateFromDeviceProperty( stream, stream->inputDevice, isInput, kAudioDevicePropertyActualSampleRate );
        
        SetupDevicePropertyListeners( stream, stream->inputDevice, isInput );
	}
    UpdateTimeStampOffsets( stream );
    // Setup timestamp copies to be used by audio callback.
    stream->timestampOffsetCombined_ioProcCopy = stream->timestampOffsetCombined;
    stream->timestampOffsetInputDevice_ioProcCopy = stream->timestampOffsetInputDevice;
    stream->timestampOffsetOutputDevice_ioProcCopy = stream->timestampOffsetOutputDevice;

    stream->state = STOPPED;
    stream->xrunFlags = 0;

    *s = (PaStream*)stream;

    return result;

error:
    CloseStream( stream );
    return result;
}


#define HOST_TIME_TO_PA_TIME( x ) ( AudioConvertHostTimeToNanos( (x) ) * 1.0E-09) /* convert to nanoseconds and then to seconds */

PaTime GetStreamTime( PaStream *s )
{
	return HOST_TIME_TO_PA_TIME( AudioGetCurrentHostTime() ); 
}

#define RING_BUFFER_EMPTY (1000)

static OSStatus ringBufferIOProc( AudioConverterRef inAudioConverter, 
                             UInt32*ioDataSize, 
                             void** outData, 
                             void*inUserData )
{
   void *dummyData;
   ring_buffer_size_t dummySize;
   PaUtilRingBuffer *rb = (PaUtilRingBuffer *) inUserData;

   VVDBUG(("ringBufferIOProc()\n"));

   if( PaUtil_GetRingBufferReadAvailable( rb ) == 0 ) {
      *outData = NULL;
      *ioDataSize = 0;
      return RING_BUFFER_EMPTY;
   }
   assert(sizeof(UInt32) == sizeof(ring_buffer_size_t));
   assert( ( (*ioDataSize) / rb->elementSizeBytes ) * rb->elementSizeBytes == (*ioDataSize) ) ;
   (*ioDataSize) /= rb->elementSizeBytes ;
   PaUtil_GetRingBufferReadRegions( rb, *ioDataSize,
                                    outData, (ring_buffer_size_t *)ioDataSize, 
                                    &dummyData, &dummySize );
   assert( *ioDataSize );
   PaUtil_AdvanceRingBufferReadIndex( rb, *ioDataSize );
   (*ioDataSize) *= rb->elementSizeBytes ;

   return noErr;
}

/*
 * Called by the AudioUnit API to process audio from the sound card.
 * This is where the magic happens.
 */
/* FEEDBACK: there is a lot of redundant code here because of how all the cases differ. This makes it hard to maintain, so if there are suggestinos for cleaning it up, I'm all ears. */
static OSStatus AudioIOProc( void *inRefCon,
                               AudioUnitRenderActionFlags *ioActionFlags,
                               const AudioTimeStamp *inTimeStamp,
                               UInt32 inBusNumber,
                               UInt32 inNumberFrames,
                               AudioBufferList *ioData )
{
   unsigned long framesProcessed     = 0;
   PaStreamCallbackTimeInfo timeInfo = {0,0,0};
   PaMacCoreStream *stream           = (PaMacCoreStream*)inRefCon;
   const bool isRender               = inBusNumber == OUTPUT_ELEMENT;
   int callbackResult                = paContinue ;
   double hostTimeStampInPaTime      = HOST_TIME_TO_PA_TIME(inTimeStamp->mHostTime);
    
   VVDBUG(("AudioIOProc()\n"));

   PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );
    
   /* -----------------------------------------------------------------*\
      This output may be useful for debugging,
      But printing durring the callback is a bad enough idea that
      this is not enabled by enableing the usual debugging calls.
   \* -----------------------------------------------------------------*/
   /*
   static int renderCount = 0;
   static int inputCount = 0;
   printf( "-------------------  starting reder/input\n" );
   if( isRender )
      printf("Render callback (%d):\t", ++renderCount);
   else
      printf("Input callback  (%d):\t", ++inputCount);
   printf( "Call totals: %d (input), %d (render)\n", inputCount, renderCount );

   printf( "--- inBusNumber: %lu\n", inBusNumber );
   printf( "--- inNumberFrames: %lu\n", inNumberFrames );
   printf( "--- %x ioData\n", (unsigned) ioData );
   if( ioData )
   {
      int i=0;
      printf( "--- ioData.mNumBuffers %lu: \n", ioData->mNumberBuffers );
      for( i=0; i<ioData->mNumberBuffers; ++i )
         printf( "--- ioData buffer %d size: %lu.\n", i, ioData->mBuffers[i].mDataByteSize );
   }
      ----------------------------------------------------------------- */

	/* compute PaStreamCallbackTimeInfo */
	
	if( pthread_mutex_trylock( &stream->timingInformationMutex ) == 0 ){
		/* snapshot the ioproc copy of timing information */
		stream->timestampOffsetCombined_ioProcCopy = stream->timestampOffsetCombined;
		stream->timestampOffsetInputDevice_ioProcCopy = stream->timestampOffsetInputDevice;
		stream->timestampOffsetOutputDevice_ioProcCopy = stream->timestampOffsetOutputDevice;
		pthread_mutex_unlock( &stream->timingInformationMutex );
	}
	
	/* For timeInfo.currentTime we could calculate current time backwards from the HAL audio 
	 output time to give a more accurate impression of the current timeslice but it doesn't 
	 seem worth it at the moment since other PA host APIs don't do any better.
	 */
	timeInfo.currentTime = HOST_TIME_TO_PA_TIME( AudioGetCurrentHostTime() );
	
	/*
	 For an input HAL AU, inTimeStamp is the time the samples are received from the hardware,
	 for an output HAL AU inTimeStamp is the time the samples are sent to the hardware. 
	 PA expresses timestamps in terms of when the samples enter the ADC or leave the DAC
	 so we add or subtract kAudioDevicePropertyLatency below.
	 */
	
	/* FIXME: not sure what to do below if the host timestamps aren't valid (kAudioTimeStampHostTimeValid isn't set)
	 Could ask on CA mailing list if it is possible for it not to be set. If so, could probably grab a now timestamp
	 at the top and compute from there (modulo scheduling jitter) or ask on mailing list for other options. */
	
	if( isRender )
	{
		if( stream->inputUnit ) /* full duplex */
		{
			if( stream->inputUnit == stream->outputUnit ) /* full duplex AUHAL IOProc */
			{
                // Ross and Phil agreed that the following calculation is correct based on an email from Jeff Moore:
                // http://osdir.com/ml/coreaudio-api/2009-07/msg00140.html
                // Basically the difference between the Apple output timestamp and the PA timestamp is kAudioDevicePropertyLatency.
				timeInfo.inputBufferAdcTime = hostTimeStampInPaTime - 
                    (stream->timestampOffsetCombined_ioProcCopy + stream->timestampOffsetInputDevice_ioProcCopy);
 				timeInfo.outputBufferDacTime = hostTimeStampInPaTime + stream->timestampOffsetOutputDevice_ioProcCopy;
			}
			else /* full duplex with ring-buffer from a separate input AUHAL ioproc */
			{
				/* FIXME: take the ring buffer latency into account */
				timeInfo.inputBufferAdcTime = hostTimeStampInPaTime - 
                    (stream->timestampOffsetCombined_ioProcCopy + stream->timestampOffsetInputDevice_ioProcCopy);
				timeInfo.outputBufferDacTime = hostTimeStampInPaTime + stream->timestampOffsetOutputDevice_ioProcCopy;
			}
		}
		else /* output only */
		{
			timeInfo.inputBufferAdcTime = 0;
			timeInfo.outputBufferDacTime = hostTimeStampInPaTime + stream->timestampOffsetOutputDevice_ioProcCopy;
		}
	}
	else /* input only */
	{
		timeInfo.inputBufferAdcTime = hostTimeStampInPaTime - stream->timestampOffsetInputDevice_ioProcCopy; 
		timeInfo.outputBufferDacTime = 0;
	}
	
   //printf( "---%g, %g, %g\n", timeInfo.inputBufferAdcTime, timeInfo.currentTime, timeInfo.outputBufferDacTime );

   if( isRender && stream->inputUnit == stream->outputUnit
                && !stream->inputSRConverter )
   {
      /* --------- Full Duplex, One Device, no SR Conversion -------
       *
       * This is the lowest latency case, and also the simplest.
       * Input data and output data are available at the same time.
       * we do not use the input SR converter or the input ring buffer.
       *
       */
      OSStatus err = 0;
       unsigned long frames;
       long bytesPerFrame = sizeof( float ) * ioData->mBuffers[0].mNumberChannels;

      /* -- start processing -- */
      PaUtil_BeginBufferProcessing( &(stream->bufferProcessor),
                                    &timeInfo,
                                    stream->xrunFlags );
      stream->xrunFlags = 0; //FIXME: this flag also gets set outside by a callback, which calls the xrunCallback function. It should be in the same thread as the main audio callback, but the apple docs just use the word "usually" so it may be possible to loose an xrun notification, if that callback happens here.

      /* -- compute frames. do some checks -- */
      assert( ioData->mNumberBuffers == 1 );
      assert( ioData->mBuffers[0].mNumberChannels == stream->userOutChan );

      frames = ioData->mBuffers[0].mDataByteSize / bytesPerFrame;
      /* -- copy and process input data -- */
      err= AudioUnitRender(stream->inputUnit,
                    ioActionFlags,
                    inTimeStamp,
                    INPUT_ELEMENT,
                    inNumberFrames,
                    &stream->inputAudioBufferList );
      if(err != noErr)
      {
        goto stop_stream;
      }

      PaUtil_SetInputFrameCount( &(stream->bufferProcessor), frames );
      PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                          0,
                          stream->inputAudioBufferList.mBuffers[0].mData,
                          stream->inputAudioBufferList.mBuffers[0].mNumberChannels);
      /* -- Copy and process output data -- */
      PaUtil_SetOutputFrameCount( &(stream->bufferProcessor), frames );
      PaUtil_SetInterleavedOutputChannels( &(stream->bufferProcessor),
                                        0,
                                        ioData->mBuffers[0].mData,
                                        ioData->mBuffers[0].mNumberChannels);
      /* -- complete processing -- */
      framesProcessed =
                 PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                             &callbackResult );
   }
   else if( isRender )
   {
      /* -------- Output Side of Full Duplex (Separate Devices or SR Conversion)
       *       -- OR Simplex Output
       *
       * This case handles output data as in the full duplex case,
       * and, if there is input data, reads it off the ring buffer 
       * and into the PA buffer processor. If sample rate conversion
       * is required on input, that is done here as well.
       */
       unsigned long frames;
       long bytesPerFrame = sizeof( float ) * ioData->mBuffers[0].mNumberChannels;

      /* Sometimes, when stopping a duplex stream we get erroneous
         xrun flags, so if this is our last run, clear the flags. */
      int xrunFlags = stream->xrunFlags;
/*
      if( xrunFlags & paInputUnderflow )
         printf( "input underflow.\n" );
      if( xrunFlags & paInputOverflow )
         printf( "input overflow.\n" );
*/
      if( stream->state == STOPPING || stream->state == CALLBACK_STOPPED )
         xrunFlags = 0;

      /* -- start processing -- */
      PaUtil_BeginBufferProcessing( &(stream->bufferProcessor),
                                    &timeInfo,
                                    xrunFlags );
      stream->xrunFlags = 0; /* FEEDBACK: we only send flags to Buf Proc once */

      /* -- Copy and process output data -- */
      assert( ioData->mNumberBuffers == 1 );
      frames = ioData->mBuffers[0].mDataByteSize / bytesPerFrame;
      assert( ioData->mBuffers[0].mNumberChannels == stream->userOutChan );
      PaUtil_SetOutputFrameCount( &(stream->bufferProcessor), frames );
      PaUtil_SetInterleavedOutputChannels( &(stream->bufferProcessor),
                                     0,
                                     ioData->mBuffers[0].mData,
                                     ioData->mBuffers[0].mNumberChannels);

      /* -- copy and process input data, and complete processing -- */
      if( stream->inputUnit ) {
         const int flsz = sizeof( float );
         /* Here, we read the data out of the ring buffer, through the
            audio converter. */
         int inChan = stream->inputAudioBufferList.mBuffers[0].mNumberChannels;
         long bytesPerFrame = flsz * inChan;
          
         if( stream->inputSRConverter )
         {
               OSStatus err;
               UInt32 size;
               float data[ inChan * frames ];
               size = sizeof( data );
               err = AudioConverterFillBuffer( 
                             stream->inputSRConverter,
                             ringBufferIOProc,
                             &stream->inputRingBuffer,
                             &size,
                             (void *)&data );
               if( err == RING_BUFFER_EMPTY )
               { /* the ring buffer callback underflowed */
                  err = 0;
                  bzero( ((char *)data) + size, sizeof(data)-size );
                  /* The ring buffer can underflow normally when the stream is stopping.
                   * So only report an error if the stream is active. */
                  if( stream->state == ACTIVE )
                  {
                      stream->xrunFlags |= paInputUnderflow;
                  }
               }
               ERR( err );
               if(err != noErr)
               {
                 goto stop_stream;
               }

               PaUtil_SetInputFrameCount( &(stream->bufferProcessor), frames );
               PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                                   0,
                                   data,
                                   inChan );
               framesProcessed =
                    PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                                &callbackResult );
         }
         else
         {
            /* Without the AudioConverter is actually a bit more complex
               because we have to do a little buffer processing that the
               AudioConverter would otherwise handle for us. */
            void *data1, *data2;
            ring_buffer_size_t size1, size2;
            ring_buffer_size_t framesReadable = PaUtil_GetRingBufferReadRegions( &stream->inputRingBuffer,
                                             frames,
                                             &data1, &size1,
                                             &data2, &size2 );
            if( size1 == frames ) {
               /* simplest case: all in first buffer */
               PaUtil_SetInputFrameCount( &(stream->bufferProcessor), frames );
               PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                                   0,
                                   data1,
                                   inChan );
               framesProcessed =
                    PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                                &callbackResult );
               PaUtil_AdvanceRingBufferReadIndex(&stream->inputRingBuffer, size1 );
            } else if( framesReadable < frames ) {
                
                long sizeBytes1 = size1 * bytesPerFrame;
                long sizeBytes2 = size2 * bytesPerFrame;
               /*we underflowed. take what data we can, zero the rest.*/
               unsigned char data[ frames * bytesPerFrame ];
               if( size1 > 0 )
               {   
                   memcpy( data, data1, sizeBytes1 );
               }
               if( size2 > 0 )
               {
                   memcpy( data+sizeBytes1, data2, sizeBytes2 );
               }
               bzero( data+sizeBytes1+sizeBytes2, (frames*bytesPerFrame) - sizeBytes1 - sizeBytes2 );

               PaUtil_SetInputFrameCount( &(stream->bufferProcessor), frames );
               PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                                   0,
                                   data,
                                   inChan );
               framesProcessed =
                    PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                                &callbackResult );
               PaUtil_AdvanceRingBufferReadIndex( &stream->inputRingBuffer,
                                                  framesReadable );
               /* flag underflow */
               stream->xrunFlags |= paInputUnderflow;
            } else {
               /*we got all the data, but split between buffers*/
               PaUtil_SetInputFrameCount( &(stream->bufferProcessor), size1 );
               PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                                   0,
                                   data1,
                                   inChan );
               PaUtil_Set2ndInputFrameCount( &(stream->bufferProcessor), size2 );
               PaUtil_Set2ndInterleavedInputChannels( &(stream->bufferProcessor),
                                   0,
                                   data2,
                                   inChan );
               framesProcessed =
                    PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                                &callbackResult );
               PaUtil_AdvanceRingBufferReadIndex(&stream->inputRingBuffer, framesReadable );
            }
         }
      } else {
         framesProcessed =
                 PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                             &callbackResult );
      }

   }
   else
   {
      /* ------------------ Input
       *
       * First, we read off the audio data and put it in the ring buffer.
       * if this is an input-only stream, we need to process it more,
       * otherwise, we let the output case deal with it.
       */
      OSStatus err = 0;
      int chan = stream->inputAudioBufferList.mBuffers[0].mNumberChannels ;
      /* FIXME: looping here may not actually be necessary, but it was something I tried in testing. */
      do {
         err= AudioUnitRender(stream->inputUnit,
                 ioActionFlags,
                 inTimeStamp,
                 INPUT_ELEMENT,
                 inNumberFrames,
                 &stream->inputAudioBufferList );
         if( err == -10874 )
            inNumberFrames /= 2;
      } while( err == -10874 && inNumberFrames > 1 );
      ERR( err );
      if(err != noErr)
      {
          goto stop_stream;
      }

      if( stream->inputSRConverter || stream->outputUnit )
      {
         /* If this is duplex or we use a converter, put the data
            into the ring buffer. */
          ring_buffer_size_t framesWritten = PaUtil_WriteRingBuffer( &stream->inputRingBuffer,
                                            stream->inputAudioBufferList.mBuffers[0].mData,
                                            inNumberFrames );
         if( framesWritten != inNumberFrames )
         {
             stream->xrunFlags |= paInputOverflow ;
         }
      }
      else
      {
         /* for simplex input w/o SR conversion,
            just pop the data into the buffer processor.*/
         PaUtil_BeginBufferProcessing( &(stream->bufferProcessor),
                              &timeInfo,
                              stream->xrunFlags );
         stream->xrunFlags = 0;

         PaUtil_SetInputFrameCount( &(stream->bufferProcessor), inNumberFrames);
         PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                             0,
                             stream->inputAudioBufferList.mBuffers[0].mData,
                             chan );
         framesProcessed =
              PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                          &callbackResult );
      }
      if( !stream->outputUnit && stream->inputSRConverter )
      {
         /* ------------------ Simplex Input w/ SR Conversion
          *
          * if this is a simplex input stream, we need to read off the buffer,
          * do our sample rate conversion and pass the results to the buffer
          * processor.
          * The logic here is complicated somewhat by the fact that we don't
          * know how much data is available, so we loop on reasonably sized
          * chunks, and let the BufferProcessor deal with the rest.
          *
          */
         /* This might be too big or small depending on SR conversion. */
         float data[ chan * inNumberFrames ];
         OSStatus err;
         do
         { /* Run the buffer processor until we are out of data. */
            UInt32 size;
            long f;

            size = sizeof( data );
            err = AudioConverterFillBuffer( 
                          stream->inputSRConverter,
                          ringBufferIOProc,
                          &stream->inputRingBuffer,
                          &size,
                          (void *)data );
            if( err != RING_BUFFER_EMPTY )
               ERR( err );
            if( err != noErr && err != RING_BUFFER_EMPTY )
            {
                goto stop_stream;
            }


            f = size / ( chan * sizeof(float) );
            PaUtil_SetInputFrameCount( &(stream->bufferProcessor), f );
            if( f )
            {
               PaUtil_BeginBufferProcessing( &(stream->bufferProcessor),
                                             &timeInfo,
                                             stream->xrunFlags );
               stream->xrunFlags = 0;

               PaUtil_SetInterleavedInputChannels( &(stream->bufferProcessor),
                                0,
                                data,
                                chan );
               framesProcessed =
                    PaUtil_EndBufferProcessing( &(stream->bufferProcessor),
                                                &callbackResult );
            }
         } while( callbackResult == paContinue && !err );
      }
   }

    // Should we return successfully or fall through to stopping the stream?
    if( callbackResult == paContinue )
    {
        PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );
        return noErr;
    }

stop_stream:
    stream->state = CALLBACK_STOPPED ;
    if( stream->outputUnit )
        AudioOutputUnitStop(stream->outputUnit);
    if( stream->inputUnit )
        AudioOutputUnitStop(stream->inputUnit);

    PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );
    return noErr;
}

/*
    When CloseStream() is called, the multi-api layer ensures that
    the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    /* This may be called from a failed OpenStream.
       Therefore, each piece of info is treated seperately. */
    PaError result = paNoError;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;

    VVDBUG(("CloseStream()\n"));
    VDBUG( ( "Closing stream.\n" ) );

    if( stream ) {
		
		if( stream->outputUnit )
        {
            Boolean isInput = FALSE;
            CleanupDevicePropertyListeners( stream, stream->outputDevice, isInput );
		}
		
		if( stream->inputUnit )
        {
            Boolean isInput = TRUE;
            CleanupDevicePropertyListeners( stream, stream->inputDevice, isInput );
		}
		
       if( stream->outputUnit ) {
          int count = removeFromXRunListenerList( stream );
          if( count == 0 )
             AudioDeviceRemovePropertyListener( stream->outputDevice,
                                                0,
                                                false,
                                                kAudioDeviceProcessorOverload,
                                                xrunCallback );
       }
       if( stream->inputUnit && stream->outputUnit != stream->inputUnit ) {
          int count = removeFromXRunListenerList( stream );
          if( count == 0 )
             AudioDeviceRemovePropertyListener( stream->inputDevice,
                                                0,
                                                true,
                                                kAudioDeviceProcessorOverload,
                                                xrunCallback );
       }
       if( stream->outputUnit && stream->outputUnit != stream->inputUnit ) {
          AudioUnitUninitialize( stream->outputUnit );
          CloseComponent( stream->outputUnit );
       }
       stream->outputUnit = NULL;
       if( stream->inputUnit )
       {
          AudioUnitUninitialize( stream->inputUnit );
          CloseComponent( stream->inputUnit );
          stream->inputUnit = NULL;
       }
       if( stream->inputRingBuffer.buffer )
          free( (void *) stream->inputRingBuffer.buffer );
       stream->inputRingBuffer.buffer = NULL;
       /*TODO: is there more that needs to be done on error
               from AudioConverterDispose?*/
       if( stream->inputSRConverter )
          ERR( AudioConverterDispose( stream->inputSRConverter ) );
       stream->inputSRConverter = NULL;
       if( stream->inputAudioBufferList.mBuffers[0].mData )
          free( stream->inputAudioBufferList.mBuffers[0].mData );
       stream->inputAudioBufferList.mBuffers[0].mData = NULL;

       result = destroyBlioRingBuffers( &stream->blio );
       if( result )
          return result;
       if( stream->bufferProcessorIsInitialized )
          PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
		
       if( stream->timingInformationMutexIsInitialized )
          pthread_mutex_destroy( &stream->timingInformationMutex );

       PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
       PaUtil_FreeMemory( stream );
    }

    return result;
}

static PaError StartStream( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    OSStatus result = noErr;
    VVDBUG(("StartStream()\n"));
    VDBUG( ( "Starting stream.\n" ) );

#define ERR_WRAP(mac_err) do { result = mac_err ; if ( result != noErr ) return ERR(result) ; } while(0)

    /*FIXME: maybe want to do this on close/abort for faster start? */
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );
    if(  stream->inputSRConverter )
       ERR_WRAP( AudioConverterReset( stream->inputSRConverter ) );

    /* -- start -- */
    stream->state = ACTIVE;
    if( stream->inputUnit ) {
       ERR_WRAP( AudioOutputUnitStart(stream->inputUnit) );
    }
    if( stream->outputUnit && stream->outputUnit != stream->inputUnit ) {
       ERR_WRAP( AudioOutputUnitStart(stream->outputUnit) );
    }
	
    return paNoError;
#undef ERR_WRAP
}

// it's not clear from appl's docs that this really waits
// until all data is flushed.
static ComponentResult BlockWhileAudioUnitIsRunning( AudioUnit audioUnit, AudioUnitElement element )
{
    Boolean isRunning = 1;
    while( isRunning ) {
       UInt32 s = sizeof( isRunning );
       ComponentResult err = AudioUnitGetProperty( audioUnit, kAudioOutputUnitProperty_IsRunning, kAudioUnitScope_Global, element,  &isRunning, &s );
       if( err )
          return err;
       Pa_Sleep( 100 );
    }
    return noErr;
}

static PaError FinishStoppingStream( PaMacCoreStream *stream )
{
    OSStatus result = noErr;
    PaError paErr;

#define ERR_WRAP(mac_err) do { result = mac_err ; if ( result != noErr ) return ERR(result) ; } while(0)
    /* -- stop and reset -- */
    if( stream->inputUnit == stream->outputUnit && stream->inputUnit )
    {
       ERR_WRAP( AudioOutputUnitStop(stream->inputUnit) );
       ERR_WRAP( BlockWhileAudioUnitIsRunning(stream->inputUnit,0) );
       ERR_WRAP( BlockWhileAudioUnitIsRunning(stream->inputUnit,1) );
       ERR_WRAP( AudioUnitReset(stream->inputUnit, kAudioUnitScope_Global, 1) );
       ERR_WRAP( AudioUnitReset(stream->inputUnit, kAudioUnitScope_Global, 0) );
    }
    else
    {
       if( stream->inputUnit )
       {
          ERR_WRAP(AudioOutputUnitStop(stream->inputUnit) );
          ERR_WRAP( BlockWhileAudioUnitIsRunning(stream->inputUnit,1) );
          ERR_WRAP(AudioUnitReset(stream->inputUnit,kAudioUnitScope_Global,1));
       }
       if( stream->outputUnit )
       {
          ERR_WRAP(AudioOutputUnitStop(stream->outputUnit));
          ERR_WRAP( BlockWhileAudioUnitIsRunning(stream->outputUnit,0) );
          ERR_WRAP(AudioUnitReset(stream->outputUnit,kAudioUnitScope_Global,0));
       }
    }
    if( stream->inputRingBuffer.buffer ) {
       PaUtil_FlushRingBuffer( &stream->inputRingBuffer );
       bzero( (void *)stream->inputRingBuffer.buffer,
              stream->inputRingBuffer.bufferSize );
       /* advance the write point a little, so we are reading from the
          middle of the buffer. We'll need extra at the end because
          testing has shown that this helps. */
       if( stream->outputUnit )
          PaUtil_AdvanceRingBufferWriteIndex( &stream->inputRingBuffer,
                                              stream->inputRingBuffer.bufferSize
                                              / RING_BUFFER_ADVANCE_DENOMINATOR );
    }

    stream->xrunFlags = 0;
    stream->state = STOPPED;

    paErr = resetBlioRingBuffers( &stream->blio );
    if( paErr )
       return paErr;

    VDBUG( ( "Stream Stopped.\n" ) );
    return paNoError;
#undef ERR_WRAP
}

/* Block until buffer is empty then stop the stream. */
static PaError StopStream( PaStream *s )
{
    PaError paErr;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("StopStream()\n"));

    /* Tell WriteStream to stop filling the buffer. */
    stream->state = STOPPING;

    if( stream->userOutChan > 0 ) /* Does this stream do output? */
    {
        size_t maxHostFrames = MAX( stream->inputFramesPerBuffer, stream->outputFramesPerBuffer );
        VDBUG( ("Waiting for write buffer to be drained.\n") );
        paErr = waitUntilBlioWriteBufferIsEmpty( &stream->blio, stream->sampleRate,
                                                maxHostFrames );
        VDBUG( ( "waitUntilBlioWriteBufferIsEmpty returned %d\n", paErr ) );
    }
    return FinishStoppingStream( stream );
}

/* Immediately stop the stream. */
static PaError AbortStream( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VDBUG( ( "AbortStream()\n" ) );
    stream->state = STOPPING;
    return FinishStoppingStream( stream );
}


static PaError IsStreamStopped( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("IsStreamStopped()\n"));

    return stream->state == STOPPED ? 1 : 0;
}


static PaError IsStreamActive( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("IsStreamActive()\n"));
    return ( stream->state == ACTIVE || stream->state == STOPPING );
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    VVDBUG(("GetStreamCpuLoad()\n"));

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}
/*
 * Implementation of the PortAudio API for Apple AUHAL
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src

 This file contains the implementation
 required for blocking I/O. It is separated from pa_mac_core.c simply to ease
 development.
*/

// (amalg) #include "pa_mac_core_blocking.h"
// (amalg) #include "pa_mac_core_internal.h"
#include <assert.h>
#ifdef MOSX_USE_NON_ATOMIC_FLAG_BITS
# define OSAtomicOr32( a, b ) ( (*(b)) |= (a) )
# define OSAtomicAnd32( a, b ) ( (*(b)) &= (a) )
#else
# include <libkern/OSAtomic.h>
#endif

/*
 * This function determines the size of a particular sample format.
 * if the format is not recognized, this returns zero.
 */
static size_t computeSampleSizeFromFormat( PaSampleFormat format )
{
   switch( format & (~paNonInterleaved) ) {
   case paFloat32: return 4;
   case paInt32: return 4;
   case paInt24: return 3;
   case paInt16: return 2;
   case paInt8: case paUInt8: return 1;
   default: return 0;
   }
}
/*
 * Same as computeSampleSizeFromFormat, except that if
 * the size is not a power of two, it returns the next power of two up
 */
static size_t computeSampleSizeFromFormatPow2( PaSampleFormat format )
{
   switch( format & (~paNonInterleaved) ) {
   case paFloat32: return 4;
   case paInt32: return 4;
   case paInt24: return 4;
   case paInt16: return 2;
   case paInt8: case paUInt8: return 1;
   default: return 0;
   }
}



/*
 * Functions for initializing, resetting, and destroying BLIO structures.
 *
 */

/**
 * This should be called with the relevant info when initializing a stream for callback.
 *
 * @param ringBufferSizeInFrames must be a power of 2
 */
PaError initializeBlioRingBuffers(
                                       PaMacBlio *blio,
                                       PaSampleFormat inputSampleFormat,
                                       PaSampleFormat outputSampleFormat,
                                       long ringBufferSizeInFrames,
                                       int inChan,
                                       int outChan )
{
   void *data;
   int result;
   OSStatus err;

   /* zeroify things */
   bzero( blio, sizeof( PaMacBlio ) );
   /* this is redundant, but the buffers are used to check
      if the buffers have been initialized, so we do it explicitly. */
   blio->inputRingBuffer.buffer = NULL;
   blio->outputRingBuffer.buffer = NULL;

   /* initialize simple data */
   blio->ringBufferFrames = ringBufferSizeInFrames;
   blio->inputSampleFormat = inputSampleFormat;
   blio->inputSampleSizeActual = computeSampleSizeFromFormat(inputSampleFormat);
   blio->inputSampleSizePow2 = computeSampleSizeFromFormatPow2(inputSampleFormat); // FIXME: WHY?
   blio->outputSampleFormat = outputSampleFormat;
   blio->outputSampleSizeActual = computeSampleSizeFromFormat(outputSampleFormat);
   blio->outputSampleSizePow2 = computeSampleSizeFromFormatPow2(outputSampleFormat);

   blio->inChan = inChan;
   blio->outChan = outChan;
   blio->statusFlags = 0;
   blio->errors = paNoError;
#ifdef PA_MAC_BLIO_MUTEX
   blio->isInputEmpty = false;
   blio->isOutputFull = false;
#endif

   /* setup ring buffers */
#ifdef PA_MAC_BLIO_MUTEX
   result = PaMacCore_SetUnixError( pthread_mutex_init(&(blio->inputMutex),NULL), 0 );
   if( result )
      goto error;
   result = UNIX_ERR( pthread_cond_init( &(blio->inputCond), NULL ) );
   if( result )
      goto error;
   result = UNIX_ERR( pthread_mutex_init(&(blio->outputMutex),NULL) );
   if( result )
      goto error;
   result = UNIX_ERR( pthread_cond_init( &(blio->outputCond), NULL ) );
#endif
   if( inChan ) {
      data = calloc( ringBufferSizeInFrames, blio->inputSampleSizePow2 * inChan );
      if( !data )
      {
         result = paInsufficientMemory;
         goto error;
      }

      err = PaUtil_InitializeRingBuffer(
            &blio->inputRingBuffer,
            blio->inputSampleSizePow2 * inChan,
            ringBufferSizeInFrames,
            data );
      assert( !err );
   }
   if( outChan ) {
      data = calloc( ringBufferSizeInFrames, blio->outputSampleSizePow2 * outChan );
      if( !data )
      {
         result = paInsufficientMemory;
         goto error;
      }

      err = PaUtil_InitializeRingBuffer(
            &blio->outputRingBuffer,
            blio->outputSampleSizePow2 * outChan,
            ringBufferSizeInFrames,
            data );
      assert( !err );
   }

   result = resetBlioRingBuffers( blio );
   if( result )
      goto error;

   return 0;

 error:
   destroyBlioRingBuffers( blio );
   return result;
}

#ifdef PA_MAC_BLIO_MUTEX
PaError blioSetIsInputEmpty( PaMacBlio *blio, bool isEmpty )
{
   PaError result = paNoError;
   if( isEmpty == blio->isInputEmpty )
      goto done;

   /* we need to update the value. Here's what we do:
    * - Lock the mutex, so noone else can write.
    * - update the value.
    * - unlock.
    * - broadcast to all listeners.
    */
   result = UNIX_ERR( pthread_mutex_lock( &blio->inputMutex ) );
   if( result )
      goto done;
   blio->isInputEmpty = isEmpty;
   result = UNIX_ERR( pthread_mutex_unlock( &blio->inputMutex ) );
   if( result )
      goto done;
   result = UNIX_ERR( pthread_cond_broadcast( &blio->inputCond ) );
   if( result )
      goto done;

 done:
   return result;
}
PaError blioSetIsOutputFull( PaMacBlio *blio, bool isFull )
{
   PaError result = paNoError;
   if( isFull == blio->isOutputFull )
      goto done;

   /* we need to update the value. Here's what we do:
    * - Lock the mutex, so noone else can write.
    * - update the value.
    * - unlock.
    * - broadcast to all listeners.
    */
   result = UNIX_ERR( pthread_mutex_lock( &blio->outputMutex ) );
   if( result )
      goto done;
   blio->isOutputFull = isFull;
   result = UNIX_ERR( pthread_mutex_unlock( &blio->outputMutex ) );
   if( result )
      goto done;
   result = UNIX_ERR( pthread_cond_broadcast( &blio->outputCond ) );
   if( result )
      goto done;

 done:
   return result;
}
#endif

/* This should be called after stopping or aborting the stream, so that on next
   start, the buffers will be ready. */
PaError resetBlioRingBuffers( PaMacBlio *blio )
{
#ifdef PA_MAC__BLIO_MUTEX
   int result;
#endif
   blio->statusFlags = 0;
   if( blio->outputRingBuffer.buffer ) {
       PaUtil_FlushRingBuffer( &blio->outputRingBuffer );
       /* Fill the buffer with zeros. */
       bzero( blio->outputRingBuffer.buffer,
             blio->outputRingBuffer.bufferSize * blio->outputRingBuffer.elementSizeBytes );
       PaUtil_AdvanceRingBufferWriteIndex( &blio->outputRingBuffer, blio->ringBufferFrames );

      /* Update isOutputFull. */
#ifdef PA_MAC__BLIO_MUTEX
      result = blioSetIsOutputFull( blio, toAdvance == blio->outputRingBuffer.bufferSize );
      if( result )
         goto error;
#endif
/*
      printf( "------%d\n" ,  blio->outChan );
      printf( "------%d\n" ,  blio->outputSampleSize );
*/
   }
   if( blio->inputRingBuffer.buffer ) {
      PaUtil_FlushRingBuffer( &blio->inputRingBuffer );
      bzero( blio->inputRingBuffer.buffer,
             blio->inputRingBuffer.bufferSize * blio->inputRingBuffer.elementSizeBytes );
      /* Update isInputEmpty. */
#ifdef PA_MAC__BLIO_MUTEX
      result = blioSetIsInputEmpty( blio, true );
      if( result )
         goto error;
#endif
   }
   return paNoError;
#ifdef PA_MAC__BLIO_MUTEX
 error:
   return result;
#endif
}

/*This should be called when you are done with the blio. It can safely be called
  multiple times if there are no exceptions. */
PaError destroyBlioRingBuffers( PaMacBlio *blio )
{
   PaError result = paNoError;
   if( blio->inputRingBuffer.buffer ) {
      free( blio->inputRingBuffer.buffer );
#ifdef PA_MAC__BLIO_MUTEX
      result = UNIX_ERR( pthread_mutex_destroy( & blio->inputMutex ) );
      if( result ) return result;
      result = UNIX_ERR( pthread_cond_destroy( & blio->inputCond ) );
      if( result ) return result;
#endif
   }
   blio->inputRingBuffer.buffer = NULL;
   if( blio->outputRingBuffer.buffer ) {
      free( blio->outputRingBuffer.buffer );
#ifdef PA_MAC__BLIO_MUTEX
      result = UNIX_ERR( pthread_mutex_destroy( & blio->outputMutex ) );
      if( result ) return result;
      result = UNIX_ERR( pthread_cond_destroy( & blio->outputCond ) );
      if( result ) return result;
#endif
   }
   blio->outputRingBuffer.buffer = NULL;

   return result;
}

/*
 * this is the BlioCallback function. It expects to recieve a PaMacBlio Object
 * pointer as userData.
 *
 */
int BlioCallback( const void *input, void *output, unsigned long frameCount,
	const PaStreamCallbackTimeInfo* timeInfo,
        PaStreamCallbackFlags statusFlags,
        void *userData )
{
   PaMacBlio *blio = (PaMacBlio*)userData;
   ring_buffer_size_t framesAvailable;
   ring_buffer_size_t framesToTransfer;
   ring_buffer_size_t framesTransferred;

   /* set flags returned by OS: */
   OSAtomicOr32( statusFlags, &blio->statusFlags ) ;

   /* --- Handle Input Buffer --- */
   if( blio->inChan ) {
      framesAvailable = PaUtil_GetRingBufferWriteAvailable( &blio->inputRingBuffer );

      /* check for underflow */
      if( framesAvailable < frameCount )
      {
          OSAtomicOr32( paInputOverflow, &blio->statusFlags );
          framesToTransfer = framesAvailable;
      }
      else
      {
          framesToTransfer = (ring_buffer_size_t)frameCount;
      }

      /* Copy the data from the audio input to the application ring buffer. */
      /*printf( "reading %d\n", toRead );*/
      framesTransferred = PaUtil_WriteRingBuffer( &blio->inputRingBuffer, input, framesToTransfer );
      assert( framesToTransfer == framesTransferred );
#ifdef PA_MAC__BLIO_MUTEX
      /* Priority inversion. See notes below. */
      blioSetIsInputEmpty( blio, false );
#endif
   }


   /* --- Handle Output Buffer --- */
   if( blio->outChan ) {
      framesAvailable = PaUtil_GetRingBufferReadAvailable( &blio->outputRingBuffer );

      /* check for underflow */
      if( framesAvailable < frameCount )
      {
          /* zero out the end of the output buffer that we do not have data for */
          framesToTransfer = framesAvailable;

          size_t bytesPerFrame = blio->outputSampleSizeActual * blio->outChan;
          size_t offsetInBytes = framesToTransfer * bytesPerFrame;
          size_t countInBytes = (frameCount - framesToTransfer) * bytesPerFrame;
          bzero( ((char *)output) + offsetInBytes, countInBytes );

          OSAtomicOr32( paOutputUnderflow, &blio->statusFlags );
          framesToTransfer = framesAvailable;
      }
      else
      {
          framesToTransfer = (ring_buffer_size_t)frameCount;
      }

      /* copy the data */
      /*printf( "writing %d\n", toWrite );*/
      framesTransferred = PaUtil_ReadRingBuffer( &blio->outputRingBuffer, output, framesToTransfer );
      assert( framesToTransfer == framesTransferred );
#ifdef PA_MAC__BLIO_MUTEX
      /* We have a priority inversion here. However, we will only have to
         wait if this was true and is now false, which means we've got
         some room in the buffer.
         Hopefully problems will be minimized. */
      blioSetIsOutputFull( blio, false );
#endif
   }

   return paContinue;
}

PaError ReadStream( PaStream* stream,
                           void *buffer,
                           unsigned long framesRequested )
{
    PaMacBlio *blio = & ((PaMacCoreStream*)stream) -> blio;
    char *cbuf = (char *) buffer;
    PaError ret = paNoError;
    VVDBUG(("ReadStream()\n"));

    while( framesRequested > 0 ) {
       ring_buffer_size_t framesAvailable;
       ring_buffer_size_t framesToTransfer;
       ring_buffer_size_t framesTransferred;
       do {
          framesAvailable = PaUtil_GetRingBufferReadAvailable( &blio->inputRingBuffer );
/*
          printf( "Read Buffer is %%%g full: %ld of %ld.\n",
                  100 * (float)avail / (float) blio->inputRingBuffer.bufferSize,
                  framesAvailable, blio->inputRingBuffer.bufferSize );
*/
          if( framesAvailable == 0 ) {
#ifdef PA_MAC_BLIO_MUTEX
             /**block when empty*/
             ret = UNIX_ERR( pthread_mutex_lock( &blio->inputMutex ) );
             if( ret )
                return ret;
             while( blio->isInputEmpty ) {
                ret = UNIX_ERR( pthread_cond_wait( &blio->inputCond, &blio->inputMutex ) );
                if( ret )
                   return ret;
             }
             ret = UNIX_ERR( pthread_mutex_unlock( &blio->inputMutex ) );
             if( ret )
                return ret;
#else
             Pa_Sleep( PA_MAC_BLIO_BUSY_WAIT_SLEEP_INTERVAL );
#endif
          }
       } while( framesAvailable == 0 );
       framesToTransfer = (ring_buffer_size_t) MIN( framesAvailable, framesRequested );
       framesTransferred = PaUtil_ReadRingBuffer( &blio->inputRingBuffer, (void *)cbuf, framesToTransfer );
       cbuf += framesTransferred * blio->inputSampleSizeActual * blio->inChan;
       framesRequested -= framesTransferred;

       if( framesToTransfer == framesAvailable ) {
#ifdef PA_MAC_BLIO_MUTEX
          /* we just emptied the buffer, so we need to mark it as empty. */
          ret = blioSetIsInputEmpty( blio, true );
          if( ret )
             return ret;
          /* of course, in the meantime, the callback may have put some sats
             in, so
             so check for that, too, to avoid a race condition. */
          /* FIXME - this does not seem to fix any race condition. */
          if( PaUtil_GetRingBufferReadAvailable( &blio->inputRingBuffer ) ) {
             blioSetIsInputEmpty( blio, false );
             /* FIXME - why check? ret has not been set? */
             if( ret )
                return ret;
          }
#endif
       }
    }

    /*   Report either paNoError or paInputOverflowed. */
    /*   may also want to report other errors, but this is non-standard. */
    /* FIXME should not clobber ret, use if(blio->statusFlags & paInputOverflow) */
    ret = blio->statusFlags & paInputOverflow;

    /* report underflow only once: */
    if( ret ) {
       OSAtomicAnd32( (uint32_t)(~paInputOverflow), &blio->statusFlags );
       ret = paInputOverflowed;
    }

    return ret;
}


PaError WriteStream( PaStream* stream,
                            const void *buffer,
                            unsigned long framesRequested )
{
    PaMacCoreStream *macStream = (PaMacCoreStream*)stream;
    PaMacBlio *blio = &macStream->blio;
    char *cbuf = (char *) buffer;
    PaError ret = paNoError;
    VVDBUG(("WriteStream()\n"));

    while( framesRequested > 0 && macStream->state != STOPPING ) {
        ring_buffer_size_t framesAvailable;
        ring_buffer_size_t framesToTransfer;
        ring_buffer_size_t framesTransferred;

       do {
          framesAvailable = PaUtil_GetRingBufferWriteAvailable( &blio->outputRingBuffer );
/*
          printf( "Write Buffer is %%%g full: %ld of %ld.\n",
                  100 - 100 * (float)avail / (float) blio->outputRingBuffer.bufferSize,
                  framesAvailable, blio->outputRingBuffer.bufferSize );
*/
          if( framesAvailable == 0 ) {
#ifdef PA_MAC_BLIO_MUTEX
             /*block while full*/
             ret = UNIX_ERR( pthread_mutex_lock( &blio->outputMutex ) );
             if( ret )
                return ret;
             while( blio->isOutputFull ) {
                ret = UNIX_ERR( pthread_cond_wait( &blio->outputCond, &blio->outputMutex ) );
                if( ret )
                   return ret;
             }
             ret = UNIX_ERR( pthread_mutex_unlock( &blio->outputMutex ) );
             if( ret )
                return ret;
#else
             Pa_Sleep( PA_MAC_BLIO_BUSY_WAIT_SLEEP_INTERVAL );
#endif
          }
       } while( framesAvailable == 0 && macStream->state != STOPPING );

       if( macStream->state == STOPPING )
       {
           break;
       }

       framesToTransfer = MIN( framesAvailable, framesRequested );
       framesTransferred = PaUtil_WriteRingBuffer( &blio->outputRingBuffer, (void *)cbuf, framesToTransfer );
       cbuf += framesTransferred * blio->outputSampleSizeActual * blio->outChan;
       framesRequested -= framesTransferred;

#ifdef PA_MAC_BLIO_MUTEX
       if( framesToTransfer == framesAvailable ) {
          /* we just filled up the buffer, so we need to mark it as filled. */
          ret = blioSetIsOutputFull( blio, true );
          if( ret )
             return ret;
          /* of course, in the meantime, we may have emptied the buffer, so
             so check for that, too, to avoid a race condition. */
          if( PaUtil_GetRingBufferWriteAvailable( &blio->outputRingBuffer ) ) {
             blioSetIsOutputFull( blio, false );
              /* FIXME remove or review this code, does not fix race, ret not set! */
             if( ret )
                return ret;
          }
       }
#endif
    }

    if ( macStream->state == STOPPING )
    {
        ret = paInternalError;
    }
    else if (ret == paNoError )
    {
        /*   Test for underflow. */
        ret = blio->statusFlags & paOutputUnderflow;

        /* report underflow only once: */
        if( ret )
        {
            OSAtomicAnd32( (uint32_t)(~paOutputUnderflow), &blio->statusFlags );
            ret = paOutputUnderflowed;
        }
    }

    return ret;
}

/*
 * Wait until the data in the buffer has finished playing.
 */
PaError waitUntilBlioWriteBufferIsEmpty( PaMacBlio *blio, double sampleRate,
                                        size_t framesPerBuffer )
{
    PaError result = paNoError;
    if( blio->outputRingBuffer.buffer ) {
        ring_buffer_size_t framesLeft = PaUtil_GetRingBufferReadAvailable( &blio->outputRingBuffer );

        /* Calculate when we should give up waiting. To be safe wait for two extra periods. */
        PaTime now = PaUtil_GetTime();
        PaTime startTime = now;
        PaTime timeoutTime = startTime + (framesLeft + (2 * framesPerBuffer)) / sampleRate;

        long msecPerBuffer = 1 + (long)( 1000.0 * framesPerBuffer / sampleRate);
        while( framesLeft > 0 && now < timeoutTime ) {
            VDBUG(( "waitUntilBlioWriteBufferIsFlushed: framesLeft = %d, framesPerBuffer = %ld\n",
                  framesLeft, framesPerBuffer ));
            Pa_Sleep( msecPerBuffer );
            framesLeft = PaUtil_GetRingBufferReadAvailable( &blio->outputRingBuffer );
            now = PaUtil_GetTime();
        }

        if( framesLeft > 0 )
        {
            VDBUG(( "waitUntilBlioWriteBufferIsFlushed: TIMED OUT - framesLeft = %d\n", framesLeft ));
            result = paTimedOut;
        }
    }
    return result;
}

signed long GetStreamReadAvailable( PaStream* stream )
{
    PaMacBlio *blio = & ((PaMacCoreStream*)stream) -> blio;
    VVDBUG(("GetStreamReadAvailable()\n"));

    return PaUtil_GetRingBufferReadAvailable( &blio->inputRingBuffer );
}


signed long GetStreamWriteAvailable( PaStream* stream )
{
    PaMacBlio *blio = & ((PaMacCoreStream*)stream) -> blio;
    VVDBUG(("GetStreamWriteAvailable()\n"));

    return PaUtil_GetRingBufferWriteAvailable( &blio->outputRingBuffer );
}

/*
 * $Id$
 * pa_mac_core.c
 * Implementation of PortAudio for Mac OS X CoreAudio       
 *                                                                                         
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Authors: Ross Bencina and Phil Burk
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

#include <CoreAudio/CoreAudio.h>
#include <AudioToolbox/AudioToolbox.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_trace.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"

// =====  constants  =====

// =====  structs  =====
#pragma mark structs

// PaMacCoreHostApiRepresentation - host api datastructure specific to this implementation
typedef struct PaMacCore_HAR
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;
    
    PaUtilAllocationGroup *allocations;
    AudioDeviceID *macCoreDeviceIds;
}
PaMacCoreHostApiRepresentation;

typedef struct PaMacCore_DI
{
    PaDeviceInfo inheritedDeviceInfo;
}
PaMacCoreDeviceInfo;

// PaMacCoreStream - a stream data structure specifically for this implementation
typedef struct PaMacCore_S
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;
    
    int primeStreamUsingCallback;
    
    AudioDeviceID inputDevice;
    AudioDeviceID outputDevice;
    
    // Processing thread management --------------
//    HANDLE abortEvent;
//    HANDLE processingThread;
//    DWORD processingThreadId;
    
    char throttleProcessingThreadOnOverload; // 0 -> don't throtte, non-0 -> throttle
    int processingThreadPriority;
    int highThreadPriority;
    int throttledThreadPriority;
    unsigned long throttledSleepMsecs;
    
    int isStopped;
    volatile int isActive;
    volatile int stopProcessing; // stop thread once existing buffers have been returned
    volatile int abortProcessing; // stop thread immediately
    
//    DWORD allBuffersDurationMs; // used to calculate timeouts
}
PaMacCoreStream;

// Data needed by the CoreAudio callback functions
typedef struct PaMacCore_CD
{
    PaMacCoreStream *stream;
    PaStreamCallback *callback;
    void *userData;
    PaUtilConverter *inputConverter;
    PaUtilConverter *outputConverter;
    void *inputBuffer;
    void *outputBuffer;
    int inputChannelCount;
    int outputChannelCount;
    PaSampleFormat inputSampleFormat;
    PaSampleFormat outputSampleFormat;
    PaUtilTriangularDitherGenerator *ditherGenerator;
}
PaMacClientData;

// =====  CoreAudio-PortAudio bridge functions =====
#pragma mark CoreAudio-PortAudio bridge functions

// Maps CoreAudio OSStatus codes to PortAudio PaError codes
static PaError conv_err(OSStatus error)
{
    PaError result;
    
    switch (error) {
        case kAudioHardwareNoError:
            result = paNoError; break;
        case kAudioHardwareNotRunningError:
            result = paInternalError; break;
        case kAudioHardwareUnspecifiedError:
            result = paInternalError; break;
        case kAudioHardwareUnknownPropertyError:
            result = paInternalError; break;
        case kAudioHardwareBadPropertySizeError:
            result = paInternalError; break;
        case kAudioHardwareIllegalOperationError:
            result = paInternalError; break;
        case kAudioHardwareBadDeviceError:
            result = paInvalidDevice; break;
        case kAudioHardwareBadStreamError:
            result = paBadStreamPtr; break;
        case kAudioHardwareUnsupportedOperationError:
            result = paInternalError; break;
        case kAudioDeviceUnsupportedFormatError:
            result = paSampleFormatNotSupported; break;
        case kAudioDevicePermissionsError:
            result = paDeviceUnavailable; break;
        default:
            result = paInternalError;
    }
    
    return result;
}

/* This function is unused
static AudioStreamBasicDescription *InitializeStreamDescription(const PaStreamParameters *parameters, double sampleRate)
{
    struct AudioStreamBasicDescription *streamDescription = PaUtil_AllocateMemory(sizeof(AudioStreamBasicDescription));
    streamDescription->mSampleRate = sampleRate;
    streamDescription->mFormatID = kAudioFormatLinearPCM;
    streamDescription->mFormatFlags = 0;
    streamDescription->mFramesPerPacket = 1;
    
    if (parameters->sampleFormat & paNonInterleaved) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsNonInterleaved;
        streamDescription->mChannelsPerFrame = 1;
        streamDescription->mBytesPerFrame = Pa_GetSampleSize(parameters->sampleFormat);
        streamDescription->mBytesPerPacket = Pa_GetSampleSize(parameters->sampleFormat);
    }
    else {
        streamDescription->mChannelsPerFrame = parameters->channelCount;
    }
    
    streamDescription->mBytesPerFrame = Pa_GetSampleSize(parameters->sampleFormat) * streamDescription->mChannelsPerFrame;
    streamDescription->mBytesPerPacket = streamDescription->mBytesPerFrame * streamDescription->mFramesPerPacket;
    
    if (parameters->sampleFormat & paFloat32) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsFloat;
        streamDescription->mBitsPerChannel = 32;
    }
    else if (parameters->sampleFormat & paInt32) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
        streamDescription->mBitsPerChannel = 32;
    }
    else if (parameters->sampleFormat & paInt24) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
        streamDescription->mBitsPerChannel = 24;
    }
    else if (parameters->sampleFormat & paInt16) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
        streamDescription->mBitsPerChannel = 16;
    }
    else if (parameters->sampleFormat & paInt8) {
        streamDescription->mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
        streamDescription->mBitsPerChannel = 8;
    }    
    else if (parameters->sampleFormat & paInt32) {
        streamDescription->mBitsPerChannel = 8;
    }
    
    return streamDescription;
}
*/

static PaStreamCallbackTimeInfo *InitializeTimeInfo(const AudioTimeStamp* now, const AudioTimeStamp* inputTime, const AudioTimeStamp* outputTime)
{
    PaStreamCallbackTimeInfo *timeInfo = PaUtil_AllocateMemory(sizeof(PaStreamCallbackTimeInfo));
    
    timeInfo->inputBufferAdcTime = inputTime->mSampleTime;
    timeInfo->currentTime = now->mSampleTime;
    timeInfo->outputBufferDacTime = outputTime->mSampleTime;
    
    return timeInfo;
}

// =====  support functions  =====
#pragma mark support functions

static void CleanUp(PaMacCoreHostApiRepresentation *macCoreHostApi)
{
    if( macCoreHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( macCoreHostApi->allocations );
        PaUtil_DestroyAllocationGroup( macCoreHostApi->allocations );
    }
    
    PaUtil_FreeMemory( macCoreHostApi );    
}

static PaError GetChannelInfo(PaDeviceInfo *deviceInfo, AudioDeviceID macCoreDeviceId, int isInput)
{
    UInt32 propSize;
    PaError err = paNoError;
    UInt32 i;
    int numChannels = 0;
    AudioBufferList *buflist;

    err = conv_err(AudioDeviceGetPropertyInfo(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreamConfiguration, &propSize, NULL));
    buflist = PaUtil_AllocateMemory(propSize);
    err = conv_err(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreamConfiguration, &propSize, buflist));
    if (!err) {
        for (i = 0; i < buflist->mNumberBuffers; ++i) {
            numChannels += buflist->mBuffers[i].mNumberChannels;
        }
		
		if (isInput)
			deviceInfo->maxInputChannels = numChannels;
		else
			deviceInfo->maxOutputChannels = numChannels;
		
        int frameLatency;
        propSize = sizeof(UInt32);
        err = conv_err(AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyLatency, &propSize, &frameLatency));
        if (!err) {
            double secondLatency = frameLatency / deviceInfo->defaultSampleRate;
            if (isInput) {
                deviceInfo->defaultLowInputLatency = secondLatency;
                deviceInfo->defaultHighInputLatency = secondLatency;
            }
            else {
                deviceInfo->defaultLowOutputLatency = secondLatency;
                deviceInfo->defaultHighOutputLatency = secondLatency;
            }
        }
    }
    PaUtil_FreeMemory(buflist);
    
    return err;
}

static PaError InitializeDeviceInfo(PaMacCoreDeviceInfo *macCoreDeviceInfo,  AudioDeviceID macCoreDeviceId, PaHostApiIndex hostApiIndex )
{
    PaDeviceInfo *deviceInfo = &macCoreDeviceInfo->inheritedDeviceInfo;
    deviceInfo->structVersion = 2;
    deviceInfo->hostApi = hostApiIndex;
    
    PaError err = paNoError;
    UInt32 propSize;

    err = conv_err(AudioDeviceGetPropertyInfo(macCoreDeviceId, 0, 0, kAudioDevicePropertyDeviceName, &propSize, NULL));
    // FIXME: this allocation should be part of the allocations group
    char *name = PaUtil_AllocateMemory(propSize);
    err = conv_err(AudioDeviceGetProperty(macCoreDeviceId, 0, 0, kAudioDevicePropertyDeviceName, &propSize, name));
    if (!err) {
        deviceInfo->name = name;
    }
    
    Float64 sampleRate;
    propSize = sizeof(Float64);
    err = conv_err(AudioDeviceGetProperty(macCoreDeviceId, 0, 0, kAudioDevicePropertyNominalSampleRate, &propSize, &sampleRate));
    if (!err) {
        deviceInfo->defaultSampleRate = sampleRate;
    }


    // Get channel info
    err = GetChannelInfo(deviceInfo, macCoreDeviceId, 1);
    err = GetChannelInfo(deviceInfo, macCoreDeviceId, 0);

    return err;
}

static PaError InitializeDeviceInfos( PaMacCoreHostApiRepresentation *macCoreHostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *hostApi;
    PaMacCoreDeviceInfo *deviceInfoArray;

    // initialise device counts and default devices under the assumption that there are no devices. These values are incremented below if and when devices are successfully initialized.
    hostApi = &macCoreHostApi->inheritedHostApiRep;
    hostApi->info.deviceCount = 0;
    hostApi->info.defaultInputDevice = paNoDevice;
    hostApi->info.defaultOutputDevice = paNoDevice;
    
    UInt32 propsize;
    AudioHardwareGetPropertyInfo(kAudioHardwarePropertyDevices, &propsize, NULL);
    int numDevices = propsize / sizeof(AudioDeviceID);
    hostApi->info.deviceCount = numDevices;
    if (numDevices > 0) {
        hostApi->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
                                            macCoreHostApi->allocations, sizeof(PaDeviceInfo*) * numDevices );
        if( !hostApi->deviceInfos )
        {
            return paInsufficientMemory;
        }

        // allocate all device info structs in a contiguous block
        deviceInfoArray = (PaMacCoreDeviceInfo*)PaUtil_GroupAllocateMemory(
                                macCoreHostApi->allocations, sizeof(PaMacCoreDeviceInfo) * numDevices );
        if( !deviceInfoArray )
        {
            return paInsufficientMemory;
        }
        
        macCoreHostApi->macCoreDeviceIds = PaUtil_GroupAllocateMemory(macCoreHostApi->allocations, propsize);
        AudioHardwareGetProperty(kAudioHardwarePropertyDevices, &propsize, macCoreHostApi->macCoreDeviceIds);

        AudioDeviceID defaultInputDevice, defaultOutputDevice;
        propsize = sizeof(AudioDeviceID);
        AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice, &propsize, &defaultInputDevice);
        AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice, &propsize, &defaultOutputDevice);
        
        UInt32 i;
        for (i = 0; i < numDevices; ++i) {
            if (macCoreHostApi->macCoreDeviceIds[i] == defaultInputDevice) {
                hostApi->info.defaultInputDevice = i;
            }
            if (macCoreHostApi->macCoreDeviceIds[i] == defaultOutputDevice) {
                hostApi->info.defaultOutputDevice = i;
            }
            InitializeDeviceInfo(&deviceInfoArray[i], macCoreHostApi->macCoreDeviceIds[i], hostApiIndex);
            hostApi->deviceInfos[i] = &(deviceInfoArray[i].inheritedDeviceInfo);      
        }
    }

    return result;
}

static OSStatus CheckFormat(AudioDeviceID macCoreDeviceId, const PaStreamParameters *parameters, double sampleRate, int isInput)
{
    UInt32 propSize = sizeof(AudioStreamBasicDescription);
    AudioStreamBasicDescription *streamDescription = PaUtil_AllocateMemory(propSize);

    streamDescription->mSampleRate = sampleRate;
    streamDescription->mFormatID = 0;
    streamDescription->mFormatFlags = 0;
    streamDescription->mBytesPerPacket = 0;
    streamDescription->mFramesPerPacket = 0;
    streamDescription->mBytesPerFrame = 0;
    streamDescription->mChannelsPerFrame = 0;
    streamDescription->mBitsPerChannel = 0;
    streamDescription->mReserved = 0;

    OSStatus result = AudioDeviceGetProperty(macCoreDeviceId, 0, isInput, kAudioDevicePropertyStreamFormatSupported, &propSize, streamDescription);
    PaUtil_FreeMemory(streamDescription);
    return result;
}

static OSStatus CopyInputData(PaMacClientData* destination, const AudioBufferList *source, unsigned long frameCount)
{
    int frameSpacing, channelSpacing;
    if (destination->inputSampleFormat & paNonInterleaved) {
        frameSpacing = 1;
        channelSpacing = destination->inputChannelCount;
    }
    else {
        frameSpacing = destination->inputChannelCount;
        channelSpacing = 1;
    }
    
    AudioBuffer const *inputBuffer = &source->mBuffers[0];
    void *coreAudioBuffer = inputBuffer->mData;
    void *portAudioBuffer = destination->inputBuffer;
    UInt32 i, streamNumber, streamChannel;
    for (i = streamNumber = streamChannel = 0; i < destination->inputChannelCount; ++i, ++streamChannel) {
        if (streamChannel >= inputBuffer->mNumberChannels) {
            ++streamNumber;
            inputBuffer = &source->mBuffers[streamNumber];
            coreAudioBuffer = inputBuffer->mData;
            streamChannel = 0;
        }
        destination->inputConverter(portAudioBuffer, frameSpacing, coreAudioBuffer, inputBuffer->mNumberChannels, frameCount, destination->ditherGenerator);
        coreAudioBuffer += sizeof(Float32);
        portAudioBuffer += Pa_GetSampleSize(destination->inputSampleFormat) * channelSpacing;
    }
    return noErr;
}

static OSStatus CopyOutputData(AudioBufferList* destination, PaMacClientData *source, unsigned long frameCount)
{
    int frameSpacing, channelSpacing;
    if (source->outputSampleFormat & paNonInterleaved) {
        frameSpacing = 1;
        channelSpacing = source->outputChannelCount;
    }
    else {
        frameSpacing = source->outputChannelCount;
        channelSpacing = 1;
    }
    
    AudioBuffer *outputBuffer = &destination->mBuffers[0];
    void *coreAudioBuffer = outputBuffer->mData;
    void *portAudioBuffer = source->outputBuffer;
    UInt32 i, streamNumber, streamChannel;
    for (i = streamNumber = streamChannel = 0; i < source->outputChannelCount; ++i, ++streamChannel) {
        if (streamChannel >= outputBuffer->mNumberChannels) {
            ++streamNumber;
            outputBuffer = &destination->mBuffers[streamNumber];
            coreAudioBuffer = outputBuffer->mData;
            streamChannel = 0;
        }
        source->outputConverter(coreAudioBuffer, outputBuffer->mNumberChannels, portAudioBuffer, frameSpacing, frameCount, NULL);
        coreAudioBuffer += sizeof(Float32);
        portAudioBuffer += Pa_GetSampleSize(source->outputSampleFormat) * channelSpacing;
    }
    return noErr;
}

static OSStatus AudioIOProc( AudioDeviceID inDevice,
                      const AudioTimeStamp* inNow,
                      const AudioBufferList* inInputData,
                      const AudioTimeStamp* inInputTime,
                      AudioBufferList* outOutputData, 
                      const AudioTimeStamp* inOutputTime,
                      void* inClientData)
{
    PaMacClientData *clientData = (PaMacClientData *)inClientData;
    PaStreamCallbackTimeInfo *timeInfo = InitializeTimeInfo(inNow, inInputTime, inOutputTime);
    
    PaUtil_BeginCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer );
    
    AudioBuffer *outputBuffer = &outOutputData->mBuffers[0];
    unsigned long frameCount = outputBuffer->mDataByteSize / (outputBuffer->mNumberChannels * sizeof(Float32));

    if (clientData->inputBuffer) {
        CopyInputData(clientData, inInputData, frameCount);
    }
    PaStreamCallbackResult result = clientData->callback(clientData->inputBuffer, clientData->outputBuffer, frameCount, timeInfo, paNoFlag, clientData->userData);
    if (clientData->outputBuffer) {
        CopyOutputData(outOutputData, clientData, frameCount);
    }

    PaUtil_EndCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer, frameCount );
    
    if (result == paComplete || result == paAbort) {
        Pa_StopStream(clientData->stream);
    }

    PaUtil_FreeMemory( timeInfo );
    return noErr;
}

// This is not for input-only streams, this is for streams where the input device is different from the output device
static OSStatus AudioInputProc( AudioDeviceID inDevice,
                         const AudioTimeStamp* inNow,
                         const AudioBufferList* inInputData,
                         const AudioTimeStamp* inInputTime,
                         AudioBufferList* outOutputData, 
                         const AudioTimeStamp* inOutputTime,
                         void* inClientData)
{
    PaMacClientData *clientData = (PaMacClientData *)inClientData;
    PaStreamCallbackTimeInfo *timeInfo = InitializeTimeInfo(inNow, inInputTime, inOutputTime);

    PaUtil_BeginCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer );

    AudioBuffer const *inputBuffer = &inInputData->mBuffers[0];
    unsigned long frameCount = inputBuffer->mDataByteSize / (inputBuffer->mNumberChannels * sizeof(Float32));

    CopyInputData(clientData, inInputData, frameCount);
    PaStreamCallbackResult result = clientData->callback(clientData->inputBuffer, clientData->outputBuffer, frameCount, timeInfo, paNoFlag, clientData->userData);
    
    PaUtil_EndCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer, frameCount );
    if( result == paComplete || result == paAbort )
       Pa_StopStream(clientData->stream);
    PaUtil_FreeMemory( timeInfo );
    return noErr;
}

// This is not for output-only streams, this is for streams where the input device is different from the output device
static OSStatus AudioOutputProc( AudioDeviceID inDevice,
                          const AudioTimeStamp* inNow,
                          const AudioBufferList* inInputData,
                          const AudioTimeStamp* inInputTime,
                          AudioBufferList* outOutputData, 
                          const AudioTimeStamp* inOutputTime,
                          void* inClientData)
{
    PaMacClientData *clientData = (PaMacClientData *)inClientData;
    //PaStreamCallbackTimeInfo *timeInfo = InitializeTimeInfo(inNow, inInputTime, inOutputTime);

    PaUtil_BeginCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer );

    AudioBuffer *outputBuffer = &outOutputData->mBuffers[0];
    unsigned long frameCount = outputBuffer->mDataByteSize / (outputBuffer->mNumberChannels * sizeof(Float32));

    //clientData->callback(NULL, clientData->outputBuffer, frameCount, timeInfo, paNoFlag, clientData->userData);

    CopyOutputData(outOutputData, clientData, frameCount);

    PaUtil_EndCpuLoadMeasurement( &clientData->stream->cpuLoadMeasurer, frameCount );
    return noErr;
}

static PaError SetSampleRate(AudioDeviceID device, double sampleRate, int isInput)
{
    PaError result = paNoError;
    
    double actualSampleRate;
    UInt32 propSize = sizeof(double);
    result = conv_err(AudioDeviceSetProperty(device, NULL, 0, isInput, kAudioDevicePropertyNominalSampleRate, propSize, &sampleRate));
    
    result = conv_err(AudioDeviceGetProperty(device, 0, isInput, kAudioDevicePropertyNominalSampleRate, &propSize, &actualSampleRate));
    
    if (result == paNoError && actualSampleRate != sampleRate) {
        result = paInvalidSampleRate;
    }
    
    return result;    
}

static PaError SetFramesPerBuffer(AudioDeviceID device, unsigned long framesPerBuffer, int isInput)
{
    PaError result = paNoError;
    UInt32 preferredFramesPerBuffer = framesPerBuffer;
    //    while (preferredFramesPerBuffer > UINT32_MAX) {
    //        preferredFramesPerBuffer /= 2;
    //    }
    
    UInt32 actualFramesPerBuffer;
    UInt32 propSize = sizeof(UInt32);
    result = conv_err(AudioDeviceSetProperty(device, NULL, 0, isInput, kAudioDevicePropertyBufferFrameSize, propSize, &preferredFramesPerBuffer));
    
    result = conv_err(AudioDeviceGetProperty(device, 0, isInput, kAudioDevicePropertyBufferFrameSize, &propSize, &actualFramesPerBuffer));
    
    if (result != paNoError) {
        // do nothing
    }
    else if (actualFramesPerBuffer > framesPerBuffer) {
        result = paBufferTooSmall;
    }
    else if (actualFramesPerBuffer < framesPerBuffer) {
        result = paBufferTooBig;
    }
    
    return result;    
}
    
static PaError SetUpUnidirectionalStream(AudioDeviceID device, double sampleRate, unsigned long framesPerBuffer, int isInput)
{
    PaError err = paNoError;
    err = SetSampleRate(device, sampleRate, isInput);
    if( err == paNoError )
        err = SetFramesPerBuffer(device, framesPerBuffer, isInput);
    return err;
}

// =====  PortAudio functions  =====
#pragma mark PortAudio functions

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
    
    PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
    
#ifdef __cplusplus
}
#endif // __cplusplus

static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaMacCoreHostApiRepresentation *macCoreHostApi = (PaMacCoreHostApiRepresentation*)hostApi;
    
    CleanUp(macCoreHostApi);
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaMacCoreHostApiRepresentation *macCoreHostApi = (PaMacCoreHostApiRepresentation*)hostApi;
    PaDeviceInfo *deviceInfo;
    
    PaError result = paNoError;
    if (inputParameters) {
        deviceInfo = macCoreHostApi->inheritedHostApiRep.deviceInfos[inputParameters->device];
        if (inputParameters->channelCount > deviceInfo->maxInputChannels)
            result = paInvalidChannelCount;
        else if (CheckFormat(macCoreHostApi->macCoreDeviceIds[inputParameters->device], inputParameters, sampleRate, 1) != kAudioHardwareNoError) {
            result = paInvalidSampleRate;
        }
    }
    if (outputParameters && result == paNoError) {
        deviceInfo = macCoreHostApi->inheritedHostApiRep.deviceInfos[outputParameters->device];
        if (outputParameters->channelCount > deviceInfo->maxOutputChannels)
            result = paInvalidChannelCount;
        else if (CheckFormat(macCoreHostApi->macCoreDeviceIds[outputParameters->device], outputParameters, sampleRate, 0) != kAudioHardwareNoError) {
            result = paInvalidSampleRate;
        }
    }

    return result;
}

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError err = paNoError;
    PaMacCoreHostApiRepresentation *macCoreHostApi = (PaMacCoreHostApiRepresentation *)hostApi;
    PaMacCoreStream *stream = PaUtil_AllocateMemory(sizeof(PaMacCoreStream));
    stream->isActive = 0;
    stream->isStopped = 1;
    stream->inputDevice = kAudioDeviceUnknown;
    stream->outputDevice = kAudioDeviceUnknown;
    
    PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                           ( (streamCallback)
                                             ? &macCoreHostApi->callbackStreamInterface
                                             : &macCoreHostApi->blockingStreamInterface ),
                                           streamCallback, userData );
    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );
    
    *s = (PaStream*)stream;
    PaMacClientData *clientData = PaUtil_AllocateMemory(sizeof(PaMacClientData));
    clientData->stream = stream;
    clientData->callback = streamCallback;
    clientData->userData = userData;
    clientData->inputBuffer = 0;
    clientData->outputBuffer = 0;
    clientData->ditherGenerator = PaUtil_AllocateMemory(sizeof(PaUtilTriangularDitherGenerator));
    PaUtil_InitializeTriangularDitherState(clientData->ditherGenerator);
    
    if (inputParameters != NULL) {
        stream->inputDevice = macCoreHostApi->macCoreDeviceIds[inputParameters->device];
        clientData->inputConverter = PaUtil_SelectConverter(paFloat32, inputParameters->sampleFormat, streamFlags);
        clientData->inputBuffer = PaUtil_AllocateMemory(Pa_GetSampleSize(inputParameters->sampleFormat) * framesPerBuffer * inputParameters->channelCount);
        clientData->inputChannelCount = inputParameters->channelCount;
        clientData->inputSampleFormat = inputParameters->sampleFormat;
        err = SetUpUnidirectionalStream(stream->inputDevice, sampleRate, framesPerBuffer, 1);
    }
    
    if (err == paNoError && outputParameters != NULL) {
        stream->outputDevice = macCoreHostApi->macCoreDeviceIds[outputParameters->device];
        clientData->outputConverter = PaUtil_SelectConverter(outputParameters->sampleFormat, paFloat32, streamFlags);
        clientData->outputBuffer = PaUtil_AllocateMemory(Pa_GetSampleSize(outputParameters->sampleFormat) * framesPerBuffer * outputParameters->channelCount);
        clientData->outputChannelCount = outputParameters->channelCount;
        clientData->outputSampleFormat = outputParameters->sampleFormat;
        err = SetUpUnidirectionalStream(stream->outputDevice, sampleRate, framesPerBuffer, 0);
    }

    if (inputParameters == NULL || outputParameters == NULL || stream->inputDevice == stream->outputDevice) {
        AudioDeviceID device = (inputParameters == NULL) ? stream->outputDevice : stream->inputDevice;

        AudioDeviceAddIOProc(device, AudioIOProc, clientData);
    }
    else {
        // using different devices for input and output
        AudioDeviceAddIOProc(stream->inputDevice, AudioInputProc, clientData);
        AudioDeviceAddIOProc(stream->outputDevice, AudioOutputProc, clientData);
    }
    
    return err;
}

// Note: When CloseStream() is called, the multi-api layer ensures that the stream has already been stopped or aborted.
static PaError CloseStream( PaStream* s )
{
    PaError err = paNoError;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;

    PaUtil_ResetCpuLoadMeasurer( &stream->cpuLoadMeasurer );

    if (stream->inputDevice != kAudioDeviceUnknown) {
        if (stream->outputDevice == kAudioDeviceUnknown || stream->outputDevice == stream->inputDevice) {
            err = conv_err(AudioDeviceRemoveIOProc(stream->inputDevice, AudioIOProc));
        }
        else {
            err = conv_err(AudioDeviceRemoveIOProc(stream->inputDevice, AudioInputProc));
            err = conv_err(AudioDeviceRemoveIOProc(stream->outputDevice, AudioOutputProc));
        }
    }
    else {
        err = conv_err(AudioDeviceRemoveIOProc(stream->outputDevice, AudioIOProc));
    }
    
    return err;
}


static PaError StartStream( PaStream *s )
{
    PaError err = paNoError;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;

    if (stream->inputDevice != kAudioDeviceUnknown) {
        if (stream->outputDevice == kAudioDeviceUnknown || stream->outputDevice == stream->inputDevice) {
            err = conv_err(AudioDeviceStart(stream->inputDevice, AudioIOProc));
        }
        else {
            err = conv_err(AudioDeviceStart(stream->inputDevice, AudioInputProc));
            err = conv_err(AudioDeviceStart(stream->outputDevice, AudioOutputProc));
        }
    }
    else {
        err = conv_err(AudioDeviceStart(stream->outputDevice, AudioIOProc));
    }
    
    stream->isActive = 1;
    stream->isStopped = 0;
    return err;
}

static PaError AbortStream( PaStream *s )
{
    PaError err = paNoError;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    
    if (stream->inputDevice != kAudioDeviceUnknown) {
        if (stream->outputDevice == kAudioDeviceUnknown || stream->outputDevice == stream->inputDevice) {
            err = conv_err(AudioDeviceStop(stream->inputDevice, AudioIOProc));
        }
        else {
            err = conv_err(AudioDeviceStop(stream->inputDevice, AudioInputProc));
            err = conv_err(AudioDeviceStop(stream->outputDevice, AudioOutputProc));
        }
    }
    else {
        err = conv_err(AudioDeviceStop(stream->outputDevice, AudioIOProc));
    }
    
    stream->isActive = 0;
    stream->isStopped = 1;
    return err;
}    

static PaError StopStream( PaStream *s )
{
    // TODO: this should be nicer than abort
    return AbortStream(s);
}

static PaError IsStreamStopped( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    
    return stream->isStopped;
}


static PaError IsStreamActive( PaStream *s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;

    return stream->isActive;
}


static PaTime GetStreamTime( PaStream *s )
{
    OSStatus err;
    PaTime result;
    PaMacCoreStream *stream = (PaMacCoreStream*)s;

    AudioTimeStamp *timeStamp = PaUtil_AllocateMemory(sizeof(AudioTimeStamp));
    if (stream->inputDevice != kAudioDeviceUnknown) {
        err = AudioDeviceGetCurrentTime(stream->inputDevice, timeStamp);
    }
    else {
        err = AudioDeviceGetCurrentTime(stream->outputDevice, timeStamp);
    }
    
    result = err ? 0 : timeStamp->mSampleTime;
    PaUtil_FreeMemory(timeStamp);

    return result;
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaMacCoreStream *stream = (PaMacCoreStream*)s;
    
    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}


// As separate stream interfaces are used for blocking and callback streams, the following functions can be guaranteed to only be called for blocking streams.

static PaError ReadStream( PaStream* s,
                           void *buffer,
                           unsigned long frames )
{
    return paInternalError;
}


static PaError WriteStream( PaStream* s,
                            const void *buffer,
                            unsigned long frames )
{
    return paInternalError;
}


static signed long GetStreamReadAvailable( PaStream* s )
{
    return paInternalError;
}


static signed long GetStreamWriteAvailable( PaStream* s )
{
    return paInternalError;
}

// HostAPI-specific initialization function
PaError PaMacCore_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaMacCoreHostApiRepresentation *macCoreHostApi = (PaMacCoreHostApiRepresentation *)PaUtil_AllocateMemory( sizeof(PaMacCoreHostApiRepresentation) );
    if( !macCoreHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }
    
    macCoreHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !macCoreHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }
    
    *hostApi = &macCoreHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paCoreAudio;
    (*hostApi)->info.name = "CoreAudio";

    result = InitializeDeviceInfos(macCoreHostApi, hostApiIndex);
    if (result != paNoError) {
        goto error;
    }
    
    // Set up the proper callbacks to this HostApi's functions
    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;
    
    PaUtil_InitializeStreamInterface( &macCoreHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );
    
    PaUtil_InitializeStreamInterface( &macCoreHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );
    
    return result;
    
error:
        if( macCoreHostApi ) {
            CleanUp(macCoreHostApi);
        }
    
    return result;
}
/*
 * Helper and utility functions for pa_mac_core.c (Apple AUHAL implementation)
 *
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Written by Bjorn Roche of XO Audio LLC, from PA skeleton code.
 * Portions copied from code by Dominic Mazzoni (who wrote a HAL implementation)
 *
 * Dominic's code was based on code by Phil Burk, Darren Gibbs,
 * Gord Peters, Stephane Letz, and Greg Pfiel.
 *
 * The following people also deserve acknowledgements:
 *
 * Olivier Tristan for feedback and testing
 * Glenn Zelniker and Z-Systems engineering for sponsoring the Blocking I/O
 * interface.
 * 
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

// (amalg) #include "pa_mac_core_utilities.h"
// (amalg) #include "pa_mac_core_internal.h"
#include <libkern/OSAtomic.h>
#include <strings.h>
#include <pthread.h>
#include <sys/time.h>

PaError PaMacCore_SetUnixError( int err, int line )
{
   PaError ret;
   const char *errorText;

   if( err == 0 )
   {
      return paNoError;
   }

   ret = paNoError;
   errorText = strerror( err );

   /** Map Unix error to PaError. Pretty much the only one that maps
       is ENOMEM. */
   if( err == ENOMEM )
      ret = paInsufficientMemory;
   else
      ret = paInternalError;

   DBUG(("%d on line %d: msg='%s'\n", err, line, errorText));
   PaUtil_SetLastHostErrorInfo( paCoreAudio, err, errorText );

   return ret;
}

/*
 * Translates MacOS generated errors into PaErrors
 */
PaError PaMacCore_SetError(OSStatus error, int line, int isError)
{
    /*FIXME: still need to handle possible ComponentResult values.*/
    /*       unfortunately, they don't seem to be documented anywhere.*/
    PaError result;
    const char *errorType; 
    const char *errorText;
    
    switch (error) {
    case kAudioHardwareNoError:
        return paNoError;
    case kAudioHardwareNotRunningError:
        errorText = "Audio Hardware Not Running";
        result = paInternalError; break;
    case kAudioHardwareUnspecifiedError: 
        errorText = "Unspecified Audio Hardware Error";
        result = paInternalError; break;
    case kAudioHardwareUnknownPropertyError:
        errorText = "Audio Hardware: Unknown Property";
        result = paInternalError; break;
    case kAudioHardwareBadPropertySizeError:
        errorText = "Audio Hardware: Bad Property Size";
        result = paInternalError; break;
    case kAudioHardwareIllegalOperationError: 
        errorText = "Audio Hardware: Illegal Operation";
        result = paInternalError; break;
    case kAudioHardwareBadDeviceError:
        errorText = "Audio Hardware: Bad Device";
        result = paInvalidDevice; break;
    case kAudioHardwareBadStreamError:
        errorText = "Audio Hardware: BadStream";
        result = paBadStreamPtr; break;
    case kAudioHardwareUnsupportedOperationError:
        errorText = "Audio Hardware: Unsupported Operation";
        result = paInternalError; break;
    case kAudioDeviceUnsupportedFormatError:
        errorText = "Audio Device: Unsupported Format";
        result = paSampleFormatNotSupported; break;
    case kAudioDevicePermissionsError:
        errorText = "Audio Device: Permissions Error";
        result = paDeviceUnavailable; break;
    /* Audio Unit Errors: http://developer.apple.com/documentation/MusicAudio/Reference/CoreAudio/audio_units/chapter_5_section_3.html */
    case kAudioUnitErr_InvalidProperty:
        errorText = "Audio Unit: Invalid Property";
        result = paInternalError; break;
    case kAudioUnitErr_InvalidParameter:
        errorText = "Audio Unit: Invalid Parameter";
        result = paInternalError; break;
    case kAudioUnitErr_NoConnection:
        errorText = "Audio Unit: No Connection";
        result = paInternalError; break;
    case kAudioUnitErr_FailedInitialization:
        errorText = "Audio Unit: Initialization Failed";
        result = paInternalError; break;
    case kAudioUnitErr_TooManyFramesToProcess:
        errorText = "Audio Unit: Too Many Frames";
        result = paInternalError; break;
    case kAudioUnitErr_IllegalInstrument:
        errorText = "Audio Unit: Illegal Instrument";
        result = paInternalError; break;
    case kAudioUnitErr_InstrumentTypeNotFound:
        errorText = "Audio Unit: Instrument Type Not Found";
        result = paInternalError; break;
    case kAudioUnitErr_InvalidFile:
        errorText = "Audio Unit: Invalid File";
        result = paInternalError; break;
    case kAudioUnitErr_UnknownFileType:
        errorText = "Audio Unit: Unknown File Type";
        result = paInternalError; break;
    case kAudioUnitErr_FileNotSpecified:
        errorText = "Audio Unit: File Not Specified";
        result = paInternalError; break;
    case kAudioUnitErr_FormatNotSupported:
        errorText = "Audio Unit: Format Not Supported";
        result = paInternalError; break;
    case kAudioUnitErr_Uninitialized:
        errorText = "Audio Unit: Unitialized";
        result = paInternalError; break;
    case kAudioUnitErr_InvalidScope:
        errorText = "Audio Unit: Invalid Scope";
        result = paInternalError; break;
    case kAudioUnitErr_PropertyNotWritable:
        errorText = "Audio Unit: PropertyNotWritable";
        result = paInternalError; break;
    case kAudioUnitErr_InvalidPropertyValue:
        errorText = "Audio Unit: Invalid Property Value";
        result = paInternalError; break;
    case kAudioUnitErr_PropertyNotInUse:
        errorText = "Audio Unit: Property Not In Use";
        result = paInternalError; break;
    case kAudioUnitErr_Initialized:
        errorText = "Audio Unit: Initialized";
        result = paInternalError; break;
    case kAudioUnitErr_InvalidOfflineRender:
        errorText = "Audio Unit: Invalid Offline Render";
        result = paInternalError; break;
    case kAudioUnitErr_Unauthorized:
        errorText = "Audio Unit: Unauthorized";
        result = paInternalError; break;
    case kAudioUnitErr_CannotDoInCurrentContext:
        errorText = "Audio Unit: cannot do in current context";
        result = paInternalError; break;
    default:
        errorText = "Unknown Error";
        result = paInternalError;
    }

    if (isError)
        errorType = "Error";
    else
        errorType = "Warning";

    char str[20];
    // see if it appears to be a 4-char-code
    *(UInt32 *)(str + 1) = CFSwapInt32HostToBig(error);
    if (isprint(str[1]) && isprint(str[2]) && isprint(str[3]) && isprint(str[4]))
    {
        str[0] = str[5] = '\'';
        str[6] = '\0';
    } else {
        // no, format it as an integer
        sprintf(str, "%d", (int)error);
    }

    DBUG(("%s on line %d: err='%s', msg=%s\n", errorType, line, str, errorText));

    PaUtil_SetLastHostErrorInfo( paCoreAudio, error, errorText );

    return result;
}

/*
 * This function computes an appropriate ring buffer size given
 * a requested latency (in seconds), sample rate and framesPerBuffer.
 *
 * The returned ringBufferSize is computed using the following
 * constraints:
 *   - it must be at least 4.
 *   - it must be at least 3x framesPerBuffer.
 *   - it must be at least 2x the suggestedLatency.
 *   - it must be a power of 2.
 * This function attempts to compute the minimum such size.
 *
 * FEEDBACK: too liberal/conservative/another way?
 */
long computeRingBufferSize( const PaStreamParameters *inputParameters,
                                   const PaStreamParameters *outputParameters,
                                   long inputFramesPerBuffer,
                                   long outputFramesPerBuffer,
                                   double sampleRate )
{
   long ringSize;
   int index;
   int i;
   double latency ;
   long framesPerBuffer ;

   VVDBUG(( "computeRingBufferSize()\n" ));

   assert( inputParameters || outputParameters );

   if( outputParameters && inputParameters )
   {
      latency = MAX( inputParameters->suggestedLatency, outputParameters->suggestedLatency );
      framesPerBuffer = MAX( inputFramesPerBuffer, outputFramesPerBuffer );
   } 
   else if( outputParameters )
   {
      latency = outputParameters->suggestedLatency;
      framesPerBuffer = outputFramesPerBuffer ;
   }
   else /* we have inputParameters  */
   {
      latency = inputParameters->suggestedLatency;
      framesPerBuffer = inputFramesPerBuffer ;
   }

   ringSize = (long) ( latency * sampleRate * 2 + .5);
   VDBUG( ( "suggested latency : %d\n", (int) (latency*sampleRate) ) );
   if( ringSize < framesPerBuffer * 3 )
      ringSize = framesPerBuffer * 3 ;
   VDBUG(("framesPerBuffer:%d\n",(int)framesPerBuffer));
   VDBUG(("Ringbuffer size (1): %d\n", (int)ringSize ));

   /* make sure it's at least 4 */
   ringSize = MAX( ringSize, 4 );

   /* round up to the next power of 2 */
   index = -1;
   for( i=0; i<sizeof(long)*8; ++i )
      if( ringSize >> i & 0x01 )
         index = i;
   assert( index > 0 );
   if( ringSize <= ( 0x01 << index ) )
      ringSize = 0x01 << index ;
   else
      ringSize = 0x01 << ( index + 1 );

   VDBUG(( "Final Ringbuffer size (2): %d\n", (int)ringSize ));
   return ringSize;
}


/*
 * Durring testing of core audio, I found that serious crashes could occur
 * if properties such as sample rate were changed multiple times in rapid
 * succession. The function below could be used to with a condition variable.
 * to prevent propertychanges from happening until the last property
 * change is acknowledged. Instead, I implemented a busy-wait, which is simpler
 * to implement b/c in second round of testing (nov '09) property changes occured
 * quickly and so there was no real way to test the condition variable implementation.
 * therefore, this function is not used, but it is aluded to in commented code below,
 * since it represents a theoretically better implementation.
 */

OSStatus propertyProc(
    AudioDeviceID inDevice, 
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID, 
    void* inClientData )
{
   // this is where we would set the condition variable
   return noErr;
}

/* sets the value of the given property and waits for the change to 
   be acknowledged, and returns the final value, which is not guaranteed
   by this function to be the same as the desired value. Obviously, this
   function can only be used for data whose input and output are the
   same size and format, and their size and format are known in advance.
   whether or not the call succeeds, if the data is successfully read,
   it is returned in outPropertyData. If it is not read successfully,
   outPropertyData is zeroed, which may or may not be useful in
   determining if the property was read. */
PaError AudioDeviceSetPropertyNowAndWaitForChange(
    AudioDeviceID inDevice,
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID,
    UInt32 inPropertyDataSize, 
    const void *inPropertyData,
    void *outPropertyData )
{
   OSStatus macErr;
   UInt32 outPropertyDataSize = inPropertyDataSize;

   /* First, see if it already has that value. If so, return. */
   macErr = AudioDeviceGetProperty( inDevice, inChannel,
                                 isInput, inPropertyID, 
                                 &outPropertyDataSize, outPropertyData );
   if( macErr ) {
      memset( outPropertyData, 0, inPropertyDataSize );
      goto failMac;
   }
   if( inPropertyDataSize!=outPropertyDataSize )
      return paInternalError;
   if( 0==memcmp( outPropertyData, inPropertyData, outPropertyDataSize ) )
      return paNoError;

   /* Ideally, we'd use a condition variable to determine changes.
      we could set that up here. */

   /* If we were using a cond variable, we'd do something useful here,
      but for now, this is just to make 10.6 happy. */
   macErr = AudioDeviceAddPropertyListener( inDevice, inChannel, isInput,
                                   inPropertyID, propertyProc,
                                   NULL ); 
   if( macErr )
      /* we couldn't add a listener. */
      goto failMac;

   /* set property */
   macErr  = AudioDeviceSetProperty( inDevice, NULL, inChannel,
                                 isInput, inPropertyID,
                                 inPropertyDataSize, inPropertyData );
   if( macErr )
      goto failMac;

   /* busy-wait up to 30 seconds for the property to change */
   /* busy-wait is justified here only because the correct alternative (condition variable)
      was hard to test, since most of the waiting ended up being for setting rather than
      getting in OS X 10.5. This was not the case in earlier OS versions. */
   struct timeval tv1, tv2;
   gettimeofday( &tv1, NULL );
   memcpy( &tv2, &tv1, sizeof( struct timeval ) );
   while( tv2.tv_sec - tv1.tv_sec < 30 ) {
      /* now read the property back out */
      macErr = AudioDeviceGetProperty( inDevice, inChannel,
                                    isInput, inPropertyID, 
                                    &outPropertyDataSize, outPropertyData );
      if( macErr ) {
         memset( outPropertyData, 0, inPropertyDataSize );
         goto failMac;
      }
      /* and compare... */
      if( 0==memcmp( outPropertyData, inPropertyData, outPropertyDataSize ) ) {
         AudioDeviceRemovePropertyListener( inDevice, inChannel, isInput, inPropertyID, propertyProc );
         return paNoError;
      }
      /* No match yet, so let's sleep and try again. */
      Pa_Sleep( 100 );
      gettimeofday( &tv2, NULL );
   }
   DBUG( ("Timeout waiting for device setting.\n" ) );
   
   AudioDeviceRemovePropertyListener( inDevice, inChannel, isInput, inPropertyID, propertyProc );
   return paNoError;

 failMac:
   AudioDeviceRemovePropertyListener( inDevice, inChannel, isInput, inPropertyID, propertyProc );
   return ERR( macErr );
}

/*
 * Sets the sample rate the HAL device.
 * if requireExact: set the sample rate or fail.
 *
 * otherwise      : set the exact sample rate.
 *             If that fails, check for available sample rates, and choose one
 *             higher than the requested rate. If there isn't a higher one,
 *             just use the highest available.
 */
PaError setBestSampleRateForDevice( const AudioDeviceID device,
                                    const bool isOutput,
                                    const bool requireExact,
                                    const Float64 desiredSrate )
{
   const bool isInput = isOutput ? 0 : 1;
   Float64 srate;
   UInt32 propsize = sizeof( Float64 );
   OSErr err;
   AudioValueRange *ranges;
   int i=0;
   Float64 max  = -1; /*the maximum rate available*/
   Float64 best = -1; /*the lowest sample rate still greater than desired rate*/
   VDBUG(("Setting sample rate for device %ld to %g.\n",device,(float)desiredSrate));

   /* -- try setting the sample rate -- */
   srate = 0;
   err = AudioDeviceSetPropertyNowAndWaitForChange(
                                 device, 0, isInput,
                                 kAudioDevicePropertyNominalSampleRate,
                                 propsize, &desiredSrate, &srate );

   /* -- if the rate agrees, and was changed, we are done -- */
   if( srate != 0 && srate == desiredSrate )
      return paNoError;
   /* -- if the rate agrees, and we got no errors, we are done -- */
   if( !err && srate == desiredSrate )
      return paNoError;
   /* -- we've failed if the rates disagree and we are setting input -- */
   if( requireExact )
      return paInvalidSampleRate;

   /* -- generate a list of available sample rates -- */
   err = AudioDeviceGetPropertyInfo( device, 0, isInput,
                                kAudioDevicePropertyAvailableNominalSampleRates,
                                &propsize, NULL );
   if( err )
      return ERR( err );
   ranges = (AudioValueRange *)calloc( 1, propsize );
   if( !ranges )
      return paInsufficientMemory;
   err = AudioDeviceGetProperty( device, 0, isInput,
                                kAudioDevicePropertyAvailableNominalSampleRates,
                                &propsize, ranges );
   if( err )
   {
      free( ranges );
      return ERR( err );
   }
   VDBUG(("Requested sample rate of %g was not available.\n", (float)desiredSrate));
   VDBUG(("%lu Available Sample Rates are:\n",propsize/sizeof(AudioValueRange)));
#ifdef MAC_CORE_VERBOSE_DEBUG
   for( i=0; i<propsize/sizeof(AudioValueRange); ++i )
      VDBUG( ("\t%g-%g\n",
              (float) ranges[i].mMinimum,
              (float) ranges[i].mMaximum ) );
#endif
   VDBUG(("-----\n"));
   
   /* -- now pick the best available sample rate -- */
   for( i=0; i<propsize/sizeof(AudioValueRange); ++i )
   {
      if( ranges[i].mMaximum > max ) max = ranges[i].mMaximum;
      if( ranges[i].mMinimum > desiredSrate ) {
         if( best < 0 )
            best = ranges[i].mMinimum;
         else if( ranges[i].mMinimum < best )
            best = ranges[i].mMinimum;
      }
   }
   if( best < 0 )
      best = max;
   VDBUG( ("Maximum Rate %g. best is %g.\n", max, best ) );
   free( ranges );

   /* -- set the sample rate -- */
   propsize = sizeof( best );
   srate = 0;
   err = AudioDeviceSetPropertyNowAndWaitForChange(
                                 device, 0, isInput,
                                 kAudioDevicePropertyNominalSampleRate,
                                 propsize, &best, &srate );

   /* -- if the set rate matches, we are done -- */
   if( srate != 0 && srate == best )
      return paNoError;

   if( err )
      return ERR( err );

   /* -- otherwise, something wierd happened: we didn't set the rate, and we got no errors. Just bail. */
   return paInternalError;
}


/*
   Attempts to set the requestedFramesPerBuffer. If it can't set the exact
   value, it settles for something smaller if available. If nothing smaller
   is available, it uses the smallest available size.
   actualFramesPerBuffer will be set to the actual value on successful return.
   OK to pass NULL to actualFramesPerBuffer.
   The logic is very simmilar too setBestSampleRate only failure here is
   not usually catastrophic.
*/
PaError setBestFramesPerBuffer( const AudioDeviceID device,
                                const bool isOutput,
                                UInt32 requestedFramesPerBuffer, 
                                UInt32 *actualFramesPerBuffer )
{
    UInt32 afpb;
    const bool isInput = !isOutput;
    UInt32 propsize = sizeof(UInt32);
    OSErr err;
    AudioValueRange range;

    if( actualFramesPerBuffer == NULL )
    {
        actualFramesPerBuffer = &afpb;
    }

    /* -- try and set exact FPB -- */
    err = AudioDeviceSetProperty( device, NULL, 0, isInput,
                                 kAudioDevicePropertyBufferFrameSize,
                                 propsize, &requestedFramesPerBuffer);
    err = AudioDeviceGetProperty( device, 0, isInput,
                           kAudioDevicePropertyBufferFrameSize,
                           &propsize, actualFramesPerBuffer);
    if( err )
    {
        return ERR( err );
    }
    // Did we get the size we asked for?
    if( *actualFramesPerBuffer == requestedFramesPerBuffer )
    {
        return paNoError; /* we are done */
    }
    
    // Clip requested value against legal range for the device.
    propsize = sizeof(AudioValueRange);
    err = AudioDeviceGetProperty( device, 0, isInput,
                                kAudioDevicePropertyBufferFrameSizeRange,
                                &propsize, &range );
    if( err )
    {
      return ERR( err );
    }
    if( requestedFramesPerBuffer < range.mMinimum )
    {
        requestedFramesPerBuffer = range.mMinimum;
    }
    else if( requestedFramesPerBuffer > range.mMaximum )
    {
        requestedFramesPerBuffer = range.mMaximum;
    }
    
   /* --- set the buffer size (ignore errors) -- */
    propsize = sizeof( UInt32 );
   err = AudioDeviceSetProperty( device, NULL, 0, isInput,
                                 kAudioDevicePropertyBufferFrameSize,
                                 propsize, &requestedFramesPerBuffer );
   /* --- read the property to check that it was set -- */
   err = AudioDeviceGetProperty( device, 0, isInput,
                                 kAudioDevicePropertyBufferFrameSize,
                                 &propsize, actualFramesPerBuffer );

   if( err )
      return ERR( err );

   return paNoError;
}

/**********************
 *
 * XRun stuff
 *
 **********************/

struct PaMacXRunListNode_s {
   PaMacCoreStream *stream;
   struct PaMacXRunListNode_s *next;
} ;

typedef struct PaMacXRunListNode_s PaMacXRunListNode;

/** Always empty, so that it can always be the one returned by
    addToXRunListenerList. note that it's not a pointer. */
static PaMacXRunListNode firstXRunListNode;
static int xRunListSize;
static pthread_mutex_t xrunMutex;

OSStatus xrunCallback(
    AudioDeviceID inDevice, 
    UInt32 inChannel, 
    Boolean isInput, 
    AudioDevicePropertyID inPropertyID, 
    void* inClientData)
{
   PaMacXRunListNode *node = (PaMacXRunListNode *) inClientData;

   int ret = pthread_mutex_trylock( &xrunMutex ) ;

   if( ret == 0 ) {

      node = node->next ; //skip the first node

      for( ; node; node=node->next ) {
         PaMacCoreStream *stream = node->stream;

         if( stream->state != ACTIVE )
            continue; //if the stream isn't active, we don't care if the device is dropping

         if( isInput ) {
            if( stream->inputDevice == inDevice )
               OSAtomicOr32( paInputOverflow, &stream->xrunFlags );
         } else {
            if( stream->outputDevice == inDevice )
               OSAtomicOr32( paOutputUnderflow, &stream->xrunFlags );
         }
      }

      pthread_mutex_unlock( &xrunMutex );
   }

   return 0;
}

int initializeXRunListenerList()
{
   xRunListSize = 0;
   bzero( (void *) &firstXRunListNode, sizeof(firstXRunListNode) );
   return pthread_mutex_init( &xrunMutex, NULL );
}
int destroyXRunListenerList()
{
   PaMacXRunListNode *node;
   node = firstXRunListNode.next;
   while( node ) {
      PaMacXRunListNode *tmp = node;
      node = node->next;
      free( tmp );
   }
   xRunListSize = 0;
   return pthread_mutex_destroy( &xrunMutex );
}

void *addToXRunListenerList( void *stream )
{
   pthread_mutex_lock( &xrunMutex );
   PaMacXRunListNode *newNode;
   // setup new node:
   newNode = (PaMacXRunListNode *) malloc( sizeof( PaMacXRunListNode ) );
   newNode->stream = (PaMacCoreStream *) stream;
   newNode->next = firstXRunListNode.next;
   // insert:
   firstXRunListNode.next = newNode;
   pthread_mutex_unlock( &xrunMutex );

   return &firstXRunListNode;
}

int removeFromXRunListenerList( void *stream )
{
   pthread_mutex_lock( &xrunMutex );
   PaMacXRunListNode *node, *prev;
   prev = &firstXRunListNode;
   node = firstXRunListNode.next;
   while( node ) {
      if( node->stream == stream ) {
         //found it:
         --xRunListSize;
         prev->next = node->next;
         free( node );
         pthread_mutex_unlock( &xrunMutex );
         return xRunListSize;
      }
      prev = prev->next;
      node = node->next;
   }

   pthread_mutex_unlock( &xrunMutex );
   // failure
   return xRunListSize;
}
#endif

#if PA_USE_DS
/*
 * Interface for dynamically loading directsound and providing a dummy
 * implementation if it isn't present.
 *
 * Author: Ross Bencina (some portions Phil Burk & Robert Marsanyi)
 *
 * For PortAudio Portable Real-Time Audio Library
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2006 Phil Burk, Robert Marsanyi and Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#ifndef INCLUDED_PA_DSOUND_DYNLINK_H
#define INCLUDED_PA_DSOUND_DYNLINK_H

/* on Borland compilers, WIN32 doesn't seem to be defined by default, which
    breaks dsound.h. Adding the define here fixes the problem. - rossb. */
#ifdef __BORLANDC__
#if !defined(WIN32)
#define WIN32
#endif
#endif

/*
  Use the earliest version of DX required, no need to polute the namespace
*/
#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
#define DIRECTSOUND_VERSION 0x0800
#else
#define DIRECTSOUND_VERSION 0x0300
#endif
#include <dsound.h>

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


typedef struct
{
    HINSTANCE hInstance_;
    
    HRESULT (WINAPI *DllGetClassObject)(REFCLSID , REFIID , LPVOID *);

    HRESULT (WINAPI *DirectSoundCreate)(LPGUID, LPDIRECTSOUND *, LPUNKNOWN);
    HRESULT (WINAPI *DirectSoundEnumerateW)(LPDSENUMCALLBACKW, LPVOID);
    HRESULT (WINAPI *DirectSoundEnumerateA)(LPDSENUMCALLBACKA, LPVOID);

    HRESULT (WINAPI *DirectSoundCaptureCreate)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
    HRESULT (WINAPI *DirectSoundCaptureEnumerateW)(LPDSENUMCALLBACKW, LPVOID);
    HRESULT (WINAPI *DirectSoundCaptureEnumerateA)(LPDSENUMCALLBACKA, LPVOID);

#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
    HRESULT (WINAPI *DirectSoundFullDuplexCreate8)(
                LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC,
                HWND, DWORD, LPDIRECTSOUNDFULLDUPLEX *, LPDIRECTSOUNDCAPTUREBUFFER8 *, 
                LPDIRECTSOUNDBUFFER8 *, LPUNKNOWN );
#endif
}PaWinDsDSoundEntryPoints;

extern PaWinDsDSoundEntryPoints paWinDsDSoundEntryPoints;

void PaWinDs_InitializeDSoundEntryPoints(void);
void PaWinDs_TerminateDSoundEntryPoints(void);


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* INCLUDED_PA_DSOUND_DYNLINK_H */
/*
 * $Id$
 * Portable Audio I/O Library DirectSound implementation
 *
 * Authors: Phil Burk, Robert Marsanyi & Ross Bencina
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2007 Ross Bencina, Phil Burk, Robert Marsanyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/** @file
 @ingroup hostapi_src
*/

/* Until May 2011 PA/DS has used a multimedia timer to perform the callback.
   We're replacing this with a new implementation using a thread and a different timer mechanim.
   Defining PA_WIN_DS_USE_WMME_TIMER uses the old (pre-May 2011) behavior.
*/
//#define PA_WIN_DS_USE_WMME_TIMER

#include <assert.h>
#include <stdio.h>
#include <string.h> /* strlen() */

#define _WIN32_WINNT 0x0400 /* required to get waitable timer APIs */
#include <initguid.h> /* make sure ds guids get defined */
#include <windows.h>
#include <objbase.h>


/*
  Use the earliest version of DX required, no need to polute the namespace
*/
#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
#define DIRECTSOUND_VERSION 0x0800
#else
#define DIRECTSOUND_VERSION 0x0300
#endif
#include <dsound.h>
#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
#include <dsconf.h>
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */
#ifndef PA_WIN_DS_USE_WMME_TIMER
#ifndef UNDER_CE
#include <process.h>
#endif
#endif

// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_debugprint.h"

// (amalg) #include "pa_win_ds.h"
// (amalg) #include "pa_win_ds_dynlink.h"
// (amalg) #include "pa_win_waveformat.h"
// (amalg) #include "pa_win_wdmks_utils.h"
// (amalg) #include "pa_win_coinitialize.h"

#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
#pragma comment( lib, "dsound.lib" )
#pragma comment( lib, "winmm.lib" )
#pragma comment( lib, "kernel32.lib" )
#endif

/* use CreateThread for CYGWIN, _beginthreadex for all others */
#ifndef PA_WIN_DS_USE_WMME_TIMER

#if !defined(__CYGWIN__) && !defined(UNDER_CE)
#define CREATE_THREAD (HANDLE)_beginthreadex
#undef CLOSE_THREAD_HANDLE /* as per documentation we don't call CloseHandle on a thread created with _beginthreadex */
#define PA_THREAD_FUNC static unsigned WINAPI
#define PA_THREAD_ID unsigned
#else
#define CREATE_THREAD CreateThread
#define CLOSE_THREAD_HANDLE CloseHandle
#define PA_THREAD_FUNC static DWORD WINAPI
#define PA_THREAD_ID DWORD
#endif

#if (defined(UNDER_CE))
#pragma comment(lib, "Coredll.lib")
#elif (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
#pragma comment(lib, "winmm.lib")
#endif

PA_THREAD_FUNC ProcessingThreadProc( void *pArg );

#if !defined(UNDER_CE)
#define PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT /* use waitable timer where possible, otherwise we use a WaitForSingleObject timeout */
#endif

#endif /* !PA_WIN_DS_USE_WMME_TIMER */


/*
 provided in newer platform sdks and x64
 */
#ifndef DWORD_PTR
    #if defined(_WIN64)
        #define DWORD_PTR unsigned __int64
    #else
        #define DWORD_PTR unsigned long
    #endif
#endif

#define PRINT(x) PA_DEBUG(x);
#define ERR_RPT(x) PRINT(x)
#define DBUG(x)   PRINT(x)
#define DBUGX(x)  PRINT(x)

#define PA_USE_HIGH_LATENCY   (0)
#if PA_USE_HIGH_LATENCY
#define PA_DS_WIN_9X_DEFAULT_LATENCY_     (.500)
#define PA_DS_WIN_NT_DEFAULT_LATENCY_     (.600)
#else
#define PA_DS_WIN_9X_DEFAULT_LATENCY_     (.140)
#define PA_DS_WIN_NT_DEFAULT_LATENCY_     (.280)
#endif

#define PA_DS_WIN_WDM_DEFAULT_LATENCY_    (.120)

/* we allow the polling period to range between 1 and 100ms.
   prior to August 2011 we limited the minimum polling period to 10ms.
*/
#define PA_DS_MINIMUM_POLLING_PERIOD_SECONDS    (0.001) /* 1ms */
#define PA_DS_MAXIMUM_POLLING_PERIOD_SECONDS    (0.100) /* 100ms */
#define PA_DS_POLLING_JITTER_SECONDS            (0.001) /* 1ms */

#define SECONDS_PER_MSEC      (0.001)
#define MSECS_PER_SECOND       (1000)

/* prototypes for functions declared in this file */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

PaError PaWinDs_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );


/* FIXME: should convert hr to a string */
#define PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr ) \
    PaUtil_SetLastHostErrorInfo( paDirectSound, hr, "DirectSound error" )

/************************************************* DX Prototypes **********/
static BOOL CALLBACK CollectGUIDsProcW(LPGUID lpGUID,
                                     LPCWSTR lpszDesc,
                                     LPCWSTR lpszDrvName,
                                     LPVOID lpContext );

/************************************************************************************/
/********************** Structures **************************************************/
/************************************************************************************/
/* PaWinDsHostApiRepresentation - host api datastructure specific to this implementation */

typedef struct PaWinDsDeviceInfo
{
    PaDeviceInfo        inheritedDeviceInfo;
    GUID                guid;
    GUID                *lpGUID;
    double              sampleRates[3];
    char deviceInputChannelCountIsKnown; /**<< if the system returns 0xFFFF then we don't really know the number of supported channels (1=>known, 0=>unknown)*/
    char deviceOutputChannelCountIsKnown; /**<< if the system returns 0xFFFF then we don't really know the number of supported channels (1=>known, 0=>unknown)*/
} PaWinDsDeviceInfo;

typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface    callbackStreamInterface;
    PaUtilStreamInterface    blockingStreamInterface;

    PaUtilAllocationGroup   *allocations;

    /* implementation specific data goes here */

    PaWinUtilComInitializationResult comInitializationResult;

} PaWinDsHostApiRepresentation;


/* PaWinDsStream - a stream data structure specifically for this implementation */

typedef struct PaWinDsStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

/* DirectSound specific data. */
#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
    LPDIRECTSOUNDFULLDUPLEX8 pDirectSoundFullDuplex8;
#endif

/* Output */
    LPDIRECTSOUND        pDirectSound;
    LPDIRECTSOUNDBUFFER  pDirectSoundPrimaryBuffer;
    LPDIRECTSOUNDBUFFER  pDirectSoundOutputBuffer;
    DWORD                outputBufferWriteOffsetBytes;     /* last write position */
    INT                  outputBufferSizeBytes;
    INT                  outputFrameSizeBytes;
    /* Try to detect play buffer underflows. */
    LARGE_INTEGER        perfCounterTicksPerBuffer; /* counter ticks it should take to play a full buffer */
    LARGE_INTEGER        previousPlayTime;
    DWORD                previousPlayCursor;
    UINT                 outputUnderflowCount;
    BOOL                 outputIsRunning;
    INT                  finalZeroBytesWritten; /* used to determine when we've flushed the whole buffer */

/* Input */
    LPDIRECTSOUNDCAPTURE pDirectSoundCapture;
    LPDIRECTSOUNDCAPTUREBUFFER   pDirectSoundInputBuffer;
    INT                  inputFrameSizeBytes;
    UINT                 readOffset;      /* last read position */
    UINT                 inputBufferSizeBytes;

    
    int              hostBufferSizeFrames; /* input and output host ringbuffers have the same number of frames */
    double           framesWritten;
    double           secondsPerHostByte; /* Used to optimize latency calculation for outTime */
    double           pollingPeriodSeconds;

    PaStreamCallbackFlags callbackFlags;

    PaStreamFlags    streamFlags;
    int              callbackResult;
    HANDLE           processingCompleted;
    
/* FIXME - move all below to PaUtilStreamRepresentation */
    volatile int     isStarted;
    volatile int     isActive;
    volatile int     stopProcessing; /* stop thread once existing buffers have been returned */
    volatile int     abortProcessing; /* stop thread immediately */

    UINT             systemTimerResolutionPeriodMs; /* set to 0 if we were unable to set the timer period */ 

#ifdef PA_WIN_DS_USE_WMME_TIMER
    MMRESULT         timerID;
#else

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT
    HANDLE           waitableTimer;
#endif
    HANDLE           processingThread;
    PA_THREAD_ID     processingThreadId;
    HANDLE           processingThreadCompleted;
#endif

} PaWinDsStream;


/* Set minimal latency based on the current OS version.
 * NT has higher latency.
 */
static double PaWinDS_GetMinSystemLatencySeconds( void )
{
/*
NOTE: GetVersionEx() is deprecated as of Windows 8.1 and can not be used to reliably detect
versions of Windows higher than Windows 8 (due to manifest requirements for reporting higher versions).
Microsoft recommends switching to VerifyVersionInfo (available on Win 2k and later), however GetVersionEx
is is faster, for now we just disable the deprecation warning.
See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724451(v=vs.85).aspx
See: http://www.codeproject.com/Articles/678606/Part-Overcoming-Windows-s-deprecation-of-GetVe
*/
#pragma warning (disable : 4996) /* use of GetVersionEx */

    double minLatencySeconds;
    /* Set minimal latency based on whether NT or other OS.
     * NT has higher latency.
     */

    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof( osvi );
    GetVersionEx( &osvi );
    DBUG(("PA - PlatformId = 0x%x\n", osvi.dwPlatformId ));
    DBUG(("PA - MajorVersion = 0x%x\n", osvi.dwMajorVersion ));
    DBUG(("PA - MinorVersion = 0x%x\n", osvi.dwMinorVersion ));
    /* Check for NT */
    if( (osvi.dwMajorVersion == 4) && (osvi.dwPlatformId == 2) )
    {
        minLatencySeconds = PA_DS_WIN_NT_DEFAULT_LATENCY_;
    }
    else if(osvi.dwMajorVersion >= 5)
    {
        minLatencySeconds = PA_DS_WIN_WDM_DEFAULT_LATENCY_;
    }
    else
    {
        minLatencySeconds = PA_DS_WIN_9X_DEFAULT_LATENCY_;
    }
    return minLatencySeconds;

#pragma warning (default : 4996)
}


/*************************************************************************
** Return minimum workable latency required for this host. This is returned
** As the default stream latency in PaDeviceInfo.
** Latency can be optionally set by user by setting an environment variable. 
** For example, to set latency to 200 msec, put:
**
**    set PA_MIN_LATENCY_MSEC=200
**
** in the AUTOEXEC.BAT file and reboot.
** If the environment variable is not set, then the latency will be determined
** based on the OS. Windows NT has higher latency than Win95.
*/
#define PA_LATENCY_ENV_NAME  ("PA_MIN_LATENCY_MSEC")
#define PA_ENV_BUF_SIZE  (32)

static double PaWinDs_GetMinLatencySeconds( double sampleRate )
{
    char      envbuf[PA_ENV_BUF_SIZE];
    DWORD     hresult;
    double    minLatencySeconds = 0;

    /* Let user determine minimal latency by setting environment variable. */
    hresult = GetEnvironmentVariableA( PA_LATENCY_ENV_NAME, envbuf, PA_ENV_BUF_SIZE );
    if( (hresult > 0) && (hresult < PA_ENV_BUF_SIZE) )
    {
        minLatencySeconds = atoi( envbuf ) * SECONDS_PER_MSEC;
    }
    else
    {
        minLatencySeconds = PaWinDS_GetMinSystemLatencySeconds();
#if PA_USE_HIGH_LATENCY
        PRINT(("PA - Minimum Latency set to %f msec!\n", minLatencySeconds * MSECS_PER_SECOND ));
#endif
    }

    return minLatencySeconds;
}


/************************************************************************************
** Duplicate and convert the input string using the group allocations allocator.
** A NULL string is converted to a zero length string.
** If memory cannot be allocated, NULL is returned.
**/
static char *DuplicateDeviceNameString( PaUtilAllocationGroup *allocations, const wchar_t* src )
{
    char *result = 0;
    
    if( src != NULL )
    {
#if !defined(_UNICODE) && !defined(UNICODE)
        size_t len = WideCharToMultiByte(CP_ACP, 0, src, -1, NULL, 0, NULL, NULL);

        result = (char*)PaUtil_GroupAllocateMemory( allocations, (long)(len + 1) );
        if( result ) {
            if (WideCharToMultiByte(CP_ACP, 0, src, -1, result, (int)len, NULL, NULL) == 0) {
                result = 0;
            }
        }
#else
        size_t len = WideCharToMultiByte(CP_UTF8, 0, src, -1, NULL, 0, NULL, NULL);

        result = (char*)PaUtil_GroupAllocateMemory( allocations, (long)(len + 1) );
        if( result ) {
            if (WideCharToMultiByte(CP_UTF8, 0, src, -1, result, (int)len, NULL, NULL) == 0) {
                result = 0;
            }
        }
#endif
    }
    else
    {
        result = (char*)PaUtil_GroupAllocateMemory( allocations, 1 );
        if( result )
            result[0] = '\0';
    }

    return result;
}

/************************************************************************************
** DSDeviceNameAndGUID, DSDeviceNameAndGUIDVector used for collecting preliminary
** information during device enumeration.
*/
typedef struct DSDeviceNameAndGUID{
    char *name; // allocated from parent's allocations, never deleted by this structure
    GUID guid;
    LPGUID lpGUID;
    void *pnpInterface;  // wchar_t* interface path, allocated using the DS host api's allocation group
} DSDeviceNameAndGUID;

typedef struct DSDeviceNameAndGUIDVector{
    PaUtilAllocationGroup *allocations;
    PaError enumerationError;

    int count;
    int free;
    DSDeviceNameAndGUID *items; // Allocated using LocalAlloc()
} DSDeviceNameAndGUIDVector;

typedef struct DSDeviceNamesAndGUIDs{
    PaWinDsHostApiRepresentation *winDsHostApi;
    DSDeviceNameAndGUIDVector inputNamesAndGUIDs;
    DSDeviceNameAndGUIDVector outputNamesAndGUIDs;
} DSDeviceNamesAndGUIDs;

static PaError InitializeDSDeviceNameAndGUIDVector(
        DSDeviceNameAndGUIDVector *guidVector, PaUtilAllocationGroup *allocations )
{
    PaError result = paNoError;

    guidVector->allocations = allocations;
    guidVector->enumerationError = paNoError;

    guidVector->count = 0;
    guidVector->free = 8;
    guidVector->items = (DSDeviceNameAndGUID*)LocalAlloc( LMEM_FIXED, sizeof(DSDeviceNameAndGUID) * guidVector->free );
    if( guidVector->items == NULL )
        result = paInsufficientMemory;
    
    return result;
}

static PaError ExpandDSDeviceNameAndGUIDVector( DSDeviceNameAndGUIDVector *guidVector )
{
    PaError result = paNoError;
    DSDeviceNameAndGUID *newItems;
    int i;
    
    /* double size of vector */
    int size = guidVector->count + guidVector->free;
    guidVector->free += size;

    newItems = (DSDeviceNameAndGUID*)LocalAlloc( LMEM_FIXED, sizeof(DSDeviceNameAndGUID) * size * 2 );
    if( newItems == NULL )
    {
        result = paInsufficientMemory;
    }
    else
    {
        for( i=0; i < guidVector->count; ++i )
        {
            newItems[i].name = guidVector->items[i].name;
            if( guidVector->items[i].lpGUID == NULL )
            {
                newItems[i].lpGUID = NULL;
            }
            else
            {
                newItems[i].lpGUID = &newItems[i].guid;
                memcpy( &newItems[i].guid, guidVector->items[i].lpGUID, sizeof(GUID) );
            }
            newItems[i].pnpInterface = guidVector->items[i].pnpInterface;
        }

        LocalFree( guidVector->items );
        guidVector->items = newItems;
    }                                

    return result;
}

/*
    it's safe to call DSDeviceNameAndGUIDVector multiple times
*/
static PaError TerminateDSDeviceNameAndGUIDVector( DSDeviceNameAndGUIDVector *guidVector )
{
    PaError result = paNoError;

    if( guidVector->items != NULL )
    {
        if( LocalFree( guidVector->items ) != NULL )
            result = paInsufficientMemory;              /** @todo this isn't the correct error to return from a deallocation failure */

        guidVector->items = NULL;
    }

    return result;
}

/************************************************************************************
** Collect preliminary device information during DirectSound enumeration 
*/
static BOOL CALLBACK CollectGUIDsProcW(LPGUID lpGUID,
                                     LPCWSTR lpszDesc,
                                     LPCWSTR lpszDrvName,
                                     LPVOID lpContext )
{
    DSDeviceNameAndGUIDVector *namesAndGUIDs = (DSDeviceNameAndGUIDVector*)lpContext;
    PaError error;

    (void) lpszDrvName; /* unused variable */

    if( namesAndGUIDs->free == 0 )
    {
        error = ExpandDSDeviceNameAndGUIDVector( namesAndGUIDs );
        if( error != paNoError )
        {
            namesAndGUIDs->enumerationError = error;
            return FALSE;
        }
    }
    
    /* Set GUID pointer, copy GUID to storage in DSDeviceNameAndGUIDVector. */
    if( lpGUID == NULL )
    {
        namesAndGUIDs->items[namesAndGUIDs->count].lpGUID = NULL;
    }
    else
    {
        namesAndGUIDs->items[namesAndGUIDs->count].lpGUID =
                &namesAndGUIDs->items[namesAndGUIDs->count].guid;
      
        memcpy( &namesAndGUIDs->items[namesAndGUIDs->count].guid, lpGUID, sizeof(GUID) );
    }

    namesAndGUIDs->items[namesAndGUIDs->count].name =
            DuplicateDeviceNameString( namesAndGUIDs->allocations, lpszDesc );
    if( namesAndGUIDs->items[namesAndGUIDs->count].name == NULL )
    {
        namesAndGUIDs->enumerationError = paInsufficientMemory;
        return FALSE;
    }

    namesAndGUIDs->items[namesAndGUIDs->count].pnpInterface = 0;

    ++namesAndGUIDs->count;
    --namesAndGUIDs->free;
    
    return TRUE;
}


#ifdef PAWIN_USE_WDMKS_DEVICE_INFO

static void *DuplicateWCharString( PaUtilAllocationGroup *allocations, wchar_t *source )
{
    size_t len;
    wchar_t *result;

    len = wcslen( source );
    result = (wchar_t*)PaUtil_GroupAllocateMemory( allocations, (long) ((len+1) * sizeof(wchar_t)) );
    wcscpy( result, source );
    return result;
}

static BOOL CALLBACK KsPropertySetEnumerateCallback( PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA data, LPVOID context )
{
    int i;
    DSDeviceNamesAndGUIDs *deviceNamesAndGUIDs = (DSDeviceNamesAndGUIDs*)context;

    /*
        Apparently data->Interface can be NULL in some cases. 
        Possibly virtual devices without hardware.
        So we check for NULLs now. See mailing list message November 10, 2012:
        "[Portaudio] portaudio initialization crash in KsPropertySetEnumerateCallback(pa_win_ds.c)"
    */
    if( data->Interface )
    {
        if( data->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER )
        {
            for( i=0; i < deviceNamesAndGUIDs->outputNamesAndGUIDs.count; ++i )
            {
                if( deviceNamesAndGUIDs->outputNamesAndGUIDs.items[i].lpGUID
                    && memcmp( &data->DeviceId, deviceNamesAndGUIDs->outputNamesAndGUIDs.items[i].lpGUID, sizeof(GUID) ) == 0 )
                {
                    deviceNamesAndGUIDs->outputNamesAndGUIDs.items[i].pnpInterface = 
                        (char*)DuplicateWCharString( deviceNamesAndGUIDs->winDsHostApi->allocations, data->Interface );
                    break;
                }
            }
        }
        else if( data->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE )
        {
            for( i=0; i < deviceNamesAndGUIDs->inputNamesAndGUIDs.count; ++i )
            {
                if( deviceNamesAndGUIDs->inputNamesAndGUIDs.items[i].lpGUID
                    && memcmp( &data->DeviceId, deviceNamesAndGUIDs->inputNamesAndGUIDs.items[i].lpGUID, sizeof(GUID) ) == 0 )
                {
                    deviceNamesAndGUIDs->inputNamesAndGUIDs.items[i].pnpInterface = 
                        (char*)DuplicateWCharString( deviceNamesAndGUIDs->winDsHostApi->allocations, data->Interface );
                    break;
                }
            }
        }
    }

    return TRUE;
}


static GUID pawin_CLSID_DirectSoundPrivate = 
{ 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x00, 0xc0, 0x4f, 0xc2, 0x8a, 0xca };

static GUID pawin_DSPROPSETID_DirectSoundDevice = 
{ 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x00, 0xc0, 0x4f, 0xc2, 0x8a, 0xca };

static GUID pawin_IID_IKsPropertySet = 
{ 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93 };


/*
    FindDevicePnpInterfaces fills in the pnpInterface fields in deviceNamesAndGUIDs
    with UNICODE file paths to the devices. The DS documentation mentions
    at least two techniques by which these Interface paths can be found using IKsPropertySet on
    the DirectSound class object. One is using the DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION 
    property, and the other is using DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE.
    I tried both methods and only the second worked. I found two postings on the
    net from people who had the same problem with the first method, so I think the method used here is 
    more common/likely to work. The probem is that IKsPropertySet_Get returns S_OK
    but the fields of the device description are not filled in.

    The mechanism we use works by registering an enumeration callback which is called for 
    every DSound device. Our callback searches for a device in our deviceNamesAndGUIDs list
    with the matching GUID and copies the pointer to the Interface path.
    Note that we could have used this enumeration callback to perform the original 
    device enumeration, however we choose not to so we can disable this step easily.

    Apparently the IKsPropertySet mechanism was added in DirectSound 9c 2004
    http://www.tech-archive.net/Archive/Development/microsoft.public.win32.programmer.mmedia/2004-12/0099.html

        -- rossb
*/
static void FindDevicePnpInterfaces( DSDeviceNamesAndGUIDs *deviceNamesAndGUIDs )
{
    IClassFactory *pClassFactory;
   
    if( paWinDsDSoundEntryPoints.DllGetClassObject(&pawin_CLSID_DirectSoundPrivate, &IID_IClassFactory, (PVOID *) &pClassFactory) == S_OK ){
        IKsPropertySet *pPropertySet;
        if( pClassFactory->lpVtbl->CreateInstance( pClassFactory, NULL, &pawin_IID_IKsPropertySet, (PVOID *) &pPropertySet) == S_OK ){
            
            DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA data;
            ULONG bytesReturned;

            data.Callback = KsPropertySetEnumerateCallback;
            data.Context = deviceNamesAndGUIDs;

            IKsPropertySet_Get( pPropertySet,
                &pawin_DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W,
                NULL,
                0,
                &data,
                sizeof(data),
                &bytesReturned
            );
            
            IKsPropertySet_Release( pPropertySet );
        }
        pClassFactory->lpVtbl->Release( pClassFactory );
    }

    /*
        The following code fragment, which I chose not to use, queries for the 
        device interface for a device with a specific GUID:

        ULONG BytesReturned;
        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA Property;

        memset (&Property, 0, sizeof(Property));
        Property.DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
        Property.DeviceId = *lpGUID;  

        hr = IKsPropertySet_Get( pPropertySet,
            &pawin_DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W,
            NULL,
            0,
            &Property,
            sizeof(Property),
            &BytesReturned
        );

        if( hr == S_OK )
        {
            //pnpInterface = Property.Interface;
        }
    */
}
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */


/* 
    GUIDs for emulated devices which we blacklist below.
    are there more than two of them??
*/

GUID IID_IRolandVSCEmulated1 = {0xc2ad1800, 0xb243, 0x11ce, 0xa8, 0xa4, 0x00, 0xaa, 0x00, 0x6c, 0x45, 0x01};
GUID IID_IRolandVSCEmulated2 = {0xc2ad1800, 0xb243, 0x11ce, 0xa8, 0xa4, 0x00, 0xaa, 0x00, 0x6c, 0x45, 0x02};


#define PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_  (13) /* must match array length below */
static double defaultSampleRateSearchOrder_[] =
    { 44100.0, 48000.0, 32000.0, 24000.0, 22050.0, 88200.0, 96000.0, 192000.0,
        16000.0, 12000.0, 11025.0, 9600.0, 8000.0 };

/************************************************************************************
** Extract capabilities from an output device, and add it to the device info list
** if successful. This function assumes that there is enough room in the
** device info list to accomodate all entries.
**
** The device will not be added to the device list if any errors are encountered.
*/
static PaError AddOutputDeviceInfoFromDirectSound(
        PaWinDsHostApiRepresentation *winDsHostApi, char *name, LPGUID lpGUID, char *pnpInterface )
{
    PaUtilHostApiRepresentation  *hostApi = &winDsHostApi->inheritedHostApiRep;
    PaWinDsDeviceInfo            *winDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[hostApi->info.deviceCount];
    PaDeviceInfo                 *deviceInfo = &winDsDeviceInfo->inheritedDeviceInfo;
    HRESULT                       hr;
    LPDIRECTSOUND                 lpDirectSound;
    DSCAPS                        caps;
    int                           deviceOK = TRUE;
    PaError                       result = paNoError;
    int                           i;

    /* Copy GUID to the device info structure. Set pointer. */
    if( lpGUID == NULL )
    {
        winDsDeviceInfo->lpGUID = NULL;
    }
    else
    {
        memcpy( &winDsDeviceInfo->guid, lpGUID, sizeof(GUID) );
        winDsDeviceInfo->lpGUID = &winDsDeviceInfo->guid;
    }
    
    if( lpGUID )
    {
        if (IsEqualGUID (&IID_IRolandVSCEmulated1,lpGUID) ||
            IsEqualGUID (&IID_IRolandVSCEmulated2,lpGUID) )
        {
            PA_DEBUG(("BLACKLISTED: %s \n",name));
            return paNoError;
        }
    }

    /* Create a DirectSound object for the specified GUID
        Note that using CoCreateInstance doesn't work on windows CE.
    */
    hr = paWinDsDSoundEntryPoints.DirectSoundCreate( lpGUID, &lpDirectSound, NULL );

    /** try using CoCreateInstance because DirectSoundCreate was hanging under
        some circumstances - note this was probably related to the
        #define BOOL short bug which has now been fixed
        @todo delete this comment and the following code once we've ensured
        there is no bug.
    */
    /*
    hr = CoCreateInstance( &CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER,
            &IID_IDirectSound, (void**)&lpDirectSound );

    if( hr == S_OK )
    {
        hr = IDirectSound_Initialize( lpDirectSound, lpGUID );
    }
    */
    
    if( hr != DS_OK )
    {
        if (hr == DSERR_ALLOCATED)
            PA_DEBUG(("AddOutputDeviceInfoFromDirectSound %s DSERR_ALLOCATED\n",name));
        DBUG(("Cannot create DirectSound for %s. Result = 0x%x\n", name, hr ));
        if (lpGUID)
            DBUG(("%s's GUID: {0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x, 0x%x} \n",
                 name,
                 lpGUID->Data1,
                 lpGUID->Data2,
                 lpGUID->Data3,
                 lpGUID->Data4[0],
                 lpGUID->Data4[1],
                 lpGUID->Data4[2],
                 lpGUID->Data4[3],
                 lpGUID->Data4[4],
                 lpGUID->Data4[5],
                 lpGUID->Data4[6],
                 lpGUID->Data4[7]));

        deviceOK = FALSE;
    }
    else
    {
        /* Query device characteristics. */
        memset( &caps, 0, sizeof(caps) ); 
        caps.dwSize = sizeof(caps);
        hr = IDirectSound_GetCaps( lpDirectSound, &caps );
        if( hr != DS_OK )
        {
            DBUG(("Cannot GetCaps() for DirectSound device %s. Result = 0x%x\n", name, hr ));
            deviceOK = FALSE;
        }
        else
        {

#if PA_USE_WMME
            if( caps.dwFlags & DSCAPS_EMULDRIVER )
            {
                /* If WMME supported, then reject Emulated drivers because they are lousy. */
                deviceOK = FALSE;
            }
#endif

            if( deviceOK )
            {
                deviceInfo->maxInputChannels = 0;
                winDsDeviceInfo->deviceInputChannelCountIsKnown = 1;

                /* DS output capabilities only indicate supported number of channels
                   using two flags which indicate mono and/or stereo.
                   We assume that stereo devices may support more than 2 channels
                   (as is the case with 5.1 devices for example) and so
                   set deviceOutputChannelCountIsKnown to 0 (unknown).
                   In this case OpenStream will try to open the device
                   when the user requests more than 2 channels, rather than
                   returning an error. 
                */
                if( caps.dwFlags & DSCAPS_PRIMARYSTEREO )
                {
                    deviceInfo->maxOutputChannels = 2;
                    winDsDeviceInfo->deviceOutputChannelCountIsKnown = 0;
                }
                else
                {
                    deviceInfo->maxOutputChannels = 1;
                    winDsDeviceInfo->deviceOutputChannelCountIsKnown = 1;
                }

                /* Guess channels count from speaker configuration. We do it only when 
                   pnpInterface is NULL or when PAWIN_USE_WDMKS_DEVICE_INFO is undefined.
                */
#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
                if( !pnpInterface )
#endif
                {
                    DWORD spkrcfg;
                    if( SUCCEEDED(IDirectSound_GetSpeakerConfig( lpDirectSound, &spkrcfg )) )
                    {
                        int count = 0;
                        switch (DSSPEAKER_CONFIG(spkrcfg))
                        {
                            case DSSPEAKER_HEADPHONE:        count = 2; break;
                            case DSSPEAKER_MONO:             count = 1; break;
                            case DSSPEAKER_QUAD:             count = 4; break;
                            case DSSPEAKER_STEREO:           count = 2; break;
                            case DSSPEAKER_SURROUND:         count = 4; break;
                            case DSSPEAKER_5POINT1:          count = 6; break;
                            case DSSPEAKER_7POINT1:          count = 8; break;
#ifndef DSSPEAKER_7POINT1_SURROUND
#define DSSPEAKER_7POINT1_SURROUND 0x00000008
#endif                            
                            case DSSPEAKER_7POINT1_SURROUND: count = 8; break;
#ifndef DSSPEAKER_5POINT1_SURROUND
#define DSSPEAKER_5POINT1_SURROUND 0x00000009
#endif
                            case DSSPEAKER_5POINT1_SURROUND: count = 6; break;
                        }
                        if( count )
                        {
                            deviceInfo->maxOutputChannels = count;
                            winDsDeviceInfo->deviceOutputChannelCountIsKnown = 1;
                        }
                    }
                }

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
                if( pnpInterface )
                {
                    int count = PaWin_WDMKS_QueryFilterMaximumChannelCount( pnpInterface, /* isInput= */ 0  );
                    if( count > 0 )
                    {
                        deviceInfo->maxOutputChannels = count;
                        winDsDeviceInfo->deviceOutputChannelCountIsKnown = 1;
                    }
                }
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

                /* initialize defaultSampleRate */
                
                if( caps.dwFlags & DSCAPS_CONTINUOUSRATE )
                {
                    /* initialize to caps.dwMaxSecondarySampleRate incase none of the standard rates match */
                    deviceInfo->defaultSampleRate = caps.dwMaxSecondarySampleRate;

                    for( i = 0; i < PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_; ++i )
                    {
                        if( defaultSampleRateSearchOrder_[i] >= caps.dwMinSecondarySampleRate
                                && defaultSampleRateSearchOrder_[i] <= caps.dwMaxSecondarySampleRate )
                        {
                            deviceInfo->defaultSampleRate = defaultSampleRateSearchOrder_[i];
                            break;
                        }
                    }
                }
                else if( caps.dwMinSecondarySampleRate == caps.dwMaxSecondarySampleRate )
                {
                    if( caps.dwMinSecondarySampleRate == 0 )
                    {
                        /*
                        ** On my Thinkpad 380Z, DirectSoundV6 returns min-max=0 !!
                        ** But it supports continuous sampling.
                        ** So fake range of rates, and hope it really supports it.
                        */
                        deviceInfo->defaultSampleRate = 48000.0f;  /* assume 48000 as the default */

                        DBUG(("PA - Reported rates both zero. Setting to fake values for device #%s\n", name ));
                    }
                    else
                    {
                        deviceInfo->defaultSampleRate = caps.dwMaxSecondarySampleRate;
                    }
                }
                else if( (caps.dwMinSecondarySampleRate < 1000.0) && (caps.dwMaxSecondarySampleRate > 50000.0) )
                {
                    /* The EWS88MT drivers lie, lie, lie. The say they only support two rates, 100 & 100000.
                    ** But we know that they really support a range of rates!
                    ** So when we see a ridiculous set of rates, assume it is a range.
                    */
                  deviceInfo->defaultSampleRate = 48000.0f;  /* assume 48000 as the default */
                  DBUG(("PA - Sample rate range used instead of two odd values for device #%s\n", name ));
                }
                else deviceInfo->defaultSampleRate = caps.dwMaxSecondarySampleRate;

                //printf( "min %d max %d\n", caps.dwMinSecondarySampleRate, caps.dwMaxSecondarySampleRate );
                // dwFlags | DSCAPS_CONTINUOUSRATE 

                deviceInfo->defaultLowInputLatency = 0.;
                deviceInfo->defaultHighInputLatency = 0.;

                deviceInfo->defaultLowOutputLatency = PaWinDs_GetMinLatencySeconds( deviceInfo->defaultSampleRate );
                deviceInfo->defaultHighOutputLatency = deviceInfo->defaultLowOutputLatency * 2;
            }
        }

        IDirectSound_Release( lpDirectSound );
    }

    if( deviceOK )
    {
        deviceInfo->name = name;

        if( lpGUID == NULL )
            hostApi->info.defaultOutputDevice = hostApi->info.deviceCount;
            
        hostApi->info.deviceCount++;
    }

    return result;
}


/************************************************************************************
** Extract capabilities from an input device, and add it to the device info list
** if successful. This function assumes that there is enough room in the
** device info list to accomodate all entries.
**
** The device will not be added to the device list if any errors are encountered.
*/
static PaError AddInputDeviceInfoFromDirectSoundCapture(
        PaWinDsHostApiRepresentation *winDsHostApi, char *name, LPGUID lpGUID, char *pnpInterface )
{
    PaUtilHostApiRepresentation  *hostApi = &winDsHostApi->inheritedHostApiRep;
    PaWinDsDeviceInfo            *winDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[hostApi->info.deviceCount];
    PaDeviceInfo                 *deviceInfo = &winDsDeviceInfo->inheritedDeviceInfo;
    HRESULT                       hr;
    LPDIRECTSOUNDCAPTURE          lpDirectSoundCapture;
    DSCCAPS                       caps;
    int                           deviceOK = TRUE;
    PaError                       result = paNoError;
    
    /* Copy GUID to the device info structure. Set pointer. */
    if( lpGUID == NULL )
    {
        winDsDeviceInfo->lpGUID = NULL;
    }
    else
    {
        winDsDeviceInfo->lpGUID = &winDsDeviceInfo->guid;
        memcpy( &winDsDeviceInfo->guid, lpGUID, sizeof(GUID) );
    }

    hr = paWinDsDSoundEntryPoints.DirectSoundCaptureCreate( lpGUID, &lpDirectSoundCapture, NULL );

    /** try using CoCreateInstance because DirectSoundCreate was hanging under
        some circumstances - note this was probably related to the
        #define BOOL short bug which has now been fixed
        @todo delete this comment and the following code once we've ensured
        there is no bug.
    */
    /*
    hr = CoCreateInstance( &CLSID_DirectSoundCapture, NULL, CLSCTX_INPROC_SERVER,
            &IID_IDirectSoundCapture, (void**)&lpDirectSoundCapture );
    */
    if( hr != DS_OK )
    {
        DBUG(("Cannot create Capture for %s. Result = 0x%x\n", name, hr ));
        deviceOK = FALSE;
    }
    else
    {
        /* Query device characteristics. */
        memset( &caps, 0, sizeof(caps) );
        caps.dwSize = sizeof(caps);
        hr = IDirectSoundCapture_GetCaps( lpDirectSoundCapture, &caps );
        if( hr != DS_OK )
        {
            DBUG(("Cannot GetCaps() for Capture device %s. Result = 0x%x\n", name, hr ));
            deviceOK = FALSE;
        }
        else
        {
#if PA_USE_WMME
            if( caps.dwFlags & DSCAPS_EMULDRIVER )
            {
                /* If WMME supported, then reject Emulated drivers because they are lousy. */
                deviceOK = FALSE;
            }
#endif

            if( deviceOK )
            {
                deviceInfo->maxInputChannels = caps.dwChannels;
                winDsDeviceInfo->deviceInputChannelCountIsKnown = 1;

                deviceInfo->maxOutputChannels = 0;
                winDsDeviceInfo->deviceOutputChannelCountIsKnown = 1;

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
                if( pnpInterface )
                {
                    int count = PaWin_WDMKS_QueryFilterMaximumChannelCount( pnpInterface, /* isInput= */ 1  );
                    if( count > 0 )
                    {
                        deviceInfo->maxInputChannels = count;
                        winDsDeviceInfo->deviceInputChannelCountIsKnown = 1;
                    }
                }
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

/*  constants from a WINE patch by Francois Gouget, see:
    http://www.winehq.com/hypermail/wine-patches/2003/01/0290.html

    ---
    Date: Fri, 14 May 2004 10:38:12 +0200 (CEST)
    From: Francois Gouget <fgouget@ ... .fr>
    To: Ross Bencina <rbencina@ ... .au>
    Subject: Re: Permission to use wine 48/96 wave patch in BSD licensed library

    [snip]

    I give you permission to use the patch below under the BSD license.
    http://www.winehq.com/hypermail/wine-patches/2003/01/0290.html

    [snip]
*/
#ifndef WAVE_FORMAT_48M08
#define WAVE_FORMAT_48M08      0x00001000    /* 48     kHz, Mono,   8-bit  */
#define WAVE_FORMAT_48S08      0x00002000    /* 48     kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_48M16      0x00004000    /* 48     kHz, Mono,   16-bit */
#define WAVE_FORMAT_48S16      0x00008000    /* 48     kHz, Stereo, 16-bit */
#define WAVE_FORMAT_96M08      0x00010000    /* 96     kHz, Mono,   8-bit  */
#define WAVE_FORMAT_96S08      0x00020000    /* 96     kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_96M16      0x00040000    /* 96     kHz, Mono,   16-bit */
#define WAVE_FORMAT_96S16      0x00080000    /* 96     kHz, Stereo, 16-bit */
#endif

                /* defaultSampleRate */
                if( caps.dwChannels == 2 )
                {
                    if( caps.dwFormats & WAVE_FORMAT_4S16 )
                        deviceInfo->defaultSampleRate = 44100.0;
                    else if( caps.dwFormats & WAVE_FORMAT_48S16 )
                        deviceInfo->defaultSampleRate = 48000.0;
                    else if( caps.dwFormats & WAVE_FORMAT_2S16 )
                        deviceInfo->defaultSampleRate = 22050.0;
                    else if( caps.dwFormats & WAVE_FORMAT_1S16 )
                        deviceInfo->defaultSampleRate = 11025.0;
                    else if( caps.dwFormats & WAVE_FORMAT_96S16 )
                        deviceInfo->defaultSampleRate = 96000.0;
                    else
                        deviceInfo->defaultSampleRate = 48000.0; /* assume 48000 as the default */
                }
                else if( caps.dwChannels == 1 )
                {
                    if( caps.dwFormats & WAVE_FORMAT_4M16 )
                        deviceInfo->defaultSampleRate = 44100.0;
                    else if( caps.dwFormats & WAVE_FORMAT_48M16 )
                        deviceInfo->defaultSampleRate = 48000.0;
                    else if( caps.dwFormats & WAVE_FORMAT_2M16 )
                        deviceInfo->defaultSampleRate = 22050.0;
                    else if( caps.dwFormats & WAVE_FORMAT_1M16 )
                        deviceInfo->defaultSampleRate = 11025.0;
                    else if( caps.dwFormats & WAVE_FORMAT_96M16 )
                        deviceInfo->defaultSampleRate = 96000.0;
                    else
                        deviceInfo->defaultSampleRate = 48000.0; /* assume 48000 as the default */
                }
                else deviceInfo->defaultSampleRate = 48000.0; /* assume 48000 as the default */

                deviceInfo->defaultLowInputLatency = PaWinDs_GetMinLatencySeconds( deviceInfo->defaultSampleRate );
                deviceInfo->defaultHighInputLatency = deviceInfo->defaultLowInputLatency * 2;
        
                deviceInfo->defaultLowOutputLatency = 0.;
                deviceInfo->defaultHighOutputLatency = 0.;
            }
        }
        
        IDirectSoundCapture_Release( lpDirectSoundCapture );
    }

    if( deviceOK )
    {
        deviceInfo->name = name;

        if( lpGUID == NULL )
            hostApi->info.defaultInputDevice = hostApi->info.deviceCount;

        hostApi->info.deviceCount++;
    }

    return result;
}


/***********************************************************************************/
PaError PaWinDs_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    int i, deviceCount;
    PaWinDsHostApiRepresentation *winDsHostApi;
    DSDeviceNamesAndGUIDs deviceNamesAndGUIDs;
    PaWinDsDeviceInfo *deviceInfoArray;

    PaWinDs_InitializeDSoundEntryPoints();

    /* initialise guid vectors so they can be safely deleted on error */
    deviceNamesAndGUIDs.winDsHostApi = NULL;
    deviceNamesAndGUIDs.inputNamesAndGUIDs.items = NULL;
    deviceNamesAndGUIDs.outputNamesAndGUIDs.items = NULL;

    winDsHostApi = (PaWinDsHostApiRepresentation*)PaUtil_AllocateMemory( sizeof(PaWinDsHostApiRepresentation) );
    if( !winDsHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }

    memset( winDsHostApi, 0, sizeof(PaWinDsHostApiRepresentation) ); /* ensure all fields are zeroed. especially winDsHostApi->allocations */

    result = PaWinUtil_CoInitialize( paDirectSound, &winDsHostApi->comInitializationResult );
    if( result != paNoError )
    {
        goto error;
    }

    winDsHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !winDsHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }

    *hostApi = &winDsHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paDirectSound;
    (*hostApi)->info.name = "Windows DirectSound";
    
    (*hostApi)->info.deviceCount = 0;
    (*hostApi)->info.defaultInputDevice = paNoDevice;
    (*hostApi)->info.defaultOutputDevice = paNoDevice;

    
/* DSound - enumerate devices to count them and to gather their GUIDs */

    result = InitializeDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.inputNamesAndGUIDs, winDsHostApi->allocations );
    if( result != paNoError )
        goto error;

    result = InitializeDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.outputNamesAndGUIDs, winDsHostApi->allocations );
    if( result != paNoError )
        goto error;

    paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW( (LPDSENUMCALLBACKW)CollectGUIDsProcW, (void *)&deviceNamesAndGUIDs.inputNamesAndGUIDs );

    paWinDsDSoundEntryPoints.DirectSoundEnumerateW( (LPDSENUMCALLBACKW)CollectGUIDsProcW, (void *)&deviceNamesAndGUIDs.outputNamesAndGUIDs );

    if( deviceNamesAndGUIDs.inputNamesAndGUIDs.enumerationError != paNoError )
    {
        result = deviceNamesAndGUIDs.inputNamesAndGUIDs.enumerationError;
        goto error;
    }

    if( deviceNamesAndGUIDs.outputNamesAndGUIDs.enumerationError != paNoError )
    {
        result = deviceNamesAndGUIDs.outputNamesAndGUIDs.enumerationError;
        goto error;
    }

    deviceCount = deviceNamesAndGUIDs.inputNamesAndGUIDs.count + deviceNamesAndGUIDs.outputNamesAndGUIDs.count;

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
    if( deviceCount > 0 )
    {
        deviceNamesAndGUIDs.winDsHostApi = winDsHostApi;
        FindDevicePnpInterfaces( &deviceNamesAndGUIDs );
    }
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

    if( deviceCount > 0 )
    {
        /* allocate array for pointers to PaDeviceInfo structs */
        (*hostApi)->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
                winDsHostApi->allocations, sizeof(PaDeviceInfo*) * deviceCount );
        if( !(*hostApi)->deviceInfos )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all PaDeviceInfo structs in a contiguous block */
        deviceInfoArray = (PaWinDsDeviceInfo*)PaUtil_GroupAllocateMemory(
                winDsHostApi->allocations, sizeof(PaWinDsDeviceInfo) * deviceCount );
        if( !deviceInfoArray )
        {
            result = paInsufficientMemory;
            goto error;
        }

        for( i=0; i < deviceCount; ++i )
        {
            PaDeviceInfo *deviceInfo = &deviceInfoArray[i].inheritedDeviceInfo;
            deviceInfo->structVersion = 2;
            deviceInfo->hostApi = hostApiIndex;
            deviceInfo->name = 0;
            (*hostApi)->deviceInfos[i] = deviceInfo;
        }

        for( i=0; i < deviceNamesAndGUIDs.inputNamesAndGUIDs.count; ++i )
        {
            result = AddInputDeviceInfoFromDirectSoundCapture( winDsHostApi,
                    deviceNamesAndGUIDs.inputNamesAndGUIDs.items[i].name,
                    deviceNamesAndGUIDs.inputNamesAndGUIDs.items[i].lpGUID,
                    deviceNamesAndGUIDs.inputNamesAndGUIDs.items[i].pnpInterface );
            if( result != paNoError )
                goto error;
        }

        for( i=0; i < deviceNamesAndGUIDs.outputNamesAndGUIDs.count; ++i )
        {
            result = AddOutputDeviceInfoFromDirectSound( winDsHostApi,
                    deviceNamesAndGUIDs.outputNamesAndGUIDs.items[i].name,
                    deviceNamesAndGUIDs.outputNamesAndGUIDs.items[i].lpGUID,
                    deviceNamesAndGUIDs.outputNamesAndGUIDs.items[i].pnpInterface );
            if( result != paNoError )
                goto error;
        }
    }    

    result = TerminateDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.inputNamesAndGUIDs );
    if( result != paNoError )
        goto error;

    result = TerminateDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.outputNamesAndGUIDs );
    if( result != paNoError )
        goto error;

    
    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &winDsHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &winDsHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    return result;

error:
    TerminateDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.inputNamesAndGUIDs );
    TerminateDSDeviceNameAndGUIDVector( &deviceNamesAndGUIDs.outputNamesAndGUIDs );

    Terminate( (struct PaUtilHostApiRepresentation *)winDsHostApi );

    return result;
}


/***********************************************************************************/
static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaWinDsHostApiRepresentation *winDsHostApi = (PaWinDsHostApiRepresentation*)hostApi;

    if( winDsHostApi ){
        if( winDsHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( winDsHostApi->allocations );
            PaUtil_DestroyAllocationGroup( winDsHostApi->allocations );
        }

        PaWinUtil_CoUninitialize( paDirectSound, &winDsHostApi->comInitializationResult );

        PaUtil_FreeMemory( winDsHostApi );
    }

    PaWinDs_TerminateDSoundEntryPoints();
}

static PaError ValidateWinDirectSoundSpecificStreamInfo(
        const PaStreamParameters *streamParameters,
        const PaWinDirectSoundStreamInfo *streamInfo )
{
    if( streamInfo )
    {
        if( streamInfo->size != sizeof( PaWinDirectSoundStreamInfo )
                || streamInfo->version != 2 )
        {
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        if( streamInfo->flags & paWinDirectSoundUseLowLevelLatencyParameters )
        {
            if( streamInfo->framesPerBuffer <= 0 )
                return paIncompatibleHostApiSpecificStreamInfo;

        }
    }

    return paNoError;
}

/***********************************************************************************/
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaError result;
    PaWinDsDeviceInfo *inputWinDsDeviceInfo, *outputWinDsDeviceInfo;
    PaDeviceInfo *inputDeviceInfo, *outputDeviceInfo;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaWinDirectSoundStreamInfo *inputStreamInfo, *outputStreamInfo;

    if( inputParameters )
    {
        inputWinDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[ inputParameters->device ];
        inputDeviceInfo = &inputWinDsDeviceInfo->inheritedDeviceInfo;

        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputWinDsDeviceInfo->deviceInputChannelCountIsKnown
                && inputChannelCount > inputDeviceInfo->maxInputChannels )
            return paInvalidChannelCount;

        /* validate inputStreamInfo */
        inputStreamInfo = (PaWinDirectSoundStreamInfo*)inputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinDirectSoundSpecificStreamInfo( inputParameters, inputStreamInfo );
        if( result != paNoError ) return result;
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputWinDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[ outputParameters->device ];
        outputDeviceInfo = &outputWinDsDeviceInfo->inheritedDeviceInfo;

        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support inputChannelCount */
        if( outputWinDsDeviceInfo->deviceOutputChannelCountIsKnown
                && outputChannelCount > outputDeviceInfo->maxOutputChannels )
            return paInvalidChannelCount;

        /* validate outputStreamInfo */
        outputStreamInfo = (PaWinDirectSoundStreamInfo*)outputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinDirectSoundSpecificStreamInfo( outputParameters, outputStreamInfo );
        if( result != paNoError ) return result;
    }
    else
    {
        outputChannelCount = 0;
    }
    
    /*
        IMPLEMENT ME:

            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported if necessary

            - check that the device supports sampleRate

        Because the buffer adapter handles conversion between all standard
        sample formats, the following checks are only required if paCustomFormat
        is implemented, or under some other unusual conditions.

            - check that input device can support inputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - check that output device can support outputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format
    */

    return paFormatIsSupported;
}


#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
static HRESULT InitFullDuplexInputOutputBuffers( PaWinDsStream *stream,
                                       PaWinDsDeviceInfo *inputDevice,
                                       PaSampleFormat hostInputSampleFormat,
                                       WORD inputChannelCount, 
                                       int bytesPerInputBuffer,
                                       PaWinWaveFormatChannelMask inputChannelMask,
                                       PaWinDsDeviceInfo *outputDevice,
                                       PaSampleFormat hostOutputSampleFormat,
                                       WORD outputChannelCount, 
                                       int bytesPerOutputBuffer,
                                       PaWinWaveFormatChannelMask outputChannelMask,
                                       unsigned long nFrameRate
                                        )
{
    HRESULT hr;
    DSCBUFFERDESC  captureDesc;
    PaWinWaveFormat captureWaveFormat;
    DSBUFFERDESC   secondaryRenderDesc;
    PaWinWaveFormat renderWaveFormat;
    LPDIRECTSOUNDBUFFER8 pRenderBuffer8;
    LPDIRECTSOUNDCAPTUREBUFFER8 pCaptureBuffer8;

    // capture buffer description

    // only try wave format extensible. assume it's available on all ds 8 systems
    PaWin_InitializeWaveFormatExtensible( &captureWaveFormat, inputChannelCount, 
                hostInputSampleFormat, PaWin_SampleFormatToLinearWaveFormatTag( hostInputSampleFormat ),
                nFrameRate, inputChannelMask );

    ZeroMemory(&captureDesc, sizeof(DSCBUFFERDESC));
    captureDesc.dwSize = sizeof(DSCBUFFERDESC);
    captureDesc.dwFlags = 0;
    captureDesc.dwBufferBytes = bytesPerInputBuffer;
    captureDesc.lpwfxFormat = (WAVEFORMATEX*)&captureWaveFormat;

    // render buffer description

    PaWin_InitializeWaveFormatExtensible( &renderWaveFormat, outputChannelCount, 
                hostOutputSampleFormat, PaWin_SampleFormatToLinearWaveFormatTag( hostOutputSampleFormat ),
                nFrameRate, outputChannelMask );

    ZeroMemory(&secondaryRenderDesc, sizeof(DSBUFFERDESC));
    secondaryRenderDesc.dwSize = sizeof(DSBUFFERDESC);
    secondaryRenderDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
    secondaryRenderDesc.dwBufferBytes = bytesPerOutputBuffer;
    secondaryRenderDesc.lpwfxFormat = (WAVEFORMATEX*)&renderWaveFormat;

    /* note that we don't create a primary buffer here at all */

    hr = paWinDsDSoundEntryPoints.DirectSoundFullDuplexCreate8( 
            inputDevice->lpGUID, outputDevice->lpGUID,
            &captureDesc, &secondaryRenderDesc,
            GetDesktopWindow(), /* see InitOutputBuffer() for a discussion of whether this is a good idea */
            DSSCL_EXCLUSIVE,
            &stream->pDirectSoundFullDuplex8,
            &pCaptureBuffer8,
            &pRenderBuffer8,
            NULL /* pUnkOuter must be NULL */ 
        );

    if( hr == DS_OK )
    {
        PA_DEBUG(("DirectSoundFullDuplexCreate succeeded!\n"));

        /* retrieve the pre ds 8 buffer interfaces which are used by the rest of the code */

        hr = IUnknown_QueryInterface( pCaptureBuffer8, &IID_IDirectSoundCaptureBuffer, (LPVOID *)&stream->pDirectSoundInputBuffer );
        
        if( hr == DS_OK )
            hr = IUnknown_QueryInterface( pRenderBuffer8, &IID_IDirectSoundBuffer, (LPVOID *)&stream->pDirectSoundOutputBuffer );

        /* release the ds 8 interfaces, we don't need them */
        IUnknown_Release( pCaptureBuffer8 );
        IUnknown_Release( pRenderBuffer8 );

        if( !stream->pDirectSoundInputBuffer || !stream->pDirectSoundOutputBuffer ){
            /* couldn't get pre ds 8 interfaces for some reason. clean up. */
            if( stream->pDirectSoundInputBuffer )
            {
                IUnknown_Release( stream->pDirectSoundInputBuffer );
                stream->pDirectSoundInputBuffer = NULL;
            }

            if( stream->pDirectSoundOutputBuffer )
            {
                IUnknown_Release( stream->pDirectSoundOutputBuffer );
                stream->pDirectSoundOutputBuffer = NULL;
            }
            
            IUnknown_Release( stream->pDirectSoundFullDuplex8 );
            stream->pDirectSoundFullDuplex8 = NULL;
        }
    }
    else
    {
        PA_DEBUG(("DirectSoundFullDuplexCreate failed. hr=%d\n", hr));
    }

    return hr;
}
#endif /* PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE */


static HRESULT InitInputBuffer( PaWinDsStream *stream, 
                               PaWinDsDeviceInfo *device, 
                               PaSampleFormat sampleFormat, 
                               unsigned long nFrameRate, 
                               WORD nChannels, 
                               int bytesPerBuffer, 
                               PaWinWaveFormatChannelMask channelMask )
{
    DSCBUFFERDESC  captureDesc;
    PaWinWaveFormat waveFormat;
    HRESULT        result;
    
    if( (result = paWinDsDSoundEntryPoints.DirectSoundCaptureCreate( 
            device->lpGUID, &stream->pDirectSoundCapture, NULL) ) != DS_OK ){
         ERR_RPT(("PortAudio: DirectSoundCaptureCreate() failed!\n"));
         return result;
    }

    // Setup the secondary buffer description
    ZeroMemory(&captureDesc, sizeof(DSCBUFFERDESC));
    captureDesc.dwSize = sizeof(DSCBUFFERDESC);
    captureDesc.dwFlags = 0;
    captureDesc.dwBufferBytes = bytesPerBuffer;
    captureDesc.lpwfxFormat = (WAVEFORMATEX*)&waveFormat;
    
    // Create the capture buffer

    // first try WAVEFORMATEXTENSIBLE. if this fails, fall back to WAVEFORMATEX
    PaWin_InitializeWaveFormatExtensible( &waveFormat, nChannels, 
                sampleFormat, PaWin_SampleFormatToLinearWaveFormatTag( sampleFormat ),
                nFrameRate, channelMask );

    if( IDirectSoundCapture_CreateCaptureBuffer( stream->pDirectSoundCapture,
                  &captureDesc, &stream->pDirectSoundInputBuffer, NULL) != DS_OK )
    {
        PaWin_InitializeWaveFormatEx( &waveFormat, nChannels, sampleFormat, 
                PaWin_SampleFormatToLinearWaveFormatTag( sampleFormat ), nFrameRate );

        if ((result = IDirectSoundCapture_CreateCaptureBuffer( stream->pDirectSoundCapture,
                    &captureDesc, &stream->pDirectSoundInputBuffer, NULL)) != DS_OK) return result;
    }

    stream->readOffset = 0;  // reset last read position to start of buffer
    return DS_OK;
}


static HRESULT InitOutputBuffer( PaWinDsStream *stream, PaWinDsDeviceInfo *device, 
                                PaSampleFormat sampleFormat, unsigned long nFrameRate, 
                                WORD nChannels, int bytesPerBuffer, 
                                PaWinWaveFormatChannelMask channelMask )
{
    HRESULT        result;
    HWND           hWnd;
    HRESULT        hr;
    PaWinWaveFormat waveFormat;
    DSBUFFERDESC   primaryDesc;
    DSBUFFERDESC   secondaryDesc;
    
    if( (hr = paWinDsDSoundEntryPoints.DirectSoundCreate( 
                device->lpGUID, &stream->pDirectSound, NULL )) != DS_OK ){
        ERR_RPT(("PortAudio: DirectSoundCreate() failed!\n"));
        return hr;
    }

    // We were using getForegroundWindow() but sometimes the ForegroundWindow may not be the
    // applications's window. Also if that window is closed before the Buffer is closed
    // then DirectSound can crash. (Thanks for Scott Patterson for reporting this.)
    // So we will use GetDesktopWindow() which was suggested by Miller Puckette.
    // hWnd = GetForegroundWindow();
    //
    //  FIXME: The example code I have on the net creates a hidden window that
    //      is managed by our code - I think we should do that - one hidden
    //      window for the whole of Pa_DS
    //
    hWnd = GetDesktopWindow();

    // Set cooperative level to DSSCL_EXCLUSIVE so that we can get 16 bit output, 44.1 KHz.
    // exclusive also prevents unexpected sounds from other apps during a performance.
    if ((hr = IDirectSound_SetCooperativeLevel( stream->pDirectSound,
              hWnd, DSSCL_EXCLUSIVE)) != DS_OK)
    {
        return hr;
    }

    // -----------------------------------------------------------------------
    // Create primary buffer and set format just so we can specify our custom format.
    // Otherwise we would be stuck with the default which might be 8 bit or 22050 Hz.
    // Setup the primary buffer description
    ZeroMemory(&primaryDesc, sizeof(DSBUFFERDESC));
    primaryDesc.dwSize        = sizeof(DSBUFFERDESC);
    primaryDesc.dwFlags       = DSBCAPS_PRIMARYBUFFER; // all panning, mixing, etc done by synth
    primaryDesc.dwBufferBytes = 0;
    primaryDesc.lpwfxFormat   = NULL;
    // Create the buffer
    if ((result = IDirectSound_CreateSoundBuffer( stream->pDirectSound,
                  &primaryDesc, &stream->pDirectSoundPrimaryBuffer, NULL)) != DS_OK)
        goto error;

    // Set the primary buffer's format

    // first try WAVEFORMATEXTENSIBLE. if this fails, fall back to WAVEFORMATEX
    PaWin_InitializeWaveFormatExtensible( &waveFormat, nChannels, 
                sampleFormat, PaWin_SampleFormatToLinearWaveFormatTag( sampleFormat ),
                nFrameRate, channelMask );

    if( IDirectSoundBuffer_SetFormat( stream->pDirectSoundPrimaryBuffer, (WAVEFORMATEX*)&waveFormat) != DS_OK )
    {
        PaWin_InitializeWaveFormatEx( &waveFormat, nChannels, sampleFormat, 
                PaWin_SampleFormatToLinearWaveFormatTag( sampleFormat ), nFrameRate );

        if((result = IDirectSoundBuffer_SetFormat( stream->pDirectSoundPrimaryBuffer, (WAVEFORMATEX*)&waveFormat)) != DS_OK)
            goto error;
    }

    // ----------------------------------------------------------------------
    // Setup the secondary buffer description
    ZeroMemory(&secondaryDesc, sizeof(DSBUFFERDESC));
    secondaryDesc.dwSize = sizeof(DSBUFFERDESC);
    secondaryDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
    secondaryDesc.dwBufferBytes = bytesPerBuffer;
    secondaryDesc.lpwfxFormat = (WAVEFORMATEX*)&waveFormat; /* waveFormat contains whatever format was negotiated for the primary buffer above */
    // Create the secondary buffer
    if ((result = IDirectSound_CreateSoundBuffer( stream->pDirectSound,
                  &secondaryDesc, &stream->pDirectSoundOutputBuffer, NULL)) != DS_OK)
      goto error;
    
    return DS_OK;

error:

    if( stream->pDirectSoundPrimaryBuffer )
    {
        IDirectSoundBuffer_Release( stream->pDirectSoundPrimaryBuffer );
        stream->pDirectSoundPrimaryBuffer = NULL;
    }

    return result;
}


static void CalculateBufferSettings( unsigned long *hostBufferSizeFrames, 
                                    unsigned long *pollingPeriodFrames,
                                    int isFullDuplex,
                                    unsigned long suggestedInputLatencyFrames,
                                    unsigned long suggestedOutputLatencyFrames,
                                    double sampleRate, unsigned long userFramesPerBuffer )
{
    unsigned long minimumPollingPeriodFrames = (unsigned long)(sampleRate * PA_DS_MINIMUM_POLLING_PERIOD_SECONDS);
    unsigned long maximumPollingPeriodFrames = (unsigned long)(sampleRate * PA_DS_MAXIMUM_POLLING_PERIOD_SECONDS);
    unsigned long pollingJitterFrames = (unsigned long)(sampleRate * PA_DS_POLLING_JITTER_SECONDS);
    
    if( userFramesPerBuffer == paFramesPerBufferUnspecified )
    {
        unsigned long targetBufferingLatencyFrames = max( suggestedInputLatencyFrames, suggestedOutputLatencyFrames );

        *pollingPeriodFrames = targetBufferingLatencyFrames / 4;
        if( *pollingPeriodFrames < minimumPollingPeriodFrames )
        {
            *pollingPeriodFrames = minimumPollingPeriodFrames;
        }
        else if( *pollingPeriodFrames > maximumPollingPeriodFrames )
        {
            *pollingPeriodFrames = maximumPollingPeriodFrames;
        }

        *hostBufferSizeFrames = *pollingPeriodFrames 
                + max( *pollingPeriodFrames + pollingJitterFrames, targetBufferingLatencyFrames);
    }
    else
    {
        unsigned long targetBufferingLatencyFrames = suggestedInputLatencyFrames;
        if( isFullDuplex )
        {
            /* In full duplex streams we know that the buffer adapter adds userFramesPerBuffer
               extra fixed latency. so we subtract it here as a fixed latency before computing
               the buffer size. being careful not to produce an unrepresentable negative result.
               
               Note: this only works as expected if output latency is greater than input latency.
               Otherwise we use input latency anyway since we do max(in,out).
            */

            if( userFramesPerBuffer < suggestedOutputLatencyFrames )
            {
                unsigned long adjustedSuggestedOutputLatencyFrames = 
                        suggestedOutputLatencyFrames - userFramesPerBuffer;

                /* maximum of input and adjusted output suggested latency */
                if( adjustedSuggestedOutputLatencyFrames > targetBufferingLatencyFrames )
                    targetBufferingLatencyFrames = adjustedSuggestedOutputLatencyFrames;
            }
        }
        else
        {
            /* maximum of input and output suggested latency */
            if( suggestedOutputLatencyFrames > suggestedInputLatencyFrames )
                targetBufferingLatencyFrames = suggestedOutputLatencyFrames;
        }   

        *hostBufferSizeFrames = userFramesPerBuffer 
                + max( userFramesPerBuffer + pollingJitterFrames, targetBufferingLatencyFrames);

        *pollingPeriodFrames = max( max(1, userFramesPerBuffer / 4), targetBufferingLatencyFrames / 16 );

        if( *pollingPeriodFrames > maximumPollingPeriodFrames )
        {
            *pollingPeriodFrames = maximumPollingPeriodFrames;
        }
    } 
}


static void CalculatePollingPeriodFrames( unsigned long hostBufferSizeFrames, 
                                    unsigned long *pollingPeriodFrames,
                                    double sampleRate, unsigned long userFramesPerBuffer )
{
    unsigned long minimumPollingPeriodFrames = (unsigned long)(sampleRate * PA_DS_MINIMUM_POLLING_PERIOD_SECONDS);
    unsigned long maximumPollingPeriodFrames = (unsigned long)(sampleRate * PA_DS_MAXIMUM_POLLING_PERIOD_SECONDS);
    unsigned long pollingJitterFrames = (unsigned long)(sampleRate * PA_DS_POLLING_JITTER_SECONDS);

    *pollingPeriodFrames = max( max(1, userFramesPerBuffer / 4), hostBufferSizeFrames / 16 );

    if( *pollingPeriodFrames > maximumPollingPeriodFrames )
    {
        *pollingPeriodFrames = maximumPollingPeriodFrames;
    }
}


static void SetStreamInfoLatencies( PaWinDsStream *stream, 
                                   unsigned long userFramesPerBuffer, 
                                   unsigned long pollingPeriodFrames,
                                   double sampleRate )
{
    /* compute the stream info actual latencies based on framesPerBuffer, polling period, hostBufferSizeFrames, 
    and the configuration of the buffer processor */

    unsigned long effectiveFramesPerBuffer = (userFramesPerBuffer == paFramesPerBufferUnspecified)
                                             ? pollingPeriodFrames
                                             : userFramesPerBuffer;

    if( stream->bufferProcessor.inputChannelCount > 0 )
    {
        /* stream info input latency is the minimum buffering latency 
           (unlike suggested and default which are *maximums*) */
        stream->streamRepresentation.streamInfo.inputLatency =
                (double)(PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor)
                    + effectiveFramesPerBuffer) / sampleRate;
    }
    else
    {
        stream->streamRepresentation.streamInfo.inputLatency = 0;
    }

    if( stream->bufferProcessor.outputChannelCount > 0 )
    {
        stream->streamRepresentation.streamInfo.outputLatency =
                (double)(PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor)
                    + (stream->hostBufferSizeFrames - effectiveFramesPerBuffer)) / sampleRate;
    }
    else
    {
        stream->streamRepresentation.streamInfo.outputLatency = 0;
    }
}


/***********************************************************************************/
/* see pa_hostapi.h for a list of validity guarantees made about OpenStream parameters */

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaWinDsHostApiRepresentation *winDsHostApi = (PaWinDsHostApiRepresentation*)hostApi;
    PaWinDsStream *stream = 0;
    int bufferProcessorIsInitialized = 0;
    int streamRepresentationIsInitialized = 0;
    PaWinDsDeviceInfo *inputWinDsDeviceInfo, *outputWinDsDeviceInfo;
    PaDeviceInfo *inputDeviceInfo, *outputDeviceInfo;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
    int userRequestedHostInputBufferSizeFrames = 0;
    int userRequestedHostOutputBufferSizeFrames = 0;
    unsigned long suggestedInputLatencyFrames, suggestedOutputLatencyFrames;
    PaWinDirectSoundStreamInfo *inputStreamInfo, *outputStreamInfo;
    PaWinWaveFormatChannelMask inputChannelMask, outputChannelMask;
    unsigned long pollingPeriodFrames = 0;

    if( inputParameters )
    {
        inputWinDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[ inputParameters->device ];
        inputDeviceInfo = &inputWinDsDeviceInfo->inheritedDeviceInfo;

        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        suggestedInputLatencyFrames = (unsigned long)(inputParameters->suggestedLatency * sampleRate);

        /* IDEA: the following 3 checks could be performed by default by pa_front
            unless some flag indicated otherwise */
            
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputWinDsDeviceInfo->deviceInputChannelCountIsKnown
                && inputChannelCount > inputDeviceInfo->maxInputChannels )
            return paInvalidChannelCount;
            
        /* validate hostApiSpecificStreamInfo */
        inputStreamInfo = (PaWinDirectSoundStreamInfo*)inputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinDirectSoundSpecificStreamInfo( inputParameters, inputStreamInfo );
        if( result != paNoError ) return result;

        if( inputStreamInfo && inputStreamInfo->flags & paWinDirectSoundUseLowLevelLatencyParameters )
            userRequestedHostInputBufferSizeFrames = inputStreamInfo->framesPerBuffer;

        if( inputStreamInfo && inputStreamInfo->flags & paWinDirectSoundUseChannelMask )
            inputChannelMask = inputStreamInfo->channelMask;
        else
            inputChannelMask = PaWin_DefaultChannelMask( inputChannelCount );
    }
    else
    {
        inputChannelCount = 0;
        inputSampleFormat = 0;
        suggestedInputLatencyFrames = 0;
    }


    if( outputParameters )
    {
        outputWinDsDeviceInfo = (PaWinDsDeviceInfo*) hostApi->deviceInfos[ outputParameters->device ];
        outputDeviceInfo = &outputWinDsDeviceInfo->inheritedDeviceInfo;

        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        suggestedOutputLatencyFrames = (unsigned long)(outputParameters->suggestedLatency * sampleRate);

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support outputChannelCount */
        if( outputWinDsDeviceInfo->deviceOutputChannelCountIsKnown
                && outputChannelCount > outputDeviceInfo->maxOutputChannels )
            return paInvalidChannelCount;

        /* validate hostApiSpecificStreamInfo */
        outputStreamInfo = (PaWinDirectSoundStreamInfo*)outputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinDirectSoundSpecificStreamInfo( outputParameters, outputStreamInfo );
        if( result != paNoError ) return result;   

        if( outputStreamInfo && outputStreamInfo->flags & paWinDirectSoundUseLowLevelLatencyParameters )
            userRequestedHostOutputBufferSizeFrames = outputStreamInfo->framesPerBuffer;

        if( outputStreamInfo && outputStreamInfo->flags & paWinDirectSoundUseChannelMask )
            outputChannelMask = outputStreamInfo->channelMask;
        else
            outputChannelMask = PaWin_DefaultChannelMask( outputChannelCount );
    }
    else
    {
        outputChannelCount = 0;
        outputSampleFormat = 0;
        suggestedOutputLatencyFrames = 0;
    }

    /*
        If low level host buffer size is specified for both input and output
        the current code requires the sizes to match.
    */

    if( (userRequestedHostInputBufferSizeFrames > 0 && userRequestedHostOutputBufferSizeFrames > 0)
            && userRequestedHostInputBufferSizeFrames != userRequestedHostOutputBufferSizeFrames )
        return paIncompatibleHostApiSpecificStreamInfo;



    /*
        IMPLEMENT ME:

        ( the following two checks are taken care of by PaUtil_InitializeBufferProcessor() )

            - check that input device can support inputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - check that output device can support outputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported

            - check that the device supports sampleRate

            - alter sampleRate to a close allowable rate if possible / necessary

            - validate suggestedInputLatency and suggestedOutputLatency parameters,
                use default values where necessary
    */


    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform specific flag */


    stream = (PaWinDsStream*)PaUtil_AllocateMemory( sizeof(PaWinDsStream) );
    if( !stream )
    {
        result = paInsufficientMemory;
        goto error;
    }

    memset( stream, 0, sizeof(PaWinDsStream) ); /* initialize all stream variables to 0 */

    if( streamCallback )
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &winDsHostApi->callbackStreamInterface, streamCallback, userData );
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &winDsHostApi->blockingStreamInterface, streamCallback, userData );
    }
    
    streamRepresentationIsInitialized = 1;

    stream->streamFlags = streamFlags;

    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );


    if( inputParameters )
    {
        /* IMPLEMENT ME - establish which  host formats are available */
        PaSampleFormat nativeInputFormats = paInt16;
        /* PaSampleFormat nativeFormats = paUInt8 | paInt16 | paInt24 | paInt32 | paFloat32; */

        hostInputSampleFormat =
            PaUtil_SelectClosestAvailableFormat( nativeInputFormats, inputParameters->sampleFormat );
    }
    else
    {
        hostInputSampleFormat = 0;
    }

    if( outputParameters )
    {
        /* IMPLEMENT ME - establish which  host formats are available */
        PaSampleFormat nativeOutputFormats = paInt16;
        /* PaSampleFormat nativeOutputFormats = paUInt8 | paInt16 | paInt24 | paInt32 | paFloat32; */

        hostOutputSampleFormat =
            PaUtil_SelectClosestAvailableFormat( nativeOutputFormats, outputParameters->sampleFormat );
    }
    else
    {
        hostOutputSampleFormat = 0;
    }

    result =  PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                    inputChannelCount, inputSampleFormat, hostInputSampleFormat,
                    outputChannelCount, outputSampleFormat, hostOutputSampleFormat,
                    sampleRate, streamFlags, framesPerBuffer,
                    0, /* ignored in paUtilVariableHostBufferSizePartialUsageAllowed mode. */
                /* This next mode is required because DS can split the host buffer when it wraps around. */
                    paUtilVariableHostBufferSizePartialUsageAllowed,
                    streamCallback, userData );
    if( result != paNoError )
        goto error;

    bufferProcessorIsInitialized = 1;

   
/* DirectSound specific initialization */ 
    {
        HRESULT          hr;
        unsigned long    integerSampleRate = (unsigned long) (sampleRate + 0.5);
        
        stream->processingCompleted = CreateEvent( NULL, /* bManualReset = */ TRUE, /* bInitialState = */ FALSE, NULL );
        if( stream->processingCompleted == NULL )
        {
            result = paInsufficientMemory;
            goto error;
        }

#ifdef PA_WIN_DS_USE_WMME_TIMER
        stream->timerID = 0;
#endif

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT
        stream->waitableTimer = (HANDLE)CreateWaitableTimer( 0, FALSE, NULL );
        if( stream->waitableTimer == NULL )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( GetLastError() );
            goto error;
        }
#endif

#ifndef PA_WIN_DS_USE_WMME_TIMER
        stream->processingThreadCompleted = CreateEvent( NULL, /* bManualReset = */ TRUE, /* bInitialState = */ FALSE, NULL );
        if( stream->processingThreadCompleted == NULL )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( GetLastError() );
            goto error;
        }
#endif

        /* set up i/o parameters */

        if( userRequestedHostInputBufferSizeFrames > 0 || userRequestedHostOutputBufferSizeFrames > 0 )
        {
            /* use low level parameters */

            /* since we use the same host buffer size for input and output
               we choose the highest user specified value.
            */
            stream->hostBufferSizeFrames = max( userRequestedHostInputBufferSizeFrames, userRequestedHostOutputBufferSizeFrames );

            CalculatePollingPeriodFrames( 
                    stream->hostBufferSizeFrames, &pollingPeriodFrames,
                    sampleRate, framesPerBuffer );
        }
        else
        {
            CalculateBufferSettings( &stream->hostBufferSizeFrames, &pollingPeriodFrames,
                    /* isFullDuplex = */ (inputParameters && outputParameters),
                    suggestedInputLatencyFrames,
                    suggestedOutputLatencyFrames, 
                    sampleRate, framesPerBuffer );
        }

        stream->pollingPeriodSeconds = pollingPeriodFrames / sampleRate;

        DBUG(("DirectSound host buffer size frames: %d, polling period seconds: %f, @ sr: %f\n", 
                stream->hostBufferSizeFrames, stream->pollingPeriodSeconds, sampleRate ));


        /* ------------------ OUTPUT */
        if( outputParameters )
        {
            LARGE_INTEGER  counterFrequency;

            /*
            PaDeviceInfo *deviceInfo = hostApi->deviceInfos[ outputParameters->device ];
            DBUG(("PaHost_OpenStream: deviceID = 0x%x\n", outputParameters->device));
            */
            
            int sampleSizeBytes = Pa_GetSampleSize(hostOutputSampleFormat);
            stream->outputFrameSizeBytes = outputParameters->channelCount * sampleSizeBytes;

            stream->outputBufferSizeBytes = stream->hostBufferSizeFrames * stream->outputFrameSizeBytes;
            if( stream->outputBufferSizeBytes < DSBSIZE_MIN )
            {
                result = paBufferTooSmall;
                goto error;
            }
            else if( stream->outputBufferSizeBytes > DSBSIZE_MAX )
            {
                result = paBufferTooBig;
                goto error;
            }

            /* Calculate value used in latency calculation to avoid real-time divides. */
            stream->secondsPerHostByte = 1.0 /
                (stream->bufferProcessor.bytesPerHostOutputSample *
                outputChannelCount * sampleRate);

            stream->outputIsRunning = FALSE;
            stream->outputUnderflowCount = 0;
            
            /* perfCounterTicksPerBuffer is used by QueryOutputSpace for overflow detection */
            if( QueryPerformanceFrequency( &counterFrequency ) )
            {
                stream->perfCounterTicksPerBuffer.QuadPart = (counterFrequency.QuadPart * stream->hostBufferSizeFrames) / integerSampleRate;
            }
            else
            {
                stream->perfCounterTicksPerBuffer.QuadPart = 0;
            }
        }

        /* ------------------ INPUT */
        if( inputParameters )
        {
            /*
            PaDeviceInfo *deviceInfo = hostApi->deviceInfos[ inputParameters->device ];
            DBUG(("PaHost_OpenStream: deviceID = 0x%x\n", inputParameters->device));
            */
            
            int sampleSizeBytes = Pa_GetSampleSize(hostInputSampleFormat);
            stream->inputFrameSizeBytes = inputParameters->channelCount * sampleSizeBytes;

            stream->inputBufferSizeBytes = stream->hostBufferSizeFrames * stream->inputFrameSizeBytes;
            if( stream->inputBufferSizeBytes < DSBSIZE_MIN )
            {
                result = paBufferTooSmall;
                goto error;
            }
            else if( stream->inputBufferSizeBytes > DSBSIZE_MAX )
            {
                result = paBufferTooBig;
                goto error;
            }
        }

        /* open/create the DirectSound buffers */

        /* interface ptrs should be zeroed when stream is zeroed. */
        assert( stream->pDirectSoundCapture == NULL );
        assert( stream->pDirectSoundInputBuffer == NULL );
        assert( stream->pDirectSound == NULL );
        assert( stream->pDirectSoundPrimaryBuffer == NULL );
        assert( stream->pDirectSoundOutputBuffer == NULL );
        

        if( inputParameters && outputParameters )
        {
#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
            /* try to use the full-duplex DX8 API to create the buffers.
                if that fails we fall back to the half-duplex API below */

            hr = InitFullDuplexInputOutputBuffers( stream,
                                       (PaWinDsDeviceInfo*)hostApi->deviceInfos[inputParameters->device],
                                       hostInputSampleFormat,
                                       (WORD)inputParameters->channelCount, stream->inputBufferSizeBytes,
                                       inputChannelMask,
                                       (PaWinDsDeviceInfo*)hostApi->deviceInfos[outputParameters->device],
                                       hostOutputSampleFormat,
                                       (WORD)outputParameters->channelCount, stream->outputBufferSizeBytes,
                                       outputChannelMask,
                                       integerSampleRate
                                        );
            DBUG(("InitFullDuplexInputOutputBuffers() returns %x\n", hr));
            /* ignore any error returned by InitFullDuplexInputOutputBuffers. 
                we retry opening the buffers below */
#endif /* PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE */
        }

        /*  create half duplex buffers. also used for full-duplex streams which didn't 
            succeed when using the full duplex API. that could happen because
            DX8 or greater isnt installed, the i/o devices aren't the same 
            physical device. etc.
        */

        if( outputParameters && !stream->pDirectSoundOutputBuffer )
        {
            hr = InitOutputBuffer( stream,
                                       (PaWinDsDeviceInfo*)hostApi->deviceInfos[outputParameters->device],
                                       hostOutputSampleFormat,
                                       integerSampleRate,
                                       (WORD)outputParameters->channelCount, stream->outputBufferSizeBytes,
                                       outputChannelMask );
            DBUG(("InitOutputBuffer() returns %x\n", hr));
            if( hr != DS_OK )
            {
                result = paUnanticipatedHostError;
                PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr );
                goto error;
            }
        }

        if( inputParameters && !stream->pDirectSoundInputBuffer )
        {
            hr = InitInputBuffer( stream,
                                      (PaWinDsDeviceInfo*)hostApi->deviceInfos[inputParameters->device],
                                      hostInputSampleFormat,
                                      integerSampleRate,
                                      (WORD)inputParameters->channelCount, stream->inputBufferSizeBytes,
                                      inputChannelMask );
            DBUG(("InitInputBuffer() returns %x\n", hr));
            if( hr != DS_OK )
            {
                ERR_RPT(("PortAudio: DSW_InitInputBuffer() returns %x\n", hr));
                result = paUnanticipatedHostError;
                PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr );
                goto error;
            }
        }
    }

    SetStreamInfoLatencies( stream, framesPerBuffer, pollingPeriodFrames, sampleRate );

    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

    *s = (PaStream*)stream;

    return result;

error:
    if( stream )
    {
        if( stream->processingCompleted != NULL )
            CloseHandle( stream->processingCompleted );

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT
        if( stream->waitableTimer != NULL )
            CloseHandle( stream->waitableTimer );
#endif

#ifndef PA_WIN_DS_USE_WMME_TIMER
        if( stream->processingThreadCompleted != NULL )
            CloseHandle( stream->processingThreadCompleted );
#endif

        if( stream->pDirectSoundOutputBuffer )
        {
            IDirectSoundBuffer_Stop( stream->pDirectSoundOutputBuffer );
            IDirectSoundBuffer_Release( stream->pDirectSoundOutputBuffer );
            stream->pDirectSoundOutputBuffer = NULL;
        }

        if( stream->pDirectSoundPrimaryBuffer )
        {
            IDirectSoundBuffer_Release( stream->pDirectSoundPrimaryBuffer );
            stream->pDirectSoundPrimaryBuffer = NULL;
        }

        if( stream->pDirectSoundInputBuffer )
        {
            IDirectSoundCaptureBuffer_Stop( stream->pDirectSoundInputBuffer );
            IDirectSoundCaptureBuffer_Release( stream->pDirectSoundInputBuffer );
            stream->pDirectSoundInputBuffer = NULL;
        }

        if( stream->pDirectSoundCapture )
        {
            IDirectSoundCapture_Release( stream->pDirectSoundCapture );
            stream->pDirectSoundCapture = NULL;
        }

        if( stream->pDirectSound )
        {
            IDirectSound_Release( stream->pDirectSound );
            stream->pDirectSound = NULL;
        }

#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
        if( stream->pDirectSoundFullDuplex8 )
        {
            IDirectSoundFullDuplex_Release( stream->pDirectSoundFullDuplex8 );
            stream->pDirectSoundFullDuplex8 = NULL;
        }
#endif
        if( bufferProcessorIsInitialized )
            PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );

        if( streamRepresentationIsInitialized )
            PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );

        PaUtil_FreeMemory( stream );
    }

    return result;
}


/************************************************************************************
 * Determine how much space can be safely written to in DS buffer.
 * Detect underflows and overflows.
 * Does not allow writing into safety gap maintained by DirectSound.
 */
static HRESULT QueryOutputSpace( PaWinDsStream *stream, long *bytesEmpty )
{
    HRESULT hr;
    DWORD   playCursor;
    DWORD   writeCursor;
    long    numBytesEmpty;
    long    playWriteGap;
    // Query to see how much room is in buffer.
    hr = IDirectSoundBuffer_GetCurrentPosition( stream->pDirectSoundOutputBuffer,
            &playCursor, &writeCursor );
    if( hr != DS_OK )
    {
        return hr;
    }

    // Determine size of gap between playIndex and WriteIndex that we cannot write into.
    playWriteGap = writeCursor - playCursor;
    if( playWriteGap < 0 ) playWriteGap += stream->outputBufferSizeBytes; // unwrap

    /* DirectSound doesn't have a large enough playCursor so we cannot detect wrap-around. */
    /* Attempt to detect playCursor wrap-around and correct it. */
    if( stream->outputIsRunning && (stream->perfCounterTicksPerBuffer.QuadPart != 0) )
    {
        /* How much time has elapsed since last check. */
        LARGE_INTEGER   currentTime;
        LARGE_INTEGER   elapsedTime;
        long            bytesPlayed;
        long            bytesExpected;
        long            buffersWrapped;

        QueryPerformanceCounter( &currentTime );
        elapsedTime.QuadPart = currentTime.QuadPart - stream->previousPlayTime.QuadPart;
        stream->previousPlayTime = currentTime;

        /* How many bytes does DirectSound say have been played. */
        bytesPlayed = playCursor - stream->previousPlayCursor;
        if( bytesPlayed < 0 ) bytesPlayed += stream->outputBufferSizeBytes; // unwrap
        stream->previousPlayCursor = playCursor;

        /* Calculate how many bytes we would have expected to been played by now. */
        bytesExpected = (long) ((elapsedTime.QuadPart * stream->outputBufferSizeBytes) / stream->perfCounterTicksPerBuffer.QuadPart);
        buffersWrapped = (bytesExpected - bytesPlayed) / stream->outputBufferSizeBytes;
        if( buffersWrapped > 0 )
        {
            playCursor += (buffersWrapped * stream->outputBufferSizeBytes);
            bytesPlayed += (buffersWrapped * stream->outputBufferSizeBytes);
        }
    }
    numBytesEmpty = playCursor - stream->outputBufferWriteOffsetBytes;
    if( numBytesEmpty < 0 ) numBytesEmpty += stream->outputBufferSizeBytes; // unwrap offset

    /* Have we underflowed? */
    if( numBytesEmpty > (stream->outputBufferSizeBytes - playWriteGap) )
    {
        if( stream->outputIsRunning )
        {
            stream->outputUnderflowCount += 1;
        }

        /*
            From MSDN:
                The write cursor indicates the position at which it is safe  
            to write new data to the buffer. The write cursor always leads the
            play cursor, typically by about 15 milliseconds' worth of audio
            data.
                It is always safe to change data that is behind the position 
            indicated by the lpdwCurrentPlayCursor parameter.
        */

        stream->outputBufferWriteOffsetBytes = writeCursor;
        numBytesEmpty = stream->outputBufferSizeBytes - playWriteGap;
    }
    *bytesEmpty = numBytesEmpty;
    return hr;
}

/***********************************************************************************/
static int TimeSlice( PaWinDsStream *stream )
{
    long              numFrames = 0;
    long              bytesEmpty = 0;
    long              bytesFilled = 0;
    long              bytesToXfer = 0;
    long              framesToXfer = 0; /* the number of frames we'll process this tick */
    long              numInFramesReady = 0;
    long              numOutFramesReady = 0;
    long              bytesProcessed;
    HRESULT           hresult;
    double            outputLatency = 0;
    double            inputLatency = 0;
    PaStreamCallbackTimeInfo timeInfo = {0,0,0};
    
/* Input */
    LPBYTE            lpInBuf1 = NULL;
    LPBYTE            lpInBuf2 = NULL;
    DWORD             dwInSize1 = 0;
    DWORD             dwInSize2 = 0;
/* Output */
    LPBYTE            lpOutBuf1 = NULL;
    LPBYTE            lpOutBuf2 = NULL;
    DWORD             dwOutSize1 = 0;
    DWORD             dwOutSize2 = 0;

    /* How much input data is available? */
    if( stream->bufferProcessor.inputChannelCount > 0 )
    {
        HRESULT hr;
        DWORD capturePos;
        DWORD readPos;
        long  filled = 0;
        // Query to see how much data is in buffer.
        // We don't need the capture position but sometimes DirectSound doesn't handle NULLS correctly
        // so let's pass a pointer just to be safe.
        hr = IDirectSoundCaptureBuffer_GetCurrentPosition( stream->pDirectSoundInputBuffer, &capturePos, &readPos );
        if( hr == DS_OK )
        {
            filled = readPos - stream->readOffset;
            if( filled < 0 ) filled += stream->inputBufferSizeBytes; // unwrap offset
            bytesFilled = filled;

            inputLatency = ((double)bytesFilled) * stream->secondsPerHostByte;
        }
            // FIXME: what happens if IDirectSoundCaptureBuffer_GetCurrentPosition fails?

        framesToXfer = numInFramesReady = bytesFilled / stream->inputFrameSizeBytes; 

        /** @todo Check for overflow */
    }

    /* How much output room is available? */
    if( stream->bufferProcessor.outputChannelCount > 0 )
    {
        UINT previousUnderflowCount = stream->outputUnderflowCount;
        QueryOutputSpace( stream, &bytesEmpty );
        framesToXfer = numOutFramesReady = bytesEmpty / stream->outputFrameSizeBytes;

        /* Check for underflow */
        /* FIXME QueryOutputSpace should not adjust underflow count as a side effect. 
            A query function should be a const operator on the stream and return a flag on underflow. */
        if( stream->outputUnderflowCount != previousUnderflowCount )
            stream->callbackFlags |= paOutputUnderflow;

        /* We are about to compute audio into the first byte of empty space in the output buffer.
           This audio will reach the DAC after all of the current (non-empty) audio
           in the buffer has played. Therefore the output time is the current time
           plus the time it takes to play the non-empty bytes in the buffer,
           computed here:
        */
        outputLatency = ((double)(stream->outputBufferSizeBytes - bytesEmpty)) * stream->secondsPerHostByte;
    }

    /* if it's a full duplex stream, set framesToXfer to the minimum of input and output frames ready */
    if( stream->bufferProcessor.inputChannelCount > 0 && stream->bufferProcessor.outputChannelCount > 0 )
    {
        framesToXfer = (numOutFramesReady < numInFramesReady) ? numOutFramesReady : numInFramesReady;
    }

    if( framesToXfer > 0 )
    {
        PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

    /* The outputBufferDacTime parameter should indicates the time at which
        the first sample of the output buffer is heard at the DACs. */
        timeInfo.currentTime = PaUtil_GetTime();

        PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, stream->callbackFlags );
        stream->callbackFlags = 0;
        
    /* Input */
        if( stream->bufferProcessor.inputChannelCount > 0 )
        {
            timeInfo.inputBufferAdcTime = timeInfo.currentTime - inputLatency; 

            bytesToXfer = framesToXfer * stream->inputFrameSizeBytes;
            hresult = IDirectSoundCaptureBuffer_Lock ( stream->pDirectSoundInputBuffer,
                stream->readOffset, bytesToXfer,
                (void **) &lpInBuf1, &dwInSize1,
                (void **) &lpInBuf2, &dwInSize2, 0);
            if (hresult != DS_OK)
            {
                ERR_RPT(("DirectSound IDirectSoundCaptureBuffer_Lock failed, hresult = 0x%x\n",hresult));
                /* PA_DS_SET_LAST_DIRECTSOUND_ERROR( hresult ); */
                PaUtil_ResetBufferProcessor( &stream->bufferProcessor ); /* flush the buffer processor */
                stream->callbackResult = paComplete;
                goto error2;
            }

            numFrames = dwInSize1 / stream->inputFrameSizeBytes;
            PaUtil_SetInputFrameCount( &stream->bufferProcessor, numFrames );
            PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor, 0, lpInBuf1, 0 );
        /* Is input split into two regions. */
            if( dwInSize2 > 0 )
            {
                numFrames = dwInSize2 / stream->inputFrameSizeBytes;
                PaUtil_Set2ndInputFrameCount( &stream->bufferProcessor, numFrames );
                PaUtil_Set2ndInterleavedInputChannels( &stream->bufferProcessor, 0, lpInBuf2, 0 );
            }
        }

    /* Output */
        if( stream->bufferProcessor.outputChannelCount > 0 )
        {
            /*
            We don't currently add outputLatency here because it appears to produce worse
            results than not adding it. Need to do more testing to verify this.
            */
            /* timeInfo.outputBufferDacTime = timeInfo.currentTime + outputLatency; */
            timeInfo.outputBufferDacTime = timeInfo.currentTime;

            bytesToXfer = framesToXfer * stream->outputFrameSizeBytes;
            hresult = IDirectSoundBuffer_Lock ( stream->pDirectSoundOutputBuffer,
                stream->outputBufferWriteOffsetBytes, bytesToXfer,
                (void **) &lpOutBuf1, &dwOutSize1,
                (void **) &lpOutBuf2, &dwOutSize2, 0);
            if (hresult != DS_OK)
            {
                ERR_RPT(("DirectSound IDirectSoundBuffer_Lock failed, hresult = 0x%x\n",hresult));
                /* PA_DS_SET_LAST_DIRECTSOUND_ERROR( hresult ); */
                PaUtil_ResetBufferProcessor( &stream->bufferProcessor ); /* flush the buffer processor */
                stream->callbackResult = paComplete;
                goto error1;
            }

            numFrames = dwOutSize1 / stream->outputFrameSizeBytes;
            PaUtil_SetOutputFrameCount( &stream->bufferProcessor, numFrames );
            PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, 0, lpOutBuf1, 0 );

        /* Is output split into two regions. */
            if( dwOutSize2 > 0 )
            {
                numFrames = dwOutSize2 / stream->outputFrameSizeBytes;
                PaUtil_Set2ndOutputFrameCount( &stream->bufferProcessor, numFrames );
                PaUtil_Set2ndInterleavedOutputChannels( &stream->bufferProcessor, 0, lpOutBuf2, 0 );
            }
        }

        numFrames = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &stream->callbackResult );
        stream->framesWritten += numFrames;
        
        if( stream->bufferProcessor.outputChannelCount > 0 )
        {
        /* FIXME: an underflow could happen here */

        /* Update our buffer offset and unlock sound buffer */
            bytesProcessed = numFrames * stream->outputFrameSizeBytes;
            stream->outputBufferWriteOffsetBytes = (stream->outputBufferWriteOffsetBytes + bytesProcessed) % stream->outputBufferSizeBytes;
            IDirectSoundBuffer_Unlock( stream->pDirectSoundOutputBuffer, lpOutBuf1, dwOutSize1, lpOutBuf2, dwOutSize2);
        }

error1:
        if( stream->bufferProcessor.inputChannelCount > 0 )
        {
        /* FIXME: an overflow could happen here */

        /* Update our buffer offset and unlock sound buffer */
            bytesProcessed = numFrames * stream->inputFrameSizeBytes;
            stream->readOffset = (stream->readOffset + bytesProcessed) % stream->inputBufferSizeBytes;
            IDirectSoundCaptureBuffer_Unlock( stream->pDirectSoundInputBuffer, lpInBuf1, dwInSize1, lpInBuf2, dwInSize2);
        }
error2:

        PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, numFrames );        
    }

    if( stream->callbackResult == paComplete && !PaUtil_IsBufferProcessorOutputEmpty( &stream->bufferProcessor ) )
    {
        /* don't return completed until the buffer processor has been drained */
        return paContinue;
    }
    else
    {
        return stream->callbackResult;
    }
}
/*******************************************************************/

static HRESULT ZeroAvailableOutputSpace( PaWinDsStream *stream )
{
    HRESULT hr;
    LPBYTE lpbuf1 = NULL;
    LPBYTE lpbuf2 = NULL;
    DWORD dwsize1 = 0;
    DWORD dwsize2 = 0;
    long  bytesEmpty;
    hr = QueryOutputSpace( stream, &bytesEmpty );
    if (hr != DS_OK) return hr;
    if( bytesEmpty == 0 ) return DS_OK;
    // Lock free space in the DS
    hr = IDirectSoundBuffer_Lock( stream->pDirectSoundOutputBuffer, stream->outputBufferWriteOffsetBytes,
                                    bytesEmpty, (void **) &lpbuf1, &dwsize1,
                                    (void **) &lpbuf2, &dwsize2, 0);
    if (hr == DS_OK)
    {
        // Copy the buffer into the DS
        ZeroMemory(lpbuf1, dwsize1);
        if(lpbuf2 != NULL)
        {
            ZeroMemory(lpbuf2, dwsize2);
        }
        // Update our buffer offset and unlock sound buffer
        stream->outputBufferWriteOffsetBytes = (stream->outputBufferWriteOffsetBytes + dwsize1 + dwsize2) % stream->outputBufferSizeBytes;
        IDirectSoundBuffer_Unlock( stream->pDirectSoundOutputBuffer, lpbuf1, dwsize1, lpbuf2, dwsize2);

        stream->finalZeroBytesWritten += dwsize1 + dwsize2;
    }
    return hr;
}


static void CALLBACK TimerCallback(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
    PaWinDsStream *stream;
    int isFinished = 0;

    /* suppress unused variable warnings */
    (void) uID;
    (void) uMsg;
    (void) dw1;
    (void) dw2;
    
    stream = (PaWinDsStream *) dwUser;
    if( stream == NULL ) return;

    if( stream->isActive )
    {
        if( stream->abortProcessing )
        {
            isFinished = 1;
        }
        else if( stream->stopProcessing )
        {
            if( stream->bufferProcessor.outputChannelCount > 0 )
            {
                ZeroAvailableOutputSpace( stream );
                if( stream->finalZeroBytesWritten >= stream->outputBufferSizeBytes )
                {
                    /* once we've flushed the whole output buffer with zeros we know all data has been played */
                    isFinished = 1;
                }
            }
            else
            {
                isFinished = 1;
            }
        }
        else
        {
            int callbackResult = TimeSlice( stream );
            if( callbackResult != paContinue )
            {
                /* FIXME implement handling of paComplete and paAbort if possible 
                   At the moment this should behave as if paComplete was called and 
                   flush the buffer.
                */

                stream->stopProcessing = 1;
            }
        }

        if( isFinished )
        {
            if( stream->streamRepresentation.streamFinishedCallback != 0 )
                stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );

            stream->isActive = 0; /* don't set this until the stream really is inactive */
            SetEvent( stream->processingCompleted );
        }
    }
}

#ifndef PA_WIN_DS_USE_WMME_TIMER

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT

static void CALLBACK WaitableTimerAPCProc(
   LPVOID lpArg,               // Data value
   DWORD dwTimerLowValue,      // Timer low value
   DWORD dwTimerHighValue )    // Timer high value

{
    (void)dwTimerLowValue;
    (void)dwTimerHighValue;

    TimerCallback( 0, 0, (DWORD_PTR)lpArg, 0, 0 );
}

#endif /* PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT */


PA_THREAD_FUNC ProcessingThreadProc( void *pArg )
{
    PaWinDsStream *stream = (PaWinDsStream *)pArg;
    LARGE_INTEGER dueTime;
    int timerPeriodMs;

    timerPeriodMs = (int)(stream->pollingPeriodSeconds * MSECS_PER_SECOND);
    if( timerPeriodMs < 1 )
        timerPeriodMs = 1;

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT
    assert( stream->waitableTimer != NULL );

    /* invoke first timeout immediately */
    dueTime.LowPart = timerPeriodMs * 1000 * 10;
    dueTime.HighPart = 0;

    /* tick using waitable timer */
    if( SetWaitableTimer( stream->waitableTimer, &dueTime, timerPeriodMs, WaitableTimerAPCProc, pArg, FALSE ) != 0 )
    {
        DWORD wfsoResult = 0;
        do
        {
            /* wait for processingCompleted to be signaled or our timer APC to be called */
            wfsoResult = WaitForSingleObjectEx( stream->processingCompleted, timerPeriodMs * 10, /* alertable = */ TRUE );

        }while( wfsoResult == WAIT_TIMEOUT || wfsoResult == WAIT_IO_COMPLETION );
    }

    CancelWaitableTimer( stream->waitableTimer );

#else

    /* tick using WaitForSingleObject timout */
    while ( WaitForSingleObject( stream->processingCompleted, timerPeriodMs ) == WAIT_TIMEOUT )
    {
        TimerCallback( 0, 0, (DWORD_PTR)pArg, 0, 0 );
    }
#endif /* PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT */

    SetEvent( stream->processingThreadCompleted );

    return 0;
}

#endif /* !PA_WIN_DS_USE_WMME_TIMER */

/***********************************************************************************
    When CloseStream() is called, the multi-api layer ensures that
    the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaWinDsStream *stream = (PaWinDsStream*)s;

    CloseHandle( stream->processingCompleted );

#ifdef PA_WIN_DS_USE_WAITABLE_TIMER_OBJECT
    if( stream->waitableTimer != NULL )
        CloseHandle( stream->waitableTimer );
#endif

#ifndef PA_WIN_DS_USE_WMME_TIMER
    CloseHandle( stream->processingThreadCompleted );
#endif

    // Cleanup the sound buffers
    if( stream->pDirectSoundOutputBuffer )
    {
        IDirectSoundBuffer_Stop( stream->pDirectSoundOutputBuffer );
        IDirectSoundBuffer_Release( stream->pDirectSoundOutputBuffer );
        stream->pDirectSoundOutputBuffer = NULL;
    }

    if( stream->pDirectSoundPrimaryBuffer )
    {
        IDirectSoundBuffer_Release( stream->pDirectSoundPrimaryBuffer );
        stream->pDirectSoundPrimaryBuffer = NULL;
    }

    if( stream->pDirectSoundInputBuffer )
    {
        IDirectSoundCaptureBuffer_Stop( stream->pDirectSoundInputBuffer );
        IDirectSoundCaptureBuffer_Release( stream->pDirectSoundInputBuffer );
        stream->pDirectSoundInputBuffer = NULL;
    }

    if( stream->pDirectSoundCapture )
    {
        IDirectSoundCapture_Release( stream->pDirectSoundCapture );
        stream->pDirectSoundCapture = NULL;
    }

    if( stream->pDirectSound )
    {
        IDirectSound_Release( stream->pDirectSound );
        stream->pDirectSound = NULL;
    }

#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
    if( stream->pDirectSoundFullDuplex8 )
    {
        IDirectSoundFullDuplex_Release( stream->pDirectSoundFullDuplex8 );
        stream->pDirectSoundFullDuplex8 = NULL;
    }
#endif

    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
    PaUtil_FreeMemory( stream );

    return result;
}

/***********************************************************************************/
static HRESULT ClearOutputBuffer( PaWinDsStream *stream )
{
    PaError          result = paNoError;
    unsigned char*   pDSBuffData;
    DWORD            dwDataLen;
    HRESULT          hr;

    hr = IDirectSoundBuffer_SetCurrentPosition( stream->pDirectSoundOutputBuffer, 0 );
    DBUG(("PaHost_ClearOutputBuffer: IDirectSoundBuffer_SetCurrentPosition returned = 0x%X.\n", hr));
    if( hr != DS_OK )
        return hr;

    // Lock the DS buffer
    if ((hr = IDirectSoundBuffer_Lock( stream->pDirectSoundOutputBuffer, 0, stream->outputBufferSizeBytes, (LPVOID*)&pDSBuffData,
                                           &dwDataLen, NULL, 0, 0)) != DS_OK )
        return hr;

    // Zero the DS buffer
    ZeroMemory(pDSBuffData, dwDataLen);
    // Unlock the DS buffer
    if ((hr = IDirectSoundBuffer_Unlock( stream->pDirectSoundOutputBuffer, pDSBuffData, dwDataLen, NULL, 0)) != DS_OK)
        return hr;
    
    // Let DSound set the starting write position because if we set it to zero, it looks like the
    // buffer is full to begin with. This causes a long pause before sound starts when using large buffers.
    if ((hr = IDirectSoundBuffer_GetCurrentPosition( stream->pDirectSoundOutputBuffer,
            &stream->previousPlayCursor, &stream->outputBufferWriteOffsetBytes )) != DS_OK)
        return hr;

    /* printf("DSW_InitOutputBuffer: playCursor = %d, writeCursor = %d\n", playCursor, dsw->dsw_WriteOffset ); */

    return DS_OK;
}

static PaError StartStream( PaStream *s )
{
    PaError          result = paNoError;
    PaWinDsStream   *stream = (PaWinDsStream*)s;
    HRESULT          hr;
        
    stream->callbackResult = paContinue;
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );
    
    ResetEvent( stream->processingCompleted );

#ifndef PA_WIN_DS_USE_WMME_TIMER
    ResetEvent( stream->processingThreadCompleted );
#endif

    if( stream->bufferProcessor.inputChannelCount > 0 )
    {
        // Start the buffer capture
        if( stream->pDirectSoundInputBuffer != NULL ) // FIXME: not sure this check is necessary
        {
            hr = IDirectSoundCaptureBuffer_Start( stream->pDirectSoundInputBuffer, DSCBSTART_LOOPING );
        }

        DBUG(("StartStream: DSW_StartInput returned = 0x%X.\n", hr));
        if( hr != DS_OK )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr );
            goto error;
        }
    }

    stream->framesWritten = 0;
    stream->callbackFlags = 0;

    stream->abortProcessing = 0;
    stream->stopProcessing = 0;

    if( stream->bufferProcessor.outputChannelCount > 0 )
    {
        QueryPerformanceCounter( &stream->previousPlayTime );
        stream->finalZeroBytesWritten = 0;

        hr = ClearOutputBuffer( stream );
        if( hr != DS_OK )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr );
            goto error;
        }

        if( stream->streamRepresentation.streamCallback && (stream->streamFlags & paPrimeOutputBuffersUsingStreamCallback) )
        {
            stream->callbackFlags = paPrimingOutput;

            TimeSlice( stream );
            /* we ignore the return value from TimeSlice here and start the stream as usual.
                The first timer callback will detect if the callback has completed. */

            stream->callbackFlags = 0;
        }

        // Start the buffer playback in a loop.
        if( stream->pDirectSoundOutputBuffer != NULL ) // FIXME: not sure this needs to be checked here
        {
            hr = IDirectSoundBuffer_Play( stream->pDirectSoundOutputBuffer, 0, 0, DSBPLAY_LOOPING );
            DBUG(("PaHost_StartOutput: IDirectSoundBuffer_Play returned = 0x%X.\n", hr));
            if( hr != DS_OK )
            {
                result = paUnanticipatedHostError;
                PA_DS_SET_LAST_DIRECTSOUND_ERROR( hr );
                goto error;
            }
            stream->outputIsRunning = TRUE;
        }
    }

    if( stream->streamRepresentation.streamCallback )
    {
        TIMECAPS timecaps;
        int timerPeriodMs = (int)(stream->pollingPeriodSeconds * MSECS_PER_SECOND);
        if( timerPeriodMs < 1 )
            timerPeriodMs = 1;

        /* set windows scheduler granularity only as fine as needed, no finer */
        /* Although this is not fully documented by MS, it appears that
           timeBeginPeriod() affects the scheduling granulatity of all timers
           including Waitable Timer Objects. So we always call timeBeginPeriod, whether
           we're using an MM timer callback via timeSetEvent or not.
        */
        assert( stream->systemTimerResolutionPeriodMs == 0 );
        if( timeGetDevCaps( &timecaps, sizeof(TIMECAPS) ) == MMSYSERR_NOERROR && timecaps.wPeriodMin > 0 )
        {
            /* aim for resolution 4 times higher than polling rate */
            stream->systemTimerResolutionPeriodMs = (UINT)((stream->pollingPeriodSeconds * MSECS_PER_SECOND) * .25);
            if( stream->systemTimerResolutionPeriodMs < timecaps.wPeriodMin )
                stream->systemTimerResolutionPeriodMs = timecaps.wPeriodMin;
            if( stream->systemTimerResolutionPeriodMs > timecaps.wPeriodMax )
                stream->systemTimerResolutionPeriodMs = timecaps.wPeriodMax;

            if( timeBeginPeriod( stream->systemTimerResolutionPeriodMs ) != MMSYSERR_NOERROR )
                stream->systemTimerResolutionPeriodMs = 0; /* timeBeginPeriod failed, so we don't need to call timeEndPeriod() later */
        }


#ifdef PA_WIN_DS_USE_WMME_TIMER
        /* Create timer that will wake us up so we can fill the DSound buffer. */
        /* We have deprecated timeSetEvent because all MM timer callbacks
           are serialised onto a single thread. Which creates problems with multiple
           PA streams, or when also using timers for other time critical tasks
        */
        stream->timerID = timeSetEvent( timerPeriodMs, stream->systemTimerResolutionPeriodMs, (LPTIMECALLBACK) TimerCallback,
                                             (DWORD_PTR) stream, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS );
    
        if( stream->timerID == 0 )
        {
            stream->isActive = 0;
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( GetLastError() );
            goto error;
        }
#else
        /* Create processing thread which calls TimerCallback */

        stream->processingThread = CREATE_THREAD( 0, 0, ProcessingThreadProc, stream, 0, &stream->processingThreadId );
        if( !stream->processingThread )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( GetLastError() );
            goto error;
        }

        if( !SetThreadPriority( stream->processingThread, THREAD_PRIORITY_TIME_CRITICAL ) )
        {
            result = paUnanticipatedHostError;
            PA_DS_SET_LAST_DIRECTSOUND_ERROR( GetLastError() );
            goto error;
        }
#endif
    }

    stream->isActive = 1;
    stream->isStarted = 1;

    assert( result == paNoError );
    return result;

error:

    if( stream->pDirectSoundOutputBuffer != NULL && stream->outputIsRunning )
        IDirectSoundBuffer_Stop( stream->pDirectSoundOutputBuffer );
    stream->outputIsRunning = FALSE;

#ifndef PA_WIN_DS_USE_WMME_TIMER
    if( stream->processingThread )
    {
#ifdef CLOSE_THREAD_HANDLE
        CLOSE_THREAD_HANDLE( stream->processingThread ); /* Delete thread. */
#endif
        stream->processingThread = NULL;
    }
#endif

    return result;
}


/***********************************************************************************/
static PaError StopStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinDsStream *stream = (PaWinDsStream*)s;
    HRESULT          hr;
    int timeoutMsec;

    if( stream->streamRepresentation.streamCallback )
    {
        stream->stopProcessing = 1;

        /* Set timeout at 4 times maximum time we might wait. */
        timeoutMsec = (int) (4 * MSECS_PER_SECOND * (stream->hostBufferSizeFrames / stream->streamRepresentation.streamInfo.sampleRate));

        WaitForSingleObject( stream->processingCompleted, timeoutMsec );
    }

#ifdef PA_WIN_DS_USE_WMME_TIMER
    if( stream->timerID != 0 )
    {
        timeKillEvent(stream->timerID);  /* Stop callback timer. */
        stream->timerID = 0;
    }
#else
    if( stream->processingThread )
    {
        if( WaitForSingleObject( stream->processingThreadCompleted, 30*100 ) == WAIT_TIMEOUT )
            return paUnanticipatedHostError;

#ifdef CLOSE_THREAD_HANDLE
        CloseHandle( stream->processingThread ); /* Delete thread. */
        stream->processingThread = NULL;
#endif

    }
#endif

    if( stream->systemTimerResolutionPeriodMs > 0 ){
        timeEndPeriod( stream->systemTimerResolutionPeriodMs );
        stream->systemTimerResolutionPeriodMs = 0;
    }  

    if( stream->bufferProcessor.outputChannelCount > 0 )
    {
        // Stop the buffer playback
        if( stream->pDirectSoundOutputBuffer != NULL )
        {
            stream->outputIsRunning = FALSE;
            // FIXME: what happens if IDirectSoundBuffer_Stop returns an error?
            hr = IDirectSoundBuffer_Stop( stream->pDirectSoundOutputBuffer );

            if( stream->pDirectSoundPrimaryBuffer )
                IDirectSoundBuffer_Stop( stream->pDirectSoundPrimaryBuffer ); /* FIXME we never started the primary buffer so I'm not sure we need to stop it */
        }
    }

    if( stream->bufferProcessor.inputChannelCount > 0 )
    {
        // Stop the buffer capture
        if( stream->pDirectSoundInputBuffer != NULL )
        {
            // FIXME: what happens if IDirectSoundCaptureBuffer_Stop returns an error?
            hr = IDirectSoundCaptureBuffer_Stop( stream->pDirectSoundInputBuffer );
        }
    }

    stream->isStarted = 0;

    return result;
}


/***********************************************************************************/
static PaError AbortStream( PaStream *s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    stream->abortProcessing = 1;
    return StopStream( s );
}


/***********************************************************************************/
static PaError IsStreamStopped( PaStream *s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    return !stream->isStarted;
}


/***********************************************************************************/
static PaError IsStreamActive( PaStream *s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    return stream->isActive;
}

/***********************************************************************************/
static PaTime GetStreamTime( PaStream *s )
{
    /* suppress unused variable warnings */
    (void) s;

    return PaUtil_GetTime();
}


/***********************************************************************************/
static double GetStreamCpuLoad( PaStream* s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}


/***********************************************************************************
    As separate stream interfaces are used for blocking and callback
    streams, the following functions can be guaranteed to only be called
    for blocking streams.
*/

static PaError ReadStream( PaStream* s,
                           void *buffer,
                           unsigned long frames )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    /* suppress unused variable warnings */
    (void) buffer;
    (void) frames;
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/

    return paNoError;
}


/***********************************************************************************/
static PaError WriteStream( PaStream* s,
                            const void *buffer,
                            unsigned long frames )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    /* suppress unused variable warnings */
    (void) buffer;
    (void) frames;
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/

    return paNoError;
}


/***********************************************************************************/
static signed long GetStreamReadAvailable( PaStream* s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    /* suppress unused variable warnings */
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/

    return 0;
}


/***********************************************************************************/
static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaWinDsStream *stream = (PaWinDsStream*)s;

    /* suppress unused variable warnings */
    (void) stream;
    
    /* IMPLEMENT ME, see portaudio.h for required behavior*/

    return 0;
}

/*
 * Interface for dynamically loading directsound and providing a dummy
 * implementation if it isn't present.
 *
 * Author: Ross Bencina (some portions Phil Burk & Robert Marsanyi)
 *
 * For PortAudio Portable Real-Time Audio Library
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2006 Phil Burk, Robert Marsanyi and Ross Bencina
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

// (amalg) #include "pa_win_ds_dynlink.h"
// (amalg) #include "pa_debugprint.h"

PaWinDsDSoundEntryPoints paWinDsDSoundEntryPoints = { 0, 0, 0, 0, 0, 0, 0 };


static HRESULT WINAPI DummyDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    (void)rclsid; /* unused parameter */
    (void)riid; /* unused parameter */
    (void)ppv; /* unused parameter */
    return CLASS_E_CLASSNOTAVAILABLE;
}

static HRESULT WINAPI DummyDirectSoundCreate(LPGUID lpcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter)
{
    (void)lpcGuidDevice; /* unused parameter */
    (void)ppDS; /* unused parameter */
    (void)pUnkOuter; /* unused parameter */
    return E_NOTIMPL;
}

static HRESULT WINAPI DummyDirectSoundEnumerateW(LPDSENUMCALLBACKW lpDSEnumCallback, LPVOID lpContext)
{
    (void)lpDSEnumCallback; /* unused parameter */
    (void)lpContext; /* unused parameter */
    return E_NOTIMPL;
}

static HRESULT WINAPI DummyDirectSoundEnumerateA(LPDSENUMCALLBACKA lpDSEnumCallback, LPVOID lpContext)
{
    (void)lpDSEnumCallback; /* unused parameter */
    (void)lpContext; /* unused parameter */
    return E_NOTIMPL;
}

static HRESULT WINAPI DummyDirectSoundCaptureCreate(LPGUID lpcGUID, LPDIRECTSOUNDCAPTURE *lplpDSC, LPUNKNOWN pUnkOuter)
{
    (void)lpcGUID; /* unused parameter */
    (void)lplpDSC; /* unused parameter */
    (void)pUnkOuter; /* unused parameter */
    return E_NOTIMPL;
}

static HRESULT WINAPI DummyDirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW lpDSCEnumCallback, LPVOID lpContext)
{
    (void)lpDSCEnumCallback; /* unused parameter */
    (void)lpContext; /* unused parameter */
    return E_NOTIMPL;
}

static HRESULT WINAPI DummyDirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA lpDSCEnumCallback, LPVOID lpContext)
{
    (void)lpDSCEnumCallback; /* unused parameter */
    (void)lpContext; /* unused parameter */
    return E_NOTIMPL;
}

#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
static HRESULT WINAPI DummyDirectSoundFullDuplexCreate8(
         LPCGUID pcGuidCaptureDevice,
         LPCGUID pcGuidRenderDevice,
         LPCDSCBUFFERDESC pcDSCBufferDesc,
         LPCDSBUFFERDESC pcDSBufferDesc,
         HWND hWnd,
         DWORD dwLevel,
         LPDIRECTSOUNDFULLDUPLEX * ppDSFD,
         LPDIRECTSOUNDCAPTUREBUFFER8 * ppDSCBuffer8,
         LPDIRECTSOUNDBUFFER8 * ppDSBuffer8,
         LPUNKNOWN pUnkOuter)
{
    (void)pcGuidCaptureDevice; /* unused parameter */
    (void)pcGuidRenderDevice; /* unused parameter */
    (void)pcDSCBufferDesc; /* unused parameter */
    (void)pcDSBufferDesc; /* unused parameter */
    (void)hWnd; /* unused parameter */
    (void)dwLevel; /* unused parameter */
    (void)ppDSFD; /* unused parameter */
    (void)ppDSCBuffer8; /* unused parameter */
    (void)ppDSBuffer8; /* unused parameter */
    (void)pUnkOuter; /* unused parameter */

    return E_NOTIMPL;
}
#endif /* PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE */

void PaWinDs_InitializeDSoundEntryPoints(void)
{
    paWinDsDSoundEntryPoints.hInstance_ = LoadLibraryA("dsound.dll");
    if( paWinDsDSoundEntryPoints.hInstance_ != NULL )
    {
        paWinDsDSoundEntryPoints.DllGetClassObject =
                (HRESULT (WINAPI *)(REFCLSID, REFIID , LPVOID *))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DllGetClassObject" );
        if( paWinDsDSoundEntryPoints.DllGetClassObject == NULL )
            paWinDsDSoundEntryPoints.DllGetClassObject = DummyDllGetClassObject;

        paWinDsDSoundEntryPoints.DirectSoundCreate =
                (HRESULT (WINAPI *)(LPGUID, LPDIRECTSOUND *, LPUNKNOWN))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundCreate" );
        if( paWinDsDSoundEntryPoints.DirectSoundCreate == NULL )
            paWinDsDSoundEntryPoints.DirectSoundCreate = DummyDirectSoundCreate;

        paWinDsDSoundEntryPoints.DirectSoundEnumerateW =
                (HRESULT (WINAPI *)(LPDSENUMCALLBACKW, LPVOID))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundEnumerateW" );
        if( paWinDsDSoundEntryPoints.DirectSoundEnumerateW == NULL )
            paWinDsDSoundEntryPoints.DirectSoundEnumerateW = DummyDirectSoundEnumerateW;

        paWinDsDSoundEntryPoints.DirectSoundEnumerateA =
                (HRESULT (WINAPI *)(LPDSENUMCALLBACKA, LPVOID))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundEnumerateA" );
        if( paWinDsDSoundEntryPoints.DirectSoundEnumerateA == NULL )
            paWinDsDSoundEntryPoints.DirectSoundEnumerateA = DummyDirectSoundEnumerateA;

        paWinDsDSoundEntryPoints.DirectSoundCaptureCreate =
                (HRESULT (WINAPI *)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundCaptureCreate" );
        if( paWinDsDSoundEntryPoints.DirectSoundCaptureCreate == NULL )
            paWinDsDSoundEntryPoints.DirectSoundCaptureCreate = DummyDirectSoundCaptureCreate;

        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW =
                (HRESULT (WINAPI *)(LPDSENUMCALLBACKW, LPVOID))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundCaptureEnumerateW" );
        if( paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW == NULL )
            paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW = DummyDirectSoundCaptureEnumerateW;

        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateA =
                (HRESULT (WINAPI *)(LPDSENUMCALLBACKA, LPVOID))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundCaptureEnumerateA" );
        if( paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateA == NULL )
            paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateA = DummyDirectSoundCaptureEnumerateA;

#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
        paWinDsDSoundEntryPoints.DirectSoundFullDuplexCreate8 =
                (HRESULT (WINAPI *)(LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC,
                                    HWND, DWORD, LPDIRECTSOUNDFULLDUPLEX *, LPDIRECTSOUNDCAPTUREBUFFER8 *, 
                                    LPDIRECTSOUNDBUFFER8 *, LPUNKNOWN))
                GetProcAddress( paWinDsDSoundEntryPoints.hInstance_, "DirectSoundFullDuplexCreate" );
        if( paWinDsDSoundEntryPoints.DirectSoundFullDuplexCreate8 == NULL )
            paWinDsDSoundEntryPoints.DirectSoundFullDuplexCreate8 = DummyDirectSoundFullDuplexCreate8;
#endif
    }
    else
    {
        DWORD errorCode = GetLastError(); // 126 (0x7E) == ERROR_MOD_NOT_FOUND
        PA_DEBUG(("Couldn't load dsound.dll error code: %d \n",errorCode));

        /* initialize with dummy entry points to make live easy when ds isn't present */
        paWinDsDSoundEntryPoints.DirectSoundCreate = DummyDirectSoundCreate;
        paWinDsDSoundEntryPoints.DirectSoundEnumerateW = DummyDirectSoundEnumerateW;
        paWinDsDSoundEntryPoints.DirectSoundEnumerateA = DummyDirectSoundEnumerateA;
        paWinDsDSoundEntryPoints.DirectSoundCaptureCreate = DummyDirectSoundCaptureCreate;
        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW = DummyDirectSoundCaptureEnumerateW;
        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateA = DummyDirectSoundCaptureEnumerateA;
#ifdef PAWIN_USE_DIRECTSOUNDFULLDUPLEXCREATE
        paWinDsDSoundEntryPoints.DirectSoundFullDuplexCreate8 = DummyDirectSoundFullDuplexCreate8;
#endif
    }
}


void PaWinDs_TerminateDSoundEntryPoints(void)
{
    if( paWinDsDSoundEntryPoints.hInstance_ != NULL )
    {
        /* ensure that we crash reliably if the entry points arent initialised */
        paWinDsDSoundEntryPoints.DirectSoundCreate = 0;
        paWinDsDSoundEntryPoints.DirectSoundEnumerateW = 0;
        paWinDsDSoundEntryPoints.DirectSoundEnumerateA = 0;
        paWinDsDSoundEntryPoints.DirectSoundCaptureCreate = 0;
        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateW = 0;
        paWinDsDSoundEntryPoints.DirectSoundCaptureEnumerateA = 0;

        FreeLibrary( paWinDsDSoundEntryPoints.hInstance_ );
        paWinDsDSoundEntryPoints.hInstance_ = NULL;
    }
}
#endif

#if PA_USE_JACK
/*
 * $Id$
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 * JACK Implementation by Joshua Haberman
 *
 * Copyright (c) 2004 Stefan Westerfeld <stefan@space.twc.de>
 * Copyright (c) 2004 Arve Knudsen <aknuds-1@broadpark.no>
 * Copyright (c) 2002 Joshua Haberman <joshua@haberman.com>
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#include <string.h>
#include <regex.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>  /* EBUSY */
#include <signal.h> /* sig_atomic_t */
#include <math.h>
#include <semaphore.h>

#include <jack/types.h>
#include <jack/jack.h>

// (amalg) #include "pa_util.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_ringbuffer.h"
// (amalg) #include "pa_debugprint.h"

static pthread_t mainThread_;
static char *jackErr_ = NULL;
static const char* clientName_ = "PortAudio";

#define STRINGIZE_HELPER(expr) #expr
#define STRINGIZE(expr) STRINGIZE_HELPER(expr)

/* Check PaError */
#define ENSURE_PA(expr) \
    do { \
        PaError paErr; \
        if( (paErr = (expr)) < paNoError ) \
        { \
            if( (paErr) == paUnanticipatedHostError && pthread_self() == mainThread_ ) \
            { \
                const char *err = jackErr_; \
                if (! err ) err = "unknown error"; \
                PaUtil_SetLastHostErrorInfo( paJACK, -1, err ); \
            } \
            PaUtil_DebugPrint(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = paErr; \
            goto error; \
        } \
    } while( 0 )

#define UNLESS(expr, code) \
    do { \
        if( (expr) == 0 ) \
        { \
            if( (code) == paUnanticipatedHostError && pthread_self() == mainThread_ ) \
            { \
                const char *err = jackErr_; \
                if (!err) err = "unknown error"; \
                PaUtil_SetLastHostErrorInfo( paJACK, -1, err ); \
            } \
            PaUtil_DebugPrint(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = (code); \
            goto error; \
        } \
    } while( 0 )

#define ASSERT_CALL(expr, success) \
    do { \
        int err = (expr); \
        assert( err == success ); \
    } while( 0 )

/*
 * Functions that directly map to the PortAudio stream interface
 */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
/*static PaTime GetStreamInputLatency( PaStream *stream );*/
/*static PaTime GetStreamOutputLatency( PaStream *stream );*/
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );


/*
 * Data specific to this API
 */

struct PaJackStream;

typedef struct
{
    PaUtilHostApiRepresentation commonHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *deviceInfoMemory;

    jack_client_t *jack_client;
    int jack_buffer_size;
    PaHostApiIndex hostApiIndex;

    pthread_mutex_t mtx;
    pthread_cond_t cond;
    unsigned long inputBase, outputBase;

    /* For dealing with the process thread */
    volatile int xrun;     /* Received xrun notification from JACK? */
    struct PaJackStream * volatile toAdd, * volatile toRemove;
    struct PaJackStream *processQueue;
    volatile sig_atomic_t jackIsDown;
}
PaJackHostApiRepresentation;

/* PaJackStream - a stream data structure specifically for this implementation */

typedef struct PaJackStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilBufferProcessor bufferProcessor;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaJackHostApiRepresentation *hostApi;

    /* our input and output ports */
    jack_port_t **local_input_ports;
    jack_port_t **local_output_ports;

    /* the input and output ports of the client we are connecting to */
    jack_port_t **remote_input_ports;
    jack_port_t **remote_output_ports;

    int num_incoming_connections;
    int num_outgoing_connections;

    jack_client_t *jack_client;

    /* The stream is running if it's still producing samples.
     * The stream is active if samples it produced are still being heard.
     */
    volatile sig_atomic_t is_running;
    volatile sig_atomic_t is_active;
    /* Used to signal processing thread that stream should start or stop, respectively */
    volatile sig_atomic_t doStart, doStop, doAbort;

    jack_nframes_t t0;

    PaUtilAllocationGroup *stream_memory;

    /* These are useful in the process callback */

    int callbackResult;
    int isSilenced;
    int xrun;

    /* These are useful for the blocking API */

    int                     isBlockingStream;
    PaUtilRingBuffer        inFIFO;
    PaUtilRingBuffer        outFIFO;
    volatile sig_atomic_t   data_available;
    sem_t                   data_semaphore;
    int                     bytesPerFrame;
    int                     samplesPerFrame;

    struct PaJackStream *next;
}
PaJackStream;

/* In calls to jack_get_ports() this filter expression is used instead of ""
 * to prevent any other types (eg Midi ports etc) being listed */
#define JACK_PORT_TYPE_FILTER "audio"

#define TRUE 1
#define FALSE 0

/*
 * Functions specific to this API
 */

static int JackCallback( jack_nframes_t frames, void *userData );


/*
 *
 * Implementation
 *
 */

/* ---- blocking emulation layer ---- */

/* Allocate buffer. */
static PaError BlockingInitFIFO( PaUtilRingBuffer *rbuf, long numFrames, long bytesPerFrame )
{
    long numBytes = numFrames * bytesPerFrame;
    char *buffer = (char *) malloc( numBytes );
    if( buffer == NULL ) return paInsufficientMemory;
    memset( buffer, 0, numBytes );
    return (PaError) PaUtil_InitializeRingBuffer( rbuf, 1, numBytes, buffer );
}

/* Free buffer. */
static PaError BlockingTermFIFO( PaUtilRingBuffer *rbuf )
{
    if( rbuf->buffer ) free( rbuf->buffer );
    rbuf->buffer = NULL;
    return paNoError;
}

static int
BlockingCallback( const void                      *inputBuffer,
                  void                            *outputBuffer,
		  unsigned long                    framesPerBuffer,
		  const PaStreamCallbackTimeInfo*  timeInfo,
		  PaStreamCallbackFlags            statusFlags,
		  void                             *userData )
{
    struct PaJackStream *stream = (PaJackStream *)userData;
    long numBytes = stream->bytesPerFrame * framesPerBuffer;

    /* This may get called with NULL inputBuffer during initial setup. */
    if( inputBuffer != NULL )
    {
        PaUtil_WriteRingBuffer( &stream->inFIFO, inputBuffer, numBytes );
    }
    if( outputBuffer != NULL )
    {
        int numRead = PaUtil_ReadRingBuffer( &stream->outFIFO, outputBuffer, numBytes );
        /* Zero out remainder of buffer if we run out of data. */
        memset( (char *)outputBuffer + numRead, 0, numBytes - numRead );
    }

    if( !stream->data_available )
    {
        stream->data_available = 1;
        sem_post( &stream->data_semaphore );
    }
    return paContinue;
}

static PaError
BlockingBegin( PaJackStream *stream, int minimum_buffer_size )
{
    long    doRead = 0;
    long    doWrite = 0;
    PaError result = paNoError;
    long    numFrames;

    doRead = stream->local_input_ports != NULL;
    doWrite = stream->local_output_ports != NULL;
    /* <FIXME> */
    stream->samplesPerFrame = 2;
    stream->bytesPerFrame = sizeof(float) * stream->samplesPerFrame;
    /* </FIXME> */
    numFrames = 32;
    while (numFrames < minimum_buffer_size)
        numFrames *= 2;

    if( doRead )
    {
        ENSURE_PA( BlockingInitFIFO( &stream->inFIFO, numFrames, stream->bytesPerFrame ) );
    }
    if( doWrite )
    {
        long numBytes;

        ENSURE_PA( BlockingInitFIFO( &stream->outFIFO, numFrames, stream->bytesPerFrame ) );

        /* Make Write FIFO appear full initially. */
        numBytes = PaUtil_GetRingBufferWriteAvailable( &stream->outFIFO );
        PaUtil_AdvanceRingBufferWriteIndex( &stream->outFIFO, numBytes );
    }

    stream->data_available = 0;
    sem_init( &stream->data_semaphore, 0, 0 );

error:
    return result;
}

static void
BlockingEnd( PaJackStream *stream )
{
    BlockingTermFIFO( &stream->inFIFO );
    BlockingTermFIFO( &stream->outFIFO );

    sem_destroy( &stream->data_semaphore );
}

static PaError BlockingReadStream( PaStream* s, void *data, unsigned long numFrames )
{
    PaError result = paNoError;
    PaJackStream *stream = (PaJackStream *)s;

    long bytesRead;
    char *p = (char *) data;
    long numBytes = stream->bytesPerFrame * numFrames;
    while( numBytes > 0 )
    {
        bytesRead = PaUtil_ReadRingBuffer( &stream->inFIFO, p, numBytes );
        numBytes -= bytesRead;
        p += bytesRead;
        if( numBytes > 0 )
        {
            /* see write for an explanation */
            if( stream->data_available )
                stream->data_available = 0;
            else
                sem_wait( &stream->data_semaphore );
        }
    }

    return result;
}

static PaError BlockingWriteStream( PaStream* s, const void *data, unsigned long numFrames )
{
    PaError result = paNoError;
    PaJackStream *stream = (PaJackStream *)s;
    long bytesWritten;
    char *p = (char *) data;
    long numBytes = stream->bytesPerFrame * numFrames;
    while( numBytes > 0 )
    {
        bytesWritten = PaUtil_WriteRingBuffer( &stream->outFIFO, p, numBytes );
        numBytes -= bytesWritten;
        p += bytesWritten;
        if( numBytes > 0 )
        {
            /* we use the following algorithm:
             *   (1) write data
             *   (2) if some data didn't fit into the ringbuffer, set data_available to 0
             *       to indicate to the audio that if space becomes available, we want to know
             *   (3) retry to write data (because it might be that between (1) and (2)
             *       new space in the buffer became available)
             *   (4) if this failed, we are sure that the buffer is really empty and
             *       we will definitely receive a notification when it becomes available
             *       thus we can safely sleep
             *
             * if the algorithm bailed out in step (3) before, it leaks a count of 1
             * on the semaphore; however, it doesn't matter, because if we block in (4),
             * we also do it in a loop
             */
            if( stream->data_available )
                stream->data_available = 0;
            else
                sem_wait( &stream->data_semaphore );
        }
    }

    return result;
}

static signed long
BlockingGetStreamReadAvailable( PaStream* s )
{
    PaJackStream *stream = (PaJackStream *)s;

    int bytesFull = PaUtil_GetRingBufferReadAvailable( &stream->inFIFO );
    return bytesFull / stream->bytesPerFrame;
}

static signed long
BlockingGetStreamWriteAvailable( PaStream* s )
{
    PaJackStream *stream = (PaJackStream *)s;

    int bytesEmpty = PaUtil_GetRingBufferWriteAvailable( &stream->outFIFO );
    return bytesEmpty / stream->bytesPerFrame;
}

static PaError
BlockingWaitEmpty( PaStream *s )
{
    PaJackStream *stream = (PaJackStream *)s;

    while( PaUtil_GetRingBufferReadAvailable( &stream->outFIFO ) > 0 )
    {
        stream->data_available = 0;
        sem_wait( &stream->data_semaphore );
    }
    return 0;
}

/* ---- jack driver ---- */

/* BuildDeviceList():
 *
 * The process of determining a list of PortAudio "devices" from
 * JACK's client/port system is fairly involved, so it is separated
 * into its own routine.
 */

static PaError BuildDeviceList( PaJackHostApiRepresentation *jackApi )
{
    /* Utility macros for the repetitive process of allocating memory */

    /* JACK has no concept of a device.  To JACK, there are clients
     * which have an arbitrary number of ports.  To make this
     * intelligible to PortAudio clients, we will group each JACK client
     * into a device, and make each port of that client a channel */

    PaError result = paNoError;
    PaUtilHostApiRepresentation *commonApi = &jackApi->commonHostApiRep;

    const char **jack_ports = NULL;
    char **client_names = NULL;
    char *regex_pattern = NULL;
    int port_index, client_index, i;
    double globalSampleRate;
    regex_t port_regex;
    unsigned long numClients = 0, numPorts = 0;
    char *tmp_client_name = NULL;

    commonApi->info.defaultInputDevice = paNoDevice;
    commonApi->info.defaultOutputDevice = paNoDevice;
    commonApi->info.deviceCount = 0;

    /* Parse the list of ports, using a regex to grab the client names */
    ASSERT_CALL( regcomp( &port_regex, "^[^:]*", REG_EXTENDED ), 0 );

    /* since we are rebuilding the list of devices, free all memory
     * associated with the previous list */
    PaUtil_FreeAllAllocations( jackApi->deviceInfoMemory );

    regex_pattern = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, jack_client_name_size() + 3 );
    tmp_client_name = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, jack_client_name_size() );

    /* We can only retrieve the list of clients indirectly, by first
     * asking for a list of all ports, then parsing the port names
     * according to the client_name:port_name convention (which is
     * enforced by jackd)
     * A: If jack_get_ports returns NULL, there's nothing for us to do */
    UNLESS( (jack_ports = jack_get_ports( jackApi->jack_client, "", JACK_PORT_TYPE_FILTER, 0 )) && jack_ports[0], paNoError );
    /* Find number of ports */
    while( jack_ports[numPorts] )
        ++numPorts;
    /* At least there will be one port per client :) */
    UNLESS( client_names = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, numPorts *
                sizeof (char *) ), paInsufficientMemory );

    /* Build a list of clients from the list of ports */
    for( numClients = 0, port_index = 0; jack_ports[port_index] != NULL; port_index++ )
    {
        int client_seen = FALSE;
        regmatch_t match_info;
        const char *port = jack_ports[port_index];

        /* extract the client name from the port name, using a regex
         * that parses the clientname:portname syntax */
        UNLESS( !regexec( &port_regex, port, 1, &match_info, 0 ), paInternalError );
        assert(match_info.rm_eo - match_info.rm_so < jack_client_name_size());
        memcpy( tmp_client_name, port + match_info.rm_so,
                match_info.rm_eo - match_info.rm_so );
        tmp_client_name[match_info.rm_eo - match_info.rm_so] = '\0';

        /* do we know about this port's client yet? */
        for( i = 0; i < numClients; i++ )
        {
            if( strcmp( tmp_client_name, client_names[i] ) == 0 )
                client_seen = TRUE;
        }

        if (client_seen)
            continue;   /* A: Nothing to see here, move along */

        UNLESS( client_names[numClients] = (char*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
                    strlen(tmp_client_name) + 1), paInsufficientMemory );

        /* The alsa_pcm client should go in spot 0.  If this
         * is the alsa_pcm client AND we are NOT about to put
         * it in spot 0 put it in spot 0 and move whatever
         * was already in spot 0 to the end. */
        if( strcmp( "alsa_pcm", tmp_client_name ) == 0 && numClients > 0 )
        {
            /* alsa_pcm goes in spot 0 */
            strcpy( client_names[ numClients ], client_names[0] );
            strcpy( client_names[0], tmp_client_name );
        }
        else
        {
            /* put the new client at the end of the client list */
            strcpy( client_names[ numClients ], tmp_client_name );
        }
        ++numClients;
    }

    /* Now we have a list of clients, which will become the list of
     * PortAudio devices. */

    /* there is one global sample rate all clients must conform to */

    globalSampleRate = jack_get_sample_rate( jackApi->jack_client );
    UNLESS( commonApi->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
                sizeof(PaDeviceInfo*) * numClients ), paInsufficientMemory );

    assert( commonApi->info.deviceCount == 0 );

    /* Create a PaDeviceInfo structure for every client */
    for( client_index = 0; client_index < numClients; client_index++ )
    {
        PaDeviceInfo *curDevInfo;
        const char **clientPorts = NULL;

        UNLESS( curDevInfo = (PaDeviceInfo*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
                    sizeof(PaDeviceInfo) ), paInsufficientMemory );
        UNLESS( curDevInfo->name = (char*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
                    strlen(client_names[client_index]) + 1 ), paInsufficientMemory );
        strcpy( (char *)curDevInfo->name, client_names[client_index] );

        curDevInfo->structVersion = 2;
        curDevInfo->hostApi = jackApi->hostApiIndex;

        /* JACK is very inflexible: there is one sample rate the whole
         * system must run at, and all clients must speak IEEE float. */
        curDevInfo->defaultSampleRate = globalSampleRate;

        /* To determine how many input and output channels are available,
         * we re-query jackd with more specific parameters. */

        sprintf( regex_pattern, "%s:.*", client_names[client_index] );

        /* ... what are your output ports (that we could input from)? */
        clientPorts = jack_get_ports( jackApi->jack_client, regex_pattern,
                                     JACK_PORT_TYPE_FILTER, JackPortIsOutput);
        curDevInfo->maxInputChannels = 0;
        curDevInfo->defaultLowInputLatency = 0.;
        curDevInfo->defaultHighInputLatency = 0.;
        if( clientPorts )
        {
            jack_port_t *p = jack_port_by_name( jackApi->jack_client, clientPorts[0] );
            curDevInfo->defaultLowInputLatency = curDevInfo->defaultHighInputLatency =
                jack_port_get_latency( p ) / globalSampleRate;

            for( i = 0; clientPorts[i] != NULL; i++)
            {
                /* The number of ports returned is the number of output channels.
                 * We don't care what they are, we just care how many */
                curDevInfo->maxInputChannels++;
            }
            free(clientPorts);
        }

        /* ... what are your input ports (that we could output to)? */
        clientPorts = jack_get_ports( jackApi->jack_client, regex_pattern,
                                     JACK_PORT_TYPE_FILTER, JackPortIsInput);
        curDevInfo->maxOutputChannels = 0;
        curDevInfo->defaultLowOutputLatency = 0.;
        curDevInfo->defaultHighOutputLatency = 0.;
        if( clientPorts )
        {
            jack_port_t *p = jack_port_by_name( jackApi->jack_client, clientPorts[0] );
            curDevInfo->defaultLowOutputLatency = curDevInfo->defaultHighOutputLatency =
                jack_port_get_latency( p ) / globalSampleRate;

            for( i = 0; clientPorts[i] != NULL; i++)
            {
                /* The number of ports returned is the number of input channels.
                 * We don't care what they are, we just care how many */
                curDevInfo->maxOutputChannels++;
            }
            free(clientPorts);
        }

        /* Add this client to the list of devices */
        commonApi->deviceInfos[client_index] = curDevInfo;
        ++commonApi->info.deviceCount;
        if( commonApi->info.defaultInputDevice == paNoDevice && curDevInfo->maxInputChannels > 0 )
            commonApi->info.defaultInputDevice = client_index;
        if( commonApi->info.defaultOutputDevice == paNoDevice && curDevInfo->maxOutputChannels > 0 )
            commonApi->info.defaultOutputDevice = client_index;
    }

error:
    regfree( &port_regex );
    free( jack_ports );
    return result;
}

static void UpdateSampleRate( PaJackStream *stream, double sampleRate )
{
    /* XXX: Maybe not the cleanest way of going about this? */
    stream->cpuLoadMeasurer.samplingPeriod = stream->bufferProcessor.samplePeriod = 1. / sampleRate;
    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;
}

static void JackErrorCallback( const char *msg )
{
    if( pthread_self() == mainThread_ )
    {
        assert( msg );
        jackErr_ = realloc( jackErr_, strlen( msg ) + 1 );
        strcpy( jackErr_, msg );
    }
}

static void JackOnShutdown( void *arg )
{
    PaJackHostApiRepresentation *jackApi = (PaJackHostApiRepresentation *)arg;
    PaJackStream *stream = jackApi->processQueue;

    PA_DEBUG(( "%s: JACK server is shutting down\n", __FUNCTION__ ));
    for( ; stream; stream = stream->next )
    {
        stream->is_active = 0;
    }

    /* Make sure that the main thread doesn't get stuck waiting on the condition */
    ASSERT_CALL( pthread_mutex_lock( &jackApi->mtx ), 0 );
    jackApi->jackIsDown = 1;
    ASSERT_CALL( pthread_cond_signal( &jackApi->cond ), 0 );
    ASSERT_CALL( pthread_mutex_unlock( &jackApi->mtx ), 0 );

}

static int JackSrCb( jack_nframes_t nframes, void *arg )
{
    PaJackHostApiRepresentation *jackApi = (PaJackHostApiRepresentation *)arg;
    double sampleRate = (double)nframes;
    PaJackStream *stream = jackApi->processQueue;

    /* Update all streams in process queue */
    PA_DEBUG(( "%s: Acting on change in JACK samplerate: %f\n", __FUNCTION__, sampleRate ));
    for( ; stream; stream = stream->next )
    {
        if( stream->streamRepresentation.streamInfo.sampleRate != sampleRate )
        {
            PA_DEBUG(( "%s: Updating samplerate\n", __FUNCTION__ ));
            UpdateSampleRate( stream, sampleRate );
        }
    }

    return 0;
}

static int JackXRunCb(void *arg) {
    PaJackHostApiRepresentation *hostApi = (PaJackHostApiRepresentation *)arg;
    assert( hostApi );
    hostApi->xrun = TRUE;
    PA_DEBUG(( "%s: JACK signalled xrun\n", __FUNCTION__ ));
    return 0;
}

PaError PaJack_Initialize( PaUtilHostApiRepresentation **hostApi,
                           PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaJackHostApiRepresentation *jackHostApi;
    int activated = 0;
    jack_status_t jackStatus = 0;
    *hostApi = NULL;    /* Initialize to NULL */

    UNLESS( jackHostApi = (PaJackHostApiRepresentation*)
        PaUtil_AllocateMemory( sizeof(PaJackHostApiRepresentation) ), paInsufficientMemory );
    UNLESS( jackHostApi->deviceInfoMemory = PaUtil_CreateAllocationGroup(), paInsufficientMemory );

    mainThread_ = pthread_self();
    ASSERT_CALL( pthread_mutex_init( &jackHostApi->mtx, NULL ), 0 );
    ASSERT_CALL( pthread_cond_init( &jackHostApi->cond, NULL ), 0 );

    /* Try to become a client of the JACK server.  If we cannot do
     * this, then this API cannot be used.
     *
     * Without the JackNoStartServer option, the jackd server is started
     * automatically which we do not want.
     */

    jackHostApi->jack_client = jack_client_open( clientName_, JackNoStartServer, &jackStatus );
    if( !jackHostApi->jack_client )
    {
        /* the V19 development docs say that if an implementation
         * detects that it cannot be used, it should return a NULL
         * interface and paNoError */
        PA_DEBUG(( "%s: Couldn't connect to JACK, status: %d\n", __FUNCTION__, jackStatus ));
        result = paNoError;
        goto error;
    }

    jackHostApi->hostApiIndex = hostApiIndex;

    *hostApi = &jackHostApi->commonHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paJACK;
    (*hostApi)->info.name = "JACK Audio Connection Kit";

    /* Build a device list by querying the JACK server */
    ENSURE_PA( BuildDeviceList( jackHostApi ) );

    /* Register functions */

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &jackHostApi->callbackStreamInterface,
                                      CloseStream, StartStream,
                                      StopStream, AbortStream,
                                      IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable,
                                      PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &jackHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      BlockingReadStream, BlockingWriteStream,
                                      BlockingGetStreamReadAvailable, BlockingGetStreamWriteAvailable );

    jackHostApi->inputBase = jackHostApi->outputBase = 0;
    jackHostApi->xrun = 0;
    jackHostApi->toAdd = jackHostApi->toRemove = NULL;
    jackHostApi->processQueue = NULL;
    jackHostApi->jackIsDown = 0;

    jack_on_shutdown( jackHostApi->jack_client, JackOnShutdown, jackHostApi );
    jack_set_error_function( JackErrorCallback );
    jackHostApi->jack_buffer_size = jack_get_buffer_size ( jackHostApi->jack_client );
    /* Don't check for error, may not be supported (deprecated in at least jackdmp) */
    jack_set_sample_rate_callback( jackHostApi->jack_client, JackSrCb, jackHostApi );
    UNLESS( !jack_set_xrun_callback( jackHostApi->jack_client, JackXRunCb, jackHostApi ), paUnanticipatedHostError );
    UNLESS( !jack_set_process_callback( jackHostApi->jack_client, JackCallback, jackHostApi ), paUnanticipatedHostError );
    UNLESS( !jack_activate( jackHostApi->jack_client ), paUnanticipatedHostError );
    activated = 1;

    return result;

error:
    if( activated )
        ASSERT_CALL( jack_deactivate( jackHostApi->jack_client ), 0 );

    if( jackHostApi )
    {
        if( jackHostApi->jack_client )
            ASSERT_CALL( jack_client_close( jackHostApi->jack_client ), 0 );

        if( jackHostApi->deviceInfoMemory )
        {
            PaUtil_FreeAllAllocations( jackHostApi->deviceInfoMemory );
            PaUtil_DestroyAllocationGroup( jackHostApi->deviceInfoMemory );
        }

        PaUtil_FreeMemory( jackHostApi );
    }
    return result;
}


static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaJackHostApiRepresentation *jackHostApi = (PaJackHostApiRepresentation*)hostApi;

    /* note: this automatically disconnects all ports, since a deactivated
     * client is not allowed to have any ports connected */
    ASSERT_CALL( jack_deactivate( jackHostApi->jack_client ), 0 );

    ASSERT_CALL( pthread_mutex_destroy( &jackHostApi->mtx ), 0 );
    ASSERT_CALL( pthread_cond_destroy( &jackHostApi->cond ), 0 );

    ASSERT_CALL( jack_client_close( jackHostApi->jack_client ), 0 );

    if( jackHostApi->deviceInfoMemory )
    {
        PaUtil_FreeAllAllocations( jackHostApi->deviceInfoMemory );
        PaUtil_DestroyAllocationGroup( jackHostApi->deviceInfoMemory );
    }

    PaUtil_FreeMemory( jackHostApi );

    free( jackErr_ );
    jackErr_ = NULL;
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    int inputChannelCount = 0, outputChannelCount = 0;
    PaSampleFormat inputSampleFormat, outputSampleFormat;

    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
            return paInvalidChannelCount;

        /* validate inputStreamInfo */
        if( inputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support inputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
            return paInvalidChannelCount;

        /* validate outputStreamInfo */
        if( outputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        outputChannelCount = 0;
    }

    /*
        The following check is not necessary for JACK.

            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported


        Because the buffer adapter handles conversion between all standard
        sample formats, the following checks are only required if paCustomFormat
        is implemented, or under some other unusual conditions.

            - check that input device can support inputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format

            - check that output device can support outputSampleFormat, or that
                we have the capability to convert from outputSampleFormat to
                a native format
    */

    /* check that the device supports sampleRate */

#define ABS(x) ( (x) > 0 ? (x) : -(x) )
    if( ABS(sampleRate - jack_get_sample_rate(((PaJackHostApiRepresentation *) hostApi)->jack_client )) > 1 )
       return paInvalidSampleRate;
#undef ABS

    return paFormatIsSupported;
}

/* Basic stream initialization */
static PaError InitializeStream( PaJackStream *stream, PaJackHostApiRepresentation *hostApi, int numInputChannels,
        int numOutputChannels )
{
    PaError result = paNoError;
    assert( stream );

    memset( stream, 0, sizeof (PaJackStream) );
    UNLESS( stream->stream_memory = PaUtil_CreateAllocationGroup(), paInsufficientMemory );
    stream->jack_client = hostApi->jack_client;
    stream->hostApi = hostApi;

    if( numInputChannels > 0 )
    {
        UNLESS( stream->local_input_ports =
                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numInputChannels ),
                paInsufficientMemory );
        memset( stream->local_input_ports, 0, sizeof(jack_port_t*) * numInputChannels );
        UNLESS( stream->remote_output_ports =
                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numInputChannels ),
                paInsufficientMemory );
        memset( stream->remote_output_ports, 0, sizeof(jack_port_t*) * numInputChannels );
    }
    if( numOutputChannels > 0 )
    {
        UNLESS( stream->local_output_ports =
                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numOutputChannels ),
                paInsufficientMemory );
        memset( stream->local_output_ports, 0, sizeof(jack_port_t*) * numOutputChannels );
        UNLESS( stream->remote_input_ports =
                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numOutputChannels ),
                paInsufficientMemory );
        memset( stream->remote_input_ports, 0, sizeof(jack_port_t*) * numOutputChannels );
    }

    stream->num_incoming_connections = numInputChannels;
    stream->num_outgoing_connections = numOutputChannels;

error:
    return result;
}

/*!
 * Free resources associated with stream, and eventually stream itself.
 *
 * Frees allocated memory, and closes opened pcms.
 */
static void CleanUpStream( PaJackStream *stream, int terminateStreamRepresentation, int terminateBufferProcessor )
{
    int i;
    assert( stream );

    if( stream->isBlockingStream )
        BlockingEnd( stream );

    for( i = 0; i < stream->num_incoming_connections; ++i )
    {
        if( stream->local_input_ports[i] )
            ASSERT_CALL( jack_port_unregister( stream->jack_client, stream->local_input_ports[i] ), 0 );
    }
    for( i = 0; i < stream->num_outgoing_connections; ++i )
    {
        if( stream->local_output_ports[i] )
            ASSERT_CALL( jack_port_unregister( stream->jack_client, stream->local_output_ports[i] ), 0 );
    }

    if( terminateStreamRepresentation )
        PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
    if( terminateBufferProcessor )
        PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );

    if( stream->stream_memory )
    {
        PaUtil_FreeAllAllocations( stream->stream_memory );
        PaUtil_DestroyAllocationGroup( stream->stream_memory );
    }
    PaUtil_FreeMemory( stream );
}

static PaError WaitCondition( PaJackHostApiRepresentation *hostApi )
{
    PaError result = paNoError;
    int err = 0;
    PaTime pt = PaUtil_GetTime();
    struct timespec ts;

    ts.tv_sec = (time_t) floor( pt + 10 * 60 /* 10 minutes */ );
    ts.tv_nsec = (long) ((pt - floor( pt )) * 1000000000);
    /* XXX: Best enclose in loop, in case of spurious wakeups? */
    err = pthread_cond_timedwait( &hostApi->cond, &hostApi->mtx, &ts );

    /* Make sure we didn't time out */
    UNLESS( err != ETIMEDOUT, paTimedOut );
    UNLESS( !err, paInternalError );

error:
    return result;
}

static PaError AddStream( PaJackStream *stream )
{
    PaError result = paNoError;
    PaJackHostApiRepresentation *hostApi = stream->hostApi;
    /* Add to queue of streams that should be processed */
    ASSERT_CALL( pthread_mutex_lock( &hostApi->mtx ), 0 );
    if( !hostApi->jackIsDown )
    {
        hostApi->toAdd = stream;
        /* Unlock mutex and await signal from processing thread */
        result = WaitCondition( stream->hostApi );
    }
    ASSERT_CALL( pthread_mutex_unlock( &hostApi->mtx ), 0 );
    ENSURE_PA( result );

    UNLESS( !hostApi->jackIsDown, paDeviceUnavailable );

error:
    return result;
}

/* Remove stream from processing queue */
static PaError RemoveStream( PaJackStream *stream )
{
    PaError result = paNoError;
    PaJackHostApiRepresentation *hostApi = stream->hostApi;

    /* Add to queue over streams that should be processed */
    ASSERT_CALL( pthread_mutex_lock( &hostApi->mtx ), 0 );
    if( !hostApi->jackIsDown )
    {
        hostApi->toRemove = stream;
        /* Unlock mutex and await signal from processing thread */
        result = WaitCondition( stream->hostApi );
    }
    ASSERT_CALL( pthread_mutex_unlock( &hostApi->mtx ), 0 );
    ENSURE_PA( result );

error:
    return result;
}

/* Add stream to JACK callback processing queue */
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaJackHostApiRepresentation *jackHostApi = (PaJackHostApiRepresentation*)hostApi;
    PaJackStream *stream = NULL;
    char *port_string = PaUtil_GroupAllocateMemory( jackHostApi->deviceInfoMemory, jack_port_name_size() );
    unsigned long regexSz = jack_client_name_size() + 3;
    char *regex_pattern = PaUtil_GroupAllocateMemory( jackHostApi->deviceInfoMemory, regexSz );
    const char **jack_ports = NULL;
    /* int jack_max_buffer_size = jack_get_buffer_size( jackHostApi->jack_client ); */
    int i;
    int inputChannelCount, outputChannelCount;
    const double jackSr = jack_get_sample_rate( jackHostApi->jack_client );
    PaSampleFormat inputSampleFormat = 0, outputSampleFormat = 0;
    int bpInitialized = 0, srInitialized = 0;   /* Initialized buffer processor and stream representation? */
    unsigned long ofs;

    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform specific flag */
    if( (streamFlags & paPrimeOutputBuffersUsingStreamCallback) != 0 )
    {
        streamFlags &= ~paPrimeOutputBuffersUsingStreamCallback;
        /*return paInvalidFlag;*/   /* This implementation does not support buffer priming */
    }

    if( framesPerBuffer != paFramesPerBufferUnspecified )
    {
        /* Jack operates with power of two buffers, and we don't support non-integer buffer adaption (yet) */
        /*UNLESS( !(framesPerBuffer & (framesPerBuffer - 1)), paBufferTooBig );*/  /* TODO: Add descriptive error code? */
    }

    /* Preliminary checks */

    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
            return paInvalidChannelCount;

        /* validate inputStreamInfo */
        if( inputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support inputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
            return paInvalidChannelCount;

        /* validate outputStreamInfo */
        if( outputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        outputChannelCount = 0;
    }

    /* ... check that the sample rate exactly matches the ONE acceptable rate
     * A: This rate isn't necessarily constant though? */

#define ABS(x) ( (x) > 0 ? (x) : -(x) )
    if( ABS(sampleRate - jackSr) > 1 )
       return paInvalidSampleRate;
#undef ABS

    UNLESS( stream = (PaJackStream*)PaUtil_AllocateMemory( sizeof(PaJackStream) ), paInsufficientMemory );
    ENSURE_PA( InitializeStream( stream, jackHostApi, inputChannelCount, outputChannelCount ) );

    /* the blocking emulation, if necessary */
    stream->isBlockingStream = !streamCallback;
    if( stream->isBlockingStream )
    {
        float latency = 0.001; /* 1ms is the absolute minimum we support */
        int   minimum_buffer_frames = 0;

        if( inputParameters && inputParameters->suggestedLatency > latency )
            latency = inputParameters->suggestedLatency;
        else if( outputParameters && outputParameters->suggestedLatency > latency )
            latency = outputParameters->suggestedLatency;

        /* the latency the user asked for indicates the minimum buffer size in frames */
        minimum_buffer_frames = (int) (latency * jack_get_sample_rate( jackHostApi->jack_client ));

        /* we also need to be able to store at least three full jack buffers to avoid dropouts */
        if( jackHostApi->jack_buffer_size * 3 > minimum_buffer_frames )
            minimum_buffer_frames = jackHostApi->jack_buffer_size * 3;

        /* setup blocking API data structures (FIXME: can fail) */
        BlockingBegin( stream, minimum_buffer_frames );

        /* install our own callback for the blocking API */
        streamCallback = BlockingCallback;
        userData = stream;

        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &jackHostApi->blockingStreamInterface, streamCallback, userData );
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &jackHostApi->callbackStreamInterface, streamCallback, userData );
    }
    srInitialized = 1;
    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, jackSr );

    /* create the JACK ports.  We cannot connect them until audio
     * processing begins */

    /* Register a unique set of ports for this stream
     * TODO: Robust allocation of new port names */

    ofs = jackHostApi->inputBase;
    for( i = 0; i < inputChannelCount; i++ )
    {
        snprintf( port_string, jack_port_name_size(), "in_%lu", ofs + i );
        UNLESS( stream->local_input_ports[i] = jack_port_register(
              jackHostApi->jack_client, port_string,
              JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput, 0 ), paInsufficientMemory );
    }
    jackHostApi->inputBase += inputChannelCount;

    ofs = jackHostApi->outputBase;
    for( i = 0; i < outputChannelCount; i++ )
    {
        snprintf( port_string, jack_port_name_size(), "out_%lu", ofs + i );
        UNLESS( stream->local_output_ports[i] = jack_port_register(
             jackHostApi->jack_client, port_string,
             JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0 ), paInsufficientMemory );
    }
    jackHostApi->outputBase += outputChannelCount;

    /* look up the jack_port_t's for the remote ports.  We could do
     * this at stream start time, but doing it here ensures the
     * name lookup only happens once. */

    if( inputChannelCount > 0 )
    {
        int err = 0;

        /* Get output ports of our capture device */
        snprintf( regex_pattern, regexSz, "%s:.*", hostApi->deviceInfos[ inputParameters->device ]->name );
        UNLESS( jack_ports = jack_get_ports( jackHostApi->jack_client, regex_pattern,
                                     JACK_PORT_TYPE_FILTER, JackPortIsOutput ), paUnanticipatedHostError );
        for( i = 0; i < inputChannelCount && jack_ports[i]; i++ )
        {
            if( (stream->remote_output_ports[i] = jack_port_by_name(
                 jackHostApi->jack_client, jack_ports[i] )) == NULL )
            {
                err = 1;
                break;
            }
        }
        free( jack_ports );
        UNLESS( !err, paInsufficientMemory );

        /* Fewer ports than expected? */
        UNLESS( i == inputChannelCount, paInternalError );
    }

    if( outputChannelCount > 0 )
    {
        int err = 0;

        /* Get input ports of our playback device */
        snprintf( regex_pattern, regexSz, "%s:.*", hostApi->deviceInfos[ outputParameters->device ]->name );
        UNLESS( jack_ports = jack_get_ports( jackHostApi->jack_client, regex_pattern,
                                     JACK_PORT_TYPE_FILTER, JackPortIsInput ), paUnanticipatedHostError );
        for( i = 0; i < outputChannelCount && jack_ports[i]; i++ )
        {
            if( (stream->remote_input_ports[i] = jack_port_by_name(
                 jackHostApi->jack_client, jack_ports[i] )) == 0 )
            {
                err = 1;
                break;
            }
        }
        free( jack_ports );
        UNLESS( !err , paInsufficientMemory );

        /* Fewer ports than expected? */
        UNLESS( i == outputChannelCount, paInternalError );
    }

    ENSURE_PA( PaUtil_InitializeBufferProcessor(
                  &stream->bufferProcessor,
                  inputChannelCount,
                  inputSampleFormat,
                  paFloat32 | paNonInterleaved, /* hostInputSampleFormat */
                  outputChannelCount,
                  outputSampleFormat,
                  paFloat32 | paNonInterleaved, /* hostOutputSampleFormat */
                  jackSr,
                  streamFlags,
                  framesPerBuffer,
                  0,                            /* Ignored */
                  paUtilUnknownHostBufferSize,  /* Buffer size may vary on JACK's discretion */
                  streamCallback,
                  userData ) );
    bpInitialized = 1;

    if( stream->num_incoming_connections > 0 )
        stream->streamRepresentation.streamInfo.inputLatency = (jack_port_get_latency( stream->remote_output_ports[0] )
                - jack_get_buffer_size( jackHostApi->jack_client )  /* One buffer is not counted as latency */
            + PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor )) / sampleRate;
    if( stream->num_outgoing_connections > 0 )
        stream->streamRepresentation.streamInfo.outputLatency = (jack_port_get_latency( stream->remote_input_ports[0] )
                - jack_get_buffer_size( jackHostApi->jack_client )  /* One buffer is not counted as latency */
            + PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor )) / sampleRate;

    stream->streamRepresentation.streamInfo.sampleRate = jackSr;
    stream->t0 = jack_frame_time( jackHostApi->jack_client );   /* A: Time should run from Pa_OpenStream */

    /* Add to queue of opened streams */
    ENSURE_PA( AddStream( stream ) );

    *s = (PaStream*)stream;

    return result;

error:
    if( stream )
        CleanUpStream( stream, srInitialized, bpInitialized );

    return result;
}

/*
    When CloseStream() is called, the multi-api layer ensures that
    the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaJackStream *stream = (PaJackStream*)s;

    /* Remove this stream from the processing queue */
    ENSURE_PA( RemoveStream( stream ) );

error:
    CleanUpStream( stream, 1, 1 );
    return result;
}

static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
{
    PaError result = paNoError;
    PaStreamCallbackTimeInfo timeInfo = {0,0,0};
    int chn;
    int framesProcessed;
    const double sr = jack_get_sample_rate( stream->jack_client );    /* Shouldn't change during the process callback */
    PaStreamCallbackFlags cbFlags = 0;

    /* If the user has returned !paContinue from the callback we'll want to flush the internal buffers,
     * when these are empty we can finally mark the stream as inactive */
    if( stream->callbackResult != paContinue &&
            PaUtil_IsBufferProcessorOutputEmpty( &stream->bufferProcessor ) )
    {
        stream->is_active = 0;
        if( stream->streamRepresentation.streamFinishedCallback )
            stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
        PA_DEBUG(( "%s: Callback finished\n", __FUNCTION__ ));

        goto end;
    }

    timeInfo.currentTime = (jack_frame_time( stream->jack_client ) - stream->t0) / sr;
    if( stream->num_incoming_connections > 0 )
        timeInfo.inputBufferAdcTime = timeInfo.currentTime - jack_port_get_latency( stream->remote_output_ports[0] )
            / sr;
    if( stream->num_outgoing_connections > 0 )
        timeInfo.outputBufferDacTime = timeInfo.currentTime + jack_port_get_latency( stream->remote_input_ports[0] )
            / sr;

    PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

    if( stream->xrun )
    {
        /* XXX: Any way to tell which of these occurred? */
        cbFlags = paOutputUnderflow | paInputOverflow;
        stream->xrun = FALSE;
    }
    PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo,
            cbFlags );

    if( stream->num_incoming_connections > 0 )
        PaUtil_SetInputFrameCount( &stream->bufferProcessor, frames );
    if( stream->num_outgoing_connections > 0 )
        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, frames );

    for( chn = 0; chn < stream->num_incoming_connections; chn++ )
    {
        jack_default_audio_sample_t *channel_buf = (jack_default_audio_sample_t*)
            jack_port_get_buffer( stream->local_input_ports[chn],
                    frames );

        PaUtil_SetNonInterleavedInputChannel( &stream->bufferProcessor,
                chn,
                channel_buf );
    }

    for( chn = 0; chn < stream->num_outgoing_connections; chn++ )
    {
        jack_default_audio_sample_t *channel_buf = (jack_default_audio_sample_t*)
            jack_port_get_buffer( stream->local_output_ports[chn],
                    frames );

        PaUtil_SetNonInterleavedOutputChannel( &stream->bufferProcessor,
                chn,
                channel_buf );
    }

    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor,
            &stream->callbackResult );
    /* We've specified a host buffer size mode where every frame should be consumed by the buffer processor */
    assert( framesProcessed == frames );

    PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );

end:
    return result;
}

/* Update the JACK callback's stream processing queue. */
static PaError UpdateQueue( PaJackHostApiRepresentation *hostApi )
{
    PaError result = paNoError;
    int queueModified = 0;
    const double jackSr = jack_get_sample_rate( hostApi->jack_client );
    int err;

    if( (err = pthread_mutex_trylock( &hostApi->mtx )) != 0 )
    {
        assert( err == EBUSY );
        return paNoError;
    }

    if( hostApi->toAdd )
    {
        if( hostApi->processQueue )
        {
            PaJackStream *node = hostApi->processQueue;
            /* Advance to end of queue */
            while( node->next )
                node = node->next;

            node->next = hostApi->toAdd;
        }
        else
        {
            /* The only queue entry. */
            hostApi->processQueue = (PaJackStream *)hostApi->toAdd;
        }

        /* If necessary, update stream state */
        if( hostApi->toAdd->streamRepresentation.streamInfo.sampleRate != jackSr )
            UpdateSampleRate( hostApi->toAdd, jackSr );

        hostApi->toAdd = NULL;
        queueModified = 1;
    }
    if( hostApi->toRemove )
    {
        int removed = 0;
        PaJackStream *node = hostApi->processQueue, *prev = NULL;
        assert( hostApi->processQueue );

        while( node )
        {
            if( node == hostApi->toRemove )
            {
                if( prev )
                    prev->next = node->next;
                else
                    hostApi->processQueue = (PaJackStream *)node->next;

                removed = 1;
                break;
            }

            prev = node;
            node = node->next;
        }
        UNLESS( removed, paInternalError );
        hostApi->toRemove = NULL;
        PA_DEBUG(( "%s: Removed stream from processing queue\n", __FUNCTION__ ));
        queueModified = 1;
    }

    if( queueModified )
    {
        /* Signal that we've done what was asked of us */
        ASSERT_CALL( pthread_cond_signal( &hostApi->cond ), 0 );
    }

error:
    ASSERT_CALL( pthread_mutex_unlock( &hostApi->mtx ), 0 );

    return result;
}

/* Audio processing callback invoked periodically from JACK. */
static int JackCallback( jack_nframes_t frames, void *userData )
{
    PaError result = paNoError;
    PaJackHostApiRepresentation *hostApi = (PaJackHostApiRepresentation *)userData;
    PaJackStream *stream = NULL;
    int xrun = hostApi->xrun;
    hostApi->xrun = 0;

    assert( hostApi );

    ENSURE_PA( UpdateQueue( hostApi ) );

    /* Process each stream */
    stream = hostApi->processQueue;
    for( ; stream; stream = stream->next )
    {
        if( xrun )  /* Don't override if already set */
            stream->xrun = 1;

        /* See if this stream is to be started */
        if( stream->doStart )
        {
            /* If we can't obtain a lock, we'll try next time */
            int err = pthread_mutex_trylock( &stream->hostApi->mtx );
            if( !err )
            {
                if( stream->doStart )   /* Could potentially change before obtaining the lock */
                {
                    stream->is_active = 1;
                    stream->doStart = 0;
                    PA_DEBUG(( "%s: Starting stream\n", __FUNCTION__ ));
                    ASSERT_CALL( pthread_cond_signal( &stream->hostApi->cond ), 0 );
                    stream->callbackResult = paContinue;
                    stream->isSilenced = 0;
                }

                ASSERT_CALL( pthread_mutex_unlock( &stream->hostApi->mtx ), 0 );
            }
            else
                assert( err == EBUSY );
        }
        else if( stream->doStop || stream->doAbort )    /* Should we stop/abort stream? */
        {
            if( stream->callbackResult == paContinue )     /* Ok, make it stop */
            {
                PA_DEBUG(( "%s: Stopping stream\n", __FUNCTION__ ));
                stream->callbackResult = stream->doStop ? paComplete : paAbort;
            }
        }

        if( stream->is_active )
            ENSURE_PA( RealProcess( stream, frames ) );
        /* If we have just entered inactive state, silence output */
        if( !stream->is_active && !stream->isSilenced )
        {
            int i;

            /* Silence buffer after entering inactive state */
            PA_DEBUG(( "Silencing the output\n" ));
            for( i = 0; i < stream->num_outgoing_connections; ++i )
            {
                jack_default_audio_sample_t *buffer = jack_port_get_buffer( stream->local_output_ports[i], frames );
                memset( buffer, 0, sizeof (jack_default_audio_sample_t) * frames );
            }

            stream->isSilenced = 1;
        }

        if( stream->doStop || stream->doAbort )
        {
            /* See if RealProcess has acted on the request */
            if( !stream->is_active )   /* Ok, signal to the main thread that we've carried out the operation */
            {
                /* If we can't obtain a lock, we'll try next time */
                int err = pthread_mutex_trylock( &stream->hostApi->mtx );
                if( !err )
                {
                    stream->doStop = stream->doAbort = 0;
                    ASSERT_CALL( pthread_cond_signal( &stream->hostApi->cond ), 0 );
                    ASSERT_CALL( pthread_mutex_unlock( &stream->hostApi->mtx ), 0 );
                }
                else
                    assert( err == EBUSY );
            }
        }
    }

    return 0;
error:
    return -1;
}

static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaJackStream *stream = (PaJackStream*)s;
    int i;

    /* Ready the processor */
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );

    /* Connect the ports. Note that the ports may already have been connected by someone else in
     * the meantime, in which case JACK returns EEXIST. */

    if( stream->num_incoming_connections > 0 )
    {
        for( i = 0; i < stream->num_incoming_connections; i++ )
        {
            int r = jack_connect( stream->jack_client, jack_port_name( stream->remote_output_ports[i] ),
                    jack_port_name( stream->local_input_ports[i] ) );
           UNLESS( 0 == r || EEXIST == r, paUnanticipatedHostError );
        }
    }

    if( stream->num_outgoing_connections > 0 )
    {
        for( i = 0; i < stream->num_outgoing_connections; i++ )
        {
            int r = jack_connect( stream->jack_client, jack_port_name( stream->local_output_ports[i] ),
                    jack_port_name( stream->remote_input_ports[i] ) );
           UNLESS( 0 == r || EEXIST == r, paUnanticipatedHostError );
        }
    }

    stream->xrun = FALSE;

    /* Enable processing */

    ASSERT_CALL( pthread_mutex_lock( &stream->hostApi->mtx ), 0 );
    stream->doStart = 1;

    /* Wait for stream to be started */
    result = WaitCondition( stream->hostApi );
    /*
    do
    {
        err = pthread_cond_timedwait( &stream->hostApi->cond, &stream->hostApi->mtx, &ts );
    } while( !stream->is_active && !err );
    */
    if( result != paNoError )   /* Something went wrong, call off the stream start */
    {
        stream->doStart = 0;
        stream->is_active = 0;  /* Cancel any processing */
    }
    ASSERT_CALL( pthread_mutex_unlock( &stream->hostApi->mtx ), 0 );

    ENSURE_PA( result );

    stream->is_running = TRUE;
    PA_DEBUG(( "%s: Stream started\n", __FUNCTION__ ));

error:
    return result;
}

static PaError RealStop( PaJackStream *stream, int abort )
{
    PaError result = paNoError;
    int i;

    if( stream->isBlockingStream )
        BlockingWaitEmpty ( stream );

    ASSERT_CALL( pthread_mutex_lock( &stream->hostApi->mtx ), 0 );
    if( abort )
        stream->doAbort = 1;
    else
        stream->doStop = 1;

    /* Wait for stream to be stopped */
    result = WaitCondition( stream->hostApi );
    ASSERT_CALL( pthread_mutex_unlock( &stream->hostApi->mtx ), 0 );
    ENSURE_PA( result );

    UNLESS( !stream->is_active, paInternalError );

    PA_DEBUG(( "%s: Stream stopped\n", __FUNCTION__ ));

error:
    stream->is_running = FALSE;

    /* Disconnect ports belonging to this stream */

    if( !stream->hostApi->jackIsDown )  /* XXX: Well? */
    {
        for( i = 0; i < stream->num_incoming_connections; i++ )
        {
            if( jack_port_connected( stream->local_input_ports[i] ) )
            {
                UNLESS( !jack_port_disconnect( stream->jack_client, stream->local_input_ports[i] ),
                        paUnanticipatedHostError );
            }
        }
        for( i = 0; i < stream->num_outgoing_connections; i++ )
        {
            if( jack_port_connected( stream->local_output_ports[i] ) )
            {
                UNLESS( !jack_port_disconnect( stream->jack_client, stream->local_output_ports[i] ),
                        paUnanticipatedHostError );
            }
        }
    }

    return result;
}

static PaError StopStream( PaStream *s )
{
    assert(s);
    return RealStop( (PaJackStream *)s, 0 );
}

static PaError AbortStream( PaStream *s )
{
    assert(s);
    return RealStop( (PaJackStream *)s, 1 );
}

static PaError IsStreamStopped( PaStream *s )
{
    PaJackStream *stream = (PaJackStream*)s;
    return !stream->is_running;
}


static PaError IsStreamActive( PaStream *s )
{
    PaJackStream *stream = (PaJackStream*)s;
    return stream->is_active;
}


static PaTime GetStreamTime( PaStream *s )
{
    PaJackStream *stream = (PaJackStream*)s;

    /* A: Is this relevant?? --> TODO: what if we're recording-only? */
    return (jack_frame_time( stream->jack_client ) - stream->t0) / (PaTime)jack_get_sample_rate( stream->jack_client );
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaJackStream *stream = (PaJackStream*)s;
    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}

PaError PaJack_SetClientName( const char* name )
{
    if( strlen( name ) > jack_client_name_size() )
    {
        /* OK, I don't know any better error code */
        return paInvalidFlag;
    }
    clientName_ = name;
    return paNoError;
}

PaError PaJack_GetClientName(const char** clientName)
{
    PaError result = paNoError;
    PaJackHostApiRepresentation* jackHostApi = NULL;
    PaJackHostApiRepresentation** ref = &jackHostApi;
    ENSURE_PA( PaUtil_GetHostApiRepresentation( (PaUtilHostApiRepresentation**)ref, paJACK ) );
    *clientName = jack_get_client_name( jackHostApi->jack_client );

error:
    return result;
}
#endif

#if PA_USE_OSS
/*
 * $Id$
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 * OSS implementation by:
 *   Douglas Repetto
 *   Phil Burk
 *   Dominic Mazzoni
 *   Arve Knudsen
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/**
 @file
 @ingroup hostapi_src
*/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <assert.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/poll.h>
#include <limits.h>
#include <semaphore.h>

#ifdef HAVE_SYS_SOUNDCARD_H
# include <sys/soundcard.h>
# ifdef __NetBSD__
#  define DEVICE_NAME_BASE           "/dev/audio"
# else
#  define DEVICE_NAME_BASE           "/dev/dsp"
# endif
#elif defined(HAVE_LINUX_SOUNDCARD_H)
# include <linux/soundcard.h>
# define DEVICE_NAME_BASE            "/dev/dsp"
#elif defined(HAVE_MACHINE_SOUNDCARD_H)
# include <machine/soundcard.h> /* JH20010905 */
# define DEVICE_NAME_BASE            "/dev/audio"
#else
# error No sound card header file
#endif

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_unix_util.h"
// (amalg) #include "pa_debugprint.h"

static int sysErr_;
static pthread_t mainThread_;

/* Check return value of system call, and map it to PaError */
#define ENSURE_(expr, code) \
    do { \
        if( UNLIKELY( (sysErr_ = (expr)) < 0 ) ) \
        { \
            /* PaUtil_SetLastHostErrorInfo should only be used in the main thread */ \
            if( (code) == paUnanticipatedHostError && pthread_self() == mainThread_ ) \
            { \
                PaUtil_SetLastHostErrorInfo( paOSS, sysErr_, strerror( errno ) ); \
            } \
            \
            PaUtil_DebugPrint(( "Expression '" #expr "' failed in '" __FILE__ "', line: " STRINGIZE( __LINE__ ) "\n" )); \
            result = (code); \
            goto error; \
        } \
    } while( 0 );

#ifndef AFMT_S16_NE
#define AFMT_S16_NE  Get_AFMT_S16_NE()
/*********************************************************************
 * Some versions of OSS do not define AFMT_S16_NE. So check CPU.
 * PowerPC is Big Endian. X86 is Little Endian.
 */
static int Get_AFMT_S16_NE( void )
{
    long testData = 1;
    char *ptr = (char *) &testData;
    int isLittle = ( *ptr == 1 ); /* Does address point to least significant byte? */
    return isLittle ? AFMT_S16_LE : AFMT_S16_BE;
}
#endif

/* PaOSSHostApiRepresentation - host api datastructure specific to this implementation */

typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;

    PaHostApiIndex hostApiIndex;
}
PaOSSHostApiRepresentation;

/** Per-direction structure for PaOssStream.
 *
 * Aspect StreamChannels: In case the user requests to open the same device for both capture and playback,
 * but with different number of channels we will have to adapt between the number of user and host
 * channels for at least one direction, since the configuration space is the same for both directions
 * of an OSS device.
 */
typedef struct
{
    int fd;
    const char *devName;
    int userChannelCount, hostChannelCount;
    int userInterleaved;
    void *buffer;
    PaSampleFormat userFormat, hostFormat;
    double latency;
    unsigned long hostFrames, numBufs;
    void **userBuffers; /* For non-interleaved blocking */
} PaOssStreamComponent;

/** Implementation specific representation of a PaStream.
 *
 */
typedef struct PaOssStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

    PaUtilThreading threading;

    int sharedDevice;
    unsigned long framesPerHostBuffer;
    int triggered;  /* Have the devices been triggered yet (first start) */

    int isActive;
    int isStopped;

    int lastPosPtr;
    double lastStreamBytes;

    int framesProcessed;

    double sampleRate;

    int callbackMode;
    volatile int callbackStop, callbackAbort;

    PaOssStreamComponent *capture, *playback;
    unsigned long pollTimeout;
    sem_t semaphore;
}
PaOssStream;

typedef enum {
    StreamMode_In,
    StreamMode_Out
} StreamMode;

/* prototypes for functions declared in this file */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );
static PaError BuildDeviceList( PaOSSHostApiRepresentation *hostApi );


/** Initialize the OSS API implementation.
 *
 * This function will initialize host API datastructures and query host devices for information.
 *
 * Aspect DeviceCapabilities: Enumeration of host API devices is initiated from here
 *
 * Aspect FreeResources: If an error is encountered under way we have to free each resource allocated in this function,
 * this happens with the usual "error" label.
 */
PaError PaOSS_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaOSSHostApiRepresentation *ossHostApi = NULL;

    PA_UNLESS( ossHostApi = (PaOSSHostApiRepresentation*)PaUtil_AllocateMemory( sizeof(PaOSSHostApiRepresentation) ),
            paInsufficientMemory );
    PA_UNLESS( ossHostApi->allocations = PaUtil_CreateAllocationGroup(), paInsufficientMemory );
    ossHostApi->hostApiIndex = hostApiIndex;

    /* Initialize host API structure */
    *hostApi = &ossHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paOSS;
    (*hostApi)->info.name = "OSS";
    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PA_ENSURE( BuildDeviceList( ossHostApi ) );

    PaUtil_InitializeStreamInterface( &ossHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable,
                                      PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &ossHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    mainThread_ = pthread_self();

    return result;

error:
    if( ossHostApi )
    {
        if( ossHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( ossHostApi->allocations );
            PaUtil_DestroyAllocationGroup( ossHostApi->allocations );
        }

        PaUtil_FreeMemory( ossHostApi );
    }
    return result;
}

PaError PaUtil_InitializeDeviceInfo( PaDeviceInfo *deviceInfo, const char *name, PaHostApiIndex hostApiIndex, int maxInputChannels,
        int maxOutputChannels, PaTime defaultLowInputLatency, PaTime defaultLowOutputLatency, PaTime defaultHighInputLatency,
        PaTime defaultHighOutputLatency, double defaultSampleRate, PaUtilAllocationGroup *allocations  )
{
    PaError result = paNoError;

    deviceInfo->structVersion = 2;
    if( allocations )
    {
        size_t len = strlen( name ) + 1;
        PA_UNLESS( deviceInfo->name = PaUtil_GroupAllocateMemory( allocations, len ), paInsufficientMemory );
        strncpy( (char *)deviceInfo->name, name, len );
    }
    else
        deviceInfo->name = name;

    deviceInfo->hostApi = hostApiIndex;
    deviceInfo->maxInputChannels = maxInputChannels;
    deviceInfo->maxOutputChannels = maxOutputChannels;
    deviceInfo->defaultLowInputLatency = defaultLowInputLatency;
    deviceInfo->defaultLowOutputLatency = defaultLowOutputLatency;
    deviceInfo->defaultHighInputLatency = defaultHighInputLatency;
    deviceInfo->defaultHighOutputLatency = defaultHighOutputLatency;
    deviceInfo->defaultSampleRate = defaultSampleRate;

error:
    return result;
}

static int CalcHigherLogTwo( int n )
{
    int log2 = 0;
    while( (1<<log2) < n ) log2++;
    return log2;
}

static PaError QueryDirection( const char *deviceName, StreamMode mode, double *defaultSampleRate, int *maxChannelCount,
        double *defaultLowLatency, double *defaultHighLatency )
{
    PaError result = paNoError;
    int numChannels, maxNumChannels;
    int busy = 0;
    int devHandle = -1;
    int sr;
    *maxChannelCount = 0;  /* Default value in case this fails */
    int temp, frgmt;
    unsigned long fragFrames;

    if ( (devHandle = open( deviceName, (mode == StreamMode_In ? O_RDONLY : O_WRONLY) | O_NONBLOCK ))  < 0 )
    {
        if( errno == EBUSY || errno == EAGAIN )
        {
            PA_DEBUG(( "%s: Device %s busy\n", __FUNCTION__, deviceName ));
        }
        else
        {
            /* Ignore ENOENT, which means we've tried a non-existent device */
            if( errno != ENOENT )
            {
                PA_DEBUG(( "%s: Can't access device %s: %s\n", __FUNCTION__, deviceName, strerror( errno ) ));
            }
        }

        return paDeviceUnavailable;
    }

    /* Negotiate for the maximum number of channels for this device. PLB20010927
     * Consider up to 16 as the upper number of channels.
     * Variable maxNumChannels should contain the actual upper limit after the call.
     * Thanks to John Lazzaro and Heiko Purnhagen for suggestions.
     */
    maxNumChannels = 0;
    for( numChannels = 1; numChannels <= 16; numChannels++ )
    {
        temp = numChannels;
        if( ioctl( devHandle, SNDCTL_DSP_CHANNELS, &temp ) < 0 )
        {
            busy = EAGAIN == errno || EBUSY == errno;
            /* ioctl() failed so bail out if we already have stereo */
            if( maxNumChannels >= 2 )
                break;
        }
        else
        {
            /* ioctl() worked but bail out if it does not support numChannels.
             * We don't want to leave gaps in the numChannels supported.
             */
            if( (numChannels > 2) && (temp != numChannels) )
                break;
            if( temp > maxNumChannels )
                maxNumChannels = temp; /* Save maximum. */
        }
    }
    /* A: We're able to open a device for capture if it's busy playing back and vice versa,
     * but we can't configure anything */
    if( 0 == maxNumChannels && busy )
    {
        result = paDeviceUnavailable;
        goto error;
    }

    /* The above negotiation may fail for an old driver so try this older technique. */
    if( maxNumChannels < 1 )
    {
        int stereo = 1;
        if( ioctl( devHandle, SNDCTL_DSP_STEREO, &stereo ) < 0 )
        {
            maxNumChannels = 1;
        }
        else
        {
            maxNumChannels = (stereo) ? 2 : 1;
        }
        PA_DEBUG(( "%s: use SNDCTL_DSP_STEREO, maxNumChannels = %d\n", __FUNCTION__, maxNumChannels ));
    }

    /* During channel negotiation, the last ioctl() may have failed. This can
     * also cause sample rate negotiation to fail. Hence the following, to return
     * to a supported number of channels. SG20011005 */
    {
        /* use most reasonable default value */
        numChannels = PA_MIN( maxNumChannels, 2 );
        ENSURE_( ioctl( devHandle, SNDCTL_DSP_CHANNELS, &numChannels ), paUnanticipatedHostError );
    }

    /* Get supported sample rate closest to 44100 Hz */
    if( *defaultSampleRate < 0 )
    {
        sr = 44100;
        ENSURE_( ioctl( devHandle, SNDCTL_DSP_SPEED, &sr ), paUnanticipatedHostError );

        *defaultSampleRate = sr;
    }

    *maxChannelCount = maxNumChannels;

    /* Attempt to set low latency with 4 frags-per-buffer, 128 frames-per-frag (total buffer 512 frames)
     * since the ioctl sets bytes, multiply by numChannels, and base on 2 bytes-per-sample, */
    fragFrames = 128;
    frgmt = (4 << 16) + (CalcHigherLogTwo( fragFrames * numChannels * 2 ) & 0xffff);
    ENSURE_( ioctl( devHandle, SNDCTL_DSP_SETFRAGMENT, &frgmt ), paUnanticipatedHostError );

    /* Use the value set by the ioctl to give the latency achieved */
    fragFrames = pow( 2, frgmt & 0xffff ) / (numChannels * 2);
    *defaultLowLatency = ((frgmt >> 16) - 1) * fragFrames / *defaultSampleRate;

    /* Cannot now try setting a high latency (device would need closing and opening again).  Make
     * high-latency 4 times the low unless the fragFrames are significantly more than requested 128 */
    temp = (fragFrames < 256) ? 4 : (fragFrames < 512) ? 2 : 1;
    *defaultHighLatency = temp * *defaultLowLatency;

error:
    if( devHandle >= 0 )
        close( devHandle );

    return result;
}

/** Query OSS device.
 *
 * This is where PaDeviceInfo objects are constructed and filled in with relevant information.
 *
 * Aspect DeviceCapabilities: The inferred device capabilities are recorded in a PaDeviceInfo object that is constructed
 * in place.
 */
static PaError QueryDevice( char *deviceName, PaOSSHostApiRepresentation *ossApi, PaDeviceInfo **deviceInfo )
{
    PaError result = paNoError;
    double sampleRate = -1.;
    int maxInputChannels, maxOutputChannels;
    PaTime defaultLowInputLatency, defaultLowOutputLatency, defaultHighInputLatency, defaultHighOutputLatency;
    PaError tmpRes = paNoError;
    int busy = 0;
    *deviceInfo = NULL;

    /* douglas:
       we have to do this querying in a slightly different order. apparently
       some sound cards will give you different info based on their settins.
       e.g. a card might give you stereo at 22kHz but only mono at 44kHz.
       the correct order for OSS is: format, channels, sample rate
    */

    /* Aspect StreamChannels: The number of channels supported for a device may depend on the mode it is
     * opened in, it may have more channels available for capture than playback and vice versa. Therefore
     * we will open the device in both read- and write-only mode to determine the supported number.
     */
    if( (tmpRes = QueryDirection( deviceName, StreamMode_In, &sampleRate, &maxInputChannels, &defaultLowInputLatency,
                &defaultHighInputLatency )) != paNoError )
    {
        if( tmpRes != paDeviceUnavailable )
        {
            PA_DEBUG(( "%s: Querying device %s for capture failed!\n", __FUNCTION__, deviceName ));
            /* PA_ENSURE( tmpRes ); */
        }
        ++busy;
    }
    if( (tmpRes = QueryDirection( deviceName, StreamMode_Out, &sampleRate, &maxOutputChannels, &defaultLowOutputLatency,
                &defaultHighOutputLatency )) != paNoError )
    {
        if( tmpRes != paDeviceUnavailable )
        {
            PA_DEBUG(( "%s: Querying device %s for playback failed!\n", __FUNCTION__, deviceName ));
            /* PA_ENSURE( tmpRes ); */
        }
        ++busy;
    }
    assert( 0 <= busy && busy <= 2 );
    if( 2 == busy )     /* Both directions are unavailable to us */
    {
        result = paDeviceUnavailable;
        goto error;
    }

    PA_UNLESS( *deviceInfo = PaUtil_GroupAllocateMemory( ossApi->allocations, sizeof (PaDeviceInfo) ), paInsufficientMemory );
    PA_ENSURE( PaUtil_InitializeDeviceInfo( *deviceInfo, deviceName, ossApi->hostApiIndex, maxInputChannels, maxOutputChannels,
                defaultLowInputLatency, defaultLowOutputLatency, defaultHighInputLatency, defaultHighOutputLatency, sampleRate,
                ossApi->allocations ) );

error:
    return result;
}

/** Query host devices.
 *
 * Loop over host devices and query their capabilitiesu
 *
 * Aspect DeviceCapabilities: This function calls QueryDevice on each device entry and receives a filled in PaDeviceInfo object
 * per device, these are placed in the host api representation's deviceInfos array.
 */
static PaError BuildDeviceList( PaOSSHostApiRepresentation *ossApi )
{
    PaError result = paNoError;
    PaUtilHostApiRepresentation *commonApi = &ossApi->inheritedHostApiRep;
    int i;
    int numDevices = 0, maxDeviceInfos = 1;
    PaDeviceInfo **deviceInfos = NULL;

    /* These two will be set to the first working input and output device, respectively */
    commonApi->info.defaultInputDevice = paNoDevice;
    commonApi->info.defaultOutputDevice = paNoDevice;

    /* Find devices by calling QueryDevice on each
     * potential device names.  When we find a valid one,
     * add it to a linked list.
     * A: Set an arbitrary of 100 devices, should probably be a smarter way. */

    for( i = 0; i < 100; i++ )
    {
       char deviceName[32];
       PaDeviceInfo *deviceInfo;
       int testResult;

       if( i == 0 )
          snprintf(deviceName, sizeof (deviceName), "%s", DEVICE_NAME_BASE);
       else
          snprintf(deviceName, sizeof (deviceName), "%s%d", DEVICE_NAME_BASE, i);

       /* PA_DEBUG(("%s: trying device %s\n", __FUNCTION__, deviceName )); */
       if( (testResult = QueryDevice( deviceName, ossApi, &deviceInfo )) != paNoError )
       {
           if( testResult != paDeviceUnavailable )
               PA_ENSURE( testResult );

           continue;
       }

       ++numDevices;
       if( !deviceInfos || numDevices > maxDeviceInfos )
       {
           maxDeviceInfos *= 2;
           PA_UNLESS( deviceInfos = (PaDeviceInfo **) realloc( deviceInfos, maxDeviceInfos * sizeof (PaDeviceInfo *) ),
                   paInsufficientMemory );
       }
       {
           int devIdx = numDevices - 1;
           deviceInfos[devIdx] = deviceInfo;

           if( commonApi->info.defaultInputDevice == paNoDevice && deviceInfo->maxInputChannels > 0 )
               commonApi->info.defaultInputDevice = devIdx;
           if( commonApi->info.defaultOutputDevice == paNoDevice && deviceInfo->maxOutputChannels > 0 )
               commonApi->info.defaultOutputDevice = devIdx;
       }
    }

    /* Make an array of PaDeviceInfo pointers out of the linked list */

    PA_DEBUG(("PaOSS %s: Total number of devices found: %d\n", __FUNCTION__, numDevices));

    commonApi->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
        ossApi->allocations, sizeof(PaDeviceInfo*) * numDevices );
    memcpy( commonApi->deviceInfos, deviceInfos, numDevices * sizeof (PaDeviceInfo *) );

    commonApi->info.deviceCount = numDevices;

error:
    free( deviceInfos );

    return result;
}

static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaOSSHostApiRepresentation *ossHostApi = (PaOSSHostApiRepresentation*)hostApi;

    if( ossHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( ossHostApi->allocations );
        PaUtil_DestroyAllocationGroup( ossHostApi->allocations );
    }

    PaUtil_FreeMemory( ossHostApi );
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaError result = paNoError;
    PaDeviceIndex device;
    PaDeviceInfo *deviceInfo;
    char *deviceName;
    int inputChannelCount, outputChannelCount;
    int tempDevHandle = -1;
    int flags;
    PaSampleFormat inputSampleFormat, outputSampleFormat;

    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
            return paInvalidChannelCount;

        /* validate inputStreamInfo */
        if( inputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
            return paInvalidDevice;

        /* check that output device can support inputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
            return paInvalidChannelCount;

        /* validate outputStreamInfo */
        if( outputParameters->hostApiSpecificStreamInfo )
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
    }
    else
    {
        outputChannelCount = 0;
    }

    if (inputChannelCount == 0 && outputChannelCount == 0)
        return paInvalidChannelCount;

    /* if full duplex, make sure that they're the same device */

    if (inputChannelCount > 0 && outputChannelCount > 0 &&
        inputParameters->device != outputParameters->device)
        return paInvalidDevice;

    /* if full duplex, also make sure that they're the same number of channels */

    if (inputChannelCount > 0 && outputChannelCount > 0 &&
        inputChannelCount != outputChannelCount)
       return paInvalidChannelCount;

    /* open the device so we can do more tests */

    if( inputChannelCount > 0 )
    {
        result = PaUtil_DeviceIndexToHostApiDeviceIndex(&device, inputParameters->device, hostApi);
        if (result != paNoError)
            return result;
    }
    else
    {
        result = PaUtil_DeviceIndexToHostApiDeviceIndex(&device, outputParameters->device, hostApi);
        if (result != paNoError)
            return result;
    }

    deviceInfo = hostApi->deviceInfos[device];
    deviceName = (char *)deviceInfo->name;

    flags = O_NONBLOCK;
    if (inputChannelCount > 0 && outputChannelCount > 0)
       flags |= O_RDWR;
    else if (inputChannelCount > 0)
       flags |= O_RDONLY;
    else
       flags |= O_WRONLY;

    ENSURE_( tempDevHandle = open( deviceInfo->name, flags ), paDeviceUnavailable );

    /* PaOssStream_Configure will do the rest of the checking for us */
    /* PA_ENSURE( PaOssStream_Configure( tempDevHandle, deviceName, outputChannelCount, &sampleRate ) ); */

    /* everything succeeded! */

 error:
    if( tempDevHandle >= 0 )
        close( tempDevHandle );

    return result;
}

/** Validate stream parameters.
 *
 * Aspect StreamChannels: We verify that the number of channels is within the allowed range for the device
 */
static PaError ValidateParameters( const PaStreamParameters *parameters, const PaDeviceInfo *deviceInfo, StreamMode mode )
{
    int maxChans;

    assert( parameters );

    if( parameters->device == paUseHostApiSpecificDeviceSpecification )
    {
        return paInvalidDevice;
    }

    maxChans = (mode == StreamMode_In ? deviceInfo->maxInputChannels :
        deviceInfo->maxOutputChannels);
    if( parameters->channelCount > maxChans )
    {
        return paInvalidChannelCount;
    }

    return paNoError;
}

static PaError PaOssStreamComponent_Initialize( PaOssStreamComponent *component, const PaStreamParameters *parameters,
        int callbackMode, int fd, const char *deviceName )
{
    PaError result = paNoError;
    assert( component );

    memset( component, 0, sizeof (PaOssStreamComponent) );

    component->fd = fd;
    component->devName = deviceName;
    component->userChannelCount = parameters->channelCount;
    component->userFormat = parameters->sampleFormat;
    component->latency = parameters->suggestedLatency;
    component->userInterleaved = !(parameters->sampleFormat & paNonInterleaved);

    if( !callbackMode && !component->userInterleaved )
    {
        /* Pre-allocate non-interleaved user provided buffers */
        PA_UNLESS( component->userBuffers = PaUtil_AllocateMemory( sizeof (void *) * component->userChannelCount ),
                paInsufficientMemory );
    }

error:
    return result;
}

static void PaOssStreamComponent_Terminate( PaOssStreamComponent *component )
{
    assert( component );

    if( component->fd >= 0 )
        close( component->fd );
    if( component->buffer )
        PaUtil_FreeMemory( component->buffer );

    if( component->userBuffers )
        PaUtil_FreeMemory( component->userBuffers );

    PaUtil_FreeMemory( component );
}

static PaError ModifyBlocking( int fd, int blocking )
{
    PaError result = paNoError;
    int fflags;

    ENSURE_( fflags = fcntl( fd, F_GETFL ), paUnanticipatedHostError );

    if( blocking )
        fflags &= ~O_NONBLOCK;
    else
        fflags |= O_NONBLOCK;

    ENSURE_( fcntl( fd, F_SETFL, fflags ), paUnanticipatedHostError );

error:
    return result;
}

/** Open input and output devices.
 *
 * @param idev: Returned input device file descriptor.
 * @param odev: Returned output device file descriptor.
 */
static PaError OpenDevices( const char *idevName, const char *odevName, int *idev, int *odev )
{
    PaError result = paNoError;
    int flags = O_NONBLOCK, duplex = 0;
    *idev = *odev = -1;

    if( idevName && odevName )
    {
        duplex = 1;
        flags |= O_RDWR;
    }
    else if( idevName )
        flags |= O_RDONLY;
    else
        flags |= O_WRONLY;

    /* open first in nonblocking mode, in case it's busy...
     * A: then unset the non-blocking attribute */
    assert( flags & O_NONBLOCK );
    if( idevName )
    {
        ENSURE_( *idev = open( idevName, flags ), paDeviceUnavailable );
        PA_ENSURE( ModifyBlocking( *idev, 1 ) ); /* Blocking */
    }
    if( odevName )
    {
        if( !idevName )
        {
            ENSURE_( *odev = open( odevName, flags ), paDeviceUnavailable );
            PA_ENSURE( ModifyBlocking( *odev, 1 ) ); /* Blocking */
        }
        else
        {
            ENSURE_( *odev = dup( *idev ), paUnanticipatedHostError );
        }
    }

error:
    return result;
}

static PaError PaOssStream_Initialize( PaOssStream *stream, const PaStreamParameters *inputParameters, const PaStreamParameters *outputParameters,
        PaStreamCallback callback, void *userData, PaStreamFlags streamFlags,
        PaOSSHostApiRepresentation *ossApi )
{
    PaError result = paNoError;
    int idev, odev;
    PaUtilHostApiRepresentation *hostApi = &ossApi->inheritedHostApiRep;
    const char *idevName = NULL, *odevName = NULL;

    assert( stream );

    memset( stream, 0, sizeof (PaOssStream) );
    stream->isStopped = 1;

    PA_ENSURE( PaUtil_InitializeThreading( &stream->threading ) );

    if( inputParameters && outputParameters )
    {
        if( inputParameters->device == outputParameters->device )
            stream->sharedDevice = 1;
    }

    if( inputParameters )
        idevName = hostApi->deviceInfos[inputParameters->device]->name;
    if( outputParameters )
        odevName = hostApi->deviceInfos[outputParameters->device]->name;
    PA_ENSURE( OpenDevices( idevName, odevName, &idev, &odev ) );
    if( inputParameters )
    {
        PA_UNLESS( stream->capture = PaUtil_AllocateMemory( sizeof (PaOssStreamComponent) ), paInsufficientMemory );
        PA_ENSURE( PaOssStreamComponent_Initialize( stream->capture, inputParameters, callback != NULL, idev, idevName ) );
    }
    if( outputParameters )
    {
        PA_UNLESS( stream->playback = PaUtil_AllocateMemory( sizeof (PaOssStreamComponent) ), paInsufficientMemory );
        PA_ENSURE( PaOssStreamComponent_Initialize( stream->playback, outputParameters, callback != NULL, odev, odevName ) );
    }

    if( callback != NULL )
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &ossApi->callbackStreamInterface, callback, userData );
        stream->callbackMode = 1;
    }
    else
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                               &ossApi->blockingStreamInterface, callback, userData );
    }

    ENSURE_( sem_init( &stream->semaphore, 0, 0 ), paInternalError );

error:
    return result;
}

static void PaOssStream_Terminate( PaOssStream *stream )
{
    assert( stream );

    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
    PaUtil_TerminateThreading( &stream->threading );

    if( stream->capture )
        PaOssStreamComponent_Terminate( stream->capture );
    if( stream->playback )
        PaOssStreamComponent_Terminate( stream->playback );

    sem_destroy( &stream->semaphore );

    PaUtil_FreeMemory( stream );
}

/** Translate from PA format to OSS native.
 *
 */
static PaError Pa2OssFormat( PaSampleFormat paFormat, int *ossFormat )
{
    switch( paFormat )
    {
        case paUInt8:
            *ossFormat = AFMT_U8;
            break;
        case paInt8:
            *ossFormat = AFMT_S8;
            break;
        case paInt16:
            *ossFormat = AFMT_S16_NE;
            break;
        default:
            return paInternalError;     /* This shouldn't happen */
    }

    return paNoError;
}

/** Return the PA-compatible formats that this device can support.
 *
 */
static PaError GetAvailableFormats( PaOssStreamComponent *component, PaSampleFormat *availableFormats )
{
    PaError result = paNoError;
    int mask = 0;
    PaSampleFormat frmts = 0;

    ENSURE_( ioctl( component->fd, SNDCTL_DSP_GETFMTS, &mask ), paUnanticipatedHostError );
    if( mask & AFMT_U8 )
        frmts |= paUInt8;
    if( mask & AFMT_S8 )
        frmts |= paInt8;
    if( mask & AFMT_S16_NE )
        frmts |= paInt16;
    else
        result = paSampleFormatNotSupported;

    *availableFormats = frmts;

error:
    return result;
}

static unsigned int PaOssStreamComponent_FrameSize( PaOssStreamComponent *component )
{
    return Pa_GetSampleSize( component->hostFormat ) * component->hostChannelCount;
}

/** Buffer size in bytes.
 *
 */
static unsigned long PaOssStreamComponent_BufferSize( PaOssStreamComponent *component )
{
    return PaOssStreamComponent_FrameSize( component ) * component->hostFrames * component->numBufs;
}

/** Configure stream component device parameters.
 */
static PaError PaOssStreamComponent_Configure( PaOssStreamComponent *component, double sampleRate, unsigned long
        framesPerBuffer, StreamMode streamMode, PaOssStreamComponent *master )
{
    PaError result = paNoError;
    int temp, nativeFormat;
    int sr = (int)sampleRate;
    PaSampleFormat availableFormats = 0, hostFormat = 0;
    int chans = component->userChannelCount;
    int frgmt;
    int numBufs;
    int bytesPerBuf;
    unsigned long bufSz;
    unsigned long fragSz;
    audio_buf_info bufInfo;

    /* We may have a situation where only one component (the master) is configured, if both point to the same device.
     * In that case, the second component will copy settings from the other */
    if( !master )
    {
        /* Aspect BufferSettings: If framesPerBuffer is unspecified we have to infer a suitable fragment size.
         * The hardware need not respect the requested fragment size, so we may have to adapt.
         */
        if( framesPerBuffer == paFramesPerBufferUnspecified )
        {
            /* Aim for 4 fragments in the complete buffer; the latency comes from 3 of these */
            fragSz = (unsigned long)(component->latency * sampleRate / 3);
            bufSz = fragSz * 4;
        }
        else
        {
            fragSz = framesPerBuffer;
            bufSz = (unsigned long)(component->latency * sampleRate) + fragSz; /* Latency + 1 buffer */
        }

        PA_ENSURE( GetAvailableFormats( component, &availableFormats ) );
        hostFormat = PaUtil_SelectClosestAvailableFormat( availableFormats, component->userFormat );

        /* OSS demands at least 2 buffers, and 16 bytes per buffer */
        numBufs = (int)PA_MAX( bufSz / fragSz, 2 );
        bytesPerBuf = PA_MAX( fragSz * Pa_GetSampleSize( hostFormat ) * chans, 16 );

        /* The fragment parameters are encoded like this:
         * Most significant byte: number of fragments
         * Least significant byte: exponent of fragment size (i.e., for 256, 8)
         */
        frgmt = (numBufs << 16) + (CalcHigherLogTwo( bytesPerBuf ) & 0xffff);
        ENSURE_( ioctl( component->fd, SNDCTL_DSP_SETFRAGMENT, &frgmt ), paUnanticipatedHostError );

        /* A: according to the OSS programmer's guide parameters should be set in this order:
         * format, channels, rate */

        /* This format should be deemed good before we get this far */
        PA_ENSURE( Pa2OssFormat( hostFormat, &temp ) );
        nativeFormat = temp;
        ENSURE_( ioctl( component->fd, SNDCTL_DSP_SETFMT, &temp ), paUnanticipatedHostError );
        PA_UNLESS( temp == nativeFormat, paInternalError );

        /* try to set the number of channels */
        ENSURE_( ioctl( component->fd, SNDCTL_DSP_CHANNELS, &chans ), paSampleFormatNotSupported );   /* XXX: Should be paInvalidChannelCount? */
        /* It's possible that the minimum number of host channels is greater than what the user requested */
        PA_UNLESS( chans >= component->userChannelCount, paInvalidChannelCount );

        /* try to set the sample rate */
        ENSURE_( ioctl( component->fd, SNDCTL_DSP_SPEED, &sr ), paInvalidSampleRate );

        /* reject if there's no sample rate within 1% of the one requested */
        if( (fabs( sampleRate - sr ) / sampleRate) > 0.01 )
        {
            PA_DEBUG(("%s: Wanted %f, closest sample rate was %d\n", __FUNCTION__, sampleRate, sr ));
            PA_ENSURE( paInvalidSampleRate );
        }

        ENSURE_( ioctl( component->fd, streamMode == StreamMode_In ? SNDCTL_DSP_GETISPACE : SNDCTL_DSP_GETOSPACE, &bufInfo ),
                paUnanticipatedHostError );
        component->numBufs = bufInfo.fragstotal;

        /* This needs to be the last ioctl call before the first read/write, according to the OSS programmer's guide */
        ENSURE_( ioctl( component->fd, SNDCTL_DSP_GETBLKSIZE, &bytesPerBuf ), paUnanticipatedHostError );

        component->hostFrames = bytesPerBuf / Pa_GetSampleSize( hostFormat ) / chans;
        component->hostChannelCount = chans;
        component->hostFormat = hostFormat;
    }
    else
    {
        component->hostFormat = master->hostFormat;
        component->hostFrames = master->hostFrames;
        component->hostChannelCount = master->hostChannelCount;
        component->numBufs = master->numBufs;
    }

    PA_UNLESS( component->buffer = PaUtil_AllocateMemory( PaOssStreamComponent_BufferSize( component ) ),
            paInsufficientMemory );

error:
    return result;
}

static PaError PaOssStreamComponent_Read( PaOssStreamComponent *component, unsigned long *frames )
{
    PaError result = paNoError;
    size_t len = *frames * PaOssStreamComponent_FrameSize( component );
    ssize_t bytesRead;

    ENSURE_( bytesRead = read( component->fd, component->buffer, len ), paUnanticipatedHostError );
    *frames = bytesRead / PaOssStreamComponent_FrameSize( component );
    /* TODO: Handle condition where number of frames read doesn't equal number of frames requested */

error:
    return result;
}

static PaError PaOssStreamComponent_Write( PaOssStreamComponent *component, unsigned long *frames )
{
    PaError result = paNoError;
    size_t len = *frames * PaOssStreamComponent_FrameSize( component );
    ssize_t bytesWritten;

    ENSURE_( bytesWritten = write( component->fd, component->buffer, len ), paUnanticipatedHostError );
    *frames = bytesWritten / PaOssStreamComponent_FrameSize( component );
    /* TODO: Handle condition where number of frames written doesn't equal number of frames requested */

error:
    return result;
}

/** Configure the stream according to input/output parameters.
 *
 * Aspect StreamChannels: The minimum number of channels supported by the device may exceed that requested by
 * the user, if so we'll record the actual number of host channels and adapt later.
 */
static PaError PaOssStream_Configure( PaOssStream *stream, double sampleRate, unsigned long framesPerBuffer,
        double *inputLatency, double *outputLatency )
{
    PaError result = paNoError;
    int duplex = stream->capture && stream->playback;
    unsigned long framesPerHostBuffer = 0;

    /* We should request full duplex first thing after opening the device */
    if( duplex && stream->sharedDevice )
        ENSURE_( ioctl( stream->capture->fd, SNDCTL_DSP_SETDUPLEX, 0 ), paUnanticipatedHostError );

    if( stream->capture )
    {
        PaOssStreamComponent *component = stream->capture;
        PA_ENSURE( PaOssStreamComponent_Configure( component, sampleRate, framesPerBuffer, StreamMode_In,
                    NULL ) );

        assert( component->hostChannelCount > 0 );
        assert( component->hostFrames > 0 );

        *inputLatency = (component->hostFrames * (component->numBufs - 1)) / sampleRate;
    }
    if( stream->playback )
    {
        PaOssStreamComponent *component = stream->playback, *master = stream->sharedDevice ? stream->capture : NULL;
        PA_ENSURE( PaOssStreamComponent_Configure( component, sampleRate, framesPerBuffer, StreamMode_Out,
                    master ) );

        assert( component->hostChannelCount > 0 );
        assert( component->hostFrames > 0 );

        *outputLatency = (component->hostFrames * (component->numBufs - 1)) / sampleRate;
    }

    if( duplex )
        framesPerHostBuffer = PA_MIN( stream->capture->hostFrames, stream->playback->hostFrames );
    else if( stream->capture )
        framesPerHostBuffer = stream->capture->hostFrames;
    else if( stream->playback )
        framesPerHostBuffer = stream->playback->hostFrames;

    stream->framesPerHostBuffer = framesPerHostBuffer;
    stream->pollTimeout = (int) ceil( 1e6 * framesPerHostBuffer / sampleRate );    /* Period in usecs, rounded up */

    stream->sampleRate = stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

error:
    return result;
}

/* see pa_hostapi.h for a list of validity guarantees made about OpenStream parameters */

/** Open a PA OSS stream.
 *
 * Aspect StreamChannels: The number of channels is specified per direction (in/out), and can differ between the
 * two. However, OSS doesn't support separate configuration spaces for capture and playback so if both
 * directions are the same device we will demand the same number of channels. The number of channels can range
 * from 1 to the maximum supported by the device.
 *
 * Aspect BufferSettings: If framesPerBuffer != paFramesPerBufferUnspecified the number of frames per callback
 * must reflect this, in addition the host latency per device should approximate the corresponding
 * suggestedLatency. Based on these constraints we need to determine a number of frames per host buffer that
 * both capture and playback can agree on (they can be different devices), the buffer processor can adapt
 * between host and user buffer size, but the ratio should preferably be integral.
 */
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
    PaOSSHostApiRepresentation *ossHostApi = (PaOSSHostApiRepresentation*)hostApi;
    PaOssStream *stream = NULL;
    int inputChannelCount = 0, outputChannelCount = 0;
    PaSampleFormat inputSampleFormat = 0, outputSampleFormat = 0, inputHostFormat = 0, outputHostFormat = 0;
    const PaDeviceInfo *inputDeviceInfo = 0, *outputDeviceInfo = 0;
    int bpInitialized = 0;
    double inLatency = 0., outLatency = 0.;
    int i = 0;

    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform specific flag */

    if( inputParameters )
    {
        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        inputDeviceInfo = hostApi->deviceInfos[inputParameters->device];
        PA_ENSURE( ValidateParameters( inputParameters, inputDeviceInfo, StreamMode_In ) );

        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
    }
    if( outputParameters )
    {
        outputDeviceInfo = hostApi->deviceInfos[outputParameters->device];
        PA_ENSURE( ValidateParameters( outputParameters, outputDeviceInfo, StreamMode_Out ) );

        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
    }

    /* Aspect StreamChannels: We currently demand that number of input and output channels are the same, if the same
     * device is opened for both directions
     */
    if( inputChannelCount > 0 && outputChannelCount > 0 )
    {
        if( inputParameters->device == outputParameters->device )
        {
            if( inputParameters->channelCount != outputParameters->channelCount )
                return paInvalidChannelCount;
        }
    }

    /* Round framesPerBuffer to the next power-of-two to make OSS happy. */
    if( framesPerBuffer != paFramesPerBufferUnspecified )
    {
        framesPerBuffer &= INT_MAX;
        for (i = 1; framesPerBuffer > i; i <<= 1) ;
        framesPerBuffer = i;
    }

    /* allocate and do basic initialization of the stream structure */
    PA_UNLESS( stream = (PaOssStream*)PaUtil_AllocateMemory( sizeof(PaOssStream) ), paInsufficientMemory );
    PA_ENSURE( PaOssStream_Initialize( stream, inputParameters, outputParameters, streamCallback, userData, streamFlags, ossHostApi ) );

    PA_ENSURE( PaOssStream_Configure( stream, sampleRate, framesPerBuffer, &inLatency, &outLatency ) );

    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );

    if( inputParameters )
    {
        inputHostFormat = stream->capture->hostFormat;
        stream->streamRepresentation.streamInfo.inputLatency = inLatency +
            PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor ) / sampleRate;
    }
    if( outputParameters )
    {
        outputHostFormat = stream->playback->hostFormat;
        stream->streamRepresentation.streamInfo.outputLatency = outLatency +
            PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor ) / sampleRate;
    }

    /* Initialize buffer processor with fixed host buffer size.
     * Aspect StreamSampleFormat: Here we commit the user and host sample formats, PA infrastructure will
     * convert between the two.
     */
    PA_ENSURE( PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
              inputChannelCount, inputSampleFormat, inputHostFormat, outputChannelCount, outputSampleFormat,
              outputHostFormat, sampleRate, streamFlags, framesPerBuffer, stream->framesPerHostBuffer,
              paUtilFixedHostBufferSize, streamCallback, userData ) );
    bpInitialized = 1;

    *s = (PaStream*)stream;

    return result;

error:
    if( bpInitialized )
        PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    if( stream )
        PaOssStream_Terminate( stream );

    return result;
}

/*! Poll on I/O filedescriptors.

  Poll till we've determined there's data for read or write. In the full-duplex case,
  we don't want to hang around forever waiting for either input or output frames, so
  whenever we have a timed out filedescriptor we check if we're nearing under/overrun
  for the other direction (critical limit set at one buffer). If so, we exit the waiting
  state, and go on with what we got. We align the number of frames on a host buffer
  boundary because it is possible that the buffer size differs for the two directions and
  the host buffer size is a compromise between the two.
  */
static PaError PaOssStream_WaitForFrames( PaOssStream *stream, unsigned long *frames )
{
    PaError result = paNoError;
    int pollPlayback = 0, pollCapture = 0;
    int captureAvail = INT_MAX, playbackAvail = INT_MAX, commonAvail;
    audio_buf_info bufInfo;
    /* int ofs = 0, nfds = stream->nfds; */
    fd_set readFds, writeFds;
    int nfds = 0;
    struct timeval selectTimeval = {0, 0};
    unsigned long timeout = stream->pollTimeout;    /* In usecs */
    int captureFd = -1, playbackFd = -1;

    assert( stream );
    assert( frames );

    if( stream->capture )
    {
        pollCapture = 1;
        captureFd = stream->capture->fd;
        /* stream->capture->pfd->events = POLLIN; */
    }
    if( stream->playback )
    {
        pollPlayback = 1;
        playbackFd = stream->playback->fd;
        /* stream->playback->pfd->events = POLLOUT; */
    }

    FD_ZERO( &readFds );
    FD_ZERO( &writeFds );

    while( pollPlayback || pollCapture )
    {
#ifdef PTHREAD_CANCELED
        pthread_testcancel();
#else
        /* avoid indefinite waiting on thread not supporting cancelation */
        if( stream->callbackStop || stream->callbackAbort )
        {
            PA_DEBUG(( "Cancelling PaOssStream_WaitForFrames\n" ));
            (*frames) = 0;
            return paNoError;
        }
#endif

        /* select may modify the timeout parameter */
        selectTimeval.tv_usec = timeout;
        nfds = 0;

        if( pollCapture )
        {
            FD_SET( captureFd, &readFds );
            nfds = captureFd + 1;
        }
        if( pollPlayback )
        {
            FD_SET( playbackFd, &writeFds );
            nfds = PA_MAX( nfds, playbackFd + 1 );
        }
        ENSURE_( select( nfds, &readFds, &writeFds, NULL, &selectTimeval ), paUnanticipatedHostError );
        /*
        if( poll( stream->pfds + ofs, nfds, stream->pollTimeout ) < 0 )
        {

            ENSURE_( -1, paUnanticipatedHostError );
        }
        */
#ifdef PTHREAD_CANCELED
        pthread_testcancel();
#else
        /* avoid indefinite waiting on thread not supporting cancelation */
        if( stream->callbackStop || stream->callbackAbort )
        {
            PA_DEBUG(( "Cancelling PaOssStream_WaitForFrames\n" ));
            (*frames) = 0;
            return paNoError;
        }
#endif
        if( pollCapture )
        {
            if( FD_ISSET( captureFd, &readFds ) )
            {
                FD_CLR( captureFd, &readFds );
                pollCapture = 0;
            }
            /*
            if( stream->capture->pfd->revents & POLLIN )
            {
                --nfds;
                ++ofs;
                pollCapture = 0;
            }
            */
            else if( stream->playback ) /* Timed out, go on with playback? */
            {
                /*PA_DEBUG(( "%s: Trying to poll again for capture frames, pollTimeout: %d\n",
                            __FUNCTION__, stream->pollTimeout ));*/
            }
        }
        if( pollPlayback )
        {
            if( FD_ISSET( playbackFd, &writeFds ) )
            {
                FD_CLR( playbackFd, &writeFds );
                pollPlayback = 0;
            }
            /*
            if( stream->playback->pfd->revents & POLLOUT )
            {
                --nfds;
                pollPlayback = 0;
            }
            */
            else if( stream->capture )  /* Timed out, go on with capture? */
            {
                /*PA_DEBUG(( "%s: Trying to poll again for playback frames, pollTimeout: %d\n\n",
                            __FUNCTION__, stream->pollTimeout ));*/
            }
        }
    }

    if( stream->capture )
    {
        ENSURE_( ioctl( captureFd, SNDCTL_DSP_GETISPACE, &bufInfo ), paUnanticipatedHostError );
        captureAvail = bufInfo.fragments * stream->capture->hostFrames;
        if( !captureAvail )
            PA_DEBUG(( "%s: captureAvail: 0\n", __FUNCTION__ ));

        captureAvail = captureAvail == 0 ? INT_MAX : captureAvail;      /* Disregard if zero */
    }
    if( stream->playback )
    {
        ENSURE_( ioctl( playbackFd, SNDCTL_DSP_GETOSPACE, &bufInfo ), paUnanticipatedHostError );
        playbackAvail = bufInfo.fragments * stream->playback->hostFrames;
        if( !playbackAvail )
        {
            PA_DEBUG(( "%s: playbackAvail: 0\n", __FUNCTION__ ));
        }

        playbackAvail = playbackAvail == 0 ? INT_MAX : playbackAvail;      /* Disregard if zero */
    }

    commonAvail = PA_MIN( captureAvail, playbackAvail );
    if( commonAvail == INT_MAX )
        commonAvail = 0;
    commonAvail -= commonAvail % stream->framesPerHostBuffer;

    assert( commonAvail != INT_MAX );
    assert( commonAvail >= 0 );
    *frames = commonAvail;

error:
    return result;
}

/** Prepare stream for capture/playback.
 *
 * In order to synchronize capture and playback properly we use the SETTRIGGER command.
 */
static PaError PaOssStream_Prepare( PaOssStream *stream )
{
    PaError result = paNoError;
    int enableBits = 0;

    if( stream->triggered )
        return result;

    /* The OSS reference instructs us to clear direction bits before setting them.*/
    if( stream->playback )
        ENSURE_( ioctl( stream->playback->fd, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
    if( stream->capture )
        ENSURE_( ioctl( stream->capture->fd, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );

    if( stream->playback )
    {
        size_t bufSz = PaOssStreamComponent_BufferSize( stream->playback );
        memset( stream->playback->buffer, 0, bufSz );

        /* Looks like we have to turn off blocking before we try this, but if we don't fill the buffer
         * OSS will complain. */
        PA_ENSURE( ModifyBlocking( stream->playback->fd, 0 ) );
        while (1)
        {
            if( write( stream->playback->fd, stream->playback->buffer, bufSz ) < 0 )
                break;
        }
        PA_ENSURE( ModifyBlocking( stream->playback->fd, 1 ) );
    }

    if( stream->sharedDevice )
    {
        enableBits = PCM_ENABLE_INPUT | PCM_ENABLE_OUTPUT;
        ENSURE_( ioctl( stream->capture->fd, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
    }
    else
    {
        if( stream->capture )
        {
            enableBits = PCM_ENABLE_INPUT;
            ENSURE_( ioctl( stream->capture->fd, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
        }
        if( stream->playback )
        {
            enableBits = PCM_ENABLE_OUTPUT;
            ENSURE_( ioctl( stream->playback->fd, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
        }
    }

    /* Ok, we have triggered the stream */
    stream->triggered = 1;

error:
    return result;
}

/** Stop audio processing
 *
 */
static PaError PaOssStream_Stop( PaOssStream *stream, int abort )
{
    PaError result = paNoError;

    /* Looks like the only safe way to stop audio without reopening the device is SNDCTL_DSP_POST.
     * Also disable capture/playback till the stream is started again.
     */
    int captureErr = 0, playbackErr = 0;
    if( stream->capture )
    {
        if( (captureErr = ioctl( stream->capture->fd, SNDCTL_DSP_POST, 0 )) < 0 )
        {
            PA_DEBUG(( "%s: Failed to stop capture device, error: %d\n", __FUNCTION__, captureErr ));
        }
    }
    if( stream->playback && !stream->sharedDevice )
    {
        if( (playbackErr = ioctl( stream->playback->fd, SNDCTL_DSP_POST, 0 )) < 0 )
        {
            PA_DEBUG(( "%s: Failed to stop playback device, error: %d\n", __FUNCTION__, playbackErr ));
        }
    }

    if( captureErr || playbackErr )
    {
        result = paUnanticipatedHostError;
    }

    return result;
}

/** Clean up after thread exit.
 *
 * Aspect StreamState: If the user has registered a streamFinishedCallback it will be called here
 */
static void OnExit( void *data )
{
    PaOssStream *stream = (PaOssStream *) data;
    assert( data );

    PaUtil_ResetCpuLoadMeasurer( &stream->cpuLoadMeasurer );

    PaOssStream_Stop( stream, stream->callbackAbort );

    PA_DEBUG(( "OnExit: Stoppage\n" ));

    /* Eventually notify user all buffers have played */
    if( stream->streamRepresentation.streamFinishedCallback )
        stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );

    stream->callbackAbort = 0;      /* Clear state */
    stream->isActive = 0;
}

static PaError SetUpBuffers( PaOssStream *stream, unsigned long framesAvail )
{
    PaError result = paNoError;

    if( stream->capture )
    {
        PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor, 0, stream->capture->buffer,
                stream->capture->hostChannelCount );
        PaUtil_SetInputFrameCount( &stream->bufferProcessor, framesAvail );
    }
    if( stream->playback )
    {
        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, 0, stream->playback->buffer,
                stream->playback->hostChannelCount );
        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, framesAvail );
    }

    return result;
}

/** Thread procedure for callback processing.
 *
 * Aspect StreamState: StartStream will wait on this to initiate audio processing, useful in case the
 * callback should be used for buffer priming. When the stream is cancelled a separate function will
 * take care of the transition to the Callback Finished state (the stream isn't considered Stopped
 * before StopStream() or AbortStream() are called).
 */
static void *PaOSS_AudioThreadProc( void *userData )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)userData;
    unsigned long framesAvail = 0, framesProcessed = 0;
    int callbackResult = paContinue;
    int triggered = stream->triggered;  /* See if SNDCTL_DSP_TRIGGER has been issued already */
    int initiateProcessing = triggered;    /* Already triggered? */
    PaStreamCallbackFlags cbFlags = 0;  /* We might want to keep state across iterations */
    PaStreamCallbackTimeInfo timeInfo = {0,0,0}; /* TODO: IMPLEMENT ME */

    /*
#if ( SOUND_VERSION > 0x030904 )
        audio_errinfo errinfo;
#endif
*/

    assert( stream );

    pthread_cleanup_push( &OnExit, stream );	/* Execute OnExit when exiting */

    /* The first time the stream is started we use SNDCTL_DSP_TRIGGER to accurately start capture and
     * playback in sync, when the stream is restarted after being stopped we simply start by reading/
     * writing.
     */
    PA_ENSURE( PaOssStream_Prepare( stream ) );

    /* If we are to initiate processing implicitly by reading/writing data, we start off in blocking mode */
    if( initiateProcessing )
    {
        /* Make sure devices are in blocking mode */
        if( stream->capture )
            ModifyBlocking( stream->capture->fd, 1 );
        if( stream->playback )
            ModifyBlocking( stream->playback->fd, 1 );
    }

    while( 1 )
    {
#ifdef PTHREAD_CANCELED
        pthread_testcancel();
#else
        if( stream->callbackAbort ) /* avoid indefinite waiting on thread not supporting cancelation */
        {
            PA_DEBUG(( "Aborting callback thread\n" ));
            break;
        }
#endif
        if( stream->callbackStop && callbackResult == paContinue )
        {
            PA_DEBUG(( "Setting callbackResult to paComplete\n" ));
            callbackResult = paComplete;
        }

        /* Aspect StreamState: Because of the messy OSS scheme we can't explicitly trigger device start unless
         * the stream has been recently started, we will have to go right ahead and read/write in blocking
         * fashion to trigger operation. Therefore we begin with processing one host buffer before we switch
         * to non-blocking mode.
         */
        if( !initiateProcessing )
        {
            /* Wait on available frames */
            PA_ENSURE( PaOssStream_WaitForFrames( stream, &framesAvail ) );
            assert( framesAvail % stream->framesPerHostBuffer == 0 );
        }
        else
        {
            framesAvail = stream->framesPerHostBuffer;
        }

        while( framesAvail > 0 )
        {
            unsigned long frames = framesAvail;

#ifdef PTHREAD_CANCELED
            pthread_testcancel();
#else
            if( stream->callbackStop )
            {
                PA_DEBUG(( "Setting callbackResult to paComplete\n" ));
                callbackResult = paComplete;
            }

            if( stream->callbackAbort ) /* avoid indefinite waiting on thread not supporting cancelation */
            {
                PA_DEBUG(( "Aborting callback thread\n" ));
                break;
            }
#endif
            PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

            /* Read data */
            if ( stream->capture )
            {
                PA_ENSURE( PaOssStreamComponent_Read( stream->capture, &frames ) );
                if( frames < framesAvail )
                {
                    PA_DEBUG(( "Read %lu less frames than requested\n", framesAvail - frames ));
                    framesAvail = frames;
                }
            }

#if ( SOUND_VERSION >= 0x030904 )
            /*
               Check with OSS to see if there have been any under/overruns
               since last time we checked.
               */
            /*
            if( ioctl( stream->deviceHandle, SNDCTL_DSP_GETERROR, &errinfo ) >= 0 )
            {
                if( errinfo.play_underruns )
                    cbFlags |= paOutputUnderflow ;
                if( errinfo.record_underruns )
                    cbFlags |= paInputUnderflow ;
            }
            else
                PA_DEBUG(( "SNDCTL_DSP_GETERROR command failed: %s\n", strerror( errno ) ));
                */
#endif

            PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo,
                    cbFlags );
            cbFlags = 0;
            PA_ENSURE( SetUpBuffers( stream, framesAvail ) );

            framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor,
                    &callbackResult );
            assert( framesProcessed == framesAvail );
            PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );

            if ( stream->playback )
            {
                frames = framesAvail;

                PA_ENSURE( PaOssStreamComponent_Write( stream->playback, &frames ) );
                if( frames < framesAvail )
                {
                    /* TODO: handle bytesWritten != bytesRequested (slippage?) */
                    PA_DEBUG(( "Wrote %lu less frames than requested\n", framesAvail - frames ));
                }
            }

            framesAvail -= framesProcessed;
            stream->framesProcessed += framesProcessed;

            if( callbackResult != paContinue )
                break;
        }

        if( initiateProcessing || !triggered )
        {
            /* Non-blocking */
            if( stream->capture )
                PA_ENSURE( ModifyBlocking( stream->capture->fd, 0 ) );
            if( stream->playback && !stream->sharedDevice )
                PA_ENSURE( ModifyBlocking( stream->playback->fd, 0 ) );

            initiateProcessing = 0;
            sem_post( &stream->semaphore );
        }

        if( callbackResult != paContinue )
        {
            stream->callbackAbort = callbackResult == paAbort;
            if( stream->callbackAbort || PaUtil_IsBufferProcessorOutputEmpty( &stream->bufferProcessor ) )
                break;
        }
    }

    pthread_cleanup_pop( 1 );

error:
    pthread_exit( NULL );
}

/** Close the stream.
 *
 */
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;

    assert( stream );

    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaOssStream_Terminate( stream );

    return result;
}

/** Start the stream.
 *
 * Aspect StreamState: After returning, the stream shall be in the Active state, implying that an eventual
 * callback will be repeatedly called in a separate thread. If a separate thread is started this function
 * will block untill it has started processing audio, otherwise audio processing is started directly.
 */
static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;

    stream->isActive = 1;
    stream->isStopped = 0;
    stream->lastPosPtr = 0;
    stream->lastStreamBytes = 0;
    stream->framesProcessed = 0;

    /* only use the thread for callback streams */
    if( stream->bufferProcessor.streamCallback )
    {
        PA_ENSURE( PaUtil_StartThreading( &stream->threading, &PaOSS_AudioThreadProc, stream ) );
        sem_wait( &stream->semaphore );
    }
    else
        PA_ENSURE( PaOssStream_Prepare( stream ) );

error:
    return result;
}

static PaError RealStop( PaOssStream *stream, int abort )
{
    PaError result = paNoError;

    if( stream->callbackMode )
    {
        if( abort )
            stream->callbackAbort = 1;
        else
            stream->callbackStop = 1;

        PA_ENSURE( PaUtil_CancelThreading( &stream->threading, !abort, NULL ) );

        stream->callbackStop = stream->callbackAbort = 0;
    }
    else
        PA_ENSURE( PaOssStream_Stop( stream, abort ) );

    stream->isStopped = 1;

error:
    return result;
}

/** Stop the stream.
 *
 * Aspect StreamState: This will cause the stream to transition to the Stopped state, playing all enqueued
 * buffers.
 */
static PaError StopStream( PaStream *s )
{
    return RealStop( (PaOssStream *)s, 0 );
}

/** Abort the stream.
 *
 * Aspect StreamState: This will cause the stream to transition to the Stopped state, discarding all enqueued
 * buffers. Note that the buffers are not currently correctly discarded, this is difficult without closing
 * the OSS device.
 */
static PaError AbortStream( PaStream *s )
{
    return RealStop( (PaOssStream *)s, 1 );
}

/** Is the stream in the Stopped state.
 *
 */
static PaError IsStreamStopped( PaStream *s )
{
    PaOssStream *stream = (PaOssStream*)s;

    return (stream->isStopped);
}

/** Is the stream in the Active state.
 *
 */
static PaError IsStreamActive( PaStream *s )
{
    PaOssStream *stream = (PaOssStream*)s;

    return (stream->isActive);
}

static PaTime GetStreamTime( PaStream *s )
{
    PaOssStream *stream = (PaOssStream*)s;
    count_info info;
    int delta;

    if( stream->playback ) {
        if( ioctl( stream->playback->fd, SNDCTL_DSP_GETOPTR, &info) == 0 ) {
            delta = ( info.bytes - stream->lastPosPtr ) /* & 0x000FFFFF*/;
            return (float)(stream->lastStreamBytes + delta) / PaOssStreamComponent_FrameSize( stream->playback ) / stream->sampleRate;
        }
    }
    else {
        if (ioctl( stream->capture->fd, SNDCTL_DSP_GETIPTR, &info) == 0) {
            delta = (info.bytes - stream->lastPosPtr) /*& 0x000FFFFF*/;
            return (float)(stream->lastStreamBytes + delta) / PaOssStreamComponent_FrameSize( stream->capture ) / stream->sampleRate;
        }
    }

    /* the ioctl failed, but we can still give a coarse estimate */

    return stream->framesProcessed / stream->sampleRate;
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaOssStream *stream = (PaOssStream*)s;

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}


/*
    As separate stream interfaces are used for blocking and callback
    streams, the following functions can be guaranteed to only be called
    for blocking streams.
*/


static PaError ReadStream( PaStream* s,
                           void *buffer,
                           unsigned long frames )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;
    int bytesRequested, bytesRead;
    unsigned long framesRequested;
    void *userBuffer;

    /* If user input is non-interleaved, PaUtil_CopyInput will manipulate the channel pointers,
     * so we copy the user provided pointers */
    if( stream->bufferProcessor.userInputIsInterleaved )
        userBuffer = buffer;
    else /* Copy channels into local array */
    {
        userBuffer = stream->capture->userBuffers;
        memcpy( (void *)userBuffer, buffer, sizeof (void *) * stream->capture->userChannelCount );
    }

    while( frames )
    {
        framesRequested = PA_MIN( frames, stream->capture->hostFrames );

	bytesRequested = framesRequested * PaOssStreamComponent_FrameSize( stream->capture );
	ENSURE_( (bytesRead = read( stream->capture->fd, stream->capture->buffer, bytesRequested )),
                 paUnanticipatedHostError );
	if ( bytesRequested != bytesRead )
	{
	    PA_DEBUG(( "Requested %d bytes, read %d\n", bytesRequested, bytesRead ));
	    return paUnanticipatedHostError;
	}

	PaUtil_SetInputFrameCount( &stream->bufferProcessor, stream->capture->hostFrames );
	PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor, 0, stream->capture->buffer, stream->capture->hostChannelCount );
        PaUtil_CopyInput( &stream->bufferProcessor, &userBuffer, framesRequested );
	frames -= framesRequested;
    }

error:
    return result;
}


static PaError WriteStream( PaStream *s, const void *buffer, unsigned long frames )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;
    int bytesRequested, bytesWritten;
    unsigned long framesConverted;
    const void *userBuffer;

    /* If user output is non-interleaved, PaUtil_CopyOutput will manipulate the channel pointers,
     * so we copy the user provided pointers */
    if( stream->bufferProcessor.userOutputIsInterleaved )
        userBuffer = buffer;
    else
    {
        /* Copy channels into local array */
        userBuffer = stream->playback->userBuffers;
        memcpy( (void *)userBuffer, buffer, sizeof (void *) * stream->playback->userChannelCount );
    }

    while( frames )
    {
	PaUtil_SetOutputFrameCount( &stream->bufferProcessor, stream->playback->hostFrames );
	PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, 0, stream->playback->buffer, stream->playback->hostChannelCount );

	framesConverted = PaUtil_CopyOutput( &stream->bufferProcessor, &userBuffer, frames );
	frames -= framesConverted;

	bytesRequested = framesConverted * PaOssStreamComponent_FrameSize( stream->playback );
	ENSURE_( (bytesWritten = write( stream->playback->fd, stream->playback->buffer, bytesRequested )),
                 paUnanticipatedHostError );

	if ( bytesRequested != bytesWritten )
	{
	    PA_DEBUG(( "Requested %d bytes, wrote %d\n", bytesRequested, bytesWritten ));
	    return paUnanticipatedHostError;
	}
    }

error:
    return result;
}


static signed long GetStreamReadAvailable( PaStream* s )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;
    audio_buf_info info;

    ENSURE_( ioctl( stream->capture->fd, SNDCTL_DSP_GETISPACE, &info ), paUnanticipatedHostError );
    return info.fragments * stream->capture->hostFrames;

error:
    return result;
}


/* TODO: Compute number of allocated bytes somewhere else, can we use ODELAY with capture */
static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaError result = paNoError;
    PaOssStream *stream = (PaOssStream*)s;
    int delay = 0;
#ifdef SNDCTL_DSP_GETODELAY
    ENSURE_( ioctl( stream->playback->fd, SNDCTL_DSP_GETODELAY, &delay ), paUnanticipatedHostError );
#endif
    return (PaOssStreamComponent_BufferSize( stream->playback ) - delay) / PaOssStreamComponent_FrameSize( stream->playback );

/* Conditionally compile this to avoid warning about unused label */
#ifdef SNDCTL_DSP_GETODELAY
error:
    return result;
#endif
}

/*
 * recplay.c
 * Phil Burk
 * Minimal record and playback test.
 * 
 */
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#ifndef __STDC__
/* #include <getopt.h> */
#endif /* __STDC__ */
#include <fcntl.h>
#ifdef __STDC__
#include <string.h>
#else /* __STDC__ */
#include <strings.h>
#endif /* __STDC__ */
#include <sys/soundcard.h>

#define NUM_BYTES   (64*1024)
#define BLOCK_SIZE   (4*1024)

#define AUDIO "/dev/dsp"

char buffer[NUM_BYTES];

int audioDev = 0;

main (int argc, char *argv[])
{
    int   numLeft;
    char *ptr;
    int   num;
    int   samplesize;

    /********** RECORD ********************/
    /* Open audio device. */
    audioDev = open (AUDIO, O_RDONLY, 0);
    if (audioDev == -1)
    {
        perror (AUDIO);
        exit (-1);
    }

    /* Set to 16 bit samples. */
    samplesize = 16;
    ioctl(audioDev, SNDCTL_DSP_SAMPLESIZE, &samplesize);
    if (samplesize != 16)
    {
        perror("Unable to set the sample size.");
        exit(-1);
    }

    /* Record in blocks */
    printf("Begin recording.\n");
    numLeft = NUM_BYTES;
    ptr = buffer;
    while( numLeft >= BLOCK_SIZE )
    {
        if ( (num = read (audioDev, ptr, BLOCK_SIZE)) < 0 )
        {
            perror (AUDIO);
            exit (-1);
        }
        else
        {
            printf("Read %d bytes\n", num);
            ptr += num;
            numLeft -= num;
        }
    }

    close( audioDev );

    /********** PLAYBACK ********************/
    /* Open audio device for writing. */
    audioDev = open (AUDIO, O_WRONLY, 0);
    if (audioDev == -1)
    {
        perror (AUDIO);
        exit (-1);
    }

    /* Set to 16 bit samples. */
    samplesize = 16;
    ioctl(audioDev, SNDCTL_DSP_SAMPLESIZE, &samplesize);
    if (samplesize != 16)
    {
        perror("Unable to set the sample size.");
        exit(-1);
    }

    /* Play in blocks */
    printf("Begin playing.\n");
    numLeft = NUM_BYTES;
    ptr = buffer;
    while( numLeft >= BLOCK_SIZE )
    {
        if ( (num = write (audioDev, ptr, BLOCK_SIZE)) < 0 )
        {
            perror (AUDIO);
            exit (-1);
        }
        else
        {
            printf("Wrote %d bytes\n", num);
            ptr += num;
            numLeft -= num;
        }
    }

    close( audioDev );
}
#endif

#if PA_USE_WASAPI


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for audioclient.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __audioclient_h__
#define __audioclient_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAudioClient_FWD_DEFINED__
#define __IAudioClient_FWD_DEFINED__
typedef interface IAudioClient IAudioClient;
#endif 	/* __IAudioClient_FWD_DEFINED__ */


#ifndef __IAudioRenderClient_FWD_DEFINED__
#define __IAudioRenderClient_FWD_DEFINED__
typedef interface IAudioRenderClient IAudioRenderClient;
#endif 	/* __IAudioRenderClient_FWD_DEFINED__ */


#ifndef __IAudioCaptureClient_FWD_DEFINED__
#define __IAudioCaptureClient_FWD_DEFINED__
typedef interface IAudioCaptureClient IAudioCaptureClient;
#endif 	/* __IAudioCaptureClient_FWD_DEFINED__ */


#ifndef __IAudioClock_FWD_DEFINED__
#define __IAudioClock_FWD_DEFINED__
typedef interface IAudioClock IAudioClock;
#endif 	/* __IAudioClock_FWD_DEFINED__ */


#ifndef __ISimpleAudioVolume_FWD_DEFINED__
#define __ISimpleAudioVolume_FWD_DEFINED__
typedef interface ISimpleAudioVolume ISimpleAudioVolume;
#endif 	/* __ISimpleAudioVolume_FWD_DEFINED__ */


#ifndef __IAudioStreamVolume_FWD_DEFINED__
#define __IAudioStreamVolume_FWD_DEFINED__
typedef interface IAudioStreamVolume IAudioStreamVolume;
#endif 	/* __IAudioStreamVolume_FWD_DEFINED__ */


#ifndef __IChannelAudioVolume_FWD_DEFINED__
#define __IChannelAudioVolume_FWD_DEFINED__
typedef interface IChannelAudioVolume IChannelAudioVolume;
#endif 	/* __IChannelAudioVolume_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "wtypes.h"
// (amalg) #include "unknwn.h"
// (amalg) #include "AudioSessionTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_audioclient_0000_0000 */
/* [local] */ 

#if 0
typedef /* [hidden][restricted] */ struct WAVEFORMATEX
    {
    WORD wFormatTag;
    WORD nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD nBlockAlign;
    WORD wBitsPerSample;
    WORD cbSize;
    } 	WAVEFORMATEX;

#else
#include <mmreg.h>
#endif
#if 0
typedef /* [hidden][restricted] */ LONGLONG REFERENCE_TIME;

#else
#define _IKsControl_
#include <ks.h>
#include <ksmedia.h>
#endif

enum _AUDCLNT_BUFFERFLAGS
    {	AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY	= 0x1,
	AUDCLNT_BUFFERFLAGS_SILENT	= 0x2,
	AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_s_ifspec;

#ifndef __IAudioClient_INTERFACE_DEFINED__
#define __IAudioClient_INTERFACE_DEFINED__

/* interface IAudioClient */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CB9AD4C-DBFA-4c32-B178-C2F568A703B2")
    IAudioClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ 
            __in  AUDCLNT_SHAREMODE ShareMode,
            /* [in] */ 
            __in  DWORD StreamFlags,
            /* [in] */ 
            __in  REFERENCE_TIME hnsBufferDuration,
            /* [in] */ 
            __in  REFERENCE_TIME hnsPeriodicity,
            /* [in] */ 
            __in  const WAVEFORMATEX *pFormat,
            /* [in] */ 
            __in_opt  LPCGUID AudioSessionGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferSize( 
            /* [out] */ 
            __out  UINT32 *pNumBufferFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamLatency( 
            /* [out] */ 
            __out  REFERENCE_TIME *phnsLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPadding( 
            /* [out] */ 
            __out  UINT32 *pNumPaddingFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [in] */ 
            __in  AUDCLNT_SHAREMODE ShareMode,
            /* [in] */ 
            __in  const WAVEFORMATEX *pFormat,
            /* [unique][out] */ 
            __out_opt  WAVEFORMATEX **ppClosestMatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMixFormat( 
            /* [out] */ 
            __out  WAVEFORMATEX **ppDeviceFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevicePeriod( 
            /* [out] */ 
            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
            /* [out] */ 
            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventHandle( 
            /* [in] */ HANDLE eventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __out  void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAudioClient * This,
            /* [in] */ 
            __in  AUDCLNT_SHAREMODE ShareMode,
            /* [in] */ 
            __in  DWORD StreamFlags,
            /* [in] */ 
            __in  REFERENCE_TIME hnsBufferDuration,
            /* [in] */ 
            __in  REFERENCE_TIME hnsPeriodicity,
            /* [in] */ 
            __in  const WAVEFORMATEX *pFormat,
            /* [in] */ 
            __in_opt  LPCGUID AudioSessionGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferSize )( 
            IAudioClient * This,
            /* [out] */ 
            __out  UINT32 *pNumBufferFrames);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamLatency )( 
            IAudioClient * This,
            /* [out] */ 
            __out  REFERENCE_TIME *phnsLatency);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPadding )( 
            IAudioClient * This,
            /* [out] */ 
            __out  UINT32 *pNumPaddingFrames);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IAudioClient * This,
            /* [in] */ 
            __in  AUDCLNT_SHAREMODE ShareMode,
            /* [in] */ 
            __in  const WAVEFORMATEX *pFormat,
            /* [unique][out] */ 
            __out_opt  WAVEFORMATEX **ppClosestMatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixFormat )( 
            IAudioClient * This,
            /* [out] */ 
            __out  WAVEFORMATEX **ppDeviceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevicePeriod )( 
            IAudioClient * This,
            /* [out] */ 
            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
            /* [out] */ 
            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IAudioClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IAudioClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAudioClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventHandle )( 
            IAudioClient * This,
            /* [in] */ HANDLE eventHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            IAudioClient * This,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __out  void **ppv);
        
        END_INTERFACE
    } IAudioClientVtbl;

    interface IAudioClient
    {
        CONST_VTBL struct IAudioClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioClient_Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid)	\
    ( (This)->lpVtbl -> Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid) ) 

#define IAudioClient_GetBufferSize(This,pNumBufferFrames)	\
    ( (This)->lpVtbl -> GetBufferSize(This,pNumBufferFrames) ) 

#define IAudioClient_GetStreamLatency(This,phnsLatency)	\
    ( (This)->lpVtbl -> GetStreamLatency(This,phnsLatency) ) 

#define IAudioClient_GetCurrentPadding(This,pNumPaddingFrames)	\
    ( (This)->lpVtbl -> GetCurrentPadding(This,pNumPaddingFrames) ) 

#define IAudioClient_IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch) ) 

#define IAudioClient_GetMixFormat(This,ppDeviceFormat)	\
    ( (This)->lpVtbl -> GetMixFormat(This,ppDeviceFormat) ) 

#define IAudioClient_GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod)	\
    ( (This)->lpVtbl -> GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod) ) 

#define IAudioClient_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IAudioClient_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IAudioClient_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IAudioClient_SetEventHandle(This,eventHandle)	\
    ( (This)->lpVtbl -> SetEventHandle(This,eventHandle) ) 

#define IAudioClient_GetService(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetService(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioClient_INTERFACE_DEFINED__ */


#ifndef __IAudioRenderClient_INTERFACE_DEFINED__
#define __IAudioRenderClient_INTERFACE_DEFINED__

/* interface IAudioRenderClient */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAudioRenderClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F294ACFC-3146-4483-A7BF-ADDCA7C260E2")
    IAudioRenderClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ 
            __in  UINT32 NumFramesRequested,
            /* [out] */ 
            __out  BYTE **ppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ 
            __in  UINT32 NumFramesWritten,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioRenderClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioRenderClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioRenderClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioRenderClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IAudioRenderClient * This,
            /* [in] */ 
            __in  UINT32 NumFramesRequested,
            /* [out] */ 
            __out  BYTE **ppData);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IAudioRenderClient * This,
            /* [in] */ 
            __in  UINT32 NumFramesWritten,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        END_INTERFACE
    } IAudioRenderClientVtbl;

    interface IAudioRenderClient
    {
        CONST_VTBL struct IAudioRenderClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioRenderClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioRenderClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioRenderClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioRenderClient_GetBuffer(This,NumFramesRequested,ppData)	\
    ( (This)->lpVtbl -> GetBuffer(This,NumFramesRequested,ppData) ) 

#define IAudioRenderClient_ReleaseBuffer(This,NumFramesWritten,dwFlags)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesWritten,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioRenderClient_INTERFACE_DEFINED__ */


#ifndef __IAudioCaptureClient_INTERFACE_DEFINED__
#define __IAudioCaptureClient_INTERFACE_DEFINED__

/* interface IAudioCaptureClient */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAudioCaptureClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8ADBD64-E71E-48a0-A4DE-185C395CD317")
    IAudioCaptureClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ 
            __out  BYTE **ppData,
            /* [out] */ 
            __out  UINT32 *pNumFramesToRead,
            /* [out] */ 
            __out  DWORD *pdwFlags,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64DevicePosition,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64QPCPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ 
            __in  UINT32 NumFramesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPacketSize( 
            /* [out] */ 
            __out  UINT32 *pNumFramesInNextPacket) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioCaptureClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioCaptureClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioCaptureClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioCaptureClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IAudioCaptureClient * This,
            /* [out] */ 
            __out  BYTE **ppData,
            /* [out] */ 
            __out  UINT32 *pNumFramesToRead,
            /* [out] */ 
            __out  DWORD *pdwFlags,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64DevicePosition,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64QPCPosition);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IAudioCaptureClient * This,
            /* [in] */ 
            __in  UINT32 NumFramesRead);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextPacketSize )( 
            IAudioCaptureClient * This,
            /* [out] */ 
            __out  UINT32 *pNumFramesInNextPacket);
        
        END_INTERFACE
    } IAudioCaptureClientVtbl;

    interface IAudioCaptureClient
    {
        CONST_VTBL struct IAudioCaptureClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioCaptureClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioCaptureClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioCaptureClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioCaptureClient_GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition) ) 

#define IAudioCaptureClient_ReleaseBuffer(This,NumFramesRead)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesRead) ) 

#define IAudioCaptureClient_GetNextPacketSize(This,pNumFramesInNextPacket)	\
    ( (This)->lpVtbl -> GetNextPacketSize(This,pNumFramesInNextPacket) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioCaptureClient_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_audioclient_0000_0003 */
/* [local] */ 

#define AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ  0x00000001


extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_s_ifspec;

#ifndef __IAudioClock_INTERFACE_DEFINED__
#define __IAudioClock_INTERFACE_DEFINED__

/* interface IAudioClock */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD63314F-3FBA-4a1b-812C-EF96358728E7")
    IAudioClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
            /* [out] */ 
            __out  UINT64 *pu64Frequency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [out] */ 
            __out  UINT64 *pu64Position,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64QPCPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ 
            __out  DWORD *pdwCharacteristics) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
            IAudioClock * This,
            /* [out] */ 
            __out  UINT64 *pu64Frequency);
        
        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
            IAudioClock * This,
            /* [out] */ 
            __out  UINT64 *pu64Position,
            /* [unique][out] */ 
            __out_opt  UINT64 *pu64QPCPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            IAudioClock * This,
            /* [out] */ 
            __out  DWORD *pdwCharacteristics);
        
        END_INTERFACE
    } IAudioClockVtbl;

    interface IAudioClock
    {
        CONST_VTBL struct IAudioClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioClock_GetFrequency(This,pu64Frequency)	\
    ( (This)->lpVtbl -> GetFrequency(This,pu64Frequency) ) 

#define IAudioClock_GetPosition(This,pu64Position,pu64QPCPosition)	\
    ( (This)->lpVtbl -> GetPosition(This,pu64Position,pu64QPCPosition) ) 

#define IAudioClock_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioClock_INTERFACE_DEFINED__ */


#ifndef __ISimpleAudioVolume_INTERFACE_DEFINED__
#define __ISimpleAudioVolume_INTERFACE_DEFINED__

/* interface ISimpleAudioVolume */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISimpleAudioVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("87CE5498-68D6-44E5-9215-6DA47EF883D8")
    ISimpleAudioVolume : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMasterVolume( 
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID EventContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMasterVolume( 
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMute( 
            /* [in] */ 
            __in  const BOOL bMute,
            /* [unique][in] */ LPCGUID EventContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMute( 
            /* [out] */ 
            __out  BOOL *pbMute) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleAudioVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleAudioVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleAudioVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleAudioVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMasterVolume )( 
            ISimpleAudioVolume * This,
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID EventContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetMasterVolume )( 
            ISimpleAudioVolume * This,
            /* [out] */ 
            __out  float *pfLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetMute )( 
            ISimpleAudioVolume * This,
            /* [in] */ 
            __in  const BOOL bMute,
            /* [unique][in] */ LPCGUID EventContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetMute )( 
            ISimpleAudioVolume * This,
            /* [out] */ 
            __out  BOOL *pbMute);
        
        END_INTERFACE
    } ISimpleAudioVolumeVtbl;

    interface ISimpleAudioVolume
    {
        CONST_VTBL struct ISimpleAudioVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleAudioVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISimpleAudioVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISimpleAudioVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISimpleAudioVolume_SetMasterVolume(This,fLevel,EventContext)	\
    ( (This)->lpVtbl -> SetMasterVolume(This,fLevel,EventContext) ) 

#define ISimpleAudioVolume_GetMasterVolume(This,pfLevel)	\
    ( (This)->lpVtbl -> GetMasterVolume(This,pfLevel) ) 

#define ISimpleAudioVolume_SetMute(This,bMute,EventContext)	\
    ( (This)->lpVtbl -> SetMute(This,bMute,EventContext) ) 

#define ISimpleAudioVolume_GetMute(This,pbMute)	\
    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISimpleAudioVolume_INTERFACE_DEFINED__ */


#ifndef __IAudioStreamVolume_INTERFACE_DEFINED__
#define __IAudioStreamVolume_INTERFACE_DEFINED__

/* interface IAudioStreamVolume */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioStreamVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93014887-242D-4068-8A15-CF5E93B90FE3")
    IAudioStreamVolume : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT32 *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [in] */ 
            __in  const float fLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][in] */ 
            __in_ecount(dwCount)  const float *pfVolumes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][out] */ 
            __out_ecount(dwCount)  float *pfVolumes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioStreamVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioStreamVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioStreamVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioStreamVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioStreamVolume * This,
            /* [out] */ 
            __out  UINT32 *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
            IAudioStreamVolume * This,
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [in] */ 
            __in  const float fLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
            IAudioStreamVolume * This,
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [out] */ 
            __out  float *pfLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
            IAudioStreamVolume * This,
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][in] */ 
            __in_ecount(dwCount)  const float *pfVolumes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
            IAudioStreamVolume * This,
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][out] */ 
            __out_ecount(dwCount)  float *pfVolumes);
        
        END_INTERFACE
    } IAudioStreamVolumeVtbl;

    interface IAudioStreamVolume
    {
        CONST_VTBL struct IAudioStreamVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioStreamVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioStreamVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioStreamVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioStreamVolume_GetChannelCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 

#define IAudioStreamVolume_SetChannelVolume(This,dwIndex,fLevel)	\
    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel) ) 

#define IAudioStreamVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 

#define IAudioStreamVolume_SetAllVolumes(This,dwCount,pfVolumes)	\
    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes) ) 

#define IAudioStreamVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioStreamVolume_INTERFACE_DEFINED__ */


#ifndef __IChannelAudioVolume_INTERFACE_DEFINED__
#define __IChannelAudioVolume_INTERFACE_DEFINED__

/* interface IChannelAudioVolume */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IChannelAudioVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C158861-B533-4B30-B1CF-E853E51C59B8")
    IChannelAudioVolume : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT32 *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [in] */ 
            __in  const float fLevel,
            /* [unique][in] */ LPCGUID EventContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][in] */ 
            __in_ecount(dwCount)  const float *pfVolumes,
            /* [unique][in] */ LPCGUID EventContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][out] */ 
            __out_ecount(dwCount)  float *pfVolumes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChannelAudioVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChannelAudioVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChannelAudioVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChannelAudioVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IChannelAudioVolume * This,
            /* [out] */ 
            __out  UINT32 *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
            IChannelAudioVolume * This,
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [in] */ 
            __in  const float fLevel,
            /* [unique][in] */ LPCGUID EventContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
            IChannelAudioVolume * This,
            /* [in] */ 
            __in  UINT32 dwIndex,
            /* [out] */ 
            __out  float *pfLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
            IChannelAudioVolume * This,
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][in] */ 
            __in_ecount(dwCount)  const float *pfVolumes,
            /* [unique][in] */ LPCGUID EventContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
            IChannelAudioVolume * This,
            /* [in] */ 
            __in  UINT32 dwCount,
            /* [size_is][out] */ 
            __out_ecount(dwCount)  float *pfVolumes);
        
        END_INTERFACE
    } IChannelAudioVolumeVtbl;

    interface IChannelAudioVolume
    {
        CONST_VTBL struct IChannelAudioVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChannelAudioVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChannelAudioVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChannelAudioVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChannelAudioVolume_GetChannelCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 

#define IChannelAudioVolume_SetChannelVolume(This,dwIndex,fLevel,EventContext)	\
    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel,EventContext) ) 

#define IChannelAudioVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 

#define IChannelAudioVolume_SetAllVolumes(This,dwCount,pfVolumes,EventContext)	\
    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes,EventContext) ) 

#define IChannelAudioVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IChannelAudioVolume_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_audioclient_0000_0007 */
/* [local] */ 

#define FACILITY_AUDCLNT 0x889
#define AUDCLNT_ERR(n) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUDCLNT, n)
#define AUDCLNT_SUCCESS(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_AUDCLNT, n)
#define AUDCLNT_E_NOT_INITIALIZED            AUDCLNT_ERR(0x001)
#define AUDCLNT_E_ALREADY_INITIALIZED        AUDCLNT_ERR(0x002)
#define AUDCLNT_E_WRONG_ENDPOINT_TYPE        AUDCLNT_ERR(0x003)
#define AUDCLNT_E_DEVICE_INVALIDATED         AUDCLNT_ERR(0x004)
#define AUDCLNT_E_NOT_STOPPED                AUDCLNT_ERR(0x005)
#define AUDCLNT_E_BUFFER_TOO_LARGE           AUDCLNT_ERR(0x006)
#define AUDCLNT_E_OUT_OF_ORDER               AUDCLNT_ERR(0x007)
#define AUDCLNT_E_UNSUPPORTED_FORMAT         AUDCLNT_ERR(0x008)
#define AUDCLNT_E_INVALID_SIZE               AUDCLNT_ERR(0x009)
#define AUDCLNT_E_DEVICE_IN_USE              AUDCLNT_ERR(0x00a)
#define AUDCLNT_E_BUFFER_OPERATION_PENDING   AUDCLNT_ERR(0x00b)
#define AUDCLNT_E_THREAD_NOT_REGISTERED      AUDCLNT_ERR(0x00c)
#define AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED AUDCLNT_ERR(0x00e)
#define AUDCLNT_E_ENDPOINT_CREATE_FAILED     AUDCLNT_ERR(0x00f)
#define AUDCLNT_E_SERVICE_NOT_RUNNING        AUDCLNT_ERR(0x010)
#define AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     AUDCLNT_ERR(0x011)
#define AUDCLNT_E_EXCLUSIVE_MODE_ONLY          AUDCLNT_ERR(0x012)
#define AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL AUDCLNT_ERR(0x013)
#define AUDCLNT_E_EVENTHANDLE_NOT_SET          AUDCLNT_ERR(0x014)
#define AUDCLNT_E_INCORRECT_BUFFER_SIZE        AUDCLNT_ERR(0x015)
#define AUDCLNT_E_BUFFER_SIZE_ERROR            AUDCLNT_ERR(0x016)
#define AUDCLNT_E_CPUUSAGE_EXCEEDED            AUDCLNT_ERR(0x017)
#define AUDCLNT_S_BUFFER_EMPTY              AUDCLNT_SUCCESS(0x001)
#define AUDCLNT_S_THREAD_ALREADY_REGISTERED AUDCLNT_SUCCESS(0x002)
#define AUDCLNT_S_POSITION_STALLED		   AUDCLNT_SUCCESS(0x003)


extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif





/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for devicetopology.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __devicetopology_h__
#define __devicetopology_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IKsControl_FWD_DEFINED__
#define __IKsControl_FWD_DEFINED__
typedef interface IKsControl IKsControl;
#endif 	/* __IKsControl_FWD_DEFINED__ */


#ifndef __IPerChannelDbLevel_FWD_DEFINED__
#define __IPerChannelDbLevel_FWD_DEFINED__
typedef interface IPerChannelDbLevel IPerChannelDbLevel;
#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */


#ifndef __IAudioVolumeLevel_FWD_DEFINED__
#define __IAudioVolumeLevel_FWD_DEFINED__
typedef interface IAudioVolumeLevel IAudioVolumeLevel;
#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */


#ifndef __IAudioChannelConfig_FWD_DEFINED__
#define __IAudioChannelConfig_FWD_DEFINED__
typedef interface IAudioChannelConfig IAudioChannelConfig;
#endif 	/* __IAudioChannelConfig_FWD_DEFINED__ */


#ifndef __IAudioLoudness_FWD_DEFINED__
#define __IAudioLoudness_FWD_DEFINED__
typedef interface IAudioLoudness IAudioLoudness;
#endif 	/* __IAudioLoudness_FWD_DEFINED__ */


#ifndef __IAudioInputSelector_FWD_DEFINED__
#define __IAudioInputSelector_FWD_DEFINED__
typedef interface IAudioInputSelector IAudioInputSelector;
#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */


#ifndef __IAudioOutputSelector_FWD_DEFINED__
#define __IAudioOutputSelector_FWD_DEFINED__
typedef interface IAudioOutputSelector IAudioOutputSelector;
#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */


#ifndef __IAudioMute_FWD_DEFINED__
#define __IAudioMute_FWD_DEFINED__
typedef interface IAudioMute IAudioMute;
#endif 	/* __IAudioMute_FWD_DEFINED__ */


#ifndef __IAudioBass_FWD_DEFINED__
#define __IAudioBass_FWD_DEFINED__
typedef interface IAudioBass IAudioBass;
#endif 	/* __IAudioBass_FWD_DEFINED__ */


#ifndef __IAudioMidrange_FWD_DEFINED__
#define __IAudioMidrange_FWD_DEFINED__
typedef interface IAudioMidrange IAudioMidrange;
#endif 	/* __IAudioMidrange_FWD_DEFINED__ */


#ifndef __IAudioTreble_FWD_DEFINED__
#define __IAudioTreble_FWD_DEFINED__
typedef interface IAudioTreble IAudioTreble;
#endif 	/* __IAudioTreble_FWD_DEFINED__ */


#ifndef __IAudioAutoGainControl_FWD_DEFINED__
#define __IAudioAutoGainControl_FWD_DEFINED__
typedef interface IAudioAutoGainControl IAudioAutoGainControl;
#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */


#ifndef __IAudioPeakMeter_FWD_DEFINED__
#define __IAudioPeakMeter_FWD_DEFINED__
typedef interface IAudioPeakMeter IAudioPeakMeter;
#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */


#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
#define __IDeviceSpecificProperty_FWD_DEFINED__
typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */


#ifndef __IKsFormatSupport_FWD_DEFINED__
#define __IKsFormatSupport_FWD_DEFINED__
typedef interface IKsFormatSupport IKsFormatSupport;
#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */


#ifndef __IKsJackDescription_FWD_DEFINED__
#define __IKsJackDescription_FWD_DEFINED__
typedef interface IKsJackDescription IKsJackDescription;
#endif 	/* __IKsJackDescription_FWD_DEFINED__ */


#ifndef __IPartsList_FWD_DEFINED__
#define __IPartsList_FWD_DEFINED__
typedef interface IPartsList IPartsList;
#endif 	/* __IPartsList_FWD_DEFINED__ */


#ifndef __IPart_FWD_DEFINED__
#define __IPart_FWD_DEFINED__
typedef interface IPart IPart;
#endif 	/* __IPart_FWD_DEFINED__ */


#ifndef __IConnector_FWD_DEFINED__
#define __IConnector_FWD_DEFINED__
typedef interface IConnector IConnector;
#endif 	/* __IConnector_FWD_DEFINED__ */


#ifndef __ISubunit_FWD_DEFINED__
#define __ISubunit_FWD_DEFINED__
typedef interface ISubunit ISubunit;
#endif 	/* __ISubunit_FWD_DEFINED__ */


#ifndef __IControlInterface_FWD_DEFINED__
#define __IControlInterface_FWD_DEFINED__
typedef interface IControlInterface IControlInterface;
#endif 	/* __IControlInterface_FWD_DEFINED__ */


#ifndef __IControlChangeNotify_FWD_DEFINED__
#define __IControlChangeNotify_FWD_DEFINED__
typedef interface IControlChangeNotify IControlChangeNotify;
#endif 	/* __IControlChangeNotify_FWD_DEFINED__ */


#ifndef __IDeviceTopology_FWD_DEFINED__
#define __IDeviceTopology_FWD_DEFINED__
typedef interface IDeviceTopology IDeviceTopology;
#endif 	/* __IDeviceTopology_FWD_DEFINED__ */


#ifndef __DeviceTopology_FWD_DEFINED__
#define __DeviceTopology_FWD_DEFINED__

#ifdef __cplusplus
typedef class DeviceTopology DeviceTopology;
#else
typedef struct DeviceTopology DeviceTopology;
#endif /* __cplusplus */

#endif 	/* __DeviceTopology_FWD_DEFINED__ */


#ifndef __IPartsList_FWD_DEFINED__
#define __IPartsList_FWD_DEFINED__
typedef interface IPartsList IPartsList;
#endif 	/* __IPartsList_FWD_DEFINED__ */


#ifndef __IPerChannelDbLevel_FWD_DEFINED__
#define __IPerChannelDbLevel_FWD_DEFINED__
typedef interface IPerChannelDbLevel IPerChannelDbLevel;
#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */


#ifndef __IAudioVolumeLevel_FWD_DEFINED__
#define __IAudioVolumeLevel_FWD_DEFINED__
typedef interface IAudioVolumeLevel IAudioVolumeLevel;
#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */


#ifndef __IAudioLoudness_FWD_DEFINED__
#define __IAudioLoudness_FWD_DEFINED__
typedef interface IAudioLoudness IAudioLoudness;
#endif 	/* __IAudioLoudness_FWD_DEFINED__ */


#ifndef __IAudioInputSelector_FWD_DEFINED__
#define __IAudioInputSelector_FWD_DEFINED__
typedef interface IAudioInputSelector IAudioInputSelector;
#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */


#ifndef __IAudioMute_FWD_DEFINED__
#define __IAudioMute_FWD_DEFINED__
typedef interface IAudioMute IAudioMute;
#endif 	/* __IAudioMute_FWD_DEFINED__ */


#ifndef __IAudioBass_FWD_DEFINED__
#define __IAudioBass_FWD_DEFINED__
typedef interface IAudioBass IAudioBass;
#endif 	/* __IAudioBass_FWD_DEFINED__ */


#ifndef __IAudioMidrange_FWD_DEFINED__
#define __IAudioMidrange_FWD_DEFINED__
typedef interface IAudioMidrange IAudioMidrange;
#endif 	/* __IAudioMidrange_FWD_DEFINED__ */


#ifndef __IAudioTreble_FWD_DEFINED__
#define __IAudioTreble_FWD_DEFINED__
typedef interface IAudioTreble IAudioTreble;
#endif 	/* __IAudioTreble_FWD_DEFINED__ */


#ifndef __IAudioAutoGainControl_FWD_DEFINED__
#define __IAudioAutoGainControl_FWD_DEFINED__
typedef interface IAudioAutoGainControl IAudioAutoGainControl;
#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */


#ifndef __IAudioOutputSelector_FWD_DEFINED__
#define __IAudioOutputSelector_FWD_DEFINED__
typedef interface IAudioOutputSelector IAudioOutputSelector;
#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */


#ifndef __IAudioPeakMeter_FWD_DEFINED__
#define __IAudioPeakMeter_FWD_DEFINED__
typedef interface IAudioPeakMeter IAudioPeakMeter;
#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */


#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
#define __IDeviceSpecificProperty_FWD_DEFINED__
typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */


#ifndef __IKsFormatSupport_FWD_DEFINED__
#define __IKsFormatSupport_FWD_DEFINED__
typedef interface IKsFormatSupport IKsFormatSupport;
#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "oaidl.h"
// (amalg) #include "ocidl.h"
// (amalg) #include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_devicetopology_0000_0000 */
/* [local] */ 

#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
//
//   Flag for clients of IControlChangeNotify::OnNotify to allow those clients to identify hardware initiated notifications
//
#define DEVTOPO_HARDWARE_INITIATED_EVENTCONTEXT 'draH'
/* E2C2E9DE-09B1-4B04-84E5-07931225EE04 */
DEFINE_GUID(EVENTCONTEXT_VOLUMESLIDER, 0xE2C2E9DE,0x09B1,0x4B04,0x84, 0xE5, 0x07, 0x93, 0x12, 0x25, 0xEE, 0x04);
#define _IKsControl_
// (amalg) #include "ks.h"
// (amalg) #include "ksmedia.h"
#ifndef _KS_
typedef /* [public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001
    {
    ULONG FormatSize;
    ULONG Flags;
    ULONG SampleSize;
    ULONG Reserved;
    GUID MajorFormat;
    GUID SubFormat;
    GUID Specifier;
    } 	KSDATAFORMAT;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001 *PKSDATAFORMAT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002
    {
    union 
        {
        struct 
            {
            GUID Set;
            ULONG Id;
            ULONG Flags;
            } 	;
        LONGLONG Alignment;
        } 	;
    } 	KSIDENTIFIER;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002 *PKSIDENTIFIER;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0005
    {	ePcxChanMap_FL_FR	= 0,
	ePcxChanMap_FC_LFE	= ( ePcxChanMap_FL_FR + 1 ) ,
	ePcxChanMap_BL_BR	= ( ePcxChanMap_FC_LFE + 1 ) ,
	ePcxChanMap_FLC_FRC	= ( ePcxChanMap_BL_BR + 1 ) ,
	ePcxChanMap_SL_SR	= ( ePcxChanMap_FLC_FRC + 1 ) ,
	ePcxChanMap_Unknown	= ( ePcxChanMap_SL_SR + 1 ) 
    } 	EChannelMapping;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0006
    {	eConnTypeUnknown	= 0,
	eConnTypeEighth	= ( eConnTypeUnknown + 1 ) ,
	eConnTypeQuarter	= ( eConnTypeEighth + 1 ) ,
	eConnTypeAtapiInternal	= ( eConnTypeQuarter + 1 ) ,
	eConnTypeRCA	= ( eConnTypeAtapiInternal + 1 ) ,
	eConnTypeOptical	= ( eConnTypeRCA + 1 ) ,
	eConnTypeOtherDigital	= ( eConnTypeOptical + 1 ) ,
	eConnTypeOtherAnalog	= ( eConnTypeOtherDigital + 1 ) ,
	eConnTypeMultichannelAnalogDIN	= ( eConnTypeOtherAnalog + 1 ) ,
	eConnTypeXlrProfessional	= ( eConnTypeMultichannelAnalogDIN + 1 ) ,
	eConnTypeRJ11Modem	= ( eConnTypeXlrProfessional + 1 ) ,
	eConnTypeCombination	= ( eConnTypeRJ11Modem + 1 ) 
    } 	EPcxConnectionType;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0007
    {	eGeoLocRear	= 0x1,
	eGeoLocFront	= ( eGeoLocRear + 1 ) ,
	eGeoLocLeft	= ( eGeoLocFront + 1 ) ,
	eGeoLocRight	= ( eGeoLocLeft + 1 ) ,
	eGeoLocTop	= ( eGeoLocRight + 1 ) ,
	eGeoLocBottom	= ( eGeoLocTop + 1 ) ,
	eGeoLocRearOPanel	= ( eGeoLocBottom + 1 ) ,
	eGeoLocRiser	= ( eGeoLocRearOPanel + 1 ) ,
	eGeoLocInsideMobileLid	= ( eGeoLocRiser + 1 ) ,
	eGeoLocDrivebay	= ( eGeoLocInsideMobileLid + 1 ) ,
	eGeoLocHDMI	= ( eGeoLocDrivebay + 1 ) ,
	eGeoLocOutsideMobileLid	= ( eGeoLocHDMI + 1 ) ,
	eGeoLocATAPI	= ( eGeoLocOutsideMobileLid + 1 ) ,
	eGeoLocReserved5	= ( eGeoLocATAPI + 1 ) ,
	eGeoLocReserved6	= ( eGeoLocReserved5 + 1 ) 
    } 	EPcxGeoLocation;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0008
    {	eGenLocPrimaryBox	= 0,
	eGenLocInternal	= ( eGenLocPrimaryBox + 1 ) ,
	eGenLocSeperate	= ( eGenLocInternal + 1 ) ,
	eGenLocOther	= ( eGenLocSeperate + 1 ) 
    } 	EPcxGenLocation;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0009
    {	ePortConnJack	= 0,
	ePortConnIntegratedDevice	= ( ePortConnJack + 1 ) ,
	ePortConnBothIntegratedAndJack	= ( ePortConnIntegratedDevice + 1 ) ,
	ePortConnUnknown	= ( ePortConnBothIntegratedAndJack + 1 ) 
    } 	EPxcPortConnection;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010
    {
    EChannelMapping ChannelMapping;
    COLORREF Color;
    EPcxConnectionType ConnectionType;
    EPcxGeoLocation GeoLocation;
    EPcxGenLocation GenLocation;
    EPxcPortConnection PortConnection;
    BOOL IsConnected;
    } 	KSJACK_DESCRIPTION;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010 *PKSJACK_DESCRIPTION;

typedef KSIDENTIFIER KSPROPERTY;

typedef KSIDENTIFIER *PKSPROPERTY;

typedef KSIDENTIFIER KSMETHOD;

typedef KSIDENTIFIER *PKSMETHOD;

typedef KSIDENTIFIER KSEVENT;

typedef KSIDENTIFIER *PKSEVENT;

#endif








typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0011
    {	In	= 0,
	Out	= ( In + 1 ) 
    } 	DataFlow;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0012
    {	Connector	= 0,
	Subunit	= ( Connector + 1 ) 
    } 	PartType;

#define PARTTYPE_FLAG_CONNECTOR 0x00010000
#define PARTTYPE_FLAG_SUBUNIT   0x00020000
#define PARTTYPE_MASK           0x00030000
#define PARTID_MASK             0x0000ffff
typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0013
    {	Unknown_Connector	= 0,
	Physical_Internal	= ( Unknown_Connector + 1 ) ,
	Physical_External	= ( Physical_Internal + 1 ) ,
	Software_IO	= ( Physical_External + 1 ) ,
	Software_Fixed	= ( Software_IO + 1 ) ,
	Network	= ( Software_Fixed + 1 ) 
    } 	ConnectorType;



extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_s_ifspec;

#ifndef __IKsControl_INTERFACE_DEFINED__
#define __IKsControl_INTERFACE_DEFINED__

/* interface IKsControl */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28F54685-06FD-11D2-B27A-00A0C9223196")
    IKsControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE KsProperty( 
            /* [in] */ PKSPROPERTY Property,
            /* [in] */ ULONG PropertyLength,
            /* [out][in] */ void *PropertyData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KsMethod( 
            /* [in] */ PKSMETHOD Method,
            /* [in] */ ULONG MethodLength,
            /* [out][in] */ void *MethodData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KsEvent( 
            /* [in] */ PKSEVENT Event,
            /* [in] */ ULONG EventLength,
            /* [out][in] */ void *EventData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *KsProperty )( 
            IKsControl * This,
            /* [in] */ PKSPROPERTY Property,
            /* [in] */ ULONG PropertyLength,
            /* [out][in] */ void *PropertyData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *KsMethod )( 
            IKsControl * This,
            /* [in] */ PKSMETHOD Method,
            /* [in] */ ULONG MethodLength,
            /* [out][in] */ void *MethodData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *KsEvent )( 
            IKsControl * This,
            /* [in] */ PKSEVENT Event,
            /* [in] */ ULONG EventLength,
            /* [out][in] */ void *EventData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        END_INTERFACE
    } IKsControlVtbl;

    interface IKsControl
    {
        CONST_VTBL struct IKsControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsControl_KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned) ) 

#define IKsControl_KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned) ) 

#define IKsControl_KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsControl_INTERFACE_DEFINED__ */


#ifndef __IPerChannelDbLevel_INTERFACE_DEFINED__
#define __IPerChannelDbLevel_INTERFACE_DEFINED__

/* interface IPerChannelDbLevel */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IPerChannelDbLevel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C2F8E001-F205-4BC9-99BC-C13B1E048CCB")
    IPerChannelDbLevel : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pcChannels) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevelRange( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelUniform( 
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelAllChannels( 
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerChannelDbLevelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPerChannelDbLevel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPerChannelDbLevel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPerChannelDbLevel * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IPerChannelDbLevel * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IPerChannelDbLevel * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IPerChannelDbLevelVtbl;

    interface IPerChannelDbLevel
    {
        CONST_VTBL struct IPerChannelDbLevelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerChannelDbLevel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPerChannelDbLevel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPerChannelDbLevel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPerChannelDbLevel_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IPerChannelDbLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IPerChannelDbLevel_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IPerChannelDbLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IPerChannelDbLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IPerChannelDbLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPerChannelDbLevel_INTERFACE_DEFINED__ */


#ifndef __IAudioVolumeLevel_INTERFACE_DEFINED__
#define __IAudioVolumeLevel_INTERFACE_DEFINED__

/* interface IAudioVolumeLevel */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioVolumeLevel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FB7B48F-531D-44A2-BCB3-5AD5A134B3DC")
    IAudioVolumeLevel : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioVolumeLevelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioVolumeLevel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioVolumeLevel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioVolumeLevel * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioVolumeLevel * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioVolumeLevel * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioVolumeLevelVtbl;

    interface IAudioVolumeLevel
    {
        CONST_VTBL struct IAudioVolumeLevelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioVolumeLevel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioVolumeLevel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioVolumeLevel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioVolumeLevel_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioVolumeLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioVolumeLevel_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioVolumeLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioVolumeLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioVolumeLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioVolumeLevel_INTERFACE_DEFINED__ */


#ifndef __IAudioChannelConfig_INTERFACE_DEFINED__
#define __IAudioChannelConfig_INTERFACE_DEFINED__

/* interface IAudioChannelConfig */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioChannelConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB11C46F-EC28-493C-B88A-5DB88062CE98")
    IAudioChannelConfig : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetChannelConfig( 
            /* [in] */ DWORD dwConfig,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelConfig( 
            /* [retval][out] */ DWORD *pdwConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioChannelConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioChannelConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioChannelConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioChannelConfig * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetChannelConfig )( 
            IAudioChannelConfig * This,
            /* [in] */ DWORD dwConfig,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelConfig )( 
            IAudioChannelConfig * This,
            /* [retval][out] */ DWORD *pdwConfig);
        
        END_INTERFACE
    } IAudioChannelConfigVtbl;

    interface IAudioChannelConfig
    {
        CONST_VTBL struct IAudioChannelConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioChannelConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioChannelConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioChannelConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioChannelConfig_SetChannelConfig(This,dwConfig,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelConfig(This,dwConfig,pguidEventContext) ) 

#define IAudioChannelConfig_GetChannelConfig(This,pdwConfig)	\
    ( (This)->lpVtbl -> GetChannelConfig(This,pdwConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioChannelConfig_INTERFACE_DEFINED__ */


#ifndef __IAudioLoudness_INTERFACE_DEFINED__
#define __IAudioLoudness_INTERFACE_DEFINED__

/* interface IAudioLoudness */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioLoudness;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D8B1437-DD53-4350-9C1B-1EE2890BD938")
    IAudioLoudness : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioLoudnessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioLoudness * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioLoudness * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioLoudness * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IAudioLoudness * This,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IAudioLoudness * This,
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioLoudnessVtbl;

    interface IAudioLoudness
    {
        CONST_VTBL struct IAudioLoudnessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioLoudness_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioLoudness_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioLoudness_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioLoudness_GetEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 

#define IAudioLoudness_SetEnabled(This,bEnable,pguidEventContext)	\
    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioLoudness_INTERFACE_DEFINED__ */


#ifndef __IAudioInputSelector_INTERFACE_DEFINED__
#define __IAudioInputSelector_INTERFACE_DEFINED__

/* interface IAudioInputSelector */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioInputSelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F03DC02-5E6E-4653-8F72-A030C123D598")
    IAudioInputSelector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [out] */ 
            __out  UINT *pnIdSelected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioInputSelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioInputSelector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioInputSelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioInputSelector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            IAudioInputSelector * This,
            /* [out] */ 
            __out  UINT *pnIdSelected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            IAudioInputSelector * This,
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioInputSelectorVtbl;

    interface IAudioInputSelector
    {
        CONST_VTBL struct IAudioInputSelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioInputSelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioInputSelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioInputSelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioInputSelector_GetSelection(This,pnIdSelected)	\
    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 

#define IAudioInputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioInputSelector_INTERFACE_DEFINED__ */


#ifndef __IAudioOutputSelector_INTERFACE_DEFINED__
#define __IAudioOutputSelector_INTERFACE_DEFINED__

/* interface IAudioOutputSelector */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioOutputSelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB515F69-94A7-429e-8B9C-271B3F11A3AB")
    IAudioOutputSelector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [out] */ 
            __out  UINT *pnIdSelected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioOutputSelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioOutputSelector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioOutputSelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioOutputSelector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            IAudioOutputSelector * This,
            /* [out] */ 
            __out  UINT *pnIdSelected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            IAudioOutputSelector * This,
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioOutputSelectorVtbl;

    interface IAudioOutputSelector
    {
        CONST_VTBL struct IAudioOutputSelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioOutputSelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioOutputSelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioOutputSelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioOutputSelector_GetSelection(This,pnIdSelected)	\
    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 

#define IAudioOutputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioOutputSelector_INTERFACE_DEFINED__ */


#ifndef __IAudioMute_INTERFACE_DEFINED__
#define __IAudioMute_INTERFACE_DEFINED__

/* interface IAudioMute */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF45AEEA-B74A-4B6B-AFAD-2366B6AA012E")
    IAudioMute : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMute( 
            /* [in] */ 
            __in  BOOL bMuted,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMute( 
            /* [out] */ 
            __out  BOOL *pbMuted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMuteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMute * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
            IAudioMute * This,
            /* [in] */ 
            __in  BOOL bMuted,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
            IAudioMute * This,
            /* [out] */ 
            __out  BOOL *pbMuted);
        
        END_INTERFACE
    } IAudioMuteVtbl;

    interface IAudioMute
    {
        CONST_VTBL struct IAudioMuteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMute_SetMute(This,bMuted,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMute(This,bMuted,pguidEventContext) ) 

#define IAudioMute_GetMute(This,pbMuted)	\
    ( (This)->lpVtbl -> GetMute(This,pbMuted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMute_INTERFACE_DEFINED__ */


#ifndef __IAudioBass_INTERFACE_DEFINED__
#define __IAudioBass_INTERFACE_DEFINED__

/* interface IAudioBass */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioBass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2B1A1D9-4DB3-425D-A2B2-BD335CB3E2E5")
    IAudioBass : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioBassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioBass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioBass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioBass * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioBass * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioBass * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioBass * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioBassVtbl;

    interface IAudioBass
    {
        CONST_VTBL struct IAudioBassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioBass_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioBass_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioBass_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioBass_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioBass_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioBass_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioBass_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioBass_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioBass_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioBass_INTERFACE_DEFINED__ */


#ifndef __IAudioMidrange_INTERFACE_DEFINED__
#define __IAudioMidrange_INTERFACE_DEFINED__

/* interface IAudioMidrange */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMidrange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E54B6D7-B44B-40D9-9A9E-E691D9CE6EDF")
    IAudioMidrange : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioMidrangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMidrange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMidrange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMidrange * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioMidrange * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioMidrange * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioMidrangeVtbl;

    interface IAudioMidrange
    {
        CONST_VTBL struct IAudioMidrangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMidrange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMidrange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMidrange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMidrange_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioMidrange_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioMidrange_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioMidrange_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioMidrange_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioMidrange_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMidrange_INTERFACE_DEFINED__ */


#ifndef __IAudioTreble_INTERFACE_DEFINED__
#define __IAudioTreble_INTERFACE_DEFINED__

/* interface IAudioTreble */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioTreble;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A717812-694E-4907-B74B-BAFA5CFDCA7B")
    IAudioTreble : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioTrebleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioTreble * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioTreble * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioTreble * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioTreble * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioTreble * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioTrebleVtbl;

    interface IAudioTreble
    {
        CONST_VTBL struct IAudioTrebleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioTreble_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioTreble_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioTreble_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioTreble_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioTreble_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioTreble_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioTreble_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioTreble_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioTreble_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioTreble_INTERFACE_DEFINED__ */


#ifndef __IAudioAutoGainControl_INTERFACE_DEFINED__
#define __IAudioAutoGainControl_INTERFACE_DEFINED__

/* interface IAudioAutoGainControl */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioAutoGainControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85401FD4-6DE4-4b9d-9869-2D6753A82F3C")
    IAudioAutoGainControl : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioAutoGainControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioAutoGainControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioAutoGainControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioAutoGainControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IAudioAutoGainControl * This,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IAudioAutoGainControl * This,
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioAutoGainControlVtbl;

    interface IAudioAutoGainControl
    {
        CONST_VTBL struct IAudioAutoGainControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioAutoGainControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioAutoGainControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioAutoGainControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioAutoGainControl_GetEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 

#define IAudioAutoGainControl_SetEnabled(This,bEnable,pguidEventContext)	\
    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioAutoGainControl_INTERFACE_DEFINED__ */


#ifndef __IAudioPeakMeter_INTERFACE_DEFINED__
#define __IAudioPeakMeter_INTERFACE_DEFINED__

/* interface IAudioPeakMeter */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioPeakMeter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD79923C-0599-45e0-B8B6-C8DF7DB6E796")
    IAudioPeakMeter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pcChannels) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioPeakMeterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioPeakMeter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioPeakMeter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioPeakMeter * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioPeakMeter * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioPeakMeter * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel);
        
        END_INTERFACE
    } IAudioPeakMeterVtbl;

    interface IAudioPeakMeter
    {
        CONST_VTBL struct IAudioPeakMeterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioPeakMeter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioPeakMeter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioPeakMeter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioPeakMeter_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioPeakMeter_GetLevel(This,nChannel,pfLevel)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioPeakMeter_INTERFACE_DEFINED__ */


#ifndef __IDeviceSpecificProperty_INTERFACE_DEFINED__
#define __IDeviceSpecificProperty_INTERFACE_DEFINED__

/* interface IDeviceSpecificProperty */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IDeviceSpecificProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B22BCBF-2586-4af0-8583-205D391B807C")
    IDeviceSpecificProperty : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ 
            __deref_out  VARTYPE *pVType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ 
            __out  void *pvValue,
            /* [out][in] */ 
            __inout  DWORD *pcbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ 
            __in  void *pvValue,
            /* [in] */ DWORD cbValue,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get4BRange( 
            /* [out] */ 
            __deref_out  LONG *plMin,
            /* [out] */ 
            __deref_out  LONG *plMax,
            /* [out] */ 
            __deref_out  LONG *plStepping) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceSpecificPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceSpecificProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceSpecificProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceSpecificProperty * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __deref_out  VARTYPE *pVType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __out  void *pvValue,
            /* [out][in] */ 
            __inout  DWORD *pcbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IDeviceSpecificProperty * This,
            /* [in] */ 
            __in  void *pvValue,
            /* [in] */ DWORD cbValue,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get4BRange )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __deref_out  LONG *plMin,
            /* [out] */ 
            __deref_out  LONG *plMax,
            /* [out] */ 
            __deref_out  LONG *plStepping);
        
        END_INTERFACE
    } IDeviceSpecificPropertyVtbl;

    interface IDeviceSpecificProperty
    {
        CONST_VTBL struct IDeviceSpecificPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceSpecificProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeviceSpecificProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeviceSpecificProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeviceSpecificProperty_GetType(This,pVType)	\
    ( (This)->lpVtbl -> GetType(This,pVType) ) 

#define IDeviceSpecificProperty_GetValue(This,pvValue,pcbValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue,pcbValue) ) 

#define IDeviceSpecificProperty_SetValue(This,pvValue,cbValue,pguidEventContext)	\
    ( (This)->lpVtbl -> SetValue(This,pvValue,cbValue,pguidEventContext) ) 

#define IDeviceSpecificProperty_Get4BRange(This,plMin,plMax,plStepping)	\
    ( (This)->lpVtbl -> Get4BRange(This,plMin,plMax,plStepping) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceSpecificProperty_INTERFACE_DEFINED__ */


#ifndef __IKsFormatSupport_INTERFACE_DEFINED__
#define __IKsFormatSupport_INTERFACE_DEFINED__

/* interface IKsFormatSupport */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsFormatSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CB4A69D-BB6F-4D2B-95B7-452D2C155DB5")
    IKsFormatSupport : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
            /* [in] */ 
            __in  DWORD cbFormat,
            /* [out] */ 
            __out  BOOL *pbSupported) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevicePreferredFormat( 
            /* [out] */ PKSDATAFORMAT *ppKsFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsFormatSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsFormatSupport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsFormatSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsFormatSupport * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IKsFormatSupport * This,
            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
            /* [in] */ 
            __in  DWORD cbFormat,
            /* [out] */ 
            __out  BOOL *pbSupported);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevicePreferredFormat )( 
            IKsFormatSupport * This,
            /* [out] */ PKSDATAFORMAT *ppKsFormat);
        
        END_INTERFACE
    } IKsFormatSupportVtbl;

    interface IKsFormatSupport
    {
        CONST_VTBL struct IKsFormatSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsFormatSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsFormatSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsFormatSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsFormatSupport_IsFormatSupported(This,pKsFormat,cbFormat,pbSupported)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pKsFormat,cbFormat,pbSupported) ) 

#define IKsFormatSupport_GetDevicePreferredFormat(This,ppKsFormat)	\
    ( (This)->lpVtbl -> GetDevicePreferredFormat(This,ppKsFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsFormatSupport_INTERFACE_DEFINED__ */


#ifndef __IKsJackDescription_INTERFACE_DEFINED__
#define __IKsJackDescription_INTERFACE_DEFINED__

/* interface IKsJackDescription */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsJackDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4509F757-2D46-4637-8E62-CE7DB944F57B")
    IKsJackDescription : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackCount( 
            /* [out] */ 
            __out  UINT *pcJacks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackDescription( 
            /* [in] */ UINT nJack,
            /* [out] */ 
            __out  KSJACK_DESCRIPTION *pDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsJackDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsJackDescription * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsJackDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsJackDescription * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackCount )( 
            IKsJackDescription * This,
            /* [out] */ 
            __out  UINT *pcJacks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackDescription )( 
            IKsJackDescription * This,
            /* [in] */ UINT nJack,
            /* [out] */ 
            __out  KSJACK_DESCRIPTION *pDescription);
        
        END_INTERFACE
    } IKsJackDescriptionVtbl;

    interface IKsJackDescription
    {
        CONST_VTBL struct IKsJackDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsJackDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsJackDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsJackDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsJackDescription_GetJackCount(This,pcJacks)	\
    ( (This)->lpVtbl -> GetJackCount(This,pcJacks) ) 

#define IKsJackDescription_GetJackDescription(This,nJack,pDescription)	\
    ( (This)->lpVtbl -> GetJackDescription(This,nJack,pDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsJackDescription_INTERFACE_DEFINED__ */


#ifndef __IPartsList_INTERFACE_DEFINED__
#define __IPartsList_INTERFACE_DEFINED__

/* interface IPartsList */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IPartsList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DAA848C-5EB0-45CC-AEA5-998A2CDA1FFB")
    IPartsList : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPart( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IPart **ppPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartsListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartsList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartsList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartsList * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPartsList * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPart )( 
            IPartsList * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IPart **ppPart);
        
        END_INTERFACE
    } IPartsListVtbl;

    interface IPartsList
    {
        CONST_VTBL struct IPartsListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartsList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartsList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartsList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartsList_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define IPartsList_GetPart(This,nIndex,ppPart)	\
    ( (This)->lpVtbl -> GetPart(This,nIndex,ppPart) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartsList_INTERFACE_DEFINED__ */


#ifndef __IPart_INTERFACE_DEFINED__
#define __IPart_INTERFACE_DEFINED__

/* interface IPart */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IPart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9")
    IPart : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalId( 
            /* [out] */ 
            __out  UINT *pnId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGlobalId( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrGlobalId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartType( 
            /* [out] */ 
            __out  PartType *pPartType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubType( 
            /* [out] */ GUID *pSubType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterfaceCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterface( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IControlInterface **ppInterfaceDesc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsIncoming( 
            /* [out] */ 
            __out  IPartsList **ppParts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsOutgoing( 
            /* [out] */ 
            __out  IPartsList **ppParts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTopologyObject( 
            /* [out] */ 
            __out  IDeviceTopology **ppTopology) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ 
            __in  DWORD dwClsContext,
            /* [in] */ 
            __in  REFIID refiid,
            /* [iid_is][out] */ 
            __out_opt  void **ppvObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeCallback( 
            /* [in] */ 
            __in  REFGUID riid,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeCallback( 
            /* [in] */ 
            __in  IControlChangeNotify *pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPart * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IPart * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalId )( 
            IPart * This,
            /* [out] */ 
            __out  UINT *pnId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGlobalId )( 
            IPart * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrGlobalId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartType )( 
            IPart * This,
            /* [out] */ 
            __out  PartType *pPartType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubType )( 
            IPart * This,
            /* [out] */ GUID *pSubType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterfaceCount )( 
            IPart * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
            IPart * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IControlInterface **ppInterfaceDesc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsIncoming )( 
            IPart * This,
            /* [out] */ 
            __out  IPartsList **ppParts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsOutgoing )( 
            IPart * This,
            /* [out] */ 
            __out  IPartsList **ppParts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTopologyObject )( 
            IPart * This,
            /* [out] */ 
            __out  IDeviceTopology **ppTopology);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IPart * This,
            /* [in] */ 
            __in  DWORD dwClsContext,
            /* [in] */ 
            __in  REFIID refiid,
            /* [iid_is][out] */ 
            __out_opt  void **ppvObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeCallback )( 
            IPart * This,
            /* [in] */ 
            __in  REFGUID riid,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeCallback )( 
            IPart * This,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify);
        
        END_INTERFACE
    } IPartVtbl;

    interface IPart
    {
        CONST_VTBL struct IPartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPart_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPart_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPart_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPart_GetName(This,ppwstrName)	\
    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 

#define IPart_GetLocalId(This,pnId)	\
    ( (This)->lpVtbl -> GetLocalId(This,pnId) ) 

#define IPart_GetGlobalId(This,ppwstrGlobalId)	\
    ( (This)->lpVtbl -> GetGlobalId(This,ppwstrGlobalId) ) 

#define IPart_GetPartType(This,pPartType)	\
    ( (This)->lpVtbl -> GetPartType(This,pPartType) ) 

#define IPart_GetSubType(This,pSubType)	\
    ( (This)->lpVtbl -> GetSubType(This,pSubType) ) 

#define IPart_GetControlInterfaceCount(This,pCount)	\
    ( (This)->lpVtbl -> GetControlInterfaceCount(This,pCount) ) 

#define IPart_GetControlInterface(This,nIndex,ppInterfaceDesc)	\
    ( (This)->lpVtbl -> GetControlInterface(This,nIndex,ppInterfaceDesc) ) 

#define IPart_EnumPartsIncoming(This,ppParts)	\
    ( (This)->lpVtbl -> EnumPartsIncoming(This,ppParts) ) 

#define IPart_EnumPartsOutgoing(This,ppParts)	\
    ( (This)->lpVtbl -> EnumPartsOutgoing(This,ppParts) ) 

#define IPart_GetTopologyObject(This,ppTopology)	\
    ( (This)->lpVtbl -> GetTopologyObject(This,ppTopology) ) 

#define IPart_Activate(This,dwClsContext,refiid,ppvObject)	\
    ( (This)->lpVtbl -> Activate(This,dwClsContext,refiid,ppvObject) ) 

#define IPart_RegisterControlChangeCallback(This,riid,pNotify)	\
    ( (This)->lpVtbl -> RegisterControlChangeCallback(This,riid,pNotify) ) 

#define IPart_UnregisterControlChangeCallback(This,pNotify)	\
    ( (This)->lpVtbl -> UnregisterControlChangeCallback(This,pNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPart_INTERFACE_DEFINED__ */


#ifndef __IConnector_INTERFACE_DEFINED__
#define __IConnector_INTERFACE_DEFINED__

/* interface IConnector */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c2c4058-23f5-41de-877a-df3af236a09e")
    IConnector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ 
            __out  ConnectorType *pType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
            /* [out] */ 
            __out  DataFlow *pFlow) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectTo( 
            /* [in] */ 
            __in  IConnector *pConnectTo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsConnected( 
            /* [out] */ 
            __out  BOOL *pbConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectedTo( 
            /* [out] */ 
            __out  IConnector **ppConTo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorIdConnectedTo( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrConnectorId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceIdConnectedTo( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IConnector * This,
            /* [out] */ 
            __out  ConnectorType *pType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
            IConnector * This,
            /* [out] */ 
            __out  DataFlow *pFlow);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectTo )( 
            IConnector * This,
            /* [in] */ 
            __in  IConnector *pConnectTo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IConnector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
            IConnector * This,
            /* [out] */ 
            __out  BOOL *pbConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __out  IConnector **ppConTo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorIdConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrConnectorId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceIdConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId);
        
        END_INTERFACE
    } IConnectorVtbl;

    interface IConnector
    {
        CONST_VTBL struct IConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConnector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConnector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConnector_GetType(This,pType)	\
    ( (This)->lpVtbl -> GetType(This,pType) ) 

#define IConnector_GetDataFlow(This,pFlow)	\
    ( (This)->lpVtbl -> GetDataFlow(This,pFlow) ) 

#define IConnector_ConnectTo(This,pConnectTo)	\
    ( (This)->lpVtbl -> ConnectTo(This,pConnectTo) ) 

#define IConnector_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IConnector_IsConnected(This,pbConnected)	\
    ( (This)->lpVtbl -> IsConnected(This,pbConnected) ) 

#define IConnector_GetConnectedTo(This,ppConTo)	\
    ( (This)->lpVtbl -> GetConnectedTo(This,ppConTo) ) 

#define IConnector_GetConnectorIdConnectedTo(This,ppwstrConnectorId)	\
    ( (This)->lpVtbl -> GetConnectorIdConnectedTo(This,ppwstrConnectorId) ) 

#define IConnector_GetDeviceIdConnectedTo(This,ppwstrDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceIdConnectedTo(This,ppwstrDeviceId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConnector_INTERFACE_DEFINED__ */


#ifndef __ISubunit_INTERFACE_DEFINED__
#define __ISubunit_INTERFACE_DEFINED__

/* interface ISubunit */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_ISubunit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82149A85-DBA6-4487-86BB-EA8F7FEFCC71")
    ISubunit : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISubunitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubunit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubunit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubunit * This);
        
        END_INTERFACE
    } ISubunitVtbl;

    interface ISubunit
    {
        CONST_VTBL struct ISubunitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubunit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubunit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubunit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubunit_INTERFACE_DEFINED__ */


#ifndef __IControlInterface_INTERFACE_DEFINED__
#define __IControlInterface_INTERFACE_DEFINED__

/* interface IControlInterface */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IControlInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45d37c3f-5140-444a-ae24-400789f3cbf3")
    IControlInterface : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIID( 
            /* [out] */ 
            __out  GUID *pIID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlInterface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlInterface * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IControlInterface * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIID )( 
            IControlInterface * This,
            /* [out] */ 
            __out  GUID *pIID);
        
        END_INTERFACE
    } IControlInterfaceVtbl;

    interface IControlInterface
    {
        CONST_VTBL struct IControlInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlInterface_GetName(This,ppwstrName)	\
    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 

#define IControlInterface_GetIID(This,pIID)	\
    ( (This)->lpVtbl -> GetIID(This,pIID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlInterface_INTERFACE_DEFINED__ */


#ifndef __IControlChangeNotify_INTERFACE_DEFINED__
#define __IControlChangeNotify_INTERFACE_DEFINED__

/* interface IControlChangeNotify */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IControlChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A09513ED-C709-4d21-BD7B-5F34C47F3947")
    IControlChangeNotify : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [in] */ 
            __in  DWORD dwSenderProcessId,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlChangeNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlChangeNotify * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            IControlChangeNotify * This,
            /* [in] */ 
            __in  DWORD dwSenderProcessId,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IControlChangeNotifyVtbl;

    interface IControlChangeNotify
    {
        CONST_VTBL struct IControlChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlChangeNotify_OnNotify(This,dwSenderProcessId,pguidEventContext)	\
    ( (This)->lpVtbl -> OnNotify(This,dwSenderProcessId,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlChangeNotify_INTERFACE_DEFINED__ */


#ifndef __IDeviceTopology_INTERFACE_DEFINED__
#define __IDeviceTopology_INTERFACE_DEFINED__

/* interface IDeviceTopology */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IDeviceTopology;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A07407E-6497-4A18-9787-32F79BD0D98F")
    IDeviceTopology : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnector( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IConnector **ppConnector) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunitCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunit( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __deref_out  ISubunit **ppSubunit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartById( 
            /* [in] */ 
            __in  UINT nId,
            /* [out] */ 
            __deref_out  IPart **ppPart) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceId( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalPath( 
            /* [in] */ 
            __in  IPart *pIPartFrom,
            /* [in] */ 
            __in  IPart *pIPartTo,
            /* [in] */ 
            __in  BOOL bRejectMixedPaths,
            /* [out] */ 
            __deref_out  IPartsList **ppParts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceTopologyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceTopology * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceTopology * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceTopology * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorCount )( 
            IDeviceTopology * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnector )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IConnector **ppConnector);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunitCount )( 
            IDeviceTopology * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunit )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __deref_out  ISubunit **ppSubunit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartById )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nId,
            /* [out] */ 
            __deref_out  IPart **ppPart);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
            IDeviceTopology * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalPath )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  IPart *pIPartFrom,
            /* [in] */ 
            __in  IPart *pIPartTo,
            /* [in] */ 
            __in  BOOL bRejectMixedPaths,
            /* [out] */ 
            __deref_out  IPartsList **ppParts);
        
        END_INTERFACE
    } IDeviceTopologyVtbl;

    interface IDeviceTopology
    {
        CONST_VTBL struct IDeviceTopologyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceTopology_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeviceTopology_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeviceTopology_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeviceTopology_GetConnectorCount(This,pCount)	\
    ( (This)->lpVtbl -> GetConnectorCount(This,pCount) ) 

#define IDeviceTopology_GetConnector(This,nIndex,ppConnector)	\
    ( (This)->lpVtbl -> GetConnector(This,nIndex,ppConnector) ) 

#define IDeviceTopology_GetSubunitCount(This,pCount)	\
    ( (This)->lpVtbl -> GetSubunitCount(This,pCount) ) 

#define IDeviceTopology_GetSubunit(This,nIndex,ppSubunit)	\
    ( (This)->lpVtbl -> GetSubunit(This,nIndex,ppSubunit) ) 

#define IDeviceTopology_GetPartById(This,nId,ppPart)	\
    ( (This)->lpVtbl -> GetPartById(This,nId,ppPart) ) 

#define IDeviceTopology_GetDeviceId(This,ppwstrDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceId(This,ppwstrDeviceId) ) 

#define IDeviceTopology_GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts)	\
    ( (This)->lpVtbl -> GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceTopology_INTERFACE_DEFINED__ */



#ifndef __DevTopologyLib_LIBRARY_DEFINED__
#define __DevTopologyLib_LIBRARY_DEFINED__

/* library DevTopologyLib */
/* [helpstring][version][uuid] */ 
















EXTERN_C const IID LIBID_DevTopologyLib;

EXTERN_C const CLSID CLSID_DeviceTopology;

#ifdef __cplusplus

class DECLSPEC_UUID("1DF639D0-5EC1-47AA-9379-828DC1AA8C59")
DeviceTopology;
#endif
#endif /* __DevTopologyLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif





/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for endpointvolume.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __endpointvolume_h__
#define __endpointvolume_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAudioEndpointVolumeCallback_FWD_DEFINED__
#define __IAudioEndpointVolumeCallback_FWD_DEFINED__
typedef interface IAudioEndpointVolumeCallback IAudioEndpointVolumeCallback;
#endif 	/* __IAudioEndpointVolumeCallback_FWD_DEFINED__ */


#ifndef __IAudioEndpointVolume_FWD_DEFINED__
#define __IAudioEndpointVolume_FWD_DEFINED__
typedef interface IAudioEndpointVolume IAudioEndpointVolume;
#endif 	/* __IAudioEndpointVolume_FWD_DEFINED__ */


#ifndef __IAudioMeterInformation_FWD_DEFINED__
#define __IAudioMeterInformation_FWD_DEFINED__
typedef interface IAudioMeterInformation IAudioMeterInformation;
#endif 	/* __IAudioMeterInformation_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "unknwn.h"
// (amalg) #include "devicetopology.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_endpointvolume_0000_0000 */
/* [local] */ 

typedef struct AUDIO_VOLUME_NOTIFICATION_DATA
    {
    GUID guidEventContext;
    BOOL bMuted;
    float fMasterVolume;
    UINT nChannels;
    float afChannelVolumes[ 1 ];
    } 	AUDIO_VOLUME_NOTIFICATION_DATA;

typedef struct AUDIO_VOLUME_NOTIFICATION_DATA *PAUDIO_VOLUME_NOTIFICATION_DATA;

#define   ENDPOINT_HARDWARE_SUPPORT_VOLUME    0x00000001
#define   ENDPOINT_HARDWARE_SUPPORT_MUTE      0x00000002
#define   ENDPOINT_HARDWARE_SUPPORT_METER     0x00000004


extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_s_ifspec;

#ifndef __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
#define __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__

/* interface IAudioEndpointVolumeCallback */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioEndpointVolumeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("657804FA-D6AD-4496-8A60-352752AF4F89")
    IAudioEndpointVolumeCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNotify( 
            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioEndpointVolumeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioEndpointVolumeCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioEndpointVolumeCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioEndpointVolumeCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            IAudioEndpointVolumeCallback * This,
            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify);
        
        END_INTERFACE
    } IAudioEndpointVolumeCallbackVtbl;

    interface IAudioEndpointVolumeCallback
    {
        CONST_VTBL struct IAudioEndpointVolumeCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioEndpointVolumeCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioEndpointVolumeCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioEndpointVolumeCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioEndpointVolumeCallback_OnNotify(This,pNotify)	\
    ( (This)->lpVtbl -> OnNotify(This,pNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__ */


#ifndef __IAudioEndpointVolume_INTERFACE_DEFINED__
#define __IAudioEndpointVolume_INTERFACE_DEFINED__

/* interface IAudioEndpointVolume */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioEndpointVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CDF2C82-841E-4546-9722-0CF74078229A")
    IAudioEndpointVolume : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeNotify( 
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeNotify( 
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pnChannelCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevel( 
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevelScalar( 
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevel( 
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevelScalar( 
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevelScalar( 
            /* [in] */ 
            __in  UINT nChannel,
            float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevelScalar( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMute( 
            /* [in] */ 
            __in  BOOL bMute,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMute( 
            /* [out] */ 
            __out  BOOL *pbMute) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeStepInfo( 
            /* [out] */ 
            __out  UINT *pnStep,
            /* [out] */ 
            __out  UINT *pnStepCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepUp( 
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepDown( 
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeRange( 
            /* [out] */ 
            __out  float *pflVolumeMindB,
            /* [out] */ 
            __out  float *pflVolumeMaxdB,
            /* [out] */ 
            __out  float *pflVolumeIncrementdB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioEndpointVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioEndpointVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioEndpointVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioEndpointVolume * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeNotify )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeNotify )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  UINT *pnChannelCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pfLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  BOOL bMute,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  BOOL *pbMute);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeStepInfo )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  UINT *pnStep,
            /* [out] */ 
            __out  UINT *pnStepCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepUp )( 
            IAudioEndpointVolume * This,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepDown )( 
            IAudioEndpointVolume * This,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeRange )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pflVolumeMindB,
            /* [out] */ 
            __out  float *pflVolumeMaxdB,
            /* [out] */ 
            __out  float *pflVolumeIncrementdB);
        
        END_INTERFACE
    } IAudioEndpointVolumeVtbl;

    interface IAudioEndpointVolume
    {
        CONST_VTBL struct IAudioEndpointVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioEndpointVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioEndpointVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioEndpointVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioEndpointVolume_RegisterControlChangeNotify(This,pNotify)	\
    ( (This)->lpVtbl -> RegisterControlChangeNotify(This,pNotify) ) 

#define IAudioEndpointVolume_UnregisterControlChangeNotify(This,pNotify)	\
    ( (This)->lpVtbl -> UnregisterControlChangeNotify(This,pNotify) ) 

#define IAudioEndpointVolume_GetChannelCount(This,pnChannelCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pnChannelCount) ) 

#define IAudioEndpointVolume_SetMasterVolumeLevel(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMasterVolumeLevel(This,fLevelDB,pguidEventContext) ) 

#define IAudioEndpointVolume_SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext) ) 

#define IAudioEndpointVolume_GetMasterVolumeLevel(This,pfLevelDB)	\
    ( (This)->lpVtbl -> GetMasterVolumeLevel(This,pfLevelDB) ) 

#define IAudioEndpointVolume_GetMasterVolumeLevelScalar(This,pfLevel)	\
    ( (This)->lpVtbl -> GetMasterVolumeLevelScalar(This,pfLevel) ) 

#define IAudioEndpointVolume_SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioEndpointVolume_SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext) ) 

#define IAudioEndpointVolume_GetChannelVolumeLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetChannelVolumeLevel(This,nChannel,pfLevelDB) ) 

#define IAudioEndpointVolume_GetChannelVolumeLevelScalar(This,nChannel,pfLevel)	\
    ( (This)->lpVtbl -> GetChannelVolumeLevelScalar(This,nChannel,pfLevel) ) 

#define IAudioEndpointVolume_SetMute(This,bMute,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMute(This,bMute,pguidEventContext) ) 

#define IAudioEndpointVolume_GetMute(This,pbMute)	\
    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 

#define IAudioEndpointVolume_GetVolumeStepInfo(This,pnStep,pnStepCount)	\
    ( (This)->lpVtbl -> GetVolumeStepInfo(This,pnStep,pnStepCount) ) 

#define IAudioEndpointVolume_VolumeStepUp(This,pguidEventContext)	\
    ( (This)->lpVtbl -> VolumeStepUp(This,pguidEventContext) ) 

#define IAudioEndpointVolume_VolumeStepDown(This,pguidEventContext)	\
    ( (This)->lpVtbl -> VolumeStepDown(This,pguidEventContext) ) 

#define IAudioEndpointVolume_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 

#define IAudioEndpointVolume_GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB)	\
    ( (This)->lpVtbl -> GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioEndpointVolume_INTERFACE_DEFINED__ */


#ifndef __IAudioMeterInformation_INTERFACE_DEFINED__
#define __IAudioMeterInformation_INTERFACE_DEFINED__

/* interface IAudioMeterInformation */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMeterInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C02216F6-8C67-4B5B-9D00-D008E73E0064")
    IAudioMeterInformation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPeakValue( 
            /* [out] */ float *pfPeak) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMeteringChannelCount( 
            /* [out] */ 
            __out  UINT *pnChannelCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelsPeakValues( 
            /* [in] */ UINT32 u32ChannelCount,
            /* [size_is][out] */ float *afPeakValues) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMeterInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMeterInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMeterInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMeterInformation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPeakValue )( 
            IAudioMeterInformation * This,
            /* [out] */ float *pfPeak);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringChannelCount )( 
            IAudioMeterInformation * This,
            /* [out] */ 
            __out  UINT *pnChannelCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelsPeakValues )( 
            IAudioMeterInformation * This,
            /* [in] */ UINT32 u32ChannelCount,
            /* [size_is][out] */ float *afPeakValues);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
            IAudioMeterInformation * This,
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask);
        
        END_INTERFACE
    } IAudioMeterInformationVtbl;

    interface IAudioMeterInformation
    {
        CONST_VTBL struct IAudioMeterInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMeterInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMeterInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMeterInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMeterInformation_GetPeakValue(This,pfPeak)	\
    ( (This)->lpVtbl -> GetPeakValue(This,pfPeak) ) 

#define IAudioMeterInformation_GetMeteringChannelCount(This,pnChannelCount)	\
    ( (This)->lpVtbl -> GetMeteringChannelCount(This,pnChannelCount) ) 

#define IAudioMeterInformation_GetChannelsPeakValues(This,u32ChannelCount,afPeakValues)	\
    ( (This)->lpVtbl -> GetChannelsPeakValues(This,u32ChannelCount,afPeakValues) ) 

#define IAudioMeterInformation_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMeterInformation_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif



#pragma once

#if __GNUC__ >=3
#pragma GCC system_header
#endif

#ifndef DEFINE_API_PKEY
#include <propkey.h>
#endif

#include <FunctionDiscoveryKeys_devpkey.h>

// FMTID_FD = {904b03a2-471d-423c-a584-f3483238a146}
DEFINE_GUID(FMTID_FD, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46);
DEFINE_API_PKEY(PKEY_FD_Visibility, VisibilityFlags, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000001); //    VT_UINT
#define FD_Visibility_Default   0
#define FD_Visibility_Hidden    1

// FMTID_Device = {78C34FC8-104A-4aca-9EA4-524D52996E57}
DEFINE_GUID(FMTID_Device, 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57);

DEFINE_API_PKEY(PKEY_Device_NotPresent,     DeviceNotPresent   , 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000002); //    VT_UINT
DEFINE_API_PKEY(PKEY_Device_QueueSize,      DeviceQueueSize    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000024); //    VT_UI4
DEFINE_API_PKEY(PKEY_Device_Status,         DeviceStatus       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000025); //    VT_LPWSTR
DEFINE_API_PKEY(PKEY_Device_Comment,        DeviceComment      , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000026); //    VT_LPWSTR
DEFINE_API_PKEY(PKEY_Device_Model,          DeviceModel        , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000027); //    VT_LPWSTR

//  Name:     System.Device.BIOSVersion -- PKEY_Device_BIOSVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_BSTR.
//  FormatID: EAEE7F1D-6A33-44D1-9441-5F46DEF23198, 9
DEFINE_PROPERTYKEY(PKEY_Device_BIOSVersion, 0xEAEE7F1D, 0x6A33, 0x44D1, 0x94, 0x41, 0x5F, 0x46, 0xDE, 0xF2, 0x31, 0x98, 9);

DEFINE_API_PKEY(PKEY_Write_Time,            WriteTime          , 0xf53b7e1c, 0x77e0, 0x4450, 0x8c, 0x5f, 0xa7, 0x6c, 0xc7, 0xfd, 0xe0, 0x58, 0x00000100); //    VT_FILETIME

#ifdef FD_XP
DEFINE_API_PKEY(PKEY_Device_InstanceId, DeviceInstanceId   , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000100); //    VT_LPWSTR
#endif
DEFINE_API_PKEY(PKEY_Device_Interface,  DeviceInterface    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000101); //    VT_CLSID

DEFINE_API_PKEY(PKEY_ExposedIIDs,           ExposedIIDs       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003002); //  VT_VECTOR | VT_CLSID
DEFINE_API_PKEY(PKEY_ExposedCLSIDs,         ExposedCLSIDs     , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003003); //  VT_VECTOR | VT_CLSID
DEFINE_API_PKEY(PKEY_InstanceValidatorClsid,InstanceValidator , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003004); // VT_CLSID

// FMTID_WSD = {92506491-FF95-4724-A05A-5B81885A7C92}
DEFINE_GUID(FMTID_WSD, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92);

DEFINE_API_PKEY(PKEY_WSD_AddressURI, WSD_AddressURI, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001000);   // VT_LPWSTR
DEFINE_API_PKEY(PKEY_WSD_Types, WSD_Types, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001001); // VT_LPWSTR
DEFINE_API_PKEY(PKEY_WSD_Scopes, WSD_Scopes, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001002);   // VT_LPWSTR
DEFINE_API_PKEY(PKEY_WSD_MetadataVersion, WSD_MetadataVersion, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001003); //VT_UI8
DEFINE_API_PKEY(PKEY_WSD_AppSeqInstanceID, WSD_AppSeqInstanceID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001004);   // VT_UI8
DEFINE_API_PKEY(PKEY_WSD_AppSeqSessionID, WSD_AppSeqSessionID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001005); // VT_LPWSTR
DEFINE_API_PKEY(PKEY_WSD_AppSeqMessageNumber, WSD_AppSeqMessageNumber, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001006); // VT_UI8
DEFINE_API_PKEY(PKEY_WSD_XAddrs, WSD_XAddrs, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00002000); // VT_LPWSTR or VT_VECTOR | VT_LPWSTR

DEFINE_API_PKEY(PKEY_WSD_MetadataClean, WSD_MetadataClean, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000001);   // VT_BOOL
DEFINE_API_PKEY(PKEY_WSD_ServiceInfo, WSD_ServiceInfo, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000002);   // VT_VECTOR|VT_VARIANT (variants are VT_UNKNOWN)

DEFINE_API_PKEY(PKEY_PUBSVCS_TYPE, PUBSVCS_TYPE, 0xF1B88AD3, 0x109C, 0x4FD2, 0xBA, 0x3F, 0x53, 0x5A, 0x76, 0x5F, 0x82, 0xF4, 0x00005001); // VT_LPWSTR
DEFINE_API_PKEY(PKEY_PUBSVCS_SCOPE, PUBSVCS_SCOPE, 0x2AE2B567, 0xEECB, 0x4A3E, 0xB7, 0x53, 0x54, 0xC7, 0x25, 0x49, 0x43, 0x66, 0x00005002);   // VT_LPWSTR | VT_VECTOR
DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA, PUBSVCS_METADATA, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005003); // VT_LPWSTR
DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA_VERSION, PUBSVCS_METADATA_VERSION, 0xC0C96C15, 0x1823, 0x4E5B, 0x93, 0x48, 0xE8, 0x25, 0x19, 0x92, 0x3F, 0x04, 0x00005004); // VT_UI8
DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_ALLOWED, PUBSVCS_NETWORK_PROFILES_ALLOWED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005005); // VT_VECTOR | VT_LPWSTR
DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DENIED, PUBSVCS_NETWORK_PROFILES_DENIED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005006); // VT_VECTOR | VT_LPWSTR
DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DEFAULT, PUBSVCS_NETWORK_PROFILES_DEFAULT, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005007); // VT_BOOL

// FMTID_PNPX = {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}
DEFINE_GUID(FMTID_PNPX, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD);
        // from Discovery messages
DEFINE_PROPERTYKEY(PKEY_PNPX_GlobalIdentity, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001000);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_Types, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001001);   // VT_LPWSTR | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_PNPX_Scopes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001002);   // VT_LPWSTR | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_PNPX_XAddrs, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001003);   // VT_LPWSTR | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_PNPX_MetadataVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001004);   // VT_UI8
DEFINE_PROPERTYKEY(PKEY_PNPX_ID, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001005);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_RootProxy, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_BOOL

        // for Directed Discovery
DEFINE_PROPERTYKEY(PKEY_PNPX_RemoteAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_LPWSTR

        // from ThisModel metadata
DEFINE_PROPERTYKEY(PKEY_PNPX_Manufacturer, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002000);   // VT_LPWSTR (localizable)
DEFINE_PROPERTYKEY(PKEY_PNPX_ManufacturerUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002001);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_ModelName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002002);   // VT_LPWSTR (localizable)
DEFINE_PROPERTYKEY(PKEY_PNPX_ModelNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002003);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_ModelUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002004);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_Upc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002005);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_PresentationUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002006);   // VT_LPWSTR
        // from ThisDevice metadata
DEFINE_PROPERTYKEY(PKEY_PNPX_FriendlyName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003000);   // VT_LPWSTR (localizable)
DEFINE_PROPERTYKEY(PKEY_PNPX_FirmwareVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003001);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_SerialNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003002);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003004);   // VT_LPWSTR | VT_VECTOR
        // DeviceCategory values
#define PNPX_DEVICECATEGORY_COMPUTER                            L"Computers"
#define PNPX_DEVICECATEGORY_INPUTDEVICE                         L"Input"
#define PNPX_DEVICECATEGORY_PRINTER                             L"Printers"
#define PNPX_DEVICECATEGORY_SCANNER                             L"Scanners"
#define PNPX_DEVICECATEGORY_FAX                                 L"FAX"
#define PNPX_DEVICECATEGORY_MFP                                 L"MFP"
#define PNPX_DEVICECATEGORY_CAMERA                              L"Cameras"
#define PNPX_DEVICECATEGORY_STORAGE                             L"Storage"
#define PNPX_DEVICECATEGORY_NETWORK_INFRASTRUCTURE              L"NetworkInfrastructure"
#define PNPX_DEVICECATEGORY_DISPLAYS                            L"Displays"
#define PNPX_DEVICECATEGORY_MULTIMEDIA_DEVICE                   L"MediaDevices"
#define PNPX_DEVICECATEGORY_GAMING_DEVICE                       L"Gaming"
#define PNPX_DEVICECATEGORY_TELEPHONE                           L"Phones"
#define PNPX_DEVICECATEGORY_HOME_AUTOMATION_SYSTEM              L"HomeAutomation"
#define PNPX_DEVICECATEGORY_HOME_SECURITY_SYSTEM                L"HomeSecurity"
#define PNPX_DEVICECATEGORY_OTHER                               L"Other"
DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory_Desc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003005);   // VT_LPWSTR | VT_VECTOR

DEFINE_PROPERTYKEY(PKEY_PNPX_PhysicalAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003006);   // VT_UI1 | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceLuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003007);   // VT_UI8
DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceGuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003008);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_IpAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003009);   // VT_LPWSTR | VT_VECTOR
        // from Relationship metadata
DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004000);   // VT_LPWSTR | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004001);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceTypes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004002);   // VT_LPWSTR | VT_VECTOR
        // Association DB PKEYs
DEFINE_API_PKEY(PKEY_PNPX_Devnode, PnPXDevNode, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000001); // VT_BOOL
DEFINE_API_PKEY(PKEY_PNPX_AssociationState, AssociationState, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000002); // VT_UINT
DEFINE_API_PKEY(PKEY_PNPX_AssociatedInstanceId, AssociatedInstanceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000003); // VT_LPWSTR
        // for Computer Discovery
DEFINE_PROPERTYKEY(PKEY_PNPX_DomainName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005000);   // VT_LPWSTR
// Use PKEY_ComputerName (propkey.h) DEFINE_PROPERTYKEY(PKEY_PNPX_MachineName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005001);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PNPX_ShareName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005002);   // VT_LPWSTR

    // SSDP Provider custom properties
DEFINE_PROPERTYKEY(PKEY_SSDP_AltLocationInfo, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006000);   // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_SSDP_DevLifeTime, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006001);   // VT_UI4
DEFINE_PROPERTYKEY(PKEY_SSDP_NetworkInterface, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006002);   // VT_BOOL

// FMTID_PNPXDynamicProperty = {4FC5077E-B686-44BE-93E3-86CAFE368CCD}
DEFINE_GUID(FMTID_PNPXDynamicProperty, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD);

DEFINE_PROPERTYKEY(PKEY_PNPX_Installable, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000001); // VT_BOOL
DEFINE_PROPERTYKEY(PKEY_PNPX_Associated, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000002); // VT_BOOL
// PKEY_PNPX_Installed to be deprecated in Longhorn Server timeframe
// this PKEY really represents Associated state
#define PKEY_PNPX_Installed PKEY_PNPX_Associated    // Deprecated! Please use PKEY_PNPX_Associated
DEFINE_PROPERTYKEY(PKEY_PNPX_CompatibleTypes, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000003); // VT_LPWSTR | VT_VECTOR

    // WNET Provider properties
DEFINE_PROPERTYKEY(PKEY_WNET_Scope, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000001); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WNET_Type, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000002); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WNET_DisplayType, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000003); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WNET_Usage, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000004); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WNET_LocalName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000005); // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_WNET_RemoteName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000006); // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_WNET_Comment, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000007); // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_WNET_Provider, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000008); // VT_LPWSTR


    // WCN Provider properties

DEFINE_PROPERTYKEY(PKEY_WCN_Version, 0x88190b80, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000001); // VT_UI1
DEFINE_PROPERTYKEY(PKEY_WCN_RequestType, 0x88190b81, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000002); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_AuthType, 0x88190b82, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000003); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_EncryptType, 0x88190b83, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000004); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_ConnType, 0x88190b84, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000005); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_ConfigMethods, 0x88190b85, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000006); // VT_INT
// map WCN DeviceType to PKEY_PNPX_DeviceCategory
//DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType, 0x88190b86, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000007); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_RfBand, 0x88190b87, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000008); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_AssocState, 0x88190b88, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000009); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_ConfigError, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000a); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_ConfigState, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000b); // VT_UI1
DEFINE_PROPERTYKEY(PKEY_WCN_DevicePasswordId, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000c); // VT_INT
DEFINE_PROPERTYKEY(PKEY_WCN_OSVersion, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000d); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WCN_VendorExtension, 0x88190b8a, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000e); // VT_UI1 | VT_VECTOR
DEFINE_PROPERTYKEY(PKEY_WCN_RegistrarType, 0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000f); // VT_INT

//-----------------------------------------------------------------------------
// DriverPackage properties

#define PKEY_DriverPackage_Model                PKEY_DrvPkg_Model
#define PKEY_DriverPackage_VendorWebSite        PKEY_DrvPkg_VendorWebSite
#define PKEY_DriverPackage_DetailedDescription  PKEY_DrvPkg_DetailedDescription
#define PKEY_DriverPackage_DocumentationLink    PKEY_DrvPkg_DocumentationLink
#define PKEY_DriverPackage_Icon                 PKEY_DrvPkg_Icon
#define PKEY_DriverPackage_BrandingIcon         PKEY_DrvPkg_BrandingIcon

//-----------------------------------------------------------------------------
// Hardware properties

DEFINE_PROPERTYKEY(PKEY_Hardware_Devinst, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4097);

//  Name:     System.Hardware.DisplayAttribute -- PKEY_Hardware_DisplayAttribute
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 5
DEFINE_PROPERTYKEY(PKEY_Hardware_DisplayAttribute, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 5);

//  Name:     System.Hardware.DriverDate -- PKEY_Hardware_DriverDate
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 11
DEFINE_PROPERTYKEY(PKEY_Hardware_DriverDate, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 11);

//  Name:     System.Hardware.DriverProvider -- PKEY_Hardware_DriverProvider
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 10
DEFINE_PROPERTYKEY(PKEY_Hardware_DriverProvider, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 10);

//  Name:     System.Hardware.DriverVersion -- PKEY_Hardware_DriverVersion
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 9
DEFINE_PROPERTYKEY(PKEY_Hardware_DriverVersion, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 9);

//  Name:     System.Hardware.Function -- PKEY_Hardware_Function
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4099
DEFINE_PROPERTYKEY(PKEY_Hardware_Function, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4099);

//  Name:     System.Hardware.Icon -- PKEY_Hardware_Icon
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 3
DEFINE_PROPERTYKEY(PKEY_Hardware_Icon, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 3);

//  Name:     System.Hardware.Image -- PKEY_Hardware_Image
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4098
DEFINE_PROPERTYKEY(PKEY_Hardware_Image, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4098);

//  Name:     System.Hardware.Manufacturer -- PKEY_Hardware_Manufacturer
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 6
DEFINE_PROPERTYKEY(PKEY_Hardware_Manufacturer, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 6);

//  Name:     System.Hardware.Model -- PKEY_Hardware_Model
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 7
DEFINE_PROPERTYKEY(PKEY_Hardware_Model, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 7);

//  Name:     System.Hardware.Name -- PKEY_Hardware_Name
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 2
DEFINE_PROPERTYKEY(PKEY_Hardware_Name, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 2);

//  Name:     System.Hardware.SerialNumber -- PKEY_Hardware_SerialNumber
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 8
DEFINE_PROPERTYKEY(PKEY_Hardware_SerialNumber, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 8);

//  Name:     System.Hardware.ShellAttributes -- PKEY_Hardware_ShellAttributes
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4100
DEFINE_PROPERTYKEY(PKEY_Hardware_ShellAttributes, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4100);

//  Name:     System.Hardware.Status -- PKEY_Hardware_Status
//  Type:     Unspecified -- VT_NULL
//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4096
DEFINE_PROPERTYKEY(PKEY_Hardware_Status, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4096);


/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _KS_
#define _KS_

#if __GNUC__ >= 3
#pragma GCC system_header
#endif

#ifndef __MINGW_EXTENSION
#if defined(__GNUC__) || defined(__GNUG__)
#define __MINGW_EXTENSION __extension__
#else
#define __MINGW_EXTENSION
#endif
#endif 

#ifdef __TCS__
#define _KS_NO_ANONYMOUS_STRUCTURES_ 1
#endif

#ifdef  _KS_NO_ANONYMOUS_STRUCTURES_
#define _KS_ANON_STRUCT(X)			struct X
#else
#define _KS_ANON_STRUCT(X)	__MINGW_EXTENSION struct
#endif

#ifndef _NTRTL_
#ifndef DEFINE_GUIDEX
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif
#ifndef STATICGUIDOF
#define STATICGUIDOF(guid) STATIC_##guid
#endif
#endif /* _NTRTL_ */

#ifndef SIZEOF_ARRAY
#define SIZEOF_ARRAY(ar) (sizeof(ar)/sizeof((ar)[0]))
#endif

#define DEFINE_GUIDSTRUCT(g,n) DEFINE_GUIDEX(n)
#define DEFINE_GUIDNAMED(n) n

#define STATIC_GUID_NULL						\
	0x00000000L,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000",GUID_NULL);
#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)

#define IOCTL_KS_PROPERTY CTL_CODE(FILE_DEVICE_KS,0x000,METHOD_NEITHER,FILE_ANY_ACCESS)
#define IOCTL_KS_ENABLE_EVENT CTL_CODE(FILE_DEVICE_KS,0x001,METHOD_NEITHER,FILE_ANY_ACCESS)
#define IOCTL_KS_DISABLE_EVENT CTL_CODE(FILE_DEVICE_KS,0x002,METHOD_NEITHER,FILE_ANY_ACCESS)
#define IOCTL_KS_METHOD CTL_CODE(FILE_DEVICE_KS,0x003,METHOD_NEITHER,FILE_ANY_ACCESS)
#define IOCTL_KS_WRITE_STREAM CTL_CODE(FILE_DEVICE_KS,0x004,METHOD_NEITHER,FILE_WRITE_ACCESS)
#define IOCTL_KS_READ_STREAM CTL_CODE(FILE_DEVICE_KS,0x005,METHOD_NEITHER,FILE_READ_ACCESS)
#define IOCTL_KS_RESET_STATE CTL_CODE(FILE_DEVICE_KS,0x006,METHOD_NEITHER,FILE_ANY_ACCESS)

typedef enum {
  KSRESET_BEGIN,
  KSRESET_END
} KSRESET;

typedef enum {
  KSSTATE_STOP,
  KSSTATE_ACQUIRE,
  KSSTATE_PAUSE,
  KSSTATE_RUN
} KSSTATE,*PKSSTATE;

#define KSPRIORITY_LOW		0x00000001
#define KSPRIORITY_NORMAL	0x40000000
#define KSPRIORITY_HIGH		0x80000000
#define KSPRIORITY_EXCLUSIVE	0xFFFFFFFF

typedef struct {
  ULONG PriorityClass;
  ULONG PrioritySubClass;
} KSPRIORITY,*PKSPRIORITY;

typedef struct {
  __MINGW_EXTENSION union {
    _KS_ANON_STRUCT(_IDENTIFIER)
    {
      GUID Set;
      ULONG Id;
      ULONG Flags;
    };
    LONGLONG Alignment;
  };
} KSIDENTIFIER,*PKSIDENTIFIER;

typedef KSIDENTIFIER KSPROPERTY,*PKSPROPERTY,KSMETHOD,*PKSMETHOD,KSEVENT,*PKSEVENT;

#define KSMETHOD_TYPE_NONE		0x00000000
#define KSMETHOD_TYPE_READ		0x00000001
#define KSMETHOD_TYPE_WRITE		0x00000002
#define KSMETHOD_TYPE_MODIFY		0x00000003
#define KSMETHOD_TYPE_SOURCE		0x00000004

#define KSMETHOD_TYPE_SEND		0x00000001
#define KSMETHOD_TYPE_SETSUPPORT	0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT	0x00000200

#define KSMETHOD_TYPE_TOPOLOGY		0x10000000

#define KSPROPERTY_TYPE_GET		0x00000001
#define KSPROPERTY_TYPE_SET		0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT	0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT	0x00000200
#define KSPROPERTY_TYPE_RELATIONS	0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET	0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET	0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW	0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW	0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE	0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES	0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY	0x10000000

typedef struct {
  KSPROPERTY Property;
  ULONG NodeId;
  ULONG Reserved;
} KSP_NODE,*PKSP_NODE;

typedef struct {
  KSMETHOD Method;
  ULONG NodeId;
  ULONG Reserved;
} KSM_NODE,*PKSM_NODE;

typedef struct {
  KSEVENT Event;
  ULONG NodeId;
  ULONG Reserved;
} KSE_NODE,*PKSE_NODE;

#define STATIC_KSPROPTYPESETID_General					\
	0x97E99BA0L,0xBDEA,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000",KSPROPTYPESETID_General);
#define KSPROPTYPESETID_General DEFINE_GUIDNAMED(KSPROPTYPESETID_General)

typedef struct {
  ULONG Size;
  ULONG Count;
} KSMULTIPLE_ITEM,*PKSMULTIPLE_ITEM;

typedef struct {
  ULONG AccessFlags;
  ULONG DescriptionSize;
  KSIDENTIFIER PropTypeSet;
  ULONG MembersListCount;
  ULONG Reserved;
} KSPROPERTY_DESCRIPTION,*PKSPROPERTY_DESCRIPTION;

#define KSPROPERTY_MEMBER_RANGES		0x00000001
#define KSPROPERTY_MEMBER_STEPPEDRANGES		0x00000002
#define KSPROPERTY_MEMBER_VALUES		0x00000003

#define KSPROPERTY_MEMBER_FLAG_DEFAULT		0x00000001
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL 0x00000002
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM	0x00000004

typedef struct {
  ULONG MembersFlags;
  ULONG MembersSize;
  ULONG MembersCount;
  ULONG Flags;
} KSPROPERTY_MEMBERSHEADER,*PKSPROPERTY_MEMBERSHEADER;

typedef union {
  _KS_ANON_STRUCT(_SIGNED)
  {
    LONG SignedMinimum;
    LONG SignedMaximum;
  };
  _KS_ANON_STRUCT(_UNSIGNED)
  {
    ULONG UnsignedMinimum;
    ULONG UnsignedMaximum;
  };
} KSPROPERTY_BOUNDS_LONG,*PKSPROPERTY_BOUNDS_LONG;

typedef union {
  _KS_ANON_STRUCT(_SIGNED64)
  {
    LONGLONG SignedMinimum;
    LONGLONG SignedMaximum;
  };
  _KS_ANON_STRUCT(_UNSIGNED64)
  {
    DWORDLONG UnsignedMinimum;
    DWORDLONG UnsignedMaximum;
  };
} KSPROPERTY_BOUNDS_LONGLONG,*PKSPROPERTY_BOUNDS_LONGLONG;

typedef struct {
  ULONG SteppingDelta;
  ULONG Reserved;
  KSPROPERTY_BOUNDS_LONG Bounds;
} KSPROPERTY_STEPPING_LONG,*PKSPROPERTY_STEPPING_LONG;

typedef struct {
  DWORDLONG SteppingDelta;
  KSPROPERTY_BOUNDS_LONGLONG Bounds;
} KSPROPERTY_STEPPING_LONGLONG,*PKSPROPERTY_STEPPING_LONGLONG;

#if defined(_NTDDK_)
typedef struct _KSDEVICE_DESCRIPTOR KSDEVICE_DESCRIPTOR, *PKSDEVICE_DESCRIPTOR;
typedef struct _KSDEVICE_DISPATCH KSDEVICE_DISPATCH, *PKSDEVICE_DISPATCH;
typedef struct _KSDEVICE KSDEVICE, *PKSDEVICE;
typedef struct _KSFILTERFACTORY KSFILTERFACTORY, *PKSFILTERFACTORY;
typedef struct _KSFILTER_DESCRIPTOR KSFILTER_DESCRIPTOR, *PKSFILTER_DESCRIPTOR;
typedef struct _KSFILTER_DISPATCH KSFILTER_DISPATCH, *PKSFILTER_DISPATCH;
typedef struct _KSFILTER KSFILTER, *PKSFILTER;
typedef struct _KSPIN_DESCRIPTOR_EX KSPIN_DESCRIPTOR_EX, *PKSPIN_DESCRIPTOR_EX;
typedef struct _KSPIN_DISPATCH KSPIN_DISPATCH, *PKSPIN_DISPATCH;
typedef struct _KSCLOCK_DISPATCH KSCLOCK_DISPATCH, *PKSCLOCK_DISPATCH;
typedef struct _KSALLOCATOR_DISPATCH KSALLOCATOR_DISPATCH, *PKSALLOCATOR_DISPATCH;
typedef struct _KSPIN KSPIN, *PKSPIN;
typedef struct _KSNODE_DESCRIPTOR KSNODE_DESCRIPTOR, *PKSNODE_DESCRIPTOR;
typedef struct _KSSTREAM_POINTER_OFFSET KSSTREAM_POINTER_OFFSET, *PKSSTREAM_POINTER_OFFSET;
typedef struct _KSSTREAM_POINTER KSSTREAM_POINTER, *PKSSTREAM_POINTER;
typedef struct _KSMAPPING KSMAPPING, *PKSMAPPING;
typedef struct _KSPROCESSPIN KSPROCESSPIN, *PKSPROCESSPIN;
typedef struct _KSPROCESSPIN_INDEXENTRY KSPROCESSPIN_INDEXENTRY, *PKSPROCESSPIN_INDEXENTRY;
#endif /* _NTDDK_ */

typedef PVOID PKSWORKER;


typedef struct {
  ULONG NotificationType;
  __MINGW_EXTENSION union {
    struct {
      HANDLE Event;
      ULONG_PTR Reserved[2];
    } EventHandle;
    struct {
      HANDLE Semaphore;
      ULONG Reserved;
      LONG Adjustment;
    } SemaphoreHandle;
#if defined(_NTDDK_)
    struct {
      PVOID Event;
      KPRIORITY Increment;
      ULONG_PTR Reserved;
    } EventObject;
    struct {
      PVOID Semaphore;
      KPRIORITY Increment;
      LONG Adjustment;
    } SemaphoreObject;
    struct {
      PKDPC Dpc;
      ULONG ReferenceCount;
      ULONG_PTR Reserved;
    } Dpc;
    struct {
      PWORK_QUEUE_ITEM WorkQueueItem;
      WORK_QUEUE_TYPE WorkQueueType;
      ULONG_PTR Reserved;
    } WorkItem;
    struct {
      PWORK_QUEUE_ITEM WorkQueueItem;
      PKSWORKER KsWorkerObject;
      ULONG_PTR Reserved;
    } KsWorkItem;
#endif /* _NTDDK_ */
    struct {
      PVOID Unused;
      LONG_PTR Alignment[2];
    } Alignment;
  };
} KSEVENTDATA,*PKSEVENTDATA;

#define KSEVENTF_EVENT_HANDLE		0x00000001
#define KSEVENTF_SEMAPHORE_HANDLE	0x00000002
#if defined(_NTDDK_)
#define KSEVENTF_EVENT_OBJECT		0x00000004
#define KSEVENTF_SEMAPHORE_OBJECT	0x00000008
#define KSEVENTF_DPC			0x00000010
#define KSEVENTF_WORKITEM		0x00000020
#define KSEVENTF_KSWORKITEM		0x00000080
#endif /* _NTDDK_ */

#define KSEVENT_TYPE_ENABLE		0x00000001
#define KSEVENT_TYPE_ONESHOT		0x00000002
#define KSEVENT_TYPE_ENABLEBUFFERED	0x00000004
#define KSEVENT_TYPE_SETSUPPORT		0x00000100
#define KSEVENT_TYPE_BASICSUPPORT	0x00000200
#define KSEVENT_TYPE_QUERYBUFFER	0x00000400

#define KSEVENT_TYPE_TOPOLOGY		0x10000000

typedef struct {
  KSEVENT Event;
  PKSEVENTDATA EventData;
  PVOID Reserved;
} KSQUERYBUFFER,*PKSQUERYBUFFER;

typedef struct {
  ULONG Size;
  ULONG Flags;
  __MINGW_EXTENSION union {
    HANDLE ObjectHandle;
    PVOID ObjectPointer;
  };
  PVOID Reserved;
  KSEVENT Event;
  KSEVENTDATA EventData;
} KSRELATIVEEVENT;

#define KSRELATIVEEVENT_FLAG_HANDLE	0x00000001
#define KSRELATIVEEVENT_FLAG_POINTER	0x00000002

typedef struct {
  KSEVENTDATA EventData;
  LONGLONG MarkTime;
} KSEVENT_TIME_MARK,*PKSEVENT_TIME_MARK;

typedef struct {
  KSEVENTDATA EventData;
  LONGLONG TimeBase;
  LONGLONG Interval;
} KSEVENT_TIME_INTERVAL,*PKSEVENT_TIME_INTERVAL;

typedef struct {
  LONGLONG TimeBase;
  LONGLONG Interval;
} KSINTERVAL,*PKSINTERVAL;

#define STATIC_KSPROPSETID_General					\
	0x1464EDA5L,0x6A8F,0x11D1,0x9A,0xA7,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196",KSPROPSETID_General);
#define KSPROPSETID_General DEFINE_GUIDNAMED(KSPROPSETID_General)

typedef enum {
  KSPROPERTY_GENERAL_COMPONENTID
} KSPROPERTY_GENERAL;

typedef struct {
  GUID Manufacturer;
  GUID Product;
  GUID Component;
  GUID Name;
  ULONG Version;
  ULONG Revision;
} KSCOMPONENTID,*PKSCOMPONENTID;

#define DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_GENERAL_COMPONENTID,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSCOMPONENTID),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_KSMETHODSETID_StreamIo	\
	0x65D003CAL,0x1523,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196",KSMETHODSETID_StreamIo);
#define KSMETHODSETID_StreamIo DEFINE_GUIDNAMED(KSMETHODSETID_StreamIo)

typedef enum {
  KSMETHOD_STREAMIO_READ,
  KSMETHOD_STREAMIO_WRITE
} KSMETHOD_STREAMIO;

#define DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Handler)			\
	DEFINE_KSMETHOD_ITEM(						\
				KSMETHOD_STREAMIO_READ,			\
				KSMETHOD_TYPE_WRITE,			\
				(Handler),				\
				sizeof(KSMETHOD),			\
				0,					\
				NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Handler)			\
	DEFINE_KSMETHOD_ITEM(						\
				KSMETHOD_STREAMIO_WRITE,		\
				KSMETHOD_TYPE_READ,			\
				(Handler),				\
				sizeof(KSMETHOD),			\
				0,					\
				NULL)

#define STATIC_KSPROPSETID_MediaSeeking					\
	0xEE904F0CL,0xD09B,0x11D0,0xAB,0xE9,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196",KSPROPSETID_MediaSeeking);
#define KSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(KSPROPSETID_MediaSeeking)

typedef enum {
  KSPROPERTY_MEDIASEEKING_CAPABILITIES,
  KSPROPERTY_MEDIASEEKING_FORMATS,
  KSPROPERTY_MEDIASEEKING_TIMEFORMAT,
  KSPROPERTY_MEDIASEEKING_POSITION,
  KSPROPERTY_MEDIASEEKING_STOPPOSITION,
  KSPROPERTY_MEDIASEEKING_POSITIONS,
  KSPROPERTY_MEDIASEEKING_DURATION,
  KSPROPERTY_MEDIASEEKING_AVAILABLE,
  KSPROPERTY_MEDIASEEKING_PREROLL,
  KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
} KSPROPERTY_MEDIASEEKING;

typedef enum {
  KS_SEEKING_NoPositioning,
  KS_SEEKING_AbsolutePositioning,
  KS_SEEKING_RelativePositioning,
  KS_SEEKING_IncrementalPositioning,
  KS_SEEKING_PositioningBitsMask = 0x3,
  KS_SEEKING_SeekToKeyFrame,
  KS_SEEKING_ReturnTime = 0x8
} KS_SEEKING_FLAGS;

typedef enum {
  KS_SEEKING_CanSeekAbsolute = 0x1,
  KS_SEEKING_CanSeekForwards = 0x2,
  KS_SEEKING_CanSeekBackwards = 0x4,
  KS_SEEKING_CanGetCurrentPos = 0x8,
  KS_SEEKING_CanGetStopPos = 0x10,
  KS_SEEKING_CanGetDuration = 0x20,
  KS_SEEKING_CanPlayBackwards = 0x40
} KS_SEEKING_CAPABILITIES;

typedef struct {
  LONGLONG Current;
  LONGLONG Stop;
  KS_SEEKING_FLAGS CurrentFlags;
  KS_SEEKING_FLAGS StopFlags;
} KSPROPERTY_POSITIONS,*PKSPROPERTY_POSITIONS;

typedef struct {
  LONGLONG Earliest;
  LONGLONG Latest;
} KSPROPERTY_MEDIAAVAILABLE,*PKSPROPERTY_MEDIAAVAILABLE;

typedef struct {
  KSPROPERTY Property;
  GUID SourceFormat;
  GUID TargetFormat;
  LONGLONG Time;
} KSP_TIMEFORMAT,*PKSP_TIMEFORMAT;

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_CAPABILITIES,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KS_SEEKING_CAPABILITIES),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_FORMATS,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler,SetHandler) \
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_TIMEFORMAT,	\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(GUID),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_POSITION,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_STOPPOSITION,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_POSITIONS,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				sizeof(KSPROPERTY_POSITIONS),		\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_DURATION,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_AVAILABLE,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSPROPERTY_MEDIAAVAILABLE),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_PREROLL,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT, \
				(Handler),				\
				sizeof(KSP_TIMEFORMAT),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_KSPROPSETID_Topology					\
	0x720D4AC0L,0x7533,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000",KSPROPSETID_Topology);
#define KSPROPSETID_Topology DEFINE_GUIDNAMED(KSPROPSETID_Topology)

typedef enum {
  KSPROPERTY_TOPOLOGY_CATEGORIES,
  KSPROPERTY_TOPOLOGY_NODES,
  KSPROPERTY_TOPOLOGY_CONNECTIONS,
  KSPROPERTY_TOPOLOGY_NAME
} KSPROPERTY_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_TOPOLOGY_CATEGORIES,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				NULL, NULL, 0,NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_TOPOLOGY_NODES,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_TOPOLOGY_CONNECTIONS,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_TOPOLOGY_NAME,		\
				(Handler),				\
				sizeof(KSP_NODE),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_TOPOLOGYSET(TopologySet,Handler)		\
DEFINE_KSPROPERTY_TABLE(TopologySet) {					\
	DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),		\
	DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),			\
	DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),		\
	DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)			\
}

#define STATIC_KSCATEGORY_BRIDGE					\
	0x085AFF00L,0x62CE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000",KSCATEGORY_BRIDGE);
#define KSCATEGORY_BRIDGE DEFINE_GUIDNAMED(KSCATEGORY_BRIDGE)

#define STATIC_KSCATEGORY_CAPTURE					\
	0x65E8773DL,0x8F56,0x11D0,0xA3,0xB9,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196",KSCATEGORY_CAPTURE);
#define KSCATEGORY_CAPTURE DEFINE_GUIDNAMED(KSCATEGORY_CAPTURE)

#define STATIC_KSCATEGORY_RENDER					\
	0x65E8773EL,0x8F56,0x11D0,0xA3,0xB9,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196",KSCATEGORY_RENDER);
#define KSCATEGORY_RENDER DEFINE_GUIDNAMED(KSCATEGORY_RENDER)

#define STATIC_KSCATEGORY_MIXER						\
	0xAD809C00L,0x7B88,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000",KSCATEGORY_MIXER);
#define KSCATEGORY_MIXER DEFINE_GUIDNAMED(KSCATEGORY_MIXER)

#define STATIC_KSCATEGORY_SPLITTER					\
	0x0A4252A0L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000",KSCATEGORY_SPLITTER);
#define KSCATEGORY_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_SPLITTER)

#define STATIC_KSCATEGORY_DATACOMPRESSOR				\
	0x1E84C900L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000",KSCATEGORY_DATACOMPRESSOR);
#define KSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATACOMPRESSOR)

#define STATIC_KSCATEGORY_DATADECOMPRESSOR				\
	0x2721AE20L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000",KSCATEGORY_DATADECOMPRESSOR);
#define KSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATADECOMPRESSOR)

#define STATIC_KSCATEGORY_DATATRANSFORM					\
	0x2EB07EA0L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000",KSCATEGORY_DATATRANSFORM);
#define KSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_DATATRANSFORM)

#define STATIC_KSCATEGORY_COMMUNICATIONSTRANSFORM			\
	0xCF1DDA2CL,0x9743,0x11D0,0xA3,0xEE,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196",KSCATEGORY_COMMUNICATIONSTRANSFORM);
#define KSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_COMMUNICATIONSTRANSFORM)

#define STATIC_KSCATEGORY_INTERFACETRANSFORM				\
	0xCF1DDA2DL,0x9743,0x11D0,0xA3,0xEE,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196",KSCATEGORY_INTERFACETRANSFORM);
#define KSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_INTERFACETRANSFORM)

#define STATIC_KSCATEGORY_MEDIUMTRANSFORM				\
	0xCF1DDA2EL,0x9743,0x11D0,0xA3,0xEE,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196",KSCATEGORY_MEDIUMTRANSFORM);
#define KSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_MEDIUMTRANSFORM)

#define STATIC_KSCATEGORY_FILESYSTEM					\
	0x760FED5EL,0x9357,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196",KSCATEGORY_FILESYSTEM);
#define KSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(KSCATEGORY_FILESYSTEM)

#define STATIC_KSCATEGORY_CLOCK						\
	0x53172480L,0x4791,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000",KSCATEGORY_CLOCK);
#define KSCATEGORY_CLOCK DEFINE_GUIDNAMED(KSCATEGORY_CLOCK)

#define STATIC_KSCATEGORY_PROXY						\
	0x97EBAACAL,0x95BD,0x11D0,0xA3,0xEA,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196",KSCATEGORY_PROXY);
#define KSCATEGORY_PROXY DEFINE_GUIDNAMED(KSCATEGORY_PROXY)

#define STATIC_KSCATEGORY_QUALITY					\
	0x97EBAACBL,0x95BD,0x11D0,0xA3,0xEA,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196",KSCATEGORY_QUALITY);
#define KSCATEGORY_QUALITY DEFINE_GUIDNAMED(KSCATEGORY_QUALITY)

typedef struct {
  ULONG FromNode;
  ULONG FromNodePin;
  ULONG ToNode;
  ULONG ToNodePin;
} KSTOPOLOGY_CONNECTION,*PKSTOPOLOGY_CONNECTION;

typedef struct {
  ULONG CategoriesCount;
  const GUID *Categories;
  ULONG TopologyNodesCount;
  const GUID *TopologyNodes;
  ULONG TopologyConnectionsCount;
  const KSTOPOLOGY_CONNECTION *TopologyConnections;
  const GUID *TopologyNodesNames;
  ULONG Reserved;
} KSTOPOLOGY,*PKSTOPOLOGY;

#define KSFILTER_NODE	((ULONG)-1)
#define KSALL_NODES	((ULONG)-1)

typedef struct {
  ULONG CreateFlags;
  ULONG Node;
} KSNODE_CREATE,*PKSNODE_CREATE;

#define STATIC_KSTIME_FORMAT_NONE	STATIC_GUID_NULL
#define KSTIME_FORMAT_NONE		GUID_NULL

#define STATIC_KSTIME_FORMAT_FRAME					\
	0x7b785570L,0x8c82,0x11cf,0xbc,0x0c,0x00,0xaa,0x00,0xac,0x74,0xf6
DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6",KSTIME_FORMAT_FRAME);
#define KSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(KSTIME_FORMAT_FRAME)

#define STATIC_KSTIME_FORMAT_BYTE					\
	0x7b785571L,0x8c82,0x11cf,0xbc,0x0c,0x00,0xaa,0x00,0xac,0x74,0xf6
DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6",KSTIME_FORMAT_BYTE);
#define KSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(KSTIME_FORMAT_BYTE)

#define STATIC_KSTIME_FORMAT_SAMPLE					\
	0x7b785572L,0x8c82,0x11cf,0xbc,0x0c,0x00,0xaa,0x00,0xac,0x74,0xf6
DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6",KSTIME_FORMAT_SAMPLE);
#define KSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(KSTIME_FORMAT_SAMPLE)

#define STATIC_KSTIME_FORMAT_FIELD					\
	0x7b785573L,0x8c82,0x11cf,0xbc,0x0c,0x00,0xaa,0x00,0xac,0x74,0xf6
DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6",KSTIME_FORMAT_FIELD);
#define KSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(KSTIME_FORMAT_FIELD)

#define STATIC_KSTIME_FORMAT_MEDIA_TIME					\
	0x7b785574L,0x8c82,0x11cf,0xbc,0x0c,0x00,0xaa,0x00,0xac,0x74,0xf6
DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6",KSTIME_FORMAT_MEDIA_TIME);
#define KSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(KSTIME_FORMAT_MEDIA_TIME)

typedef KSIDENTIFIER KSPIN_INTERFACE,*PKSPIN_INTERFACE;

#define STATIC_KSINTERFACESETID_Standard				\
	0x1A8766A0L,0x62CE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000",KSINTERFACESETID_Standard);
#define KSINTERFACESETID_Standard DEFINE_GUIDNAMED(KSINTERFACESETID_Standard)

typedef enum {
  KSINTERFACE_STANDARD_STREAMING,
  KSINTERFACE_STANDARD_LOOPED_STREAMING,
  KSINTERFACE_STANDARD_CONTROL
} KSINTERFACE_STANDARD;

#define STATIC_KSINTERFACESETID_FileIo					\
	0x8C6F932CL,0xE771,0x11D0,0xB8,0xFF,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196",KSINTERFACESETID_FileIo);
#define KSINTERFACESETID_FileIo DEFINE_GUIDNAMED(KSINTERFACESETID_FileIo)

typedef enum {
  KSINTERFACE_FILEIO_STREAMING
} KSINTERFACE_FILEIO;

#define KSMEDIUM_TYPE_ANYINSTANCE		0

#define STATIC_KSMEDIUMSETID_Standard					\
	0x4747B320L,0x62CE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000",KSMEDIUMSETID_Standard);
#define KSMEDIUMSETID_Standard DEFINE_GUIDNAMED(KSMEDIUMSETID_Standard)

#define KSMEDIUM_STANDARD_DEVIO KSMEDIUM_TYPE_ANYINSTANCE

#define STATIC_KSPROPSETID_Pin						\
	0x8C134960L,0x51AD,0x11CF,0x87,0x8A,0x94,0xF8,0x01,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000",KSPROPSETID_Pin);
#define KSPROPSETID_Pin DEFINE_GUIDNAMED(KSPROPSETID_Pin)

typedef enum {
  KSPROPERTY_PIN_CINSTANCES,
  KSPROPERTY_PIN_CTYPES,
  KSPROPERTY_PIN_DATAFLOW,
  KSPROPERTY_PIN_DATARANGES,
  KSPROPERTY_PIN_DATAINTERSECTION,
  KSPROPERTY_PIN_INTERFACES,
  KSPROPERTY_PIN_MEDIUMS,
  KSPROPERTY_PIN_COMMUNICATION,
  KSPROPERTY_PIN_GLOBALCINSTANCES,
  KSPROPERTY_PIN_NECESSARYINSTANCES,
  KSPROPERTY_PIN_PHYSICALCONNECTION,
  KSPROPERTY_PIN_CATEGORY,
  KSPROPERTY_PIN_NAME,
  KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
  KSPROPERTY_PIN_PROPOSEDATAFORMAT
} KSPROPERTY_PIN;

typedef struct {
  KSPROPERTY Property;
  ULONG PinId;
  ULONG Reserved;
} KSP_PIN,*PKSP_PIN;

#define KSINSTANCE_INDETERMINATE	((ULONG)-1)

typedef struct {
  ULONG PossibleCount;
  ULONG CurrentCount;
} KSPIN_CINSTANCES,*PKSPIN_CINSTANCES;

typedef enum {
  KSPIN_DATAFLOW_IN = 1,
  KSPIN_DATAFLOW_OUT
} KSPIN_DATAFLOW,*PKSPIN_DATAFLOW;

#define KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION	0
#define KSDATAFORMAT_TEMPORAL_COMPRESSION	(1 << KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
#define KSDATAFORMAT_BIT_ATTRIBUTES		1
#define KSDATAFORMAT_ATTRIBUTES			(1 << KSDATAFORMAT_BIT_ATTRIBUTES)

#define KSDATARANGE_BIT_ATTRIBUTES		1
#define KSDATARANGE_ATTRIBUTES			(1 << KSDATARANGE_BIT_ATTRIBUTES)
#define KSDATARANGE_BIT_REQUIRED_ATTRIBUTES	2
#define KSDATARANGE_REQUIRED_ATTRIBUTES		(1 << KSDATARANGE_BIT_REQUIRED_ATTRIBUTES)

typedef union {
  __MINGW_EXTENSION struct {
    ULONG FormatSize;
    ULONG Flags;
    ULONG SampleSize;
    ULONG Reserved;
    GUID MajorFormat;
    GUID SubFormat;
    GUID Specifier;
  };
  LONGLONG Alignment;
} KSDATAFORMAT,*PKSDATAFORMAT,KSDATARANGE,*PKSDATARANGE;

#define KSATTRIBUTE_REQUIRED		0x00000001

typedef struct {
  ULONG Size;
  ULONG Flags;
  GUID Attribute;
} KSATTRIBUTE,*PKSATTRIBUTE;

#if defined(_NTDDK_)
typedef struct {
  ULONG Count;
  PKSATTRIBUTE *Attributes;
} KSATTRIBUTE_LIST,*PKSATTRIBUTE_LIST;
#endif /* _NTDDK_ */

typedef enum {
  KSPIN_COMMUNICATION_NONE,
  KSPIN_COMMUNICATION_SINK,
  KSPIN_COMMUNICATION_SOURCE,
  KSPIN_COMMUNICATION_BOTH,
  KSPIN_COMMUNICATION_BRIDGE
} KSPIN_COMMUNICATION,*PKSPIN_COMMUNICATION;

typedef KSIDENTIFIER KSPIN_MEDIUM,*PKSPIN_MEDIUM;

typedef struct {
  KSPIN_INTERFACE Interface;
  KSPIN_MEDIUM Medium;
  ULONG PinId;
  HANDLE PinToHandle;
  KSPRIORITY Priority;
} KSPIN_CONNECT,*PKSPIN_CONNECT;

typedef struct {
  ULONG Size;
  ULONG Pin;
  WCHAR SymbolicLinkName[1];
} KSPIN_PHYSICALCONNECTION,*PKSPIN_PHYSICALCONNECTION;

#if defined(_NTDDK_)
typedef NTSTATUS (*PFNKSINTERSECTHANDLER) ( PIRP Irp, PKSP_PIN Pin,
					    PKSDATARANGE DataRange,
					    PVOID Data);
typedef NTSTATUS (*PFNKSINTERSECTHANDLEREX)(PVOID Context, PIRP Irp,
					    PKSP_PIN Pin,
					    PKSDATARANGE DataRange,
					    PKSDATARANGE MatchingDataRange,
					    ULONG DataBufferSize,
					    PVOID Data,
					    PULONG DataSize);
#endif /* _NTDDK_ */

#define DEFINE_KSPIN_INTERFACE_TABLE(tablename)				\
	const KSPIN_INTERFACE tablename[] =

#define DEFINE_KSPIN_INTERFACE_ITEM(guid,_interFace)			\
	{								\
		STATICGUIDOF(guid),					\
		(_interFace),						\
		0							\
	}

#define DEFINE_KSPIN_MEDIUM_TABLE(tablename)				\
	const KSPIN_MEDIUM tablename[] =

#define DEFINE_KSPIN_MEDIUM_ITEM(guid,medium)				\
		DEFINE_KSPIN_INTERFACE_ITEM(guid,medium)

#define DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_CINSTANCES,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(KSPIN_CINSTANCES),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_CTYPES,			\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(ULONG),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_DATAFLOW,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(KSPIN_DATAFLOW),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_DATARANGES,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_DATAINTERSECTION,	\
				(Handler),				\
				sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM),\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_INTERFACES,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_MEDIUMS,			\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_COMMUNICATION,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(KSPIN_COMMUNICATION),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_GLOBALCINSTANCES,	\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(KSPIN_CINSTANCES),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_NECESSARYINSTANCES,	\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(ULONG),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_PHYSICALCONNECTION,	\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_CATEGORY,		\
				(Handler),				\
				sizeof(KSP_PIN),			\
				sizeof(GUID),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NAME(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_NAME,			\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_CONSTRAINEDDATARANGES,	\
				(Handler),				\
				sizeof(KSP_PIN),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_PIN_PROPOSEDATAFORMAT,	\
				NULL,					\
				sizeof(KSP_PIN),			\
				sizeof(KSDATAFORMAT),			\
				(Handler), NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_PINSET(PinSet,PropGeneral,PropInstances,PropIntersection) \
DEFINE_KSPROPERTY_TABLE(PinSet) {					\
	DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),		\
	DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),			\
	DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),	\
	DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral)			\
}

#define DEFINE_KSPROPERTY_PINSETCONSTRAINED(PinSet,PropGeneral,PropInstances,PropIntersection) \
DEFINE_KSPROPERTY_TABLE(PinSet) {					\
	DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),		\
	DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),			\
	DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),	\
	DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),		\
	DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral),			\
	DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)	\
}

#define STATIC_KSNAME_Filter						\
	0x9b365890L,0x165f,0x11d0,0xa1,0x95,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4",KSNAME_Filter);
#define KSNAME_Filter DEFINE_GUIDNAMED(KSNAME_Filter)

#define KSSTRING_Filter		L"{9B365890-165F-11D0-A195-0020AFD156E4}"

#define STATIC_KSNAME_Pin						\
	0x146F1A80L,0x4791,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000",KSNAME_Pin);
#define KSNAME_Pin DEFINE_GUIDNAMED(KSNAME_Pin)

#define KSSTRING_Pin		L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Clock						\
	0x53172480L,0x4791,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000",KSNAME_Clock);
#define KSNAME_Clock DEFINE_GUIDNAMED(KSNAME_Clock)

#define KSSTRING_Clock		L"{53172480-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Allocator						\
	0x642F5D00L,0x4791,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000",KSNAME_Allocator);
#define KSNAME_Allocator DEFINE_GUIDNAMED(KSNAME_Allocator)

#define KSSTRING_Allocator	L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"

#define KSSTRING_AllocatorEx	L"{091BB63B-603F-11D1-B067-00A0C9062802}"

#define STATIC_KSNAME_TopologyNode					\
	0x0621061AL,0xEE75,0x11D0,0xB9,0x15,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196",KSNAME_TopologyNode);
#define KSNAME_TopologyNode DEFINE_GUIDNAMED(KSNAME_TopologyNode)

#define KSSTRING_TopologyNode	L"{0621061A-EE75-11D0-B915-00A0C9223196}"

#if defined(_NTDDK_)
typedef struct {
  ULONG InterfacesCount;
  const KSPIN_INTERFACE *Interfaces;
  ULONG MediumsCount;
  const KSPIN_MEDIUM *Mediums;
  ULONG DataRangesCount;
  const PKSDATARANGE *DataRanges;
  KSPIN_DATAFLOW DataFlow;
  KSPIN_COMMUNICATION Communication;
  const GUID *Category;
  const GUID *Name;
  __MINGW_EXTENSION union {
    LONGLONG Reserved;
    __MINGW_EXTENSION struct {
      ULONG ConstrainedDataRangesCount;
      PKSDATARANGE *ConstrainedDataRanges;
    };
  };
} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;
typedef const KSPIN_DESCRIPTOR *PCKSPIN_DESCRIPTOR;

#define DEFINE_KSPIN_DESCRIPTOR_TABLE(tablename)			\
	const KSPIN_DESCRIPTOR tablename[] =

#define DEFINE_KSPIN_DESCRIPTOR_ITEM(InterfacesCount,Interfaces,MediumsCount, Mediums,DataRangesCount,DataRanges,DataFlow,Communication)\
{									\
		InterfacesCount, Interfaces, MediumsCount, Mediums,	\
		DataRangesCount, DataRanges, DataFlow, Communication,	\
		NULL, NULL, 0						\
}

#define DEFINE_KSPIN_DESCRIPTOR_ITEMEX(InterfacesCount,Interfaces,MediumsCount,Mediums,DataRangesCount,DataRanges,DataFlow,Communication,Category,Name)\
{									\
		InterfacesCount, Interfaces, MediumsCount, Mediums,	\
		DataRangesCount, DataRanges, DataFlow, Communication,	\
		Category, Name, 0					\
}
#endif /* _NTDDK_ */

#define STATIC_KSDATAFORMAT_TYPE_WILDCARD	STATIC_GUID_NULL
#define KSDATAFORMAT_TYPE_WILDCARD		GUID_NULL

#define STATIC_KSDATAFORMAT_SUBTYPE_WILDCARD	STATIC_GUID_NULL
#define KSDATAFORMAT_SUBTYPE_WILDCARD		GUID_NULL

#define STATIC_KSDATAFORMAT_TYPE_STREAM					\
	0xE436EB83L,0x524F,0x11CE,0x9F,0x53,0x00,0x20,0xAF,0x0B,0xA7,0x70
DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770",KSDATAFORMAT_TYPE_STREAM);
#define KSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STREAM)

#define STATIC_KSDATAFORMAT_SUBTYPE_NONE				\
	0xE436EB8EL,0x524F,0x11CE,0x9F,0x53,0x00,0x20,0xAF,0x0B,0xA7,0x70
DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770",KSDATAFORMAT_SUBTYPE_NONE);
#define KSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NONE)

#define STATIC_KSDATAFORMAT_SPECIFIER_WILDCARD	STATIC_GUID_NULL
#define KSDATAFORMAT_SPECIFIER_WILDCARD		GUID_NULL

#define STATIC_KSDATAFORMAT_SPECIFIER_FILENAME				\
	0xAA797B40L,0xE974,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000",KSDATAFORMAT_SPECIFIER_FILENAME);
#define KSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILENAME)

#define STATIC_KSDATAFORMAT_SPECIFIER_FILEHANDLE			\
	0x65E8773CL,0x8F56,0x11D0,0xA3,0xB9,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196",KSDATAFORMAT_SPECIFIER_FILEHANDLE);
#define KSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILEHANDLE)

#define STATIC_KSDATAFORMAT_SPECIFIER_NONE				\
	0x0F6417D6L,0xC318,0x11D0,0xA4,0x3F,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196",KSDATAFORMAT_SPECIFIER_NONE);
#define KSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_NONE)

#define STATIC_KSPROPSETID_Quality					\
	0xD16AD380L,0xAC1A,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000",KSPROPSETID_Quality);
#define KSPROPSETID_Quality DEFINE_GUIDNAMED(KSPROPSETID_Quality)

typedef enum {
  KSPROPERTY_QUALITY_REPORT,
  KSPROPERTY_QUALITY_ERROR
} KSPROPERTY_QUALITY;

#define DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_QUALITY_REPORT,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSQUALITY),			\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_QUALITY_ERROR,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSERROR),			\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define STATIC_KSPROPSETID_Connection					\
	0x1D58C920L,0xAC9B,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000",KSPROPSETID_Connection);
#define KSPROPSETID_Connection DEFINE_GUIDNAMED(KSPROPSETID_Connection)

typedef enum {
  KSPROPERTY_CONNECTION_STATE,
  KSPROPERTY_CONNECTION_PRIORITY,
  KSPROPERTY_CONNECTION_DATAFORMAT,
  KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
  KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
  KSPROPERTY_CONNECTION_ACQUIREORDERING,
  KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
  KSPROPERTY_CONNECTION_STARTAT
} KSPROPERTY_CONNECTION;

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_STATE,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSSTATE),			\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler,SetHandler) \
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_PRIORITY,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSPRIORITY),			\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler,SetHandler)\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_DATAFORMAT,	\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_ALLOCATORFRAMING,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSALLOCATOR_FRAMING),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,\
				NULL,					\
				sizeof(KSPROPERTY),			\
				sizeof(KSDATAFORMAT),			\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_ACQUIREORDERING,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(int),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CONNECTION_STARTAT,		\
				NULL,					\
				sizeof(KSPROPERTY),			\
				sizeof(KSRELATIVEEVENT),		\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER	0x00000001
#define KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY		0x00000002
#define KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY	0x00000004
#define KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE		0x00000008
#define KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY	0x80000000

#define KSALLOCATOR_OPTIONF_COMPATIBLE			0x00000001
#define KSALLOCATOR_OPTIONF_SYSTEM_MEMORY		0x00000002
#define KSALLOCATOR_OPTIONF_VALID			0x00000003

#define KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT		0x00000010
#define KSALLOCATOR_FLAG_DEVICE_SPECIFIC		0x00000020
#define KSALLOCATOR_FLAG_CAN_ALLOCATE			0x00000040
#define KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO	0x00000080
#define KSALLOCATOR_FLAG_NO_FRAME_INTEGRITY		0x00000100
#define KSALLOCATOR_FLAG_MULTIPLE_OUTPUT		0x00000200
#define KSALLOCATOR_FLAG_CYCLE				0x00000400
#define KSALLOCATOR_FLAG_ALLOCATOR_EXISTS		0x00000800
#define KSALLOCATOR_FLAG_INDEPENDENT_RANGES		0x00001000
#define KSALLOCATOR_FLAG_ATTENTION_STEPPING		0x00002000

typedef struct {
  __MINGW_EXTENSION union {
    ULONG OptionsFlags;
    ULONG RequirementsFlags;
  };
#if defined(_NTDDK_)
  POOL_TYPE PoolType;
#else
  ULONG PoolType;
#endif /* _NTDDK_ */
  ULONG Frames;
  ULONG FrameSize;
  ULONG FileAlignment;
  ULONG Reserved;
} KSALLOCATOR_FRAMING,*PKSALLOCATOR_FRAMING;

#if defined(_NTDDK_)
typedef PVOID (*PFNKSDEFAULTALLOCATE)(PVOID Context);
typedef VOID (*PFNKSDEFAULTFREE)(PVOID Context, PVOID Buffer);
typedef NTSTATUS (*PFNKSINITIALIZEALLOCATOR)(PVOID InitialContext,
					PKSALLOCATOR_FRAMING AllocatorFraming,
					PVOID* Context);
typedef VOID (*PFNKSDELETEALLOCATOR) (PVOID Context);
#endif /* _NTDDK_ */

typedef struct {
  ULONG MinFrameSize;
  ULONG MaxFrameSize;
  ULONG Stepping;
} KS_FRAMING_RANGE,*PKS_FRAMING_RANGE;

typedef struct {
  KS_FRAMING_RANGE Range;
  ULONG InPlaceWeight;
  ULONG NotInPlaceWeight;
} KS_FRAMING_RANGE_WEIGHTED,*PKS_FRAMING_RANGE_WEIGHTED;

typedef struct {
  ULONG RatioNumerator;
  ULONG RatioDenominator;
  ULONG RatioConstantMargin;
} KS_COMPRESSION,*PKS_COMPRESSION;

typedef struct {
  GUID MemoryType;
  GUID BusType;
  ULONG MemoryFlags;
  ULONG BusFlags;
  ULONG Flags;
  ULONG Frames;
  ULONG FileAlignment;
  ULONG MemoryTypeWeight;
  KS_FRAMING_RANGE PhysicalRange;
  KS_FRAMING_RANGE_WEIGHTED FramingRange;
} KS_FRAMING_ITEM,*PKS_FRAMING_ITEM;

typedef struct {
  ULONG CountItems;
  ULONG PinFlags;
  KS_COMPRESSION OutputCompression;
  ULONG PinWeight;
  KS_FRAMING_ITEM FramingItem[1];
} KSALLOCATOR_FRAMING_EX,*PKSALLOCATOR_FRAMING_EX;

#define KSMEMORY_TYPE_WILDCARD		GUID_NULL
#define STATIC_KSMEMORY_TYPE_WILDCARD	STATIC_GUID_NULL

#define KSMEMORY_TYPE_DONT_CARE		GUID_NULL
#define STATIC_KSMEMORY_TYPE_DONT_CARE	STATIC_GUID_NULL

#define KS_TYPE_DONT_CARE		GUID_NULL
#define STATIC_KS_TYPE_DONT_CARE	STATIC_GUID_NULL

#define STATIC_KSMEMORY_TYPE_SYSTEM					\
	0x091bb638L,0x603f,0x11d1,0xb0,0x67,0x00,0xa0,0xc9,0x06,0x28,0x02
DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802",KSMEMORY_TYPE_SYSTEM);
#define KSMEMORY_TYPE_SYSTEM DEFINE_GUIDNAMED(KSMEMORY_TYPE_SYSTEM)

#define STATIC_KSMEMORY_TYPE_USER					\
	0x8cb0fc28L,0x7893,0x11d1,0xb0,0x69,0x00,0xa0,0xc9,0x06,0x28,0x02
DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802",KSMEMORY_TYPE_USER);
#define KSMEMORY_TYPE_USER DEFINE_GUIDNAMED(KSMEMORY_TYPE_USER)

#define STATIC_KSMEMORY_TYPE_KERNEL_PAGED				\
	0xd833f8f8L,0x7894,0x11d1,0xb0,0x69,0x00,0xa0,0xc9,0x06,0x28,0x02
DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802",KSMEMORY_TYPE_KERNEL_PAGED);
#define KSMEMORY_TYPE_KERNEL_PAGED DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_PAGED)

#define STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED				\
	0x4a6d5fc4L,0x7895,0x11d1,0xb0,0x69,0x00,0xa0,0xc9,0x06,0x28,0x02
DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802",KSMEMORY_TYPE_KERNEL_NONPAGED);
#define KSMEMORY_TYPE_KERNEL_NONPAGED DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_NONPAGED)

#define STATIC_KSMEMORY_TYPE_DEVICE_UNKNOWN				\
	0x091bb639L,0x603f,0x11d1,0xb0,0x67,0x00,0xa0,0xc9,0x06,0x28,0x02
DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802",KSMEMORY_TYPE_DEVICE_UNKNOWN);
#define KSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(KSMEMORY_TYPE_DEVICE_UNKNOWN)

#define DECLARE_SIMPLE_FRAMING_EX(FramingExName,MemoryType,Flags,Frames,Alignment,MinFrameSize,MaxFrameSize) \
const KSALLOCATOR_FRAMING_EX FramingExName =				\
{									\
	1,								\
	0,								\
	{								\
		1,							\
		1,							\
		0							\
	},								\
	0,								\
	{								\
		{							\
			MemoryType,					\
			STATIC_KS_TYPE_DONT_CARE,			\
			0,						\
			0,						\
			Flags,						\
			Frames,						\
			Alignment,					\
			0,						\
			{						\
				0,					\
				(ULONG)-1,				\
				1					\
			},						\
			{						\
				{					\
					MinFrameSize,			\
					MaxFrameSize,			\
					1				\
				},					\
				0,					\
				0					\
			}						\
		}							\
	}								\
}

#define SetDefaultKsCompression(KsCompressionPointer)			\
{									\
	KsCompressionPointer->RatioNumerator = 1;			\
	KsCompressionPointer->RatioDenominator = 1;			\
	KsCompressionPointer->RatioConstantMargin = 0;			\
}

#define SetDontCareKsFramingRange(KsFramingRangePointer)		\
{									\
	KsFramingRangePointer->MinFrameSize = 0;			\
	KsFramingRangePointer->MaxFrameSize = (ULONG) -1;		\
	KsFramingRangePointer->Stepping = 1;				\
}

#define SetKsFramingRange(KsFramingRangePointer,P_MinFrameSize,P_MaxFrameSize) \
{									\
	KsFramingRangePointer->MinFrameSize = P_MinFrameSize;		\
	KsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;		\
	KsFramingRangePointer->Stepping = 1;				\
}

#define SetKsFramingRangeWeighted(KsFramingRangeWeightedPointer,P_MinFrameSize,P_MaxFrameSize) \
{									\
	KS_FRAMING_RANGE *KsFramingRange =				\
				&KsFramingRangeWeightedPointer->Range;	\
	SetKsFramingRange(KsFramingRange,P_MinFrameSize,P_MaxFrameSize);\
	KsFramingRangeWeightedPointer->InPlaceWeight = 0;		\
	KsFramingRangeWeightedPointer->NotInPlaceWeight = 0;		\
}

#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer,P_MemoryType,P_Flags,P_Frames,P_Alignment,P_MinFrameSize,P_MaxFrameSize) \
{									\
	KS_COMPRESSION *KsCompression =					\
			&FramingExPointer->OutputCompression;		\
	KS_FRAMING_RANGE *KsFramingRange =				\
			&FramingExPointer->FramingItem[0].PhysicalRange;\
	KS_FRAMING_RANGE_WEIGHTED *KsFramingRangeWeighted =		\
			&FramingExPointer->FramingItem[0].FramingRange;	\
	FramingExPointer->CountItems = 1;				\
	FramingExPointer->PinFlags = 0;					\
	SetDefaultKsCompression(KsCompression);				\
	FramingExPointer->PinWeight = 0;				\
	FramingExPointer->FramingItem[0].MemoryType = P_MemoryType;	\
	FramingExPointer->FramingItem[0].BusType = KS_TYPE_DONT_CARE;	\
	FramingExPointer->FramingItem[0].MemoryFlags = 0;		\
	FramingExPointer->FramingItem[0].BusFlags = 0;			\
	FramingExPointer->FramingItem[0].Flags = P_Flags;		\
	FramingExPointer->FramingItem[0].Frames = P_Frames;		\
	FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;	\
	FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;		\
	SetDontCareKsFramingRange(KsFramingRange);			\
	SetKsFramingRangeWeighted(KsFramingRangeWeighted,		\
				  P_MinFrameSize,P_MaxFrameSize);	\
}

#define STATIC_KSEVENTSETID_StreamAllocator				\
	0x75d95571L,0x073c,0x11d0,0xa1,0x61,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4",KSEVENTSETID_StreamAllocator);
#define KSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(KSEVENTSETID_StreamAllocator)

typedef enum {
  KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
  KSEVENT_STREAMALLOCATOR_FREEFRAME
} KSEVENT_STREAMALLOCATOR;

#define STATIC_KSMETHODSETID_StreamAllocator				\
	0xcf6e4341L,0xec87,0x11cf,0xa1,0x30,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4",KSMETHODSETID_StreamAllocator);
#define KSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(KSMETHODSETID_StreamAllocator)

typedef enum {
  KSMETHOD_STREAMALLOCATOR_ALLOC,
  KSMETHOD_STREAMALLOCATOR_FREE
} KSMETHOD_STREAMALLOCATOR;

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)		\
	DEFINE_KSMETHOD_ITEM(						\
				KSMETHOD_STREAMALLOCATOR_ALLOC,		\
				KSMETHOD_TYPE_WRITE,			\
				(Handler),				\
				sizeof(KSMETHOD),			\
				sizeof(PVOID),				\
				NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)		\
	DEFINE_KSMETHOD_ITEM(						\
				KSMETHOD_STREAMALLOCATOR_FREE,		\
				KSMETHOD_TYPE_READ,			\
				(Handler),				\
				sizeof(KSMETHOD),			\
				sizeof(PVOID),				\
				NULL)

#define DEFINE_KSMETHOD_ALLOCATORSET(AllocatorSet,MethodAlloc,MethodFree)\
DEFINE_KSMETHOD_TABLE(AllocatorSet) {					\
	DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),	\
	DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)		\
}

#define STATIC_KSPROPSETID_StreamAllocator				\
	0xcf6e4342L,0xec87,0x11cf,0xa1,0x30,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4",KSPROPSETID_StreamAllocator);
#define KSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(KSPROPSETID_StreamAllocator)

#if defined(_NTDDK_)
typedef enum {
  KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
  KSPROPERTY_STREAMALLOCATOR_STATUS
} KSPROPERTY_STREAMALLOCATOR;

#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSSTREAMALLOCATOR_FUNCTIONTABLE),\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAMALLOCATOR_STATUS,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSSTREAMALLOCATOR_STATUS),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ALLOCATORSET(AllocatorSet,PropFunctionTable,PropStatus)\
DEFINE_KSPROPERTY_TABLE(AllocatorSet) {					\
	DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),	\
	DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable)\
}

typedef NTSTATUS (*PFNALLOCATOR_ALLOCATEFRAME) (PFILE_OBJECT FileObject,
						PVOID *Frame);
typedef VOID (*PFNALLOCATOR_FREEFRAME) (PFILE_OBJECT FileObject, PVOID Frame);

typedef struct {
  PFNALLOCATOR_ALLOCATEFRAME AllocateFrame;
  PFNALLOCATOR_FREEFRAME FreeFrame;
} KSSTREAMALLOCATOR_FUNCTIONTABLE, *PKSSTREAMALLOCATOR_FUNCTIONTABLE;
#endif /* _NTDDK_ */

typedef struct {
  KSALLOCATOR_FRAMING Framing;
  ULONG AllocatedFrames;
  ULONG Reserved;
} KSSTREAMALLOCATOR_STATUS,*PKSSTREAMALLOCATOR_STATUS;

typedef struct {
  KSALLOCATOR_FRAMING_EX Framing;
  ULONG AllocatedFrames;
  ULONG Reserved;
} KSSTREAMALLOCATOR_STATUS_EX,*PKSSTREAMALLOCATOR_STATUS_EX;

#define KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT		0x00000001
#define KSSTREAM_HEADER_OPTIONSF_PREROLL		0x00000002
#define KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY	0x00000004
#define KSSTREAM_HEADER_OPTIONSF_TYPECHANGED		0x00000008
#define KSSTREAM_HEADER_OPTIONSF_TIMEVALID		0x00000010
#define KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY	0x00000040
#define KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE		0x00000080
#define KSSTREAM_HEADER_OPTIONSF_DURATIONVALID		0x00000100
#define KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM		0x00000200
#define KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA		0x80000000

typedef struct {
  LONGLONG Time;
  ULONG Numerator;
  ULONG Denominator;
} KSTIME,*PKSTIME;

typedef struct {
  ULONG Size;
  ULONG TypeSpecificFlags;
  KSTIME PresentationTime;
  LONGLONG Duration;
  ULONG FrameExtent;
  ULONG DataUsed;
  PVOID Data;
  ULONG OptionsFlags;
#ifdef _WIN64
  ULONG Reserved;
#endif
} KSSTREAM_HEADER,*PKSSTREAM_HEADER;

#define STATIC_KSPROPSETID_StreamInterface				\
	0x1fdd8ee1L,0x9cd3,0x11d0,0x82,0xaa,0x00,0x00,0xf8,0x22,0xfe,0x8a
DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a",KSPROPSETID_StreamInterface);
#define KSPROPSETID_StreamInterface DEFINE_GUIDNAMED(KSPROPSETID_StreamInterface)

typedef enum {
  KSPROPERTY_STREAMINTERFACE_HEADERSIZE
} KSPROPERTY_STREAMINTERFACE;

#define DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE(GetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAMINTERFACE_HEADERSIZE,	\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(ULONG),				\
				NULL,NULL,0,NULL,NULL,0)

#define DEFINE_KSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet,HeaderSizeHandler) \
DEFINE_KSPROPERTY_TABLE(StreamInterfaceSet) {				\
	DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE(HeaderSizeHandler)\
}

#define STATIC_KSPROPSETID_Stream					\
	0x65aaba60L,0x98ae,0x11cf,0xa1,0x0d,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4",KSPROPSETID_Stream);
#define KSPROPSETID_Stream DEFINE_GUIDNAMED(KSPROPSETID_Stream)

typedef enum {
  KSPROPERTY_STREAM_ALLOCATOR,
  KSPROPERTY_STREAM_QUALITY,
  KSPROPERTY_STREAM_DEGRADATION,
  KSPROPERTY_STREAM_MASTERCLOCK,
  KSPROPERTY_STREAM_TIMEFORMAT,
  KSPROPERTY_STREAM_PRESENTATIONTIME,
  KSPROPERTY_STREAM_PRESENTATIONEXTENT,
  KSPROPERTY_STREAM_FRAMETIME,
  KSPROPERTY_STREAM_RATECAPABILITY,
  KSPROPERTY_STREAM_RATE,
  KSPROPERTY_STREAM_PIPE_ID
} KSPROPERTY_STREAM;

#define DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_ALLOCATOR,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(HANDLE),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_QUALITY,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSQUALITY_MANAGER),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler,SetHandler)\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_DEGRADATION,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				0,					\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler,SetHandler)\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_MASTERCLOCK,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(HANDLE),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_TIMEFORMAT,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(GUID),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler,SetHandler)\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_PRESENTATIONTIME,	\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSTIME),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_PRESENTATIONEXTENT,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(LONGLONG),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_FRAMETIME,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSFRAMETIME),			\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_RATECAPABILITY,	\
				(Handler),				\
				sizeof(KSRATE_CAPABILITY),		\
				sizeof(KSRATE),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATE(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_RATE,			\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSRATE),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler,SetHandler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_STREAM_PIPE_ID,		\
				(GetHandler),				\
				sizeof(KSPROPERTY),			\
				sizeof(HANDLE),				\
				(SetHandler),				\
				NULL, 0, NULL, NULL, 0)

typedef struct {
  HANDLE QualityManager;
  PVOID Context;
} KSQUALITY_MANAGER,*PKSQUALITY_MANAGER;

typedef struct {
  LONGLONG Duration;
  ULONG FrameFlags;
  ULONG Reserved;
} KSFRAMETIME,*PKSFRAMETIME;

#define KSFRAMETIME_VARIABLESIZE	0x00000001

typedef struct {
  LONGLONG PresentationStart;
  LONGLONG Duration;
  KSPIN_INTERFACE Interface;
  LONG Rate;
  ULONG Flags;
} KSRATE,*PKSRATE;

#define KSRATE_NOPRESENTATIONSTART	0x00000001
#define KSRATE_NOPRESENTATIONDURATION	0x00000002

typedef struct {
  KSPROPERTY Property;
  KSRATE Rate;
} KSRATE_CAPABILITY,*PKSRATE_CAPABILITY;

#define STATIC_KSPROPSETID_Clock					\
	0xDF12A4C0L,0xAC17,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000",KSPROPSETID_Clock);
#define KSPROPSETID_Clock DEFINE_GUIDNAMED(KSPROPSETID_Clock)

#define NANOSECONDS 10000000
#define KSCONVERT_PERFORMANCE_TIME(Frequency,PerformanceTime)		\
	((((ULONGLONG)(ULONG)(PerformanceTime).HighPart *NANOSECONDS / (Frequency)) << 32) +	\
	 ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart *NANOSECONDS) % (Frequency)) << 32) +\
	 ((ULONGLONG)(PerformanceTime).LowPart *NANOSECONDS)) / (Frequency)))

typedef struct {
  ULONG CreateFlags;
} KSCLOCK_CREATE,*PKSCLOCK_CREATE;

typedef struct {
  LONGLONG Time;
  LONGLONG SystemTime;
} KSCORRELATED_TIME,*PKSCORRELATED_TIME;

typedef struct {
  LONGLONG Granularity;
  LONGLONG Error;
} KSRESOLUTION,*PKSRESOLUTION;

typedef enum {
  KSPROPERTY_CLOCK_TIME,
  KSPROPERTY_CLOCK_PHYSICALTIME,
  KSPROPERTY_CLOCK_CORRELATEDTIME,
  KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
  KSPROPERTY_CLOCK_RESOLUTION,
  KSPROPERTY_CLOCK_STATE,
#if defined(_NTDDK_)
  KSPROPERTY_CLOCK_FUNCTIONTABLE
#endif /* _NTDDK_ */
} KSPROPERTY_CLOCK;

#if defined(_NTDDK_)
typedef LONGLONG (FASTCALL *PFNKSCLOCK_GETTIME)(PFILE_OBJECT FileObject);
typedef LONGLONG (FASTCALL *PFNKSCLOCK_CORRELATEDTIME)(PFILE_OBJECT FileObject,
							PLONGLONG SystemTime);

typedef struct {
   PFNKSCLOCK_GETTIME GetTime;
   PFNKSCLOCK_GETTIME GetPhysicalTime;
   PFNKSCLOCK_CORRELATEDTIME GetCorrelatedTime;
   PFNKSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
} KSCLOCK_FUNCTIONTABLE, *PKSCLOCK_FUNCTIONTABLE;

typedef BOOLEAN (*PFNKSSETTIMER)(PVOID Context, PKTIMER Timer,
				 LARGE_INTEGER DueTime, PKDPC Dpc);
typedef BOOLEAN (*PFNKSCANCELTIMER) (PVOID Context, PKTIMER Timer);
typedef LONGLONG (FASTCALL *PFNKSCORRELATEDTIME)(PVOID Context,
						 PLONGLONG SystemTime);

typedef PVOID			PKSDEFAULTCLOCK;

#define DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_TIME,			\
				(Handler),				\
				sizeof(KSPROPERTY), sizeof(LONGLONG),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_PHYSICALTIME,		\
				(Handler),				\
				sizeof(KSPROPERTY), sizeof(LONGLONG),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_CORRELATEDTIME,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSCORRELATED_TIME),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSCORRELATED_TIME),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_RESOLUTION,		\
				(Handler),				\
				sizeof(KSPROPERTY),sizeof(KSRESOLUTION),\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(Handler)			\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_STATE,			\
				(Handler),				\
				sizeof(KSPROPERTY), sizeof(KSSTATE),	\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_CLOCK_FUNCTIONTABLE,		\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(KSCLOCK_FUNCTIONTABLE),		\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_CLOCKSET(ClockSet,PropTime,PropPhysicalTime,PropCorrelatedTime,PropCorrelatedPhysicalTime,PropResolution,PropState,PropFunctionTable)\
DEFINE_KSPROPERTY_TABLE(ClockSet) {					\
	DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(PropTime),			\
	DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),	\
	DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime),\
	DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime),\
	DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),	\
	DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(PropState),			\
	DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable),	\
}
#endif /* _NTDDK_ */

#define STATIC_KSEVENTSETID_Clock					\
	0x364D8E20L,0x62C7,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000",KSEVENTSETID_Clock);
#define KSEVENTSETID_Clock DEFINE_GUIDNAMED(KSEVENTSETID_Clock)

typedef enum {
  KSEVENT_CLOCK_INTERVAL_MARK,
  KSEVENT_CLOCK_POSITION_MARK
} KSEVENT_CLOCK_POSITION;

#define STATIC_KSEVENTSETID_Connection					\
	0x7f4bcbe0L,0x9ea5,0x11cf,0xa5,0xd6,0x28,0xdb,0x04,0xc1,0x00,0x00
DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000",KSEVENTSETID_Connection);
#define KSEVENTSETID_Connection DEFINE_GUIDNAMED(KSEVENTSETID_Connection)

typedef enum {
  KSEVENT_CONNECTION_POSITIONUPDATE,
  KSEVENT_CONNECTION_DATADISCONTINUITY,
  KSEVENT_CONNECTION_TIMEDISCONTINUITY,
  KSEVENT_CONNECTION_PRIORITY,
  KSEVENT_CONNECTION_ENDOFSTREAM
} KSEVENT_CONNECTION;

typedef struct {
  PVOID Context;
  ULONG Proportion;
  LONGLONG DeltaTime;
} KSQUALITY,*PKSQUALITY;

typedef struct {
  PVOID Context;
  ULONG Status;
} KSERROR,*PKSERROR;

typedef KSIDENTIFIER KSDEGRADE,*PKSDEGRADE;

#define STATIC_KSDEGRADESETID_Standard					\
	0x9F564180L,0x704C,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("9F564180-704C-11D0-A5D6-28DB04C10000",KSDEGRADESETID_Standard);
#define KSDEGRADESETID_Standard DEFINE_GUIDNAMED(KSDEGRADESETID_Standard)

typedef enum {
  KSDEGRADE_STANDARD_SAMPLE,
  KSDEGRADE_STANDARD_QUALITY,
  KSDEGRADE_STANDARD_COMPUTATION,
  KSDEGRADE_STANDARD_SKIP
} KSDEGRADE_STANDARD;

#if defined(_NTDDK_)

#define KSPROBE_STREAMREAD		0x00000000
#define KSPROBE_STREAMWRITE		0x00000001
#define KSPROBE_ALLOCATEMDL		0x00000010
#define KSPROBE_PROBEANDLOCK		0x00000020
#define KSPROBE_SYSTEMADDRESS		0x00000040
#define KSPROBE_MODIFY			0x00000200
#define KSPROBE_STREAMWRITEMODIFY	(KSPROBE_MODIFY | KSPROBE_STREAMWRITE)
#define KSPROBE_ALLOWFORMATCHANGE	0x00000080
#define KSSTREAM_READ			KSPROBE_STREAMREAD
#define KSSTREAM_WRITE			KSPROBE_STREAMWRITE
#define KSSTREAM_PAGED_DATA		0x00000000
#define KSSTREAM_NONPAGED_DATA		0x00000100
#define KSSTREAM_SYNCHRONOUS		0x00001000
#define KSSTREAM_FAILUREEXCEPTION	0x00002000

typedef NTSTATUS (*PFNKSCONTEXT_DISPATCH)(PVOID Context, PIRP Irp);
typedef NTSTATUS (*PFNKSHANDLER)(PIRP Irp, PKSIDENTIFIER Request, PVOID Data);
typedef BOOLEAN (*PFNKSFASTHANDLER)(PFILE_OBJECT FileObject,
				    PKSIDENTIFIER Request,
				    ULONG RequestLength, PVOID Data,
				    ULONG DataLength,
				    PIO_STATUS_BLOCK IoStatus);
typedef NTSTATUS (*PFNKSALLOCATOR) (PIRP Irp, ULONG BufferSize,
				    BOOLEAN InputOperation);

typedef struct {
  KSPROPERTY_MEMBERSHEADER MembersHeader;
  const VOID *Members;
} KSPROPERTY_MEMBERSLIST, *PKSPROPERTY_MEMBERSLIST;

typedef struct {
  KSIDENTIFIER PropTypeSet;
  ULONG MembersListCount;
  const KSPROPERTY_MEMBERSLIST *MembersList;
} KSPROPERTY_VALUES, *PKSPROPERTY_VALUES;

#define DEFINE_KSPROPERTY_TABLE(tablename)				\
	const KSPROPERTY_ITEM tablename[] =

#define DEFINE_KSPROPERTY_ITEM(PropertyId,GetHandler,MinProperty,MinData,SetHandler,Values,RelationsCount,Relations,SupportHandler,SerializedSize)\
{									\
			PropertyId, (PFNKSHANDLER)GetHandler,		\
			MinProperty, MinData,				\
			(PFNKSHANDLER)SetHandler,			\
			(PKSPROPERTY_VALUES)Values, RelationsCount,	\
			(PKSPROPERTY)Relations,				\
			(PFNKSHANDLER)SupportHandler,			\
			(ULONG)SerializedSize				\
}

typedef struct {
  ULONG PropertyId;
  __MINGW_EXTENSION union {
    PFNKSHANDLER GetPropertyHandler;
    BOOLEAN GetSupported;
  };
  ULONG MinProperty;
  ULONG MinData;
  __MINGW_EXTENSION union {
    PFNKSHANDLER SetPropertyHandler;
    BOOLEAN SetSupported;
  };
  const KSPROPERTY_VALUES *Values;
  ULONG RelationsCount;
  const KSPROPERTY *Relations;
  PFNKSHANDLER SupportHandler;
  ULONG SerializedSize;
} KSPROPERTY_ITEM, *PKSPROPERTY_ITEM;

#define DEFINE_KSFASTPROPERTY_ITEM(PropertyId, GetHandler, SetHandler)	\
{									\
			PropertyId, (PFNKSFASTHANDLER)GetHandler,	\
			(PFNKSFASTHANDLER)SetHandler, 0			\
}

typedef struct {
  ULONG PropertyId;
  __MINGW_EXTENSION union {
    PFNKSFASTHANDLER GetPropertyHandler;
    BOOLEAN GetSupported;
  };
  __MINGW_EXTENSION union {
    PFNKSFASTHANDLER SetPropertyHandler;
    BOOLEAN SetSupported;
  };
  ULONG Reserved;
} KSFASTPROPERTY_ITEM, *PKSFASTPROPERTY_ITEM;

#define DEFINE_KSPROPERTY_SET(Set,PropertiesCount,PropertyItem,FastIoCount,FastIoTable)\
{									\
			Set,						\
			PropertiesCount, PropertyItem,			\
			FastIoCount, FastIoTable			\
}

#define DEFINE_KSPROPERTY_SET_TABLE(tablename)				\
	const KSPROPERTY_SET tablename[] =

typedef struct {
  const GUID *Set;
  ULONG PropertiesCount;
  const KSPROPERTY_ITEM *PropertyItem;
  ULONG FastIoCount;
  const KSFASTPROPERTY_ITEM *FastIoTable;
} KSPROPERTY_SET, *PKSPROPERTY_SET;

#define DEFINE_KSMETHOD_TABLE(tablename)				\
	const KSMETHOD_ITEM tablename[] =

#define DEFINE_KSMETHOD_ITEM(MethodId,Flags,MethodHandler,MinMethod,MinData,SupportHandler)\
{									\
			MethodId, (PFNKSHANDLER)MethodHandler,		\
			MinMethod, MinData,				\
			SupportHandler, Flags				\
}

typedef struct {
  ULONG MethodId;
  __MINGW_EXTENSION union {
    PFNKSHANDLER MethodHandler;
    BOOLEAN MethodSupported;
  };
  ULONG MinMethod;
  ULONG MinData;
  PFNKSHANDLER SupportHandler;
  ULONG Flags;
} KSMETHOD_ITEM, *PKSMETHOD_ITEM;

#define DEFINE_KSFASTMETHOD_ITEM(MethodId,MethodHandler)		\
{									\
			MethodId, (PFNKSFASTHANDLER)MethodHandler	\
}

typedef struct {
  ULONG MethodId;
  __MINGW_EXTENSION union {
    PFNKSFASTHANDLER MethodHandler;
    BOOLEAN MethodSupported;
  };
} KSFASTMETHOD_ITEM, *PKSFASTMETHOD_ITEM;

#define DEFINE_KSMETHOD_SET(Set,MethodsCount,MethodItem,FastIoCount,FastIoTable)\
{									\
			Set,						\
			MethodsCount, MethodItem,			\
			FastIoCount, FastIoTable			\
}

#define DEFINE_KSMETHOD_SET_TABLE(tablename)				\
	const KSMETHOD_SET tablename[] =

typedef struct {
  const GUID *Set;
  ULONG MethodsCount;
  const KSMETHOD_ITEM *MethodItem;
  ULONG FastIoCount;
  const KSFASTMETHOD_ITEM *FastIoTable;
} KSMETHOD_SET, *PKSMETHOD_SET;

typedef struct _KSEVENT_ENTRY	KSEVENT_ENTRY, *PKSEVENT_ENTRY;
typedef NTSTATUS (*PFNKSADDEVENT)(PIRP Irp, PKSEVENTDATA EventData,
				  struct _KSEVENT_ENTRY* EventEntry);
typedef VOID (*PFNKSREMOVEEVENT)(PFILE_OBJECT FileObject,
				 struct _KSEVENT_ENTRY* EventEntry);

#define DEFINE_KSEVENT_TABLE(tablename)					\
	const KSEVENT_ITEM tablename[] =

#define DEFINE_KSEVENT_ITEM(EventId,DataInput,ExtraEntryData,AddHandler,RemoveHandler,SupportHandler)\
{									\
			EventId, DataInput, ExtraEntryData,		\
			AddHandler, RemoveHandler, SupportHandler	\
}

typedef struct {
  ULONG EventId;
  ULONG DataInput;
  ULONG ExtraEntryData;
  PFNKSADDEVENT AddHandler;
  PFNKSREMOVEEVENT RemoveHandler;
  PFNKSHANDLER SupportHandler;
} KSEVENT_ITEM, *PKSEVENT_ITEM;

#define DEFINE_KSEVENT_SET(Set,EventsCount,EventItem)			\
{									\
			Set, EventsCount, EventItem			\
}

#define DEFINE_KSEVENT_SET_TABLE(tablename)				\
	const KSEVENT_SET tablename[] =

typedef struct {
  const GUID *Set;
  ULONG EventsCount;
  const KSEVENT_ITEM *EventItem;
} KSEVENT_SET, *PKSEVENT_SET;

typedef struct {
  KDPC Dpc;
  ULONG ReferenceCount;
  KSPIN_LOCK AccessLock;
} KSDPC_ITEM, *PKSDPC_ITEM;

typedef struct {
  KSDPC_ITEM DpcItem;
  LIST_ENTRY BufferList;
} KSBUFFER_ITEM, *PKSBUFFER_ITEM;


#define KSEVENT_ENTRY_DELETED		1
#define KSEVENT_ENTRY_ONESHOT		2
#define KSEVENT_ENTRY_BUFFERED		4

struct _KSEVENT_ENTRY {
  LIST_ENTRY ListEntry;
  PVOID Object;
  __MINGW_EXTENSION union {
    PKSDPC_ITEM DpcItem;
    PKSBUFFER_ITEM BufferItem;
  };
  PKSEVENTDATA EventData;
  ULONG NotificationType;
  const KSEVENT_SET *EventSet;
  const KSEVENT_ITEM *EventItem;
  PFILE_OBJECT FileObject;
  ULONG SemaphoreAdjustment;
  ULONG Reserved;
  ULONG Flags;
};

typedef enum {
  KSEVENTS_NONE,
  KSEVENTS_SPINLOCK,
  KSEVENTS_MUTEX,
  KSEVENTS_FMUTEX,
  KSEVENTS_FMUTEXUNSAFE,
  KSEVENTS_INTERRUPT,
  KSEVENTS_ERESOURCE
} KSEVENTS_LOCKTYPE;

#define KSDISPATCH_FASTIO			0x80000000

typedef struct {
  PDRIVER_DISPATCH Create;
  PVOID Context;
  UNICODE_STRING ObjectClass;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  ULONG Flags;
} KSOBJECT_CREATE_ITEM, *PKSOBJECT_CREATE_ITEM;

typedef VOID (*PFNKSITEMFREECALLBACK)(PKSOBJECT_CREATE_ITEM CreateItem);

#define KSCREATE_ITEM_SECURITYCHANGED		0x00000001
#define KSCREATE_ITEM_WILDCARD			0x00000002
#define KSCREATE_ITEM_NOPARAMETERS		0x00000004
#define KSCREATE_ITEM_FREEONSTOP		0x00000008

#define DEFINE_KSCREATE_DISPATCH_TABLE( tablename )			\
	KSOBJECT_CREATE_ITEM tablename[] =

#define DEFINE_KSCREATE_ITEM(DispatchCreate,TypeName,Context)		\
{									\
			(DispatchCreate), (PVOID)(Context),		\
			{						\
				sizeof(TypeName) - sizeof(UNICODE_NULL),\
				sizeof(TypeName),			\
				(PWCHAR)(TypeName)			\
			},						\
			NULL, 0						\
}

#define DEFINE_KSCREATE_ITEMEX(DispatchCreate,TypeName,Context,Flags)	\
{									\
			(DispatchCreate),				\
			(PVOID)(Context),				\
			{						\
				sizeof(TypeName) - sizeof(UNICODE_NULL),\
				sizeof(TypeName),			\
				(PWCHAR)(TypeName)			\
			},						\
			NULL, (Flags)					\
}

#define DEFINE_KSCREATE_ITEMNULL(DispatchCreate,Context)		\
{									\
			DispatchCreate, Context,			\
			{						\
				0, 0, NULL,				\
			},						\
			NULL, 0						\
}

typedef struct {
  ULONG CreateItemsCount;
  PKSOBJECT_CREATE_ITEM CreateItemsList;
} KSOBJECT_CREATE, *PKSOBJECT_CREATE;

typedef struct {
  PDRIVER_DISPATCH DeviceIoControl;
  PDRIVER_DISPATCH Read;
  PDRIVER_DISPATCH Write;
  PDRIVER_DISPATCH Flush;
  PDRIVER_DISPATCH Close;
  PDRIVER_DISPATCH QuerySecurity;
  PDRIVER_DISPATCH SetSecurity;
  PFAST_IO_DEVICE_CONTROL FastDeviceIoControl;
  PFAST_IO_READ FastRead;
  PFAST_IO_WRITE FastWrite;
} KSDISPATCH_TABLE, *PKSDISPATCH_TABLE;

#define DEFINE_KSDISPATCH_TABLE(tablename,DeviceIoControl,Read,Write,Flush,Close,QuerySecurity,SetSecurity,FastDeviceIoControl,FastRead,FastWrite)\
	const KSDISPATCH_TABLE tablename =				\
	{								\
		DeviceIoControl,					\
		Read,							\
		Write,							\
		Flush,							\
		Close,							\
		QuerySecurity,						\
		SetSecurity,						\
		FastDeviceIoControl,					\
		FastRead,						\
		FastWrite,						\
	}

#define KSCREATE_ITEM_IRP_STORAGE(Irp)					\
	(*(PKSOBJECT_CREATE_ITEM *)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_SET_IRP_STORAGE(Irp)					\
	(*(const KSEVENT_SET **)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_ITEM_IRP_STORAGE(Irp)					\
	(*(const KSEVENT_ITEM **)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSEVENT_ENTRY_IRP_STORAGE(Irp)					\
	(*(PKSEVENT_ENTRY *)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_SET_IRP_STORAGE(Irp)					\
	(*(const KSMETHOD_SET **)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_ITEM_IRP_STORAGE(Irp)					\
	(*(const KSMETHOD_ITEM **)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSMETHOD_TYPE_IRP_STORAGE(Irp)					\
	(*(ULONG_PTR *)(&(Irp)->Tail.Overlay.DriverContext[2]))
#define KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)				\
	(*(PKSPIN_LOCK *)&(Irp)->Tail.Overlay.DriverContext[1])
#define KSPROPERTY_SET_IRP_STORAGE(Irp)					\
	(*(const KSPROPERTY_SET **)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSPROPERTY_ITEM_IRP_STORAGE(Irp)				\
	(*(const KSPROPERTY_ITEM **)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp)				\
	(*(PKSATTRIBUTE_LIST *)&(Irp)->Tail.Overlay.DriverContext[2])

typedef PVOID		KSDEVICE_HEADER, KSOBJECT_HEADER;

typedef enum {
  KsInvokeOnSuccess = 1,
  KsInvokeOnError = 2,
  KsInvokeOnCancel = 4
} KSCOMPLETION_INVOCATION;

typedef enum {
  KsListEntryTail,
  KsListEntryHead
} KSLIST_ENTRY_LOCATION;

typedef enum {
  KsAcquireOnly,
  KsAcquireAndRemove,
  KsAcquireOnlySingleItem,
  KsAcquireAndRemoveOnlySingleItem
} KSIRP_REMOVAL_OPERATION;

typedef enum {
  KsStackCopyToNewLocation,
  KsStackReuseCurrentLocation,
  KsStackUseNewLocation
} KSSTACK_USE;

typedef enum {
  KSTARGET_STATE_DISABLED,
  KSTARGET_STATE_ENABLED
} KSTARGET_STATE;

typedef NTSTATUS (*PFNKSIRPLISTCALLBACK)(PIRP Irp, PVOID Context);
typedef VOID (*PFNREFERENCEDEVICEOBJECT)(PVOID Context);
typedef VOID (*PFNDEREFERENCEDEVICEOBJECT)(PVOID Context);
typedef NTSTATUS (*PFNQUERYREFERENCESTRING)(PVOID Context, PWCHAR *String);

#define BUS_INTERFACE_REFERENCE_VERSION			0x100

typedef struct {
  INTERFACE Interface;

  PFNREFERENCEDEVICEOBJECT ReferenceDeviceObject;
  PFNDEREFERENCEDEVICEOBJECT DereferenceDeviceObject;
  PFNQUERYREFERENCESTRING QueryReferenceString;
} BUS_INTERFACE_REFERENCE, *PBUS_INTERFACE_REFERENCE;

#define STATIC_REFERENCE_BUS_INTERFACE		STATIC_KSMEDIUMSETID_Standard
#define REFERENCE_BUS_INTERFACE			KSMEDIUMSETID_Standard

#endif /* _NTDDK_ */

#ifndef PACK_PRAGMAS_NOT_SUPPORTED
#include <pshpack1.h>
#endif

typedef struct {
  GUID PropertySet;
  ULONG Count;
} KSPROPERTY_SERIALHDR,*PKSPROPERTY_SERIALHDR;

#ifndef PACK_PRAGMAS_NOT_SUPPORTED
#include <poppack.h>
#endif

typedef struct {
  KSIDENTIFIER PropTypeSet;
  ULONG Id;
  ULONG PropertyLength;
} KSPROPERTY_SERIAL,*PKSPROPERTY_SERIAL;


#if defined(_NTDDK_)

#define IOCTL_KS_HANDSHAKE						\
	CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct {
  GUID ProtocolId;
  PVOID Argument1;
  PVOID Argument2;
} KSHANDSHAKE, *PKSHANDSHAKE;

typedef struct _KSGATE		KSGATE, *PKSGATE;

struct _KSGATE {
  LONG Count;
  PKSGATE NextGate;
};

typedef PVOID KSOBJECT_BAG;


typedef BOOLEAN (*PFNKSGENERATEEVENTCALLBACK)(PVOID Context,
					      PKSEVENT_ENTRY EventEntry);

typedef NTSTATUS (*PFNKSDEVICECREATE)(PKSDEVICE Device);

typedef NTSTATUS (*PFNKSDEVICEPNPSTART)(PKSDEVICE Device,PIRP Irp,
				PCM_RESOURCE_LIST TranslatedResourceList,
				PCM_RESOURCE_LIST UntranslatedResourceList);

typedef NTSTATUS (*PFNKSDEVICE)(PKSDEVICE Device);

typedef NTSTATUS (*PFNKSDEVICEIRP)(PKSDEVICE Device,PIRP Irp);

typedef void (*PFNKSDEVICEIRPVOID)(PKSDEVICE Device,PIRP Irp);

typedef NTSTATUS (*PFNKSDEVICEQUERYCAPABILITIES)(PKSDEVICE Device,PIRP Irp,
					 PDEVICE_CAPABILITIES Capabilities);

typedef NTSTATUS (*PFNKSDEVICEQUERYPOWER)(PKSDEVICE Device,PIRP Irp,
					  DEVICE_POWER_STATE DeviceTo,
					  DEVICE_POWER_STATE DeviceFrom,
					  SYSTEM_POWER_STATE SystemTo,
					  SYSTEM_POWER_STATE SystemFrom,
					  POWER_ACTION Action);

typedef void (*PFNKSDEVICESETPOWER)(PKSDEVICE Device,PIRP Irp,
				    DEVICE_POWER_STATE To,
				    DEVICE_POWER_STATE From);

typedef NTSTATUS (*PFNKSFILTERFACTORYVOID)(PKSFILTERFACTORY FilterFactory);

typedef void (*PFNKSFILTERFACTORYPOWER)(PKSFILTERFACTORY FilterFactory,
					DEVICE_POWER_STATE State);

typedef NTSTATUS (*PFNKSFILTERIRP)(PKSFILTER Filter,PIRP Irp);

typedef NTSTATUS (*PFNKSFILTERPROCESS)(PKSFILTER Filter,
					PKSPROCESSPIN_INDEXENTRY Index);

typedef NTSTATUS (*PFNKSFILTERVOID)(PKSFILTER Filter);

typedef void (*PFNKSFILTERPOWER)(PKSFILTER Filter,DEVICE_POWER_STATE State);

typedef NTSTATUS (*PFNKSPINIRP)(PKSPIN Pin,PIRP Irp);

typedef NTSTATUS (*PFNKSPINSETDEVICESTATE)(PKSPIN Pin,KSSTATE ToState,
					   KSSTATE FromState);

typedef NTSTATUS (*PFNKSPINSETDATAFORMAT)(PKSPIN Pin,PKSDATAFORMAT OldFormat,
					  PKSMULTIPLE_ITEM OldAttributeList,
					  const KSDATARANGE *DataRange,
					  const KSATTRIBUTE_LIST *AttributeRange);

typedef NTSTATUS (*PFNKSPINHANDSHAKE)(PKSPIN Pin,PKSHANDSHAKE In,
				      PKSHANDSHAKE Out);

typedef NTSTATUS (*PFNKSPIN)(PKSPIN Pin);

typedef void (*PFNKSPINVOID)(PKSPIN Pin);

typedef void (*PFNKSPINPOWER)(PKSPIN Pin,DEVICE_POWER_STATE State);

typedef BOOLEAN (*PFNKSPINSETTIMER)(PKSPIN Pin,PKTIMER Timer,
				    LARGE_INTEGER DueTime,PKDPC Dpc);

typedef BOOLEAN (*PFNKSPINCANCELTIMER)(PKSPIN Pin,PKTIMER Timer);

typedef LONGLONG (FASTCALL *PFNKSPINCORRELATEDTIME)(PKSPIN Pin,
						    PLONGLONG SystemTime);

typedef void (*PFNKSPINRESOLUTION)(PKSPIN Pin,PKSRESOLUTION Resolution);

typedef NTSTATUS (*PFNKSPININITIALIZEALLOCATOR)(PKSPIN Pin,
					PKSALLOCATOR_FRAMING AllocatorFraming,
					PVOID *Context);

typedef void (*PFNKSSTREAMPOINTER)(PKSSTREAM_POINTER StreamPointer);


typedef struct KSAUTOMATION_TABLE_ KSAUTOMATION_TABLE,*PKSAUTOMATION_TABLE;

struct KSAUTOMATION_TABLE_ {
  ULONG PropertySetsCount;
  ULONG PropertyItemSize;
  const KSPROPERTY_SET *PropertySets;
  ULONG MethodSetsCount;
  ULONG MethodItemSize;
  const KSMETHOD_SET *MethodSets;
  ULONG EventSetsCount;
  ULONG EventItemSize;
  const KSEVENT_SET *EventSets;
#ifndef _WIN64
  PVOID Alignment;
#endif
};

#define DEFINE_KSAUTOMATION_TABLE(table)				\
		const KSAUTOMATION_TABLE table =

#define DEFINE_KSAUTOMATION_PROPERTIES(table)				\
		SIZEOF_ARRAY(table),					\
		sizeof(KSPROPERTY_ITEM),				\
		table

#define DEFINE_KSAUTOMATION_METHODS(table)				\
		SIZEOF_ARRAY(table),					\
		sizeof(KSMETHOD_ITEM),					\
		table

#define DEFINE_KSAUTOMATION_EVENTS(table)				\
		SIZEOF_ARRAY(table),					\
		sizeof(KSEVENT_ITEM),					\
		table

#define DEFINE_KSAUTOMATION_PROPERTIES_NULL				\
		0,							\
		sizeof(KSPROPERTY_ITEM),				\
		NULL

#define DEFINE_KSAUTOMATION_METHODS_NULL				\
		0,							\
		sizeof(KSMETHOD_ITEM),					\
		NULL

#define DEFINE_KSAUTOMATION_EVENTS_NULL					\
		0,							\
		sizeof(KSEVENT_ITEM),					\
		NULL

#define MIN_DEV_VER_FOR_QI		(0x100)

struct _KSDEVICE_DISPATCH {
  PFNKSDEVICECREATE Add;
  PFNKSDEVICEPNPSTART Start;
  PFNKSDEVICE PostStart;
  PFNKSDEVICEIRP QueryStop;
  PFNKSDEVICEIRPVOID CancelStop;
  PFNKSDEVICEIRPVOID Stop;
  PFNKSDEVICEIRP QueryRemove;
  PFNKSDEVICEIRPVOID CancelRemove;
  PFNKSDEVICEIRPVOID Remove;
  PFNKSDEVICEQUERYCAPABILITIES QueryCapabilities;
  PFNKSDEVICEIRPVOID SurpriseRemoval;
  PFNKSDEVICEQUERYPOWER QueryPower;
  PFNKSDEVICESETPOWER SetPower;
  PFNKSDEVICEIRP QueryInterface;
};

struct _KSFILTER_DISPATCH {
  PFNKSFILTERIRP Create;
  PFNKSFILTERIRP Close;
  PFNKSFILTERPROCESS Process;
  PFNKSFILTERVOID Reset;
};

struct _KSPIN_DISPATCH {
  PFNKSPINIRP Create;
  PFNKSPINIRP Close;
  PFNKSPIN Process;
  PFNKSPINVOID Reset;
  PFNKSPINSETDATAFORMAT SetDataFormat;
  PFNKSPINSETDEVICESTATE SetDeviceState;
  PFNKSPIN Connect;
  PFNKSPINVOID Disconnect;
  const KSCLOCK_DISPATCH *Clock;
  const KSALLOCATOR_DISPATCH *Allocator;
};

struct _KSCLOCK_DISPATCH {
  PFNKSPINSETTIMER SetTimer;
  PFNKSPINCANCELTIMER CancelTimer;
  PFNKSPINCORRELATEDTIME CorrelatedTime;
  PFNKSPINRESOLUTION Resolution;
};

struct _KSALLOCATOR_DISPATCH {
  PFNKSPININITIALIZEALLOCATOR InitializeAllocator;
  PFNKSDELETEALLOCATOR DeleteAllocator;
  PFNKSDEFAULTALLOCATE Allocate;
  PFNKSDEFAULTFREE Free;
};

#define KSDEVICE_DESCRIPTOR_VERSION	(0x100)

struct _KSDEVICE_DESCRIPTOR {
  const KSDEVICE_DISPATCH *Dispatch;
  ULONG FilterDescriptorsCount;
  const KSFILTER_DESCRIPTOR*const *FilterDescriptors;
  ULONG Version;
};

struct _KSFILTER_DESCRIPTOR {
  const KSFILTER_DISPATCH *Dispatch;
  const KSAUTOMATION_TABLE *AutomationTable;
  ULONG Version;
#define KSFILTER_DESCRIPTOR_VERSION	((ULONG)-1)
  ULONG Flags;
#define KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING		0x00000001
#define KSFILTER_FLAG_CRITICAL_PROCESSING		0x00000002
#define KSFILTER_FLAG_HYPERCRITICAL_PROCESSING		0x00000004
#define KSFILTER_FLAG_RECEIVE_ZERO_LENGTH_SAMPLES	0x00000008
#define KSFILTER_FLAG_DENY_USERMODE_ACCESS		0x80000000
  const GUID *ReferenceGuid;
  ULONG PinDescriptorsCount;
  ULONG PinDescriptorSize;
  const KSPIN_DESCRIPTOR_EX *PinDescriptors;
  ULONG CategoriesCount;
  const GUID *Categories;
  ULONG NodeDescriptorsCount;
  ULONG NodeDescriptorSize;
  const KSNODE_DESCRIPTOR *NodeDescriptors;
  ULONG ConnectionsCount;
  const KSTOPOLOGY_CONNECTION *Connections;
  const KSCOMPONENTID *ComponentId;
};

#define DEFINE_KSFILTER_DESCRIPTOR(descriptor)				\
	const KSFILTER_DESCRIPTOR descriptor =

#define DEFINE_KSFILTER_PIN_DESCRIPTORS(table)				\
	SIZEOF_ARRAY(table),						\
	sizeof(table[0]),						\
	table

#define DEFINE_KSFILTER_CATEGORIES(table)				\
	SIZEOF_ARRAY(table),						\
	table

#define DEFINE_KSFILTER_CATEGORY(category)				\
	1,								\
	&(category)

#define DEFINE_KSFILTER_CATEGORIES_NULL					\
	0,								\
	NULL

#define DEFINE_KSFILTER_NODE_DESCRIPTORS(table)				\
	SIZEOF_ARRAY(table),						\
	sizeof(table[0]),						\
	table

#define DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL				\
	0,								\
	sizeof(KSNODE_DESCRIPTOR),					\
	NULL

#define DEFINE_KSFILTER_CONNECTIONS(table)				\
	SIZEOF_ARRAY(table),						\
	table

#define DEFINE_KSFILTER_DEFAULT_CONNECTIONS				\
	0,								\
	NULL

#define DEFINE_KSFILTER_DESCRIPTOR_TABLE(table)				\
	const KSFILTER_DESCRIPTOR*const table[] =

struct _KSPIN_DESCRIPTOR_EX {
  const KSPIN_DISPATCH *Dispatch;
  const KSAUTOMATION_TABLE *AutomationTable;
  KSPIN_DESCRIPTOR PinDescriptor;
  ULONG Flags;
#define KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING	KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING
#define KSPIN_FLAG_CRITICAL_PROCESSING		KSFILTER_FLAG_CRITICAL_PROCESSING
#define KSPIN_FLAG_HYPERCRITICAL_PROCESSING	KSFILTER_FLAG_HYPERCRITICAL_PROCESSING
#define KSPIN_FLAG_ASYNCHRONOUS_PROCESSING			0x00000008
#define KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING			0x00000010
#define KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL		0x00000020
#define KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING		0x00000040
#define KSPIN_FLAG_ENFORCE_FIFO					0x00000080
#define KSPIN_FLAG_GENERATE_MAPPINGS				0x00000100
#define KSPIN_FLAG_DISTINCT_TRAILING_EDGE			0x00000200
#define KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY			0x00010000
#define KSPIN_FLAG_SPLITTER					0x00020000
#define KSPIN_FLAG_USE_STANDARD_TRANSPORT			0x00040000
#define KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT		0x00080000
#define KSPIN_FLAG_FIXED_FORMAT					0x00100000
#define KSPIN_FLAG_GENERATE_EOS_EVENTS				0x00200000
#define KSPIN_FLAG_RENDERER			(KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY|KSPIN_FLAG_GENERATE_EOS_EVENTS)
#define KSPIN_FLAG_IMPLEMENT_CLOCK				0x00400000
#define KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING		0x00800000
#define KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE			0x01000000
#define KSPIN_FLAG_DENY_USERMODE_ACCESS				0x80000000
  ULONG InstancesPossible;
  ULONG InstancesNecessary;
  const KSALLOCATOR_FRAMING_EX *AllocatorFraming;
  PFNKSINTERSECTHANDLEREX IntersectHandler;
};

#define DEFINE_KSPIN_DEFAULT_INTERFACES					\
	0,								\
	NULL

#define DEFINE_KSPIN_DEFAULT_MEDIUMS					\
	0,								\
	NULL

struct _KSNODE_DESCRIPTOR {
  const KSAUTOMATION_TABLE *AutomationTable;
  const GUID *Type;
  const GUID *Name;
#ifndef _WIN64
  PVOID Alignment;
#endif
};

#ifndef _WIN64
#define DEFINE_NODE_DESCRIPTOR(automation,type,name)			\
	{ (automation), (type), (name), NULL }
#else
#define DEFINE_NODE_DESCRIPTOR(automation,type,name)			\
	{ (automation), (type), (name) }
#endif

struct _KSDEVICE {
  const KSDEVICE_DESCRIPTOR *Descriptor;
  KSOBJECT_BAG Bag;
  PVOID Context;
  PDEVICE_OBJECT FunctionalDeviceObject;
  PDEVICE_OBJECT PhysicalDeviceObject;
  PDEVICE_OBJECT NextDeviceObject;
  BOOLEAN Started;
  SYSTEM_POWER_STATE SystemPowerState;
  DEVICE_POWER_STATE DevicePowerState;
};

struct _KSFILTERFACTORY {
  const KSFILTER_DESCRIPTOR *FilterDescriptor;
  KSOBJECT_BAG Bag;
  PVOID Context;
};

struct _KSFILTER {
  const KSFILTER_DESCRIPTOR *Descriptor;
  KSOBJECT_BAG Bag;
  PVOID Context;
};

struct _KSPIN {
  const KSPIN_DESCRIPTOR_EX *Descriptor;
  KSOBJECT_BAG Bag;
  PVOID Context;
  ULONG Id;
  KSPIN_COMMUNICATION Communication;
  BOOLEAN ConnectionIsExternal;
  KSPIN_INTERFACE ConnectionInterface;
  KSPIN_MEDIUM ConnectionMedium;
  KSPRIORITY ConnectionPriority;
  PKSDATAFORMAT ConnectionFormat;
  PKSMULTIPLE_ITEM AttributeList;
  ULONG StreamHeaderSize;
  KSPIN_DATAFLOW DataFlow;
  KSSTATE DeviceState;
  KSRESET ResetState;
  KSSTATE ClientState;
};

struct _KSMAPPING {
  PHYSICAL_ADDRESS PhysicalAddress;
  ULONG ByteCount;
  ULONG Alignment;
};

struct _KSSTREAM_POINTER_OFFSET
{
#if defined(_NTDDK_)
  __MINGW_EXTENSION union {
    PUCHAR Data;
    PKSMAPPING Mappings;
  };
#else
  PUCHAR Data;
#endif /* _NTDDK_ */
#ifndef _WIN64
  PVOID Alignment;
#endif
  ULONG Count;
  ULONG Remaining;
};

struct _KSSTREAM_POINTER
{
  PVOID Context;
  PKSPIN Pin;
  PKSSTREAM_HEADER StreamHeader;
  PKSSTREAM_POINTER_OFFSET Offset;
  KSSTREAM_POINTER_OFFSET OffsetIn;
  KSSTREAM_POINTER_OFFSET OffsetOut;
};

struct _KSPROCESSPIN {
  PKSPIN Pin;
  PKSSTREAM_POINTER StreamPointer;
  PKSPROCESSPIN InPlaceCounterpart;
  PKSPROCESSPIN DelegateBranch;
  PKSPROCESSPIN CopySource;
  PVOID Data;
  ULONG BytesAvailable;
  ULONG BytesUsed;
  ULONG Flags;
  BOOLEAN Terminate;
};

struct _KSPROCESSPIN_INDEXENTRY {
  PKSPROCESSPIN *Pins;
  ULONG Count;
};

typedef enum {
  KsObjectTypeDevice,
  KsObjectTypeFilterFactory,
  KsObjectTypeFilter,
  KsObjectTypePin
} KSOBJECTTYPE;


typedef void (*PFNKSFREE)(PVOID Data);

typedef void (*PFNKSPINFRAMERETURN)(PKSPIN Pin,PVOID Data,ULONG Size,PMDL Mdl,
				    PVOID Context,NTSTATUS Status);

typedef void (*PFNKSPINIRPCOMPLETION)(PKSPIN Pin,PIRP Irp);


#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
#ifndef _IKsControl_
#define _IKsControl_

typedef struct IKsControl *PIKSCONTROL;

#ifndef DEFINE_ABSTRACT_UNKNOWN
#define DEFINE_ABSTRACT_UNKNOWN()					\
	STDMETHOD_(NTSTATUS,QueryInterface) (THIS_ 			\
						REFIID InterfaceId,	\
						PVOID *Interface	\
					    ) PURE;			\
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;				\
	STDMETHOD_(ULONG,Release)(THIS) PURE;
#endif

#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl,IUnknown)
{
  DEFINE_ABSTRACT_UNKNOWN()
  STDMETHOD_(NTSTATUS,KsProperty)(THIS_
					PKSPROPERTY Property,
					ULONG PropertyLength,
					PVOID PropertyData,
					ULONG DataLength,
					ULONG *BytesReturned
				 ) PURE;
  STDMETHOD_(NTSTATUS,KsMethod)	(THIS_
					PKSMETHOD Method,
					ULONG MethodLength,
					PVOID MethodData,
					ULONG DataLength,
					ULONG *BytesReturned
				 ) PURE;
  STDMETHOD_(NTSTATUS,KsEvent)	(THIS_
					PKSEVENT Event,
					ULONG EventLength,
					PVOID EventData,
					ULONG DataLength,
					ULONG *BytesReturned
				) PURE;
};
typedef struct IKsReferenceClock *PIKSREFERENCECLOCK;

#undef INTERFACE
#define INTERFACE IKsReferenceClock
DECLARE_INTERFACE_(IKsReferenceClock,IUnknown)
{
  DEFINE_ABSTRACT_UNKNOWN()
  STDMETHOD_(LONGLONG,GetTime)		(THIS) PURE;
  STDMETHOD_(LONGLONG,GetPhysicalTime)	(THIS) PURE;
  STDMETHOD_(LONGLONG,GetCorrelatedTime)(THIS_
  						PLONGLONG SystemTime
  					) PURE;
  STDMETHOD_(LONGLONG,GetCorrelatedPhysicalTime)(THIS_
						PLONGLONG SystemTime
					) PURE;
  STDMETHOD_(NTSTATUS,GetResolution)	(THIS_
						PKSRESOLUTION Resolution
					) PURE;
  STDMETHOD_(NTSTATUS,GetState)		(THIS_
						PKSSTATE State
					) PURE;
};
#undef INTERFACE

#define INTERFACE IKsDeviceFunctions
DECLARE_INTERFACE_(IKsDeviceFunctions,IUnknown)
{
  DEFINE_ABSTRACT_UNKNOWN()
  STDMETHOD_(NTSTATUS,RegisterAdapterObjectEx)	(THIS_
						  PADAPTER_OBJECT AdapterObject,
						  PDEVICE_DESCRIPTION DeviceDescription,
						  ULONG NumberOfMapRegisters,
						  ULONG MaxMappingsByteCount,
						  ULONG MappingTableStride
						) PURE;
};

#undef INTERFACE
#define STATIC_IID_IKsControl						\
	0x28F54685L,0x06FD,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUID(IID_IKsControl,
	0x28F54685L,0x06FD,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96);
#define STATIC_IID_IKsFastClock						\
	0xc9902485,0xc180,0x11d2,0x84,0x73,0xd4,0x23,0x94,0x45,0x9e,0x5e
DEFINE_GUID(IID_IKsFastClock,
	0xc9902485,0xc180,0x11d2,0x84,0x73,0xd4,0x23,0x94,0x45,0x9e,0x5e);
#define STATIC_IID_IKsDeviceFunctions					\
	0xe234f2e2,0xbd69,0x4f8c,0xb3,0xf2,0x7c,0xd7,0x9e,0xd4,0x66,0xbd
DEFINE_GUID(IID_IKsDeviceFunctions,
	0xe234f2e2,0xbd69,0x4f8c,0xb3,0xf2,0x7c,0xd7,0x9e,0xd4,0x66,0xbd);
#endif /* _IKsControl_ */
#endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */

#endif /* _NTDDK_ */


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _KSDDK_
#define KSDDKAPI
#else
#define KSDDKAPI DECLSPEC_IMPORT
#endif

#if defined(_NTDDK_)

KSDDKAPI NTSTATUS NTAPI KsEnableEvent
			(PIRP Irp, ULONG EventSetsCount, const KSEVENT_SET *EventSet,
			 PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags,
			 PVOID EventsLock);

KSDDKAPI NTSTATUS NTAPI KsEnableEventWithAllocator
			(PIRP Irp, ULONG EventSetsCount, const KSEVENT_SET *EventSet,
			 PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags,
			 PVOID EventsLock, PFNKSALLOCATOR Allocator, ULONG EventItemSize);

KSDDKAPI NTSTATUS NTAPI KsDisableEvent
			(PIRP Irp, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags,
			 PVOID EventsLock);

KSDDKAPI VOID NTAPI KsDiscardEvent (PKSEVENT_ENTRY EventEntry);

KSDDKAPI VOID NTAPI KsFreeEventList
			(PFILE_OBJECT FileObject, PLIST_ENTRY EventsList,
			 KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);

KSDDKAPI NTSTATUS NTAPI KsGenerateEvent (PKSEVENT_ENTRY EventEntry);

KSDDKAPI NTSTATUS NTAPI KsGenerateDataEvent
			(PKSEVENT_ENTRY EventEntry, ULONG DataSize, PVOID Data);

KSDDKAPI VOID NTAPI KsGenerateEventList
			(GUID *Set, ULONG EventId, PLIST_ENTRY EventsList,
			 KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);

KSDDKAPI NTSTATUS NTAPI KsPropertyHandler
			(PIRP Irp, ULONG PropertySetsCount,
			 const KSPROPERTY_SET *PropertySet);

KSDDKAPI NTSTATUS NTAPI KsPropertyHandlerWithAllocator
			(PIRP Irp, ULONG PropertySetsCount,
			 const KSPROPERTY_SET *PropertySet, PFNKSALLOCATOR Allocator,
			 ULONG PropertyItemSize);

KSDDKAPI BOOLEAN NTAPI KsFastPropertyHandler
			(PFILE_OBJECT FileObject, PKSPROPERTY Property,
			 ULONG PropertyLength, PVOID Data, ULONG DataLength,
			 PIO_STATUS_BLOCK IoStatus, ULONG PropertySetsCount,
			 const KSPROPERTY_SET *PropertySet);

KSDDKAPI NTSTATUS NTAPI KsMethodHandler
			(PIRP Irp, ULONG MethodSetsCount,
			 const KSMETHOD_SET *MethodSet);

KSDDKAPI NTSTATUS NTAPI KsMethodHandlerWithAllocator
			(PIRP Irp, ULONG MethodSetsCount,
			 const KSMETHOD_SET *MethodSet, PFNKSALLOCATOR Allocator,
			 ULONG MethodItemSize);

KSDDKAPI BOOLEAN NTAPI KsFastMethodHandler
			(PFILE_OBJECT FileObject, PKSMETHOD Method, ULONG MethodLength,
			 PVOID Data, ULONG DataLength, PIO_STATUS_BLOCK IoStatus,
			 ULONG MethodSetsCount, const KSMETHOD_SET *MethodSet);

KSDDKAPI NTSTATUS NTAPI KsCreateDefaultAllocator (PIRP Irp);

KSDDKAPI NTSTATUS NTAPI KsCreateDefaultAllocatorEx
			(PIRP Irp, PVOID InitializeContext,
			 PFNKSDEFAULTALLOCATE DefaultAllocate,
			 PFNKSDEFAULTFREE DefaultFree,
			 PFNKSINITIALIZEALLOCATOR InitializeAllocator,
			 PFNKSDELETEALLOCATOR DeleteAllocator);

KSDDKAPI NTSTATUS NTAPI KsCreateAllocator
			(HANDLE ConnectionHandle, PKSALLOCATOR_FRAMING AllocatorFraming,
			 PHANDLE AllocatorHandle);

KSDDKAPI NTSTATUS NTAPI KsValidateAllocatorCreateRequest
			(PIRP Irp, PKSALLOCATOR_FRAMING *AllocatorFraming);

KSDDKAPI NTSTATUS NTAPI KsValidateAllocatorFramingEx
			(PKSALLOCATOR_FRAMING_EX Framing, ULONG BufferSize,
			 const KSALLOCATOR_FRAMING_EX *PinFraming);

KSDDKAPI NTSTATUS NTAPI KsAllocateDefaultClock (PKSDEFAULTCLOCK *DefaultClock);

KSDDKAPI NTSTATUS NTAPI KsAllocateDefaultClockEx
			(PKSDEFAULTCLOCK *DefaultClock, PVOID Context,
			 PFNKSSETTIMER SetTimer, PFNKSCANCELTIMER CancelTimer,
			 PFNKSCORRELATEDTIME CorrelatedTime,
			 const KSRESOLUTION *Resolution, ULONG Flags);

KSDDKAPI VOID NTAPI KsFreeDefaultClock (PKSDEFAULTCLOCK DefaultClock);
KSDDKAPI NTSTATUS NTAPI KsCreateDefaultClock (PIRP Irp, PKSDEFAULTCLOCK DefaultClock);

KSDDKAPI NTSTATUS NTAPI KsCreateClock
			(HANDLE ConnectionHandle, PKSCLOCK_CREATE ClockCreate,
			 PHANDLE ClockHandle);

KSDDKAPI NTSTATUS NTAPI KsValidateClockCreateRequest
			(PIRP Irp, PKSCLOCK_CREATE *ClockCreate);

KSDDKAPI KSSTATE NTAPI KsGetDefaultClockState (PKSDEFAULTCLOCK DefaultClock);
KSDDKAPI VOID NTAPI KsSetDefaultClockState(PKSDEFAULTCLOCK DefaultClock, KSSTATE State);
KSDDKAPI LONGLONG NTAPI KsGetDefaultClockTime (PKSDEFAULTCLOCK DefaultClock);
KSDDKAPI VOID NTAPI KsSetDefaultClockTime(PKSDEFAULTCLOCK DefaultClock, LONGLONG Time);

KSDDKAPI NTSTATUS NTAPI KsCreatePin
			(HANDLE FilterHandle, PKSPIN_CONNECT Connect,
			 ACCESS_MASK DesiredAccess, PHANDLE ConnectionHandle);

KSDDKAPI NTSTATUS NTAPI KsValidateConnectRequest
			(PIRP Irp, ULONG DescriptorsCount,
			 const KSPIN_DESCRIPTOR *Descriptor, PKSPIN_CONNECT *Connect);

KSDDKAPI NTSTATUS NTAPI KsPinPropertyHandler
			(PIRP Irp, PKSPROPERTY Property, PVOID Data,
			 ULONG DescriptorsCount, const KSPIN_DESCRIPTOR *Descriptor);

KSDDKAPI NTSTATUS NTAPI KsPinDataIntersection
			(PIRP Irp, PKSP_PIN Pin, PVOID Data, ULONG DescriptorsCount,
			 const KSPIN_DESCRIPTOR *Descriptor,
			 PFNKSINTERSECTHANDLER IntersectHandler);

KSDDKAPI NTSTATUS NTAPI KsPinDataIntersectionEx
			(PIRP Irp, PKSP_PIN Pin, PVOID Data, ULONG DescriptorsCount,
			 const KSPIN_DESCRIPTOR *Descriptor, ULONG DescriptorSize,
			 PFNKSINTERSECTHANDLEREX IntersectHandler, PVOID HandlerContext);

KSDDKAPI NTSTATUS NTAPI KsHandleSizedListQuery
			(PIRP Irp, ULONG DataItemsCount, ULONG DataItemSize,
			 const VOID *DataItems);

#ifndef MAKEINTRESOURCE
#define MAKEINTRESOURCE(r)		((ULONG_PTR) (USHORT) r)
#endif
#ifndef RT_STRING
#define RT_STRING			MAKEINTRESOURCE(6)
#define RT_RCDATA			MAKEINTRESOURCE(10)
#endif

KSDDKAPI NTSTATUS NTAPI KsLoadResource
			(PVOID ImageBase, POOL_TYPE PoolType, ULONG_PTR ResourceName,
			 ULONG ResourceType, PVOID *Resource, PULONG ResourceSize);

KSDDKAPI NTSTATUS NTAPI KsGetImageNameAndResourceId
			(HANDLE RegKey, PUNICODE_STRING ImageName, PULONG_PTR ResourceId,
			 PULONG ValueType);

KSDDKAPI NTSTATUS NTAPI KsMapModuleName
			(PDEVICE_OBJECT PhysicalDeviceObject, PUNICODE_STRING ModuleName,
			 PUNICODE_STRING ImageName, PULONG_PTR ResourceId,
			 PULONG ValueType);

KSDDKAPI NTSTATUS NTAPI KsReferenceBusObject (KSDEVICE_HEADER Header);
KSDDKAPI VOID NTAPI KsDereferenceBusObject (KSDEVICE_HEADER Header);
KSDDKAPI NTSTATUS NTAPI KsDispatchQuerySecurity (PDEVICE_OBJECT DeviceObject, PIRP Irp);
KSDDKAPI NTSTATUS NTAPI KsDispatchSetSecurity (PDEVICE_OBJECT DeviceObject, PIRP Irp);
KSDDKAPI NTSTATUS NTAPI KsDispatchSpecificProperty (PIRP Irp, PFNKSHANDLER Handler);
KSDDKAPI NTSTATUS NTAPI KsDispatchSpecificMethod (PIRP Irp, PFNKSHANDLER Handler);

KSDDKAPI NTSTATUS NTAPI KsReadFile
			(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext,
			 PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
			 ULONG Key, KPROCESSOR_MODE RequestorMode);

KSDDKAPI NTSTATUS NTAPI KsWriteFile
			(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext,
			 PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
			 ULONG Key, KPROCESSOR_MODE RequestorMode);

KSDDKAPI NTSTATUS NTAPI KsQueryInformationFile
			(PFILE_OBJECT FileObject, PVOID FileInformation, ULONG Length,
			 FILE_INFORMATION_CLASS FileInformationClass);

KSDDKAPI NTSTATUS NTAPI KsSetInformationFile
			(PFILE_OBJECT FileObject, PVOID FileInformation, ULONG Length,
			 FILE_INFORMATION_CLASS FileInformationClass);

KSDDKAPI NTSTATUS NTAPI KsStreamIo
			(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext,
			 PIO_COMPLETION_ROUTINE CompletionRoutine, PVOID CompletionContext,
			 KSCOMPLETION_INVOCATION CompletionInvocationFlags,
			 PIO_STATUS_BLOCK IoStatusBlock, PVOID StreamHeaders, ULONG Length,
			 ULONG Flags, KPROCESSOR_MODE RequestorMode);

KSDDKAPI NTSTATUS NTAPI KsProbeStreamIrp(PIRP Irp, ULONG ProbeFlags, ULONG HeaderSize);
KSDDKAPI NTSTATUS NTAPI KsAllocateExtraData(PIRP Irp, ULONG ExtraSize, PVOID *ExtraBuffer);
KSDDKAPI VOID NTAPI KsNullDriverUnload (PDRIVER_OBJECT DriverObject);

KSDDKAPI NTSTATUS NTAPI KsSetMajorFunctionHandler
			(PDRIVER_OBJECT DriverObject, ULONG MajorFunction);

KSDDKAPI NTSTATUS NTAPI KsDispatchInvalidDeviceRequest
			(PDEVICE_OBJECT DeviceObject, PIRP Irp);

KSDDKAPI NTSTATUS NTAPI KsDefaultDeviceIoCompletion
			(PDEVICE_OBJECT DeviceObject, PIRP Irp);

KSDDKAPI NTSTATUS NTAPI KsDispatchIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);

KSDDKAPI BOOLEAN NTAPI KsDispatchFastIoDeviceControlFailure
			(PFILE_OBJECT FileObject, BOOLEAN Wait, PVOID InputBuffer,
			 ULONG InputBufferLength, PVOID OutputBuffer,
			 ULONG OutputBufferLength, ULONG IoControlCode,
			 PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject);

KSDDKAPI BOOLEAN NTAPI KsDispatchFastReadFailure
			(PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset,
			 ULONG Length, BOOLEAN Wait, ULONG LockKey, PVOID Buffer,
			 PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject);

#define KsDispatchFastWriteFailure		KsDispatchFastReadFailure

KSDDKAPI VOID NTAPI KsCancelRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp);
KSDDKAPI VOID NTAPI KsCancelIo(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock);
KSDDKAPI VOID NTAPI KsReleaseIrpOnCancelableQueue(PIRP Irp, PDRIVER_CANCEL DriverCancel);

KSDDKAPI PIRP NTAPI KsRemoveIrpFromCancelableQueue
			(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock,
			 KSLIST_ENTRY_LOCATION ListLocation,
			 KSIRP_REMOVAL_OPERATION RemovalOperation);

KSDDKAPI NTSTATUS NTAPI KsMoveIrpsOnCancelableQueue
			(PLIST_ENTRY SourceList, PKSPIN_LOCK SourceLock,
			 PLIST_ENTRY DestinationList, PKSPIN_LOCK DestinationLock,
			 KSLIST_ENTRY_LOCATION ListLocation,
			 PFNKSIRPLISTCALLBACK ListCallback, PVOID Context);

KSDDKAPI VOID NTAPI KsRemoveSpecificIrpFromCancelableQueue (PIRP Irp);

KSDDKAPI VOID NTAPI KsAddIrpToCancelableQueue
			(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock, PIRP Irp,
			 KSLIST_ENTRY_LOCATION ListLocation, PDRIVER_CANCEL DriverCancel);

KSDDKAPI NTSTATUS NTAPI KsAcquireResetValue(PIRP Irp, KSRESET *ResetValue);

KSDDKAPI NTSTATUS NTAPI KsTopologyPropertyHandler
			(PIRP Irp, PKSPROPERTY Property, PVOID Data,
			 const KSTOPOLOGY *Topology);

KSDDKAPI VOID NTAPI KsAcquireDeviceSecurityLock(KSDEVICE_HEADER Header, BOOLEAN Exclusive);
KSDDKAPI VOID NTAPI KsReleaseDeviceSecurityLock (KSDEVICE_HEADER Header);
KSDDKAPI NTSTATUS NTAPI KsDefaultDispatchPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
KSDDKAPI NTSTATUS NTAPI KsDefaultDispatchPower(PDEVICE_OBJECT DeviceObject, PIRP Irp);
KSDDKAPI NTSTATUS NTAPI KsDefaultForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);

KSDDKAPI VOID NTAPI KsSetDevicePnpAndBaseObject
			(KSDEVICE_HEADER Header, PDEVICE_OBJECT PnpDeviceObject,
			 PDEVICE_OBJECT BaseObject);

KSDDKAPI PDEVICE_OBJECT NTAPI KsQueryDevicePnpObject (KSDEVICE_HEADER Header);
KSDDKAPI ACCESS_MASK NTAPI KsQueryObjectAccessMask (KSOBJECT_HEADER Header);

KSDDKAPI VOID NTAPI KsRecalculateStackDepth
			(KSDEVICE_HEADER Header, BOOLEAN ReuseStackLocation);

KSDDKAPI VOID NTAPI KsSetTargetState
			(KSOBJECT_HEADER Header, KSTARGET_STATE TargetState);

KSDDKAPI VOID NTAPI KsSetTargetDeviceObject
			(KSOBJECT_HEADER Header, PDEVICE_OBJECT TargetDevice);

KSDDKAPI VOID NTAPI KsSetPowerDispatch
			(KSOBJECT_HEADER Header, PFNKSCONTEXT_DISPATCH PowerDispatch,
			 PVOID PowerContext);

KSDDKAPI PKSOBJECT_CREATE_ITEM NTAPI KsQueryObjectCreateItem (KSOBJECT_HEADER Header);

KSDDKAPI NTSTATUS NTAPI KsAllocateDeviceHeader
			(KSDEVICE_HEADER *Header, ULONG ItemsCount,
			 PKSOBJECT_CREATE_ITEM ItemsList);

KSDDKAPI VOID NTAPI KsFreeDeviceHeader (KSDEVICE_HEADER Header);

KSDDKAPI NTSTATUS NTAPI KsAllocateObjectHeader
			(KSOBJECT_HEADER *Header, ULONG ItemsCount,
			 PKSOBJECT_CREATE_ITEM ItemsList, PIRP Irp,
			 const KSDISPATCH_TABLE *Table);

KSDDKAPI VOID NTAPI KsFreeObjectHeader (KSOBJECT_HEADER Header);

KSDDKAPI NTSTATUS NTAPI KsAddObjectCreateItemToDeviceHeader
			(KSDEVICE_HEADER Header, PDRIVER_DISPATCH Create, PVOID Context,
			 PWSTR ObjectClass, PSECURITY_DESCRIPTOR SecurityDescriptor);

KSDDKAPI NTSTATUS NTAPI KsAddObjectCreateItemToObjectHeader
			(KSOBJECT_HEADER Header, PDRIVER_DISPATCH Create, PVOID Context,
			 PWSTR ObjectClass, PSECURITY_DESCRIPTOR SecurityDescriptor);

KSDDKAPI NTSTATUS NTAPI KsAllocateObjectCreateItem
			(KSDEVICE_HEADER Header, PKSOBJECT_CREATE_ITEM CreateItem,
			 BOOLEAN AllocateEntry, PFNKSITEMFREECALLBACK ItemFreeCallback);

KSDDKAPI NTSTATUS NTAPI KsFreeObjectCreateItem
			(KSDEVICE_HEADER Header, PUNICODE_STRING CreateItem);

KSDDKAPI NTSTATUS NTAPI KsFreeObjectCreateItemsByContext
			(KSDEVICE_HEADER Header, PVOID Context);

KSDDKAPI NTSTATUS NTAPI KsCreateDefaultSecurity
			(PSECURITY_DESCRIPTOR ParentSecurity,
			 PSECURITY_DESCRIPTOR *DefaultSecurity);

KSDDKAPI NTSTATUS NTAPI KsForwardIrp
			(PIRP Irp, PFILE_OBJECT FileObject, BOOLEAN ReuseStackLocation);

KSDDKAPI NTSTATUS NTAPI KsForwardAndCatchIrp
			(PDEVICE_OBJECT DeviceObject, PIRP Irp, PFILE_OBJECT FileObject,
			 KSSTACK_USE StackUse);

KSDDKAPI NTSTATUS NTAPI KsSynchronousIoControlDevice
			(PFILE_OBJECT FileObject, KPROCESSOR_MODE RequestorMode,
			 ULONG IoControl, PVOID InBuffer, ULONG InSize, PVOID OutBuffer,
			 ULONG OutSize, PULONG BytesReturned);

KSDDKAPI NTSTATUS NTAPI KsUnserializeObjectPropertiesFromRegistry
			(PFILE_OBJECT FileObject, HANDLE ParentKey,
			 PUNICODE_STRING RegistryPath);

KSDDKAPI NTSTATUS NTAPI KsCacheMedium
			(PUNICODE_STRING SymbolicLink, PKSPIN_MEDIUM Medium,
			 ULONG PinDirection);

KSDDKAPI NTSTATUS NTAPI KsRegisterWorker
			(WORK_QUEUE_TYPE WorkQueueType, PKSWORKER *Worker);

KSDDKAPI NTSTATUS NTAPI KsRegisterCountedWorker
			(WORK_QUEUE_TYPE WorkQueueType, PWORK_QUEUE_ITEM CountedWorkItem,
			 PKSWORKER *Worker);

KSDDKAPI VOID NTAPI KsUnregisterWorker (PKSWORKER Worker);
KSDDKAPI NTSTATUS NTAPI KsQueueWorkItem(PKSWORKER Worker, PWORK_QUEUE_ITEM WorkItem);
KSDDKAPI ULONG NTAPI KsIncrementCountedWorker (PKSWORKER Worker);
KSDDKAPI ULONG NTAPI KsDecrementCountedWorker (PKSWORKER Worker);

KSDDKAPI NTSTATUS NTAPI KsCreateTopologyNode
			(HANDLE ParentHandle, PKSNODE_CREATE NodeCreate,
			 ACCESS_MASK DesiredAccess, PHANDLE NodeHandle);

KSDDKAPI NTSTATUS NTAPI KsValidateTopologyNodeCreateRequest
			(PIRP Irp, PKSTOPOLOGY Topology, PKSNODE_CREATE *NodeCreate);

KSDDKAPI NTSTATUS NTAPI KsMergeAutomationTables
			(PKSAUTOMATION_TABLE *AutomationTableAB,
			 PKSAUTOMATION_TABLE AutomationTableA,
			 PKSAUTOMATION_TABLE AutomationTableB,
			 KSOBJECT_BAG Bag);

KSDDKAPI NTSTATUS NTAPI KsInitializeDriver
			(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPathName,
			 const KSDEVICE_DESCRIPTOR *Descriptor);

KSDDKAPI NTSTATUS NTAPI KsAddDevice
			(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject);

KSDDKAPI NTSTATUS NTAPI KsCreateDevice
			(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject,
			 const KSDEVICE_DESCRIPTOR *Descriptor, ULONG ExtensionSize,
			 PKSDEVICE *Device);

KSDDKAPI NTSTATUS NTAPI KsInitializeDevice
			(PDEVICE_OBJECT FunctionalDeviceObject,
			 PDEVICE_OBJECT PhysicalDeviceObject,
			 PDEVICE_OBJECT NextDeviceObject,
			 const KSDEVICE_DESCRIPTOR *Descriptor);

KSDDKAPI void NTAPI KsTerminateDevice (PDEVICE_OBJECT DeviceObject);
KSDDKAPI PKSDEVICE NTAPI KsGetDeviceForDeviceObject (PDEVICE_OBJECT FunctionalDeviceObject);
KSDDKAPI void NTAPI KsAcquireDevice (PKSDEVICE Device);
KSDDKAPI void NTAPI KsReleaseDevice (PKSDEVICE Device);

KSDDKAPI void NTAPI KsDeviceRegisterAdapterObject
			(PKSDEVICE Device, PADAPTER_OBJECT AdapterObject,
			 ULONG MaxMappingsByteCount, ULONG MappingTableStride);

KSDDKAPI ULONG NTAPI KsDeviceGetBusData
			(PKSDEVICE Device, ULONG DataType, PVOID Buffer, ULONG Offset,
			 ULONG Length);

KSDDKAPI ULONG NTAPI KsDeviceSetBusData
			(PKSDEVICE Device, ULONG DataType, PVOID Buffer, ULONG Offset,
			 ULONG Length);

KSDDKAPI NTSTATUS NTAPI KsCreateFilterFactory
			(PDEVICE_OBJECT DeviceObject, const KSFILTER_DESCRIPTOR *Descriptor,
			 PWSTR RefString, PSECURITY_DESCRIPTOR SecurityDescriptor,
			 ULONG CreateItemFlags, PFNKSFILTERFACTORYPOWER SleepCallback,
			 PFNKSFILTERFACTORYPOWER WakeCallback,
			 PKSFILTERFACTORY *FilterFactory);

#define KsDeleteFilterFactory(FilterFactory)												\
	KsFreeObjectCreateItemsByContext( *(KSDEVICE_HEADER *)(										\
						KsFilterFactoryGetParentDevice(FilterFactory)->FunctionalDeviceObject->DeviceExtension),\
					   FilterFactory)

KSDDKAPI NTSTATUS NTAPI KsFilterFactoryUpdateCacheData
			(PKSFILTERFACTORY FilterFactory,
			 const KSFILTER_DESCRIPTOR *FilterDescriptor);

KSDDKAPI NTSTATUS NTAPI KsFilterFactoryAddCreateItem
			(PKSFILTERFACTORY FilterFactory, PWSTR RefString,
			 PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG CreateItemFlags);

KSDDKAPI NTSTATUS NTAPI KsFilterFactorySetDeviceClassesState
			(PKSFILTERFACTORY FilterFactory, BOOLEAN NewState);

KSDDKAPI PUNICODE_STRING NTAPI KsFilterFactoryGetSymbolicLink
			(PKSFILTERFACTORY FilterFactory);

KSDDKAPI void NTAPI KsAddEvent(PVOID Object, PKSEVENT_ENTRY EventEntry);

void __forceinline KsFilterAddEvent (PKSFILTER Filter, PKSEVENT_ENTRY EventEntry)
{
	KsAddEvent(Filter, EventEntry);
}

void __forceinline KsPinAddEvent (PKSPIN Pin, PKSEVENT_ENTRY EventEntry)
{
	KsAddEvent(Pin, EventEntry);
}

KSDDKAPI NTSTATUS NTAPI KsDefaultAddEventHandler
			(PIRP Irp, PKSEVENTDATA EventData, PKSEVENT_ENTRY EventEntry);

KSDDKAPI void NTAPI KsGenerateEvents
			(PVOID Object, const GUID *EventSet, ULONG EventId,
			 ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack,
			 PVOID CallBackContext);

void __forceinline KsFilterGenerateEvents
			(PKSFILTER Filter, const GUID *EventSet, ULONG EventId,
			 ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack,
			 PVOID CallBackContext)
{
	KsGenerateEvents(Filter, EventSet, EventId, DataSize, Data, CallBack,
			 CallBackContext);
}

void __forceinline KsPinGenerateEvents
			(PKSPIN Pin, const GUID *EventSet, ULONG EventId,
			 ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack,
			 PVOID CallBackContext)
{
	KsGenerateEvents(Pin, EventSet, EventId, DataSize, Data, CallBack,
			 CallBackContext);
}

typedef enum {
  KSSTREAM_POINTER_STATE_UNLOCKED = 0,
  KSSTREAM_POINTER_STATE_LOCKED
} KSSTREAM_POINTER_STATE;

KSDDKAPI NTSTATUS NTAPI KsPinGetAvailableByteCount
			(PKSPIN Pin, PLONG InputDataBytes, PLONG OutputBufferBytes);

KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetLeadingEdgeStreamPointer
			(PKSPIN Pin, KSSTREAM_POINTER_STATE State);

KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetTrailingEdgeStreamPointer
			(PKSPIN Pin, KSSTREAM_POINTER_STATE State);

KSDDKAPI NTSTATUS NTAPI KsStreamPointerSetStatusCode
			(PKSSTREAM_POINTER StreamPointer, NTSTATUS Status);

KSDDKAPI NTSTATUS NTAPI KsStreamPointerLock (PKSSTREAM_POINTER StreamPointer);
KSDDKAPI void NTAPI KsStreamPointerUnlock(PKSSTREAM_POINTER StreamPointer, BOOLEAN Eject);

KSDDKAPI void NTAPI KsStreamPointerAdvanceOffsetsAndUnlock
			(PKSSTREAM_POINTER StreamPointer, ULONG InUsed, ULONG OutUsed,
			 BOOLEAN Eject);

KSDDKAPI void NTAPI KsStreamPointerDelete (PKSSTREAM_POINTER StreamPointer);

KSDDKAPI NTSTATUS NTAPI KsStreamPointerClone
			(PKSSTREAM_POINTER StreamPointer, PFNKSSTREAMPOINTER CancelCallback,
			 ULONG ContextSize, PKSSTREAM_POINTER *CloneStreamPointer);

KSDDKAPI NTSTATUS NTAPI KsStreamPointerAdvanceOffsets
			(PKSSTREAM_POINTER StreamPointer, ULONG InUsed, ULONG OutUsed,
			 BOOLEAN Eject);

KSDDKAPI NTSTATUS NTAPI KsStreamPointerAdvance (PKSSTREAM_POINTER StreamPointer);
KSDDKAPI PMDL NTAPI KsStreamPointerGetMdl (PKSSTREAM_POINTER StreamPointer);

KSDDKAPI PIRP NTAPI KsStreamPointerGetIrp
			(PKSSTREAM_POINTER StreamPointer, PBOOLEAN FirstFrameInIrp,
			 PBOOLEAN LastFrameInIrp);

KSDDKAPI void NTAPI KsStreamPointerScheduleTimeout
			(PKSSTREAM_POINTER StreamPointer, PFNKSSTREAMPOINTER Callback,
			 ULONGLONG Interval);

KSDDKAPI void NTAPI KsStreamPointerCancelTimeout (PKSSTREAM_POINTER StreamPointer);
KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetFirstCloneStreamPointer (PKSPIN Pin);

KSDDKAPI PKSSTREAM_POINTER NTAPI KsStreamPointerGetNextClone
			(PKSSTREAM_POINTER StreamPointer);

KSDDKAPI NTSTATUS NTAPI KsPinHandshake(PKSPIN Pin, PKSHANDSHAKE In, PKSHANDSHAKE Out);
KSDDKAPI void NTAPI KsCompletePendingRequest (PIRP Irp);
KSDDKAPI KSOBJECTTYPE NTAPI KsGetObjectTypeFromIrp (PIRP Irp);
KSDDKAPI PVOID NTAPI KsGetObjectFromFileObject (PFILE_OBJECT FileObject);
KSDDKAPI KSOBJECTTYPE NTAPI KsGetObjectTypeFromFileObject (PFILE_OBJECT FileObject);

PKSFILTER __forceinline KsGetFilterFromFileObject (PFILE_OBJECT FileObject)
{
	return (PKSFILTER) KsGetObjectFromFileObject(FileObject);
}

PKSPIN __forceinline KsGetPinFromFileObject (PFILE_OBJECT FileObject)
{
	return (PKSPIN) KsGetObjectFromFileObject(FileObject);
}

KSDDKAPI PKSGATE NTAPI KsFilterGetAndGate (PKSFILTER Filter);
KSDDKAPI void NTAPI KsFilterAcquireProcessingMutex (PKSFILTER Filter);
KSDDKAPI void NTAPI KsFilterReleaseProcessingMutex (PKSFILTER Filter);
KSDDKAPI void NTAPI KsFilterAttemptProcessing(PKSFILTER Filter, BOOLEAN Asynchronous);
KSDDKAPI PKSGATE NTAPI KsPinGetAndGate(PKSPIN Pin);
KSDDKAPI void NTAPI KsPinAttachAndGate(PKSPIN Pin, PKSGATE AndGate);
KSDDKAPI void NTAPI KsPinAttachOrGate (PKSPIN Pin, PKSGATE OrGate);
KSDDKAPI void NTAPI KsPinAcquireProcessingMutex (PKSPIN Pin);
KSDDKAPI void NTAPI KsPinReleaseProcessingMutex (PKSPIN Pin);
KSDDKAPI BOOLEAN NTAPI KsProcessPinUpdate (PKSPROCESSPIN ProcessPin);

KSDDKAPI void NTAPI KsPinGetCopyRelationships
			(PKSPIN Pin, PKSPIN *CopySource, PKSPIN *DelegateBranch);

KSDDKAPI void NTAPI KsPinAttemptProcessing(PKSPIN Pin, BOOLEAN Asynchronous);
KSDDKAPI PVOID NTAPI KsGetParent (PVOID Object);

PKSDEVICE __forceinline KsFilterFactoryGetParentDevice (PKSFILTERFACTORY FilterFactory)
{
	return (PKSDEVICE) KsGetParent((PVOID) FilterFactory);
}

PKSFILTERFACTORY __forceinline KsFilterGetParentFilterFactory (PKSFILTER Filter)
{
	return (PKSFILTERFACTORY) KsGetParent((PVOID) Filter);
}

KSDDKAPI PKSFILTER NTAPI KsPinGetParentFilter (PKSPIN Pin);
KSDDKAPI PVOID NTAPI KsGetFirstChild (PVOID Object);

PKSFILTERFACTORY __forceinline KsDeviceGetFirstChildFilterFactory (PKSDEVICE Device)
{
	return (PKSFILTERFACTORY) KsGetFirstChild((PVOID) Device);
}

PKSFILTER __forceinline KsFilterFactoryGetFirstChildFilter (PKSFILTERFACTORY FilterFactory)
{
	return (PKSFILTER) KsGetFirstChild((PVOID) FilterFactory);
}

KSDDKAPI ULONG NTAPI KsFilterGetChildPinCount(PKSFILTER Filter, ULONG PinId);
KSDDKAPI PKSPIN NTAPI KsFilterGetFirstChildPin(PKSFILTER Filter, ULONG PinId);
KSDDKAPI PVOID NTAPI KsGetNextSibling (PVOID Object);
KSDDKAPI PKSPIN NTAPI KsPinGetNextSiblingPin (PKSPIN Pin);

PKSFILTERFACTORY __forceinline KsFilterFactoryGetNextSiblingFilterFactory
			(PKSFILTERFACTORY FilterFactory)
{
	return (PKSFILTERFACTORY) KsGetNextSibling((PVOID) FilterFactory);
}

PKSFILTER __forceinline KsFilterGetNextSiblingFilter (PKSFILTER Filter)
{
	return (PKSFILTER) KsGetNextSibling((PVOID) Filter);
}

KSDDKAPI PKSDEVICE NTAPI KsGetDevice (PVOID Object);

PKSDEVICE __forceinline KsFilterFactoryGetDevice (PKSFILTERFACTORY FilterFactory)
{
	return KsGetDevice((PVOID) FilterFactory);
}

PKSDEVICE __forceinline KsFilterGetDevice (PKSFILTER Filter)
{
	return KsGetDevice((PVOID) Filter);
}

PKSDEVICE __forceinline KsPinGetDevice (PKSPIN Pin)
{
	return KsGetDevice((PVOID) Pin);
}

KSDDKAPI PKSFILTER NTAPI KsGetFilterFromIrp (PIRP Irp);
KSDDKAPI PKSPIN NTAPI KsGetPinFromIrp (PIRP Irp);
KSDDKAPI ULONG NTAPI KsGetNodeIdFromIrp (PIRP Irp);
KSDDKAPI void NTAPI KsAcquireControl (PVOID Object);
KSDDKAPI void NTAPI KsReleaseControl (PVOID Object);

void __forceinline KsFilterAcquireControl (PKSFILTER Filter)
{
	KsAcquireControl((PVOID) Filter);
}

void __forceinline KsFilterReleaseControl (PKSFILTER Filter)
{
	KsReleaseControl((PVOID) Filter);
}

void __forceinline KsPinAcquireControl (PKSPIN Pin)
{
	KsAcquireControl((PVOID) Pin);
}

void __forceinline KsPinReleaseControl (PKSPIN Pin)
{
	KsReleaseControl((PVOID) Pin);
}

KSDDKAPI NTSTATUS NTAPI KsAddItemToObjectBag
			(KSOBJECT_BAG ObjectBag, PVOID Item, PFNKSFREE Free);

KSDDKAPI ULONG NTAPI KsRemoveItemFromObjectBag
			(KSOBJECT_BAG ObjectBag, PVOID Item, BOOLEAN Free);

#define KsDiscard(Object,Pointer)					\
	KsRemoveItemFromObjectBag((Object)->Bag, (PVOID)(Pointer), TRUE)

KSDDKAPI NTSTATUS NTAPI KsAllocateObjectBag(PKSDEVICE Device, KSOBJECT_BAG *ObjectBag);
KSDDKAPI void NTAPI KsFreeObjectBag (KSOBJECT_BAG ObjectBag);

KSDDKAPI NTSTATUS NTAPI KsCopyObjectBagItems
			(KSOBJECT_BAG ObjectBagDestination, KSOBJECT_BAG ObjectBagSource);

KSDDKAPI NTSTATUS NTAPI _KsEdit
			(KSOBJECT_BAG ObjectBag, PVOID *PointerToPointerToItem,
			 ULONG NewSize, ULONG OldSize, ULONG Tag);

#define KsEdit(Object, PointerToPointer, Tag)						\
	_KsEdit((Object)->Bag, (PVOID*)(PointerToPointer),				\
		sizeof(**(PointerToPointer)), sizeof(**(PointerToPointer)), (Tag))

#define KsEditSized(Object, PointerToPointer, NewSize, OldSize, Tag)			\
	_KsEdit((Object)->Bag, (PVOID*)(PointerToPointer), (NewSize), (OldSize), (Tag))

KSDDKAPI NTSTATUS NTAPI KsRegisterFilterWithNoKSPins
			(PDEVICE_OBJECT DeviceObject, const GUID *InterfaceClassGUID,
			 ULONG PinCount, WINBOOL *PinDirection, KSPIN_MEDIUM *MediumList,
			 GUID *CategoryList);

KSDDKAPI NTSTATUS NTAPI KsFilterCreatePinFactory
			(PKSFILTER Filter, const KSPIN_DESCRIPTOR_EX *const PinDescriptor,
			 PULONG PinID);

KSDDKAPI NTSTATUS NTAPI KsFilterCreateNode
			(PKSFILTER Filter, const KSNODE_DESCRIPTOR *const NodeDescriptor,
			 PULONG NodeID);

KSDDKAPI NTSTATUS NTAPI KsFilterAddTopologyConnections
			(PKSFILTER Filter, ULONG NewConnectionsCount,
			 const KSTOPOLOGY_CONNECTION *const NewTopologyConnections);

KSDDKAPI NTSTATUS NTAPI KsPinGetConnectedPinInterface
			(PKSPIN Pin, const GUID *InterfaceId, PVOID *Interface);

KSDDKAPI PFILE_OBJECT NTAPI KsPinGetConnectedPinFileObject (PKSPIN Pin);
KSDDKAPI PDEVICE_OBJECT NTAPI KsPinGetConnectedPinDeviceObject (PKSPIN Pin);

KSDDKAPI NTSTATUS NTAPI KsPinGetConnectedFilterInterface
			(PKSPIN Pin, const GUID *InterfaceId, PVOID *Interface);

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
KSDDKAPI NTSTATUS NTAPI KsPinGetReferenceClockInterface
			(PKSPIN Pin, PIKSREFERENCECLOCK *Interface);
#endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */

KSDDKAPI VOID NTAPI KsPinSetPinClockTime(PKSPIN Pin, LONGLONG Time);

KSDDKAPI NTSTATUS NTAPI KsPinSubmitFrame
			(PKSPIN Pin, PVOID Data, ULONG Size,
			 PKSSTREAM_HEADER StreamHeader, PVOID Context);

KSDDKAPI NTSTATUS NTAPI KsPinSubmitFrameMdl
			(PKSPIN Pin, PMDL Mdl, PKSSTREAM_HEADER StreamHeader,
			 PVOID Context);

KSDDKAPI void NTAPI KsPinRegisterFrameReturnCallback
			(PKSPIN Pin, PFNKSPINFRAMERETURN FrameReturn);

KSDDKAPI void NTAPI KsPinRegisterIrpCompletionCallback
			(PKSPIN Pin, PFNKSPINIRPCOMPLETION IrpCompletion);

KSDDKAPI void NTAPI KsPinRegisterHandshakeCallback
			(PKSPIN Pin, PFNKSPINHANDSHAKE Handshake);

KSDDKAPI void NTAPI KsFilterRegisterPowerCallbacks
			(PKSFILTER Filter, PFNKSFILTERPOWER Sleep, PFNKSFILTERPOWER Wake);

KSDDKAPI void NTAPI KsPinRegisterPowerCallbacks
			(PKSPIN Pin, PFNKSPINPOWER Sleep, PFNKSPINPOWER Wake);

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
KSDDKAPI PUNKNOWN NTAPI KsRegisterAggregatedClientUnknown
			(PVOID Object, PUNKNOWN ClientUnknown);

KSDDKAPI PUNKNOWN NTAPI KsGetOuterUnknown (PVOID Object);

PUNKNOWN __forceinline KsDeviceRegisterAggregatedClientUnknown
			(PKSDEVICE Device, PUNKNOWN ClientUnknown)
{
	return KsRegisterAggregatedClientUnknown((PVOID)Device, ClientUnknown);
}

PUNKNOWN __forceinline KsDeviceGetOuterUnknown (PKSDEVICE Device)
{
	return KsGetOuterUnknown((PVOID) Device);
}

PUNKNOWN __forceinline KsFilterFactoryRegisterAggregatedClientUnknown
			(PKSFILTERFACTORY FilterFactory, PUNKNOWN ClientUnknown)
{
	return KsRegisterAggregatedClientUnknown((PVOID)FilterFactory, ClientUnknown);
}

PUNKNOWN __forceinline KsFilterFactoryGetOuterUnknown (PKSFILTERFACTORY FilterFactory)
{
	return KsGetOuterUnknown((PVOID)FilterFactory);
}

PUNKNOWN __forceinline KsFilterRegisterAggregatedClientUnknown
			(PKSFILTER Filter, PUNKNOWN ClientUnknown)
{
	return KsRegisterAggregatedClientUnknown((PVOID)Filter, ClientUnknown);
}

PUNKNOWN __forceinline KsFilterGetOuterUnknown (PKSFILTER Filter)
{
	return KsGetOuterUnknown((PVOID)Filter);
}

PUNKNOWN __forceinline KsPinRegisterAggregatedClientUnknown
			(PKSPIN Pin, PUNKNOWN ClientUnknown)
{
	return KsRegisterAggregatedClientUnknown((PVOID)Pin, ClientUnknown);
}

PUNKNOWN __forceinline KsPinGetOuterUnknown (PKSPIN Pin)
{
	return KsGetOuterUnknown((PVOID)Pin);
}
#endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */

#else /* _NTDDK_ */

#ifndef KS_NO_CREATE_FUNCTIONS
KSDDKAPI DWORD WINAPI KsCreateAllocator(HANDLE ConnectionHandle,PKSALLOCATOR_FRAMING AllocatorFraming,PHANDLE AllocatorHandle);
KSDDKAPI DWORD NTAPI KsCreateClock(HANDLE ConnectionHandle,PKSCLOCK_CREATE ClockCreate,PHANDLE ClockHandle);
KSDDKAPI DWORD WINAPI KsCreatePin(HANDLE FilterHandle,PKSPIN_CONNECT Connect,ACCESS_MASK DesiredAccess,PHANDLE ConnectionHandle);
KSDDKAPI DWORD WINAPI KsCreateTopologyNode(HANDLE ParentHandle,PKSNODE_CREATE NodeCreate,ACCESS_MASK DesiredAccess,PHANDLE NodeHandle);
#endif

#endif /* _NTDDK_ */

#ifdef __cplusplus
}
#endif

#define DENY_USERMODE_ACCESS(pIrp,CompleteRequest)			\
	if(pIrp->RequestorMode!=KernelMode) {				\
		pIrp->IoStatus.Information = 0;				\
		pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;	\
		if(CompleteRequest)					\
			IoCompleteRequest (pIrp,IO_NO_INCREMENT);	\
		return STATUS_INVALID_DEVICE_REQUEST;			\
	}

#endif /* _KS_ */

/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define INITGUID
#include <guiddef.h>

#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif

#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#endif

#ifdef __cplusplus
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID DECLSPEC_SELECTANY name = { STATICGUIDOF(name) }
#else
#define DEFINE_GUIDEX(name) const CDECL GUID DECLSPEC_SELECTANY name = { STATICGUIDOF(name) }
#endif
#ifndef STATICGUIDOF
#define STATICGUIDOF(guid) STATIC_##guid
#endif

#ifndef DEFINE_WAVEFORMATEX_GUID
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x),0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
#endif
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(_KS_)
#warning ks.h must be included before ksmedia.h
// (amalg) #include "ks.h"
#endif

#if __GNUC__ >= 3
#pragma GCC system_header
#endif

#if !defined(_KSMEDIA_)
#define _KSMEDIA_

typedef struct {
  KSPROPERTY Property;
  KSMULTIPLE_ITEM MultipleItem;
} KSMULTIPLE_DATA_PROP,*PKSMULTIPLE_DATA_PROP;

#define STATIC_KSMEDIUMSETID_MidiBus					\
	0x05908040L,0x3246,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000",KSMEDIUMSETID_MidiBus);
#define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)

#define STATIC_KSMEDIUMSETID_VPBus					\
	0xA18C15ECL,0xCE43,0x11D0,0xAB,0xE7,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196",KSMEDIUMSETID_VPBus);
#define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)

#define STATIC_KSINTERFACESETID_Media					\
	0x3A13EB40L,0x30A7,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000",KSINTERFACESETID_Media);
#define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)

typedef enum {
  KSINTERFACE_MEDIA_MUSIC,
  KSINTERFACE_MEDIA_WAVE_BUFFERED,
  KSINTERFACE_MEDIA_WAVE_QUEUED
} KSINTERFACE_MEDIA;

#ifndef INIT_USBAUDIO_MID
#define INIT_USBAUDIO_MID(guid,id)					\
{									\
	(guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);			\
	(guid)->Data2 = 0x1679;						\
	(guid)->Data3 = 0x463b;						\
	(guid)->Data4[0] = 0xa7;					\
	(guid)->Data4[1] = 0x2f;					\
	(guid)->Data4[2] = 0xa5;					\
	(guid)->Data4[3] = 0xbf;					\
	(guid)->Data4[4] = 0x64;					\
	(guid)->Data4[5] = 0xc8;					\
	(guid)->Data4[6] = 0x6e;					\
	(guid)->Data4[7] = 0xba;					\
}
#define EXTRACT_USBAUDIO_MID(guid)					\
	(USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)					\
	0x4e1cecd2+(USHORT)(id),0x1679,0x463b,0xa7,0x2f,0xa5,0xbf,0x64,0xc8,0x6e,0xba
#define IS_COMPATIBLE_USBAUDIO_MID(guid)				\
	(((guid)->Data1 >= 0x4e1cecd2) &&				\
	 ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&			\
	 ((guid)->Data2 == 0x1679) &&					\
	 ((guid)->Data3 == 0x463b) &&					\
	 ((guid)->Data4[0] == 0xa7) &&					\
	 ((guid)->Data4[1] == 0x2f) &&					\
	 ((guid)->Data4[2] == 0xa5) &&					\
	 ((guid)->Data4[3] == 0xbf) &&					\
	 ((guid)->Data4[4] == 0x64) &&					\
	 ((guid)->Data4[5] == 0xc8) &&					\
	 ((guid)->Data4[6] == 0x6e) &&					\
	 ((guid)->Data4[7] == 0xba) )
#endif /* INIT_USBAUDIO_MID */

#ifndef INIT_USBAUDIO_PID
#define INIT_USBAUDIO_PID(guid,id)					\
{									\
	(guid)->Data1 = 0xabcc5a5e + (USHORT)(id);			\
	(guid)->Data2 = 0xc263;						\
	(guid)->Data3 = 0x463b;						\
	(guid)->Data4[0] = 0xa7;					\
	(guid)->Data4[1] = 0x2f;					\
	(guid)->Data4[2] = 0xa5;					\
	(guid)->Data4[3] = 0xbf;					\
	(guid)->Data4[4] = 0x64;					\
	(guid)->Data4[5] = 0xc8;					\
	(guid)->Data4[6] = 0x6e;					\
	(guid)->Data4[7] = 0xba;					\
}
#define EXTRACT_USBAUDIO_PID(guid)					\
	(USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)					\
	0xabcc5a5e+(USHORT)(id),0xc263,0x463b,0xa7,0x2f,0xa5,0xbf,0x64,0xc8,0x6e,0xba
#define IS_COMPATIBLE_USBAUDIO_PID(guid)				\
	(((guid)->Data1 >= 0xabcc5a5e) &&				\
	 ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&			\
	 ((guid)->Data2 == 0xc263) &&					\
	 ((guid)->Data3 == 0x463b) &&					\
	 ((guid)->Data4[0] == 0xa7) &&					\
	 ((guid)->Data4[1] == 0x2f) &&					\
	 ((guid)->Data4[2] == 0xa5) &&					\
	 ((guid)->Data4[3] == 0xbf) &&					\
	 ((guid)->Data4[4] == 0x64) &&					\
	 ((guid)->Data4[5] == 0xc8) &&					\
	 ((guid)->Data4[6] == 0x6e) &&					\
	 ((guid)->Data4[7] == 0xba) )
#endif /* INIT_USBAUDIO_PID */

#ifndef INIT_USBAUDIO_PRODUCT_NAME
#define INIT_USBAUDIO_PRODUCT_NAME(guid,vid,pid,strIndex)		\
{									\
	(guid)->Data1 = 0XFC575048 + (USHORT)(vid);			\
	(guid)->Data2 = 0x2E08 + (USHORT)(pid);				\
	(guid)->Data3 = 0x463B + (USHORT)(strIndex);			\
	(guid)->Data4[0] = 0xA7;					\
	(guid)->Data4[1] = 0x2F;					\
	(guid)->Data4[2] = 0xA5;					\
	(guid)->Data4[3] = 0xBF;					\
	(guid)->Data4[4] = 0x64;					\
	(guid)->Data4[5] = 0xC8;					\
	(guid)->Data4[6] = 0x6E;					\
	(guid)->Data4[7] = 0xBA;					\
}
#define DEFINE_USBAUDIO_PRODUCT_NAME(vid,pid,strIndex)			\
	0xFC575048+(USHORT)(vid),0x2E08+(USHORT)(pid),0x463B+(USHORT)(strIndex),0xA7,0x2F,0xA5,0xBF,0x64,0xC8,0x6E,0xBA
#endif /* INIT_USBAUDIO_PRODUCT_NAME */

#define STATIC_KSCOMPONENTID_USBAUDIO					\
	0x8F1275F0,0x26E9,0x4264,0xBA,0x4D,0x39,0xFF,0xF0,0x1D,0x94,0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA",KSCOMPONENTID_USBAUDIO);
#define KSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(KSCOMPONENTID_USBAUDIO)

#define INIT_USB_TERMINAL(guid,id)					\
{									\
	(guid)->Data1 = 0xDFF219E0 + (USHORT)(id);			\
	(guid)->Data2 = 0xF70F;						\
	(guid)->Data3 = 0x11D0;						\
	(guid)->Data4[0] = 0xb9;					\
	(guid)->Data4[1] = 0x17;					\
	(guid)->Data4[2] = 0x00;					\
	(guid)->Data4[3] = 0xa0;					\
	(guid)->Data4[4] = 0xc9;					\
	(guid)->Data4[5] = 0x22;					\
	(guid)->Data4[6] = 0x31;					\
	(guid)->Data4[7] = 0x96;					\
}
#define EXTRACT_USB_TERMINAL(guid)					\
	(USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)					\
	0xDFF219E0+(USHORT)(id),0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96

#define STATIC_KSNODETYPE_MICROPHONE					\
	DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_MICROPHONE);
#define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)

#define STATIC_KSNODETYPE_DESKTOP_MICROPHONE				\
	DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DESKTOP_MICROPHONE);
#define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_KSNODETYPE_PERSONAL_MICROPHONE				\
	DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_PERSONAL_MICROPHONE);
#define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE			\
	DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY				\
	DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_MICROPHONE_ARRAY);
#define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY			\
	DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196",KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#define STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR			\
	0x830a44f2,0xa32d,0x476b,0xbe,0x97,0x42,0x84,0x56,0x73,0xb3,0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a",KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_KSNODETYPE_SPEAKER					\
	DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_SPEAKER);
#define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)

#define STATIC_KSNODETYPE_HEADPHONES					\
	DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_HEADPHONES);
#define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)

#define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO			\
	DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_KSNODETYPE_DESKTOP_SPEAKER				\
	DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DESKTOP_SPEAKER);
#define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_KSNODETYPE_ROOM_SPEAKER					\
	DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_ROOM_SPEAKER);
#define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)

#define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER				\
	DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196",KSNODETYPE_COMMUNICATION_SPEAKER);
#define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER			\
	DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196",KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_KSNODETYPE_HANDSET					\
	DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_HANDSET);
#define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)

#define STATIC_KSNODETYPE_HEADSET					\
	DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_HEADSET);
#define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)

#define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION		\
	DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE			\
	DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE			\
	DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_PHONE_LINE					\
	DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_PHONE_LINE);
#define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)

#define STATIC_KSNODETYPE_TELEPHONE					\
	DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_TELEPHONE);
#define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)

#define STATIC_KSNODETYPE_DOWN_LINE_PHONE				\
	DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DOWN_LINE_PHONE);
#define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_KSNODETYPE_ANALOG_CONNECTOR				\
	DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_ANALOG_CONNECTOR);
#define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE			\
	DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_KSNODETYPE_LINE_CONNECTOR				\
	DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_LINE_CONNECTOR);
#define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)

#define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR			\
	DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_KSNODETYPE_SPDIF_INTERFACE				\
	DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_SPDIF_INTERFACE);
#define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)

#define STATIC_KSNODETYPE_1394_DA_STREAM				\
	DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196",KSNODETYPE_1394_DA_STREAM);
#define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)

#define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK			\
	DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196",KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE		\
	DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_KSNODETYPE_EQUALIZATION_NOISE				\
	DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_EQUALIZATION_NOISE);
#define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_KSNODETYPE_CD_PLAYER					\
	DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_CD_PLAYER);
#define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)

#define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE			\
	DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE		\
	DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_KSNODETYPE_MINIDISK					\
	DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196",KSNODETYPE_MINIDISK);
#define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)

#define STATIC_KSNODETYPE_ANALOG_TAPE					\
	DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196",KSNODETYPE_ANALOG_TAPE);
#define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)

#define STATIC_KSNODETYPE_PHONOGRAPH					\
	DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196",KSNODETYPE_PHONOGRAPH);
#define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)

#define STATIC_KSNODETYPE_VCR_AUDIO					\
	DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VCR_AUDIO);
#define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)

#define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO				\
	DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_DISC_AUDIO);
#define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_KSNODETYPE_DVD_AUDIO					\
	DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DVD_AUDIO);
#define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)

#define STATIC_KSNODETYPE_TV_TUNER_AUDIO				\
	DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196",KSNODETYPE_TV_TUNER_AUDIO);
#define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO			\
	DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196",KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO				\
	DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196",KSNODETYPE_CABLE_TUNER_AUDIO);
#define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_KSNODETYPE_DSS_AUDIO					\
	DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196",KSNODETYPE_DSS_AUDIO);
#define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)

#define STATIC_KSNODETYPE_RADIO_RECEIVER				\
	DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196",KSNODETYPE_RADIO_RECEIVER);
#define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)

#define STATIC_KSNODETYPE_RADIO_TRANSMITTER				\
	DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_RADIO_TRANSMITTER);
#define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_KSNODETYPE_MULTITRACK_RECORDER				\
	DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_MULTITRACK_RECORDER);
#define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_KSNODETYPE_SYNTHESIZER					\
	DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_SYNTHESIZER);
#define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)

#define STATIC_KSNODETYPE_SWSYNTH					\
	0x423274A0L,0x8B81,0x11D1,0xA0,0x50,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788",KSNODETYPE_SWSYNTH);
#define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)

#define STATIC_KSNODETYPE_SWMIDI					\
	0xCB9BEFA0L,0xA251,0x11D1,0xA0,0x50,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788",KSNODETYPE_SWMIDI);
#define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)

#define STATIC_KSNODETYPE_DRM_DESCRAMBLE				\
	0xFFBB6E3FL,0xCCFE,0x4D84,0x90,0xD9,0x42,0x14,0x18,0xB0,0x3A,0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E",KSNODETYPE_DRM_DESCRAMBLE);
#define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)

#define STATIC_KSCATEGORY_AUDIO						\
	0x6994AD04L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196",KSCATEGORY_AUDIO);
#define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)

#define STATIC_KSCATEGORY_VIDEO						\
	0x6994AD05L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196",KSCATEGORY_VIDEO);
#define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)

/* Added for Vista and later */
#define STATIC_KSCATEGORY_REALTIME \
    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", KSCATEGORY_REALTIME);
#define KSCATEGORY_REALTIME DEFINE_GUIDNAMED(KSCATEGORY_REALTIME)

#define STATIC_KSCATEGORY_TEXT						\
	0x6994AD06L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196",KSCATEGORY_TEXT);
#define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)

#define STATIC_KSCATEGORY_NETWORK					\
	0x67C9CC3CL,0x69C4,0x11D2,0x87,0x59,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196",KSCATEGORY_NETWORK);
#define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)

#define STATIC_KSCATEGORY_TOPOLOGY					\
	0xDDA54A40L,0x1E4C,0x11D1,0xA0,0x50,0x40,0x57,0x05,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000",KSCATEGORY_TOPOLOGY);
#define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)

#define STATIC_KSCATEGORY_VIRTUAL					\
	0x3503EAC4L,0x1F26,0x11D1,0x8A,0xB0,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196",KSCATEGORY_VIRTUAL);
#define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)

#define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL				\
	0xBF963D80L,0xC559,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1",KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSCATEGORY_SYSAUDIO					\
	0xA7C7A5B1L,0x5AF3,0x11D1,0x9C,0xED,0x00,0xA0,0x24,0xBF,0x04,0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407",KSCATEGORY_SYSAUDIO);
#define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)

#define STATIC_KSCATEGORY_WDMAUD					\
	0x3E227E76L,0x690D,0x11D2,0x81,0x61,0x00,0x00,0xF8,0x77,0x5B,0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1",KSCATEGORY_WDMAUD);
#define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)

#define STATIC_KSCATEGORY_AUDIO_GFX					\
	0x9BAF9572L,0x340C,0x11D3,0xAB,0xDC,0x00,0xA0,0xC9,0x0A,0xB1,0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F",KSCATEGORY_AUDIO_GFX);
#define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)

#define STATIC_KSCATEGORY_AUDIO_SPLITTER				\
	0x9EA331FAL,0xB91B,0x45F8,0x92,0x85,0xBD,0x2B,0xC7,0x7A,0xFC,0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE",KSCATEGORY_AUDIO_SPLITTER);
#define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)

#define STATIC_KSCATEGORY_SYNTHESIZER		STATIC_KSNODETYPE_SYNTHESIZER
#define KSCATEGORY_SYNTHESIZER			KSNODETYPE_SYNTHESIZER

#define STATIC_KSCATEGORY_DRM_DESCRAMBLE	STATIC_KSNODETYPE_DRM_DESCRAMBLE
#define KSCATEGORY_DRM_DESCRAMBLE		KSNODETYPE_DRM_DESCRAMBLE

#define STATIC_KSCATEGORY_AUDIO_DEVICE					\
	0xFBF6F530L,0x07B9,0x11D2,0xA7,0x1E,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788",KSCATEGORY_AUDIO_DEVICE);
#define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE			\
	0xD6C5066EL,0x72C1,0x11D2,0x97,0x55,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788",KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE			\
	0xD6C50671L,0x72C1,0x11D2,0x97,0x55,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788",KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE			\
	0xD6C50674L,0x72C1,0x11D2,0x97,0x55,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788",KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

#define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME				\
	0x47A4FA20L,0xA251,0x11D1,0xA0,0x50,0x00,0x00,0xF8,0x00,0x47,0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788",KSCATEGORY_WDMAUD_USE_PIN_NAME);
#define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)

#define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER			\
	0x74f3aea8L,0x9768,0x11d1,0x8e,0x07,0x00,0xa0,0xc9,0x5e,0xc2,0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e",KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

#define STATIC_KSDATAFORMAT_TYPE_VIDEO					\
	0x73646976L,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71",KSDATAFORMAT_TYPE_VIDEO);
#define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)

#define STATIC_KSDATAFORMAT_TYPE_AUDIO					\
	0x73647561L,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71",KSDATAFORMAT_TYPE_AUDIO);
#define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)

#define STATIC_KSDATAFORMAT_TYPE_TEXT					\
	0x73747874L,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71",KSDATAFORMAT_TYPE_TEXT);
#define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)

#if !defined(DEFINE_WAVEFORMATEX_GUID)
#define DEFINE_WAVEFORMATEX_GUID(x)					\
	(USHORT)(x),0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
#endif

#define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX			\
	0x00000000L,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)

#define INIT_WAVEFORMATEX_GUID(Guid,x)					\
{									\
	*(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;			\
	(Guid)->Data1 = (USHORT)(x);					\
}

#define EXTRACT_WAVEFORMATEX_ID(Guid)					\
	(USHORT)((Guid)->Data1)

#define IS_VALID_WAVEFORMATEX_GUID(Guid)				\
	(!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1,sizeof(GUID) - sizeof(USHORT)))

#ifndef INIT_MMREG_MID
#define INIT_MMREG_MID(guid,id)						\
{									\
	(guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);			\
	(guid)->Data2 = 0x6d98;						\
	(guid)->Data3 = 0x11d1;						\
	(guid)->Data4[0] = 0xa2;					\
	(guid)->Data4[1] = 0x1a;					\
	(guid)->Data4[2] = 0x00;					\
	(guid)->Data4[3] = 0xa0;					\
	(guid)->Data4[4] = 0xc9;					\
	(guid)->Data4[5] = 0x22;					\
	(guid)->Data4[6] = 0x31;					\
	(guid)->Data4[7] = 0x96;					\
}
#define EXTRACT_MMREG_MID(guid)						\
	(USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)					\
	0xd5a47fa7+(USHORT)(id),0x6d98,0x11d1,0xa2,0x1a,0x00,0xa0,0xc9,0x22,0x31,0x96

#define IS_COMPATIBLE_MMREG_MID(guid)					\
	(((guid)->Data1 >= 0xd5a47fa7) &&				\
	 ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&			\
	 ((guid)->Data2 == 0x6d98) &&					\
	 ((guid)->Data3 == 0x11d1) &&					\
	 ((guid)->Data4[0] == 0xa2) &&					\
	 ((guid)->Data4[1] == 0x1a) &&					\
	 ((guid)->Data4[2] == 0x00) &&					\
	 ((guid)->Data4[3] == 0xa0) &&					\
	 ((guid)->Data4[4] == 0xc9) &&					\
	 ((guid)->Data4[5] == 0x22) &&					\
	 ((guid)->Data4[6] == 0x31) &&					\
	 ((guid)->Data4[7] == 0x96) )
#endif /* INIT_MMREG_MID */

#ifndef INIT_MMREG_PID
#define INIT_MMREG_PID(guid,id)						\
{									\
	(guid)->Data1 = 0xe36dc2ac + (USHORT)(id);			\
	(guid)->Data2 = 0x6d9a;						\
	(guid)->Data3 = 0x11d1;						\
	(guid)->Data4[0] = 0xa2;					\
	(guid)->Data4[1] = 0x1a;					\
	(guid)->Data4[2] = 0x00;					\
	(guid)->Data4[3] = 0xa0;					\
	(guid)->Data4[4] = 0xc9;					\
	(guid)->Data4[5] = 0x22;					\
	(guid)->Data4[6] = 0x31;					\
	(guid)->Data4[7] = 0x96;					\
}
#define EXTRACT_MMREG_PID(guid)						\
	(USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)					\
	0xe36dc2ac+(USHORT)(id),0x6d9a,0x11d1,0xa2,0x1a,0x00,0xa0,0xc9,0x22,0x31,0x96

#define IS_COMPATIBLE_MMREG_PID(guid)					\
	(((guid)->Data1 >= 0xe36dc2ac) &&				\
	 ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&			\
	 ((guid)->Data2 == 0x6d9a) &&					\
	 ((guid)->Data3 == 0x11d1) &&					\
	 ((guid)->Data4[0] == 0xa2) &&					\
	 ((guid)->Data4[1] == 0x1a) &&					\
	 ((guid)->Data4[2] == 0x00) &&					\
	 ((guid)->Data4[3] == 0xa0) &&					\
	 ((guid)->Data4[4] == 0xc9) &&					\
	 ((guid)->Data4[5] == 0x22) &&					\
	 ((guid)->Data4[6] == 0x31) &&					\
	 ((guid)->Data4[7] == 0x96) )
#endif /* INIT_MMREG_PID */

#define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG				\
	0x6dba3190L,0x67bd,0x11cf,0xa0,0xf7,0x00,0x20,0xaf,0xd1,0x56,0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4",KSDATAFORMAT_SUBTYPE_ANALOG);
#define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)

#define STATIC_KSDATAFORMAT_SUBTYPE_PCM					\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_PCM);
#define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)

#ifdef _INC_MMREG
#define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT				\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

#define STATIC_KSDATAFORMAT_SUBTYPE_DRM					\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_DRM);
#define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)

#define STATIC_KSDATAFORMAT_SUBTYPE_ALAW				\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_ALAW);
#define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_MULAW				\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_MULAW);
#define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM				\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_ADPCM);
#define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG				\
	DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71",KSDATAFORMAT_SUBTYPE_MPEG);
#define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
#endif /* _INC_MMREG */

#define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID				\
	0xAD98D184L,0xAAC3,0x11D0,0xA4,0x1C,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196",KSDATAFORMAT_SPECIFIER_VC_ID);
#define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX			\
	0x05589f81L,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a",KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND				\
	0x518590a2L,0xa184,0x11d0,0x85,0x22,0x00,0xc0,0x4f,0xd9,0xba,0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3",KSDATAFORMAT_SPECIFIER_DSOUND);
#define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined(PACK_PRAGMAS_NOT_SUPPORTED)
#include <pshpack1.h>
#endif
typedef struct {
  KSDATAFORMAT DataFormat;
  WAVEFORMATEX WaveFormatEx;
} KSDATAFORMAT_WAVEFORMATEX,*PKSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
  WAVEFORMATEX Format;
  union {
    WORD wValidBitsPerSample;
    WORD wSamplesPerBlock;
    WORD wReserved;
  } Samples;
  DWORD dwChannelMask;

  GUID SubFormat;
} WAVEFORMATEXTENSIBLE,*PWAVEFORMATEXTENSIBLE;
#endif /* _WAVEFORMATEXTENSIBLE_ */

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define WAVE_FORMAT_EXTENSIBLE			0xFFFE
#endif

typedef struct {
  ULONG Flags;
  ULONG Control;
  WAVEFORMATEX WaveFormatEx;
} KSDSOUND_BUFFERDESC,*PKSDSOUND_BUFFERDESC;

typedef struct {
  KSDATAFORMAT DataFormat;
  KSDSOUND_BUFFERDESC BufferDesc;
} KSDATAFORMAT_DSOUND,*PKSDATAFORMAT_DSOUND;

#if !defined(PACK_PRAGMAS_NOT_SUPPORTED)
#include <poppack.h>
#endif
#endif /* defined(_INC_MMSYSTEM) || defined(_INC_MMREG) */

#define KSDSOUND_BUFFER_PRIMARY			0x00000001
#define KSDSOUND_BUFFER_STATIC			0x00000002
#define KSDSOUND_BUFFER_LOCHARDWARE		0x00000004
#define KSDSOUND_BUFFER_LOCSOFTWARE		0x00000008

#define KSDSOUND_BUFFER_CTRL_3D			0x00000001
#define KSDSOUND_BUFFER_CTRL_FREQUENCY		0x00000002
#define KSDSOUND_BUFFER_CTRL_PAN		0x00000004
#define KSDSOUND_BUFFER_CTRL_VOLUME		0x00000008
#define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY	0x00000010

typedef struct {
  DWORDLONG PlayOffset;
  DWORDLONG WriteOffset;
} KSAUDIO_POSITION,*PKSAUDIO_POSITION;

typedef struct _DS3DVECTOR {
  __MINGW_EXTENSION union {
    FLOAT x;
    FLOAT dvX;
  };
  __MINGW_EXTENSION union {
    FLOAT y;
    FLOAT dvY;
  };
  __MINGW_EXTENSION union {
    FLOAT z;
    FLOAT dvZ;
  };
} DS3DVECTOR,*PDS3DVECTOR;

#define STATIC_KSPROPSETID_DirectSound3DListener			\
	0x437b3414L,0xd060,0x11d0,0x85,0x83,0x00,0xc0,0x4f,0xd9,0xba,0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DListener);
#define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)

typedef enum {
  KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
  KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
  KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
  KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
  KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
  KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
  KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
  KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
  KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} KSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
  DS3DVECTOR Position;
  DS3DVECTOR Velocity;
  DS3DVECTOR OrientFront;
  DS3DVECTOR OrientTop;
  FLOAT DistanceFactor;
  FLOAT RolloffFactor;
  FLOAT DopplerFactor;
} KSDS3D_LISTENER_ALL,*PKSDS3D_LISTENER_ALL;

typedef struct {
  DS3DVECTOR Front;
  DS3DVECTOR Top;
} KSDS3D_LISTENER_ORIENTATION,*PKSDS3D_LISTENER_ORIENTATION;

#define STATIC_KSPROPSETID_DirectSound3DBuffer				\
	0x437b3411L,0xd060,0x11d0,0x85,0x83,0x00,0xc0,0x4f,0xd9,0xba,0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DBuffer);
#define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)

typedef enum {
  KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
  KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
  KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
  KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
  KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
  KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} KSPROPERTY_DIRECTSOUND3DBUFFER;

typedef struct {
  DS3DVECTOR Position;
  DS3DVECTOR Velocity;
  ULONG InsideConeAngle;
  ULONG OutsideConeAngle;
  DS3DVECTOR ConeOrientation;
  LONG ConeOutsideVolume;
  FLOAT MinDistance;
  FLOAT MaxDistance;
  ULONG Mode;
} KSDS3D_BUFFER_ALL,*PKSDS3D_BUFFER_ALL;

typedef struct {
  ULONG InsideConeAngle;
  ULONG OutsideConeAngle;
} KSDS3D_BUFFER_CONE_ANGLES,*PKSDS3D_BUFFER_CONE_ANGLES;

#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE	(-1)
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN		5
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW		10
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE		20
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX		180

#define KSDSOUND_3D_MODE_NORMAL			0x00000000
#define KSDSOUND_3D_MODE_HEADRELATIVE		0x00000001
#define KSDSOUND_3D_MODE_DISABLE		0x00000002

#define KSDSOUND_BUFFER_CTRL_HRTF_3D		0x40000000

typedef struct {
  ULONG Size;
  ULONG Enabled;
  WINBOOL SwapChannels;
  WINBOOL ZeroAzimuth;
  WINBOOL CrossFadeOutput;
  ULONG FilterSize;
} KSDS3D_HRTF_PARAMS_MSG,*PKSDS3D_HRTF_PARAMS_MSG;

typedef enum {
  FULL_FILTER,
  LIGHT_FILTER,
  KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
  ULONG Size;
  KSDS3D_HRTF_FILTER_QUALITY Quality;
  FLOAT SampleRate;
  ULONG MaxFilterSize;
  ULONG FilterTransientMuteLength;
  ULONG FilterOverlapBufferLength;
  ULONG OutputOverlapBufferLength;
  ULONG Reserved;
} KSDS3D_HRTF_INIT_MSG,*PKSDS3D_HRTF_INIT_MSG;

typedef enum {
  FLOAT_COEFF,
  SHORT_COEFF,
  KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

typedef enum {
  DIRECT_FORM,
  CASCADE_FORM,
  KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

typedef enum {
  DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
  KSDS3D_HRTF_FILTER_METHOD FilterMethod;
  KSDS3D_HRTF_COEFF_FORMAT CoeffFormat;
  KSDS3D_HRTF_FILTER_VERSION Version;
  ULONG Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG,*PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_KSPROPSETID_Hrtf3d					\
	0xb66decb0L,0xa083,0x11d0,0x85,0x1e,0x00,0xc0,0x4f,0xd9,0xba,0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3",KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
  KSPROPERTY_HRTF3D_PARAMS = 0,
  KSPROPERTY_HRTF3D_INITIALIZE,
  KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;

typedef struct {
  LONG Channel;
  FLOAT VolSmoothScale;
  FLOAT TotalDryAttenuation;
  FLOAT TotalWetAttenuation;
  LONG SmoothFrequency;
  LONG Delay;
} KSDS3D_ITD_PARAMS,*PKSDS3D_ITD_PARAMS;

typedef struct {
  ULONG Enabled;
  KSDS3D_ITD_PARAMS LeftParams;
  KSDS3D_ITD_PARAMS RightParams;
  ULONG Reserved;
} KSDS3D_ITD_PARAMS_MSG,*PKSDS3D_ITD_PARAMS_MSG;

#define STATIC_KSPROPSETID_Itd3d					\
	0x6429f090L,0x9fd9,0x11d0,0xa7,0x5b,0x00,0xa0,0xc9,0x03,0x65,0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3",KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
  KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;

typedef struct {
  KSDATARANGE DataRange;
  ULONG MaximumChannels;
  ULONG MinimumBitsPerSample;
  ULONG MaximumBitsPerSample;
  ULONG MinimumSampleFrequency;
  ULONG MaximumSampleFrequency;
} KSDATARANGE_AUDIO,*PKSDATARANGE_AUDIO;

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFF				\
	0x4995DAEEL,0x9EE6,0x11D0,0xA4,0x0E,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196",KSDATAFORMAT_SUBTYPE_RIFF);
#define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE				\
	0xe436eb8bL,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770",KSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)

#define STATIC_KSPROPSETID_Bibliographic				\
	0x07BA150EL,0xE2B1,0x11D0,0xAC,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196",KSPROPSETID_Bibliographic);
#define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)

typedef enum {
  KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
  KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
  KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
  KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
  KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
  KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
  KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
  KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
  KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
  KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
  KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
  KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
  KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
  KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
  KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
  KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
  KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
  KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
  KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
  KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
  KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
  KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
  KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
  KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
  KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
  KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} KSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_KSPROPSETID_TopologyNode					\
	0x45FFAAA1L,0x6E1B,0x11D0,0xBC,0xF2,0x44,0x45,0x53,0x54,0x00,0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000",KSPROPSETID_TopologyNode);
#define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)

typedef enum {
  KSPROPERTY_TOPOLOGYNODE_ENABLE = 1,
  KSPROPERTY_TOPOLOGYNODE_RESET
} KSPROPERTY_TOPOLOGYNODE;

#define STATIC_KSPROPSETID_RtAudio					\
	0xa855a48c,0x2f78,0x4729,0x90,0x51,0x19,0x68,0x74,0x6b,0x9e,0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF",KSPROPSETID_RtAudio);
#define KSPROPSETID_RtAudio DEFINE_GUIDNAMED(KSPROPSETID_RtAudio)

typedef enum {
  KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
  /* Added for Vista and later */
  KSPROPERTY_RTAUDIO_BUFFER,
  KSPROPERTY_RTAUDIO_HWLATENCY,
  KSPROPERTY_RTAUDIO_POSITIONREGISTER,
  KSPROPERTY_RTAUDIO_CLOCKREGISTER,
  KSPROPERTY_RTAUDIO_BUFFER_WITH_NOTIFICATION,
  KSPROPERTY_RTAUDIO_REGISTER_NOTIFICATION_EVENT,
  KSPROPERTY_RTAUDIO_UNREGISTER_NOTIFICATION_EVENT
} KSPROPERTY_RTAUDIO;

#define STATIC_KSPROPSETID_DrmAudioStream				\
	0x2f2c8ddd,0x4198,0x4fac,0xba,0x29,0x61,0xbb,0x5,0xb7,0xde,0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06",KSPROPSETID_DrmAudioStream);
#define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)

typedef enum {
  KSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} KSPROPERTY_DRMAUDIOSTREAM;

#define STATIC_KSPROPSETID_Audio					\
	0x45FFAAA0L,0x6E1B,0x11D0,0xBC,0xF2,0x44,0x45,0x53,0x54,0x00,0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000",KSPROPSETID_Audio);
#define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)

typedef enum {
  KSPROPERTY_AUDIO_LATENCY = 1,
  KSPROPERTY_AUDIO_COPY_PROTECTION,
  KSPROPERTY_AUDIO_CHANNEL_CONFIG,
  KSPROPERTY_AUDIO_VOLUMELEVEL,
  KSPROPERTY_AUDIO_POSITION,
  KSPROPERTY_AUDIO_DYNAMIC_RANGE,
  KSPROPERTY_AUDIO_QUALITY,
  KSPROPERTY_AUDIO_SAMPLING_RATE,
  KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
  KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
  KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
  KSPROPERTY_AUDIO_MUX_SOURCE,
  KSPROPERTY_AUDIO_MUTE,
  KSPROPERTY_AUDIO_BASS,
  KSPROPERTY_AUDIO_MID,
  KSPROPERTY_AUDIO_TREBLE,
  KSPROPERTY_AUDIO_BASS_BOOST,
  KSPROPERTY_AUDIO_EQ_LEVEL,
  KSPROPERTY_AUDIO_NUM_EQ_BANDS,
  KSPROPERTY_AUDIO_EQ_BANDS,
  KSPROPERTY_AUDIO_AGC,
  KSPROPERTY_AUDIO_DELAY,
  KSPROPERTY_AUDIO_LOUDNESS,
  KSPROPERTY_AUDIO_WIDE_MODE,
  KSPROPERTY_AUDIO_WIDENESS,
  KSPROPERTY_AUDIO_REVERB_LEVEL,
  KSPROPERTY_AUDIO_CHORUS_LEVEL,
  KSPROPERTY_AUDIO_DEV_SPECIFIC,
  KSPROPERTY_AUDIO_DEMUX_DEST,
  KSPROPERTY_AUDIO_STEREO_ENHANCE,
  KSPROPERTY_AUDIO_MANUFACTURE_GUID,
  KSPROPERTY_AUDIO_PRODUCT_GUID,
  KSPROPERTY_AUDIO_CPU_RESOURCES,
  KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
  KSPROPERTY_AUDIO_SURROUND_ENCODE,
  KSPROPERTY_AUDIO_3D_INTERFACE,
  KSPROPERTY_AUDIO_PEAKMETER,
  KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
  KSPROPERTY_AUDIO_FILTER_STATE,
  KSPROPERTY_AUDIO_PREFERRED_STATUS
} KSPROPERTY_AUDIO;

#define KSAUDIO_QUALITY_WORST			0x0
#define KSAUDIO_QUALITY_PC			0x1
#define KSAUDIO_QUALITY_BASIC			0x2
#define KSAUDIO_QUALITY_ADVANCED		0x3

#define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU	0x00000000
#define KSAUDIO_CPU_RESOURCES_HOST_CPU		0x7FFFFFFF

typedef struct {
  WINBOOL fCopyrighted;
  WINBOOL fOriginal;
} KSAUDIO_COPY_PROTECTION,*PKSAUDIO_COPY_PROTECTION;

typedef struct {
  LONG ActiveSpeakerPositions;
} KSAUDIO_CHANNEL_CONFIG,*PKSAUDIO_CHANNEL_CONFIG;

#define SPEAKER_FRONT_LEFT		0x1
#define SPEAKER_FRONT_RIGHT		0x2
#define SPEAKER_FRONT_CENTER		0x4
#define SPEAKER_LOW_FREQUENCY		0x8
#define SPEAKER_BACK_LEFT		0x10
#define SPEAKER_BACK_RIGHT		0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER	0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER	0x80
#define SPEAKER_BACK_CENTER		0x100
#define SPEAKER_SIDE_LEFT		0x200
#define SPEAKER_SIDE_RIGHT		0x400
#define SPEAKER_TOP_CENTER		0x800
#define SPEAKER_TOP_FRONT_LEFT		0x1000
#define SPEAKER_TOP_FRONT_CENTER	0x2000
#define SPEAKER_TOP_FRONT_RIGHT		0x4000
#define SPEAKER_TOP_BACK_LEFT		0x8000
#define SPEAKER_TOP_BACK_CENTER		0x10000
#define SPEAKER_TOP_BACK_RIGHT		0x20000

#define SPEAKER_RESERVED		0x7FFC0000

#define SPEAKER_ALL			0x80000000

#define KSAUDIO_SPEAKER_DIRECTOUT	0
#define KSAUDIO_SPEAKER_MONO		(SPEAKER_FRONT_CENTER)
#define KSAUDIO_SPEAKER_STEREO		(SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define KSAUDIO_SPEAKER_QUAD		(SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					 SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_SURROUND	(SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					 SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define KSAUDIO_SPEAKER_5POINT1		(SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					 SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |		\
					 SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1		(SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					 SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |		\
					 SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT |		\
					 SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)
#define KSAUDIO_SPEAKER_5POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					  SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |	\
					  SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |		\
					  SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |	\
					  SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT |		\
					  SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)

#define KSAUDIO_SPEAKER_5POINT1_BACK	KSAUDIO_SPEAKER_5POINT1
#define KSAUDIO_SPEAKER_7POINT1_WIDE	KSAUDIO_SPEAKER_7POINT1

#define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT	SPEAKER_FRONT_LEFT
#define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER	SPEAKER_FRONT_CENTER
#define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT	SPEAKER_FRONT_RIGHT
#define KSAUDIO_SPEAKER_GROUND_REAR_LEFT	SPEAKER_BACK_LEFT
#define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT	SPEAKER_BACK_RIGHT
#define KSAUDIO_SPEAKER_TOP_MIDDLE		SPEAKER_TOP_CENTER
#define KSAUDIO_SPEAKER_SUPER_WOOFER		SPEAKER_LOW_FREQUENCY

typedef struct {
  ULONG QuietCompression;
  ULONG LoudCompression;
} KSAUDIO_DYNAMIC_RANGE,*PKSAUDIO_DYNAMIC_RANGE;

typedef struct {
  WINBOOL Mute;
  LONG Level;
} KSAUDIO_MIXLEVEL,*PKSAUDIO_MIXLEVEL;

typedef struct {
  WINBOOL Mute;
  LONG Minimum;
  LONG Maximum;
  LONG Reset;
} KSAUDIO_MIX_CAPS,*PKSAUDIO_MIX_CAPS;

typedef struct {
  ULONG InputChannels;
  ULONG OutputChannels;
  KSAUDIO_MIX_CAPS Capabilities[1];
} KSAUDIO_MIXCAP_TABLE,*PKSAUDIO_MIXCAP_TABLE;

typedef enum {
  SE_TECH_NONE,
  SE_TECH_ANALOG_DEVICES_PHAT,
  SE_TECH_CREATIVE,
  SE_TECH_NATIONAL_SEMI,
  SE_TECH_YAMAHA_YMERSION,
  SE_TECH_BBE,
  SE_TECH_CRYSTAL_SEMI,
  SE_TECH_QSOUND_QXPANDER,
  SE_TECH_SPATIALIZER,
  SE_TECH_SRS,
  SE_TECH_PLATFORM_TECH,
  SE_TECH_AKM,
  SE_TECH_AUREAL,
  SE_TECH_AZTECH,
  SE_TECH_BINAURA,
  SE_TECH_ESS_TECH,
  SE_TECH_HARMAN_VMAX,
  SE_TECH_NVIDEA,
  SE_TECH_PHILIPS_INCREDIBLE,
  SE_TECH_TEXAS_INST,
  SE_TECH_VLSI_TECH
} SE_TECHNIQUE;

typedef struct {
  SE_TECHNIQUE Technique;
  ULONG Center;
  ULONG Depth;
  ULONG Reserved;
} KSAUDIO_STEREO_ENHANCE,*PKSAUDIO_STEREO_ENHANCE;

typedef enum {
  KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
  KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
  KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
  KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
  KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

typedef struct {
  WINBOOL Enable;
  KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
  ULONG Flags;
  ULONG Reserved;
} KSAUDIO_PREFERRED_STATUS,*PKSAUDIO_PREFERRED_STATUS;

#define STATIC_KSNODETYPE_DAC						\
	0x507AE360L,0xC554,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1",KSNODETYPE_DAC);
#define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)

#define STATIC_KSNODETYPE_ADC						\
	0x4D837FE0L,0xC555,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1",KSNODETYPE_ADC);
#define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)

#define STATIC_KSNODETYPE_SRC						\
	0x9DB7B9E0L,0xC555,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1",KSNODETYPE_SRC);
#define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)

#define STATIC_KSNODETYPE_SUPERMIX					\
	0xE573ADC0L,0xC555,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1",KSNODETYPE_SUPERMIX);
#define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)

#define STATIC_KSNODETYPE_MUX						\
	0x2CEAF780L,0xC556,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1",KSNODETYPE_MUX);
#define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)

#define STATIC_KSNODETYPE_DEMUX						\
	0xC0EB67D4L,0xE807,0x11D0,0x95,0x8A,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3",KSNODETYPE_DEMUX);
#define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)

#define STATIC_KSNODETYPE_SUM						\
	0xDA441A60L,0xC556,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1",KSNODETYPE_SUM);
#define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)

#define STATIC_KSNODETYPE_MUTE						\
	0x02B223C0L,0xC557,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1",KSNODETYPE_MUTE);
#define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)

#define STATIC_KSNODETYPE_VOLUME					\
	0x3A5ACC00L,0xC557,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1",KSNODETYPE_VOLUME);
#define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)

#define STATIC_KSNODETYPE_TONE						\
	0x7607E580L,0xC557,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1",KSNODETYPE_TONE);
#define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)

#define STATIC_KSNODETYPE_EQUALIZER					\
	0x9D41B4A0L,0xC557,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1",KSNODETYPE_EQUALIZER);
#define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)

#define STATIC_KSNODETYPE_AGC						\
	0xE88C9BA0L,0xC557,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1",KSNODETYPE_AGC);
#define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)

#define STATIC_KSNODETYPE_NOISE_SUPPRESS				\
	0xe07f903f,0x62fd,0x4e60,0x8c,0xdd,0xde,0xa7,0x23,0x66,0x65,0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5",KSNODETYPE_NOISE_SUPPRESS);
#define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)

#define STATIC_KSNODETYPE_DELAY						\
	0x144981E0L,0xC558,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1",KSNODETYPE_DELAY);
#define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)

#define STATIC_KSNODETYPE_LOUDNESS					\
	0x41887440L,0xC558,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1",KSNODETYPE_LOUDNESS);
#define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)

#define STATIC_KSNODETYPE_PROLOGIC_DECODER				\
	0x831C2C80L,0xC558,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1",KSNODETYPE_PROLOGIC_DECODER);
#define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)

#define STATIC_KSNODETYPE_STEREO_WIDE					\
	0xA9E69800L,0xC558,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1",KSNODETYPE_STEREO_WIDE);
#define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)

#define STATIC_KSNODETYPE_STEREO_ENHANCE				\
	0xAF6878ACL,0xE83F,0x11D0,0x95,0x8A,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3",KSNODETYPE_STEREO_ENHANCE);
#define KSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_ENHANCE)

#define STATIC_KSNODETYPE_REVERB					\
	0xEF0328E0L,0xC558,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1",KSNODETYPE_REVERB);
#define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)

#define STATIC_KSNODETYPE_CHORUS					\
	0x20173F20L,0xC559,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1",KSNODETYPE_CHORUS);
#define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)

#define STATIC_KSNODETYPE_3D_EFFECTS					\
	0x55515860L,0xC559,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1",KSNODETYPE_3D_EFFECTS);
#define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)

#define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL		\
	0x1c22c56dL,0x9879,0x4f5b,0xa3,0x89,0x27,0x99,0x6d,0xdc,0x28,0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810",KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS		\
	0x5ab0882eL,0x7274,0x4516,0x87,0x7d,0x4e,0xee,0x99,0xba,0x4f,0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0",KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_AGC				\
	0x950e55b9L,0x877c,0x4c67,0xbe,0x8,0xe4,0x7b,0x56,0x11,0x13,0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A",KSALGORITHMINSTANCE_SYSTEM_AGC);
#define KSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR	\
	0xB6F5A0A0L,0x9E61,0x4F8C,0x91,0xE3,0x76,0xCF,0xF,0x3C,0x47,0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F",KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#define STATIC_KSNODETYPE_DEV_SPECIFIC					\
	0x941C7AC0L,0xC559,0x11D0,0x8A,0x2B,0x00,0xA0,0xC9,0x25,0x5A,0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1",KSNODETYPE_DEV_SPECIFIC);
#define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)

#define STATIC_KSNODETYPE_PROLOGIC_ENCODER				\
	0x8074C5B2L,0x3C66,0x11D2,0xB4,0x5A,0x30,0x78,0x30,0x2C,0x20,0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030",KSNODETYPE_PROLOGIC_ENCODER);
#define KSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_ENCODER)
#define KSNODETYPE_SURROUND_ENCODER KSNODETYPE_PROLOGIC_ENCODER

#define STATIC_KSNODETYPE_PEAKMETER					\
	0xa085651eL,0x5f0d,0x4b36,0xa8,0x69,0xd1,0x95,0xd6,0xab,0x4b,0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E",KSNODETYPE_PEAKMETER);
#define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)

#define STATIC_KSAUDFNAME_BASS						\
	0x185FEDE0L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_BASS);
#define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)

#define STATIC_KSAUDFNAME_TREBLE					\
	0x185FEDE1L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_TREBLE);
#define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)

#define STATIC_KSAUDFNAME_3D_STEREO					\
	0x185FEDE2L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_3D_STEREO);
#define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)

#define STATIC_KSAUDFNAME_MASTER_VOLUME					\
	0x185FEDE3L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MASTER_VOLUME);
#define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)

#define STATIC_KSAUDFNAME_MASTER_MUTE					\
	0x185FEDE4L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MASTER_MUTE);
#define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)

#define STATIC_KSAUDFNAME_WAVE_VOLUME					\
	0x185FEDE5L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_WAVE_VOLUME);
#define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_MUTE					\
	0x185FEDE6L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_WAVE_MUTE);
#define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)

#define STATIC_KSAUDFNAME_MIDI_VOLUME					\
	0x185FEDE7L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIDI_VOLUME);
#define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)

#define STATIC_KSAUDFNAME_MIDI_MUTE					\
	0x185FEDE8L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIDI_MUTE);
#define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)

#define STATIC_KSAUDFNAME_CD_VOLUME					\
	0x185FEDE9L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_CD_VOLUME);
#define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)

#define STATIC_KSAUDFNAME_CD_MUTE					\
	0x185FEDEAL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_CD_MUTE);
#define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)

#define STATIC_KSAUDFNAME_LINE_VOLUME					\
	0x185FEDEBL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_LINE_VOLUME);
#define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)

#define STATIC_KSAUDFNAME_LINE_MUTE					\
	0x185FEDECL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_LINE_MUTE);
#define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)

#define STATIC_KSAUDFNAME_MIC_VOLUME					\
	0x185FEDEDL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIC_VOLUME);
#define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)

#define STATIC_KSAUDFNAME_MIC_MUTE					\
	0x185FEDEEL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIC_MUTE);
#define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)

#define STATIC_KSAUDFNAME_RECORDING_SOURCE				\
	0x185FEDEFL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_RECORDING_SOURCE);
#define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)

#define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME				\
	0x185FEDF0L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_PC_SPEAKER_VOLUME);
#define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE				\
	0x185FEDF1L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_PC_SPEAKER_MUTE);
#define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_KSAUDFNAME_MIDI_IN_VOLUME				\
	0x185FEDF2L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIDI_IN_VOLUME);
#define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_KSAUDFNAME_CD_IN_VOLUME					\
	0x185FEDF3L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_CD_IN_VOLUME);
#define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)

#define STATIC_KSAUDFNAME_LINE_IN_VOLUME				\
	0x185FEDF4L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_LINE_IN_VOLUME);
#define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_KSAUDFNAME_MIC_IN_VOLUME					\
	0x185FEDF5L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIC_IN_VOLUME);
#define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_IN_VOLUME				\
	0x185FEDF6L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_WAVE_IN_VOLUME);
#define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_KSAUDFNAME_VOLUME_CONTROL				\
	0x185FEDF7L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_VOLUME_CONTROL);
#define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)

#define STATIC_KSAUDFNAME_MIDI						\
	0x185FEDF8L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_MIDI);
#define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)

#define STATIC_KSAUDFNAME_LINE_IN					\
	0x185FEDF9L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_LINE_IN);
#define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)

#define STATIC_KSAUDFNAME_RECORDING_CONTROL				\
	0x185FEDFAL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_RECORDING_CONTROL);
#define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)

#define STATIC_KSAUDFNAME_CD_AUDIO					\
	0x185FEDFBL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_CD_AUDIO);
#define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)

#define STATIC_KSAUDFNAME_AUX_VOLUME					\
	0x185FEDFCL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_AUX_VOLUME);
#define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)

#define STATIC_KSAUDFNAME_AUX_MUTE					\
	0x185FEDFDL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_AUX_MUTE);
#define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)

#define STATIC_KSAUDFNAME_AUX						\
	0x185FEDFEL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_AUX);
#define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)

#define STATIC_KSAUDFNAME_PC_SPEAKER					\
	0x185FEDFFL,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_PC_SPEAKER);
#define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)

#define STATIC_KSAUDFNAME_WAVE_OUT_MIX					\
	0x185FEE00L,0x9905,0x11D1,0x95,0xA9,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3",KSAUDFNAME_WAVE_OUT_MIX);
#define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT					\
	0xf9b41dc3L,0x96e2,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_OUT);
#define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)

#define STATIC_KSAUDFNAME_STEREO_MIX					\
	0xdff077L,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_STEREO_MIX);
#define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)

#define STATIC_KSAUDFNAME_MONO_MIX					\
	0xdff078L,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_MIX);
#define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT_VOLUME				\
	0x1ad247ebL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_OUT_VOLUME);
#define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_KSAUDFNAME_MONO_OUT_MUTE					\
	0x1ad247ecL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_OUT_MUTE);
#define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME				\
	0x1ad247edL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_STEREO_MIX_VOLUME);
#define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_STEREO_MIX_MUTE				\
	0x22b0eafdL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_STEREO_MIX_MUTE);
#define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MONO_MIX_VOLUME				\
	0x22b0eafeL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_MIX_VOLUME);
#define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_MONO_MIX_MUTE					\
	0x2bc31d69L,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MONO_MIX_MUTE);
#define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MICROPHONE_BOOST				\
	0x2bc31d6aL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_MICROPHONE_BOOST);
#define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE				\
	0x2bc31d6bL,0x96e3,0x11d2,0xac,0x4c,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68",KSAUDFNAME_ALTERNATE_MICROPHONE);
#define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_KSAUDFNAME_3D_DEPTH					\
	0x63ff5747L,0x991f,0x11d2,0xac,0x4d,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68",KSAUDFNAME_3D_DEPTH);
#define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)

#define STATIC_KSAUDFNAME_3D_CENTER					\
	0x9f0670b4L,0x991f,0x11d2,0xac,0x4d,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68",KSAUDFNAME_3D_CENTER);
#define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)

#define STATIC_KSAUDFNAME_VIDEO_VOLUME					\
	0x9b46e708L,0x992a,0x11d2,0xac,0x4d,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68",KSAUDFNAME_VIDEO_VOLUME);
#define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)

#define STATIC_KSAUDFNAME_VIDEO_MUTE					\
	0x9b46e709L,0x992a,0x11d2,0xac,0x4d,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68",KSAUDFNAME_VIDEO_MUTE);
#define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)

#define STATIC_KSAUDFNAME_VIDEO						\
	0x915daec4L,0xa434,0x11d2,0xac,0x52,0x0,0xc0,0x4f,0x8e,0xfb,0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68",KSAUDFNAME_VIDEO);
#define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)

#define STATIC_KSAUDFNAME_PEAKMETER					\
	0x57e24340L,0xfc5b,0x4612,0xa5,0x62,0x72,0xb1,0x1a,0x29,0xdf,0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE",KSAUDFNAME_PEAKMETER);
#define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)

#define KSNODEPIN_STANDARD_IN		1
#define KSNODEPIN_STANDARD_OUT		0

#define KSNODEPIN_SUM_MUX_IN		1
#define KSNODEPIN_SUM_MUX_OUT		0

#define KSNODEPIN_DEMUX_IN		0
#define KSNODEPIN_DEMUX_OUT		1

#define KSNODEPIN_AEC_RENDER_IN		1
#define KSNODEPIN_AEC_RENDER_OUT	0
#define KSNODEPIN_AEC_CAPTURE_IN	2
#define KSNODEPIN_AEC_CAPTURE_OUT	3

#define STATIC_KSMETHODSETID_Wavetable					\
	0xDCEF31EBL,0xD907,0x11D0,0x95,0x83,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3",KSMETHODSETID_Wavetable);
#define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)

typedef enum {
  KSMETHOD_WAVETABLE_WAVE_ALLOC,
  KSMETHOD_WAVETABLE_WAVE_FREE,
  KSMETHOD_WAVETABLE_WAVE_FIND,
  KSMETHOD_WAVETABLE_WAVE_WRITE
} KSMETHOD_WAVETABLE;

typedef struct {
  KSIDENTIFIER Identifier;
  ULONG Size;
  WINBOOL Looped;
  ULONG LoopPoint;
  WINBOOL InROM;
  KSDATAFORMAT Format;
} KSWAVETABLE_WAVE_DESC,*PKSWAVETABLE_WAVE_DESC;

#define STATIC_KSPROPSETID_Acoustic_Echo_Cancel				\
	0xd7a4af8bL,0x3dc1,0x4902,0x91,0xea,0x8a,0x15,0xc9,0x0e,0x05,0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2",KSPROPSETID_Acoustic_Echo_Cancel);
#define KSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(KSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
  KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
  KSPROPERTY_AEC_STATUS,
  KSPROPERTY_AEC_MODE
} KSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED		0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED	0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED	0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED		0x8

#define AEC_MODE_PASS_THROUGH				0x0
#define AEC_MODE_HALF_DUPLEX				0x1
#define AEC_MODE_FULL_DUPLEX				0x2

#define STATIC_KSPROPSETID_Wave						\
	0x924e54b0L,0x630f,0x11cf,0xad,0xa7,0x08,0x00,0x3e,0x30,0x49,0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a",KSPROPSETID_Wave);
#define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)

typedef enum {
  KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
  KSPROPERTY_WAVE_INPUT_CAPABILITIES,
  KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
  KSPROPERTY_WAVE_BUFFER,
  KSPROPERTY_WAVE_FREQUENCY,
  KSPROPERTY_WAVE_VOLUME,
  KSPROPERTY_WAVE_PAN
} KSPROPERTY_WAVE;

typedef struct {
  ULONG ulDeviceType;
} KSWAVE_COMPATCAPS,*PKSWAVE_COMPATCAPS;

#define KSWAVE_COMPATCAPS_INPUT		0x00000000
#define KSWAVE_COMPATCAPS_OUTPUT	0x00000001

typedef struct {
  ULONG MaximumChannelsPerConnection;
  ULONG MinimumBitsPerSample;
  ULONG MaximumBitsPerSample;
  ULONG MinimumSampleFrequency;
  ULONG MaximumSampleFrequency;
  ULONG TotalConnections;
  ULONG ActiveConnections;
} KSWAVE_INPUT_CAPABILITIES,*PKSWAVE_INPUT_CAPABILITIES;

typedef struct {
  ULONG MaximumChannelsPerConnection;
  ULONG MinimumBitsPerSample;
  ULONG MaximumBitsPerSample;
  ULONG MinimumSampleFrequency;
  ULONG MaximumSampleFrequency;
  ULONG TotalConnections;
  ULONG StaticConnections;
  ULONG StreamingConnections;
  ULONG ActiveConnections;
  ULONG ActiveStaticConnections;
  ULONG ActiveStreamingConnections;
  ULONG Total3DConnections;
  ULONG Static3DConnections;
  ULONG Streaming3DConnections;
  ULONG Active3DConnections;
  ULONG ActiveStatic3DConnections;
  ULONG ActiveStreaming3DConnections;
  ULONG TotalSampleMemory;
  ULONG FreeSampleMemory;
  ULONG LargestFreeContiguousSampleMemory;
} KSWAVE_OUTPUT_CAPABILITIES,*PKSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
  LONG LeftAttenuation;
  LONG RightAttenuation;
} KSWAVE_VOLUME,*PKSWAVE_VOLUME;

#define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING	0x00000001
#define KSWAVE_BUFFER_ATTRIBUTEF_STATIC		0x00000002

typedef struct {
  ULONG Attributes;
  ULONG BufferSize;
  PVOID BufferAddress;
} KSWAVE_BUFFER,*PKSWAVE_BUFFER;

#define STATIC_KSMUSIC_TECHNOLOGY_PORT					\
	0x86C92E60L,0x62E8,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000",KSMUSIC_TECHNOLOGY_PORT);
#define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)

#define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH				\
	0x0ECF4380L,0x62E9,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000",KSMUSIC_TECHNOLOGY_SQSYNTH);
#define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH				\
	0x252C5C80L,0x62E9,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000",KSMUSIC_TECHNOLOGY_FMSYNTH);
#define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE				\
	0x394EC7C0L,0x62E9,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000",KSMUSIC_TECHNOLOGY_WAVETABLE);
#define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH				\
	0x37407736L,0x3620,0x11D1,0x85,0xD3,0x00,0x00,0xF8,0x75,0x43,0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380",KSMUSIC_TECHNOLOGY_SWSYNTH);
#define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)

#define STATIC_KSPROPSETID_WaveTable					\
	0x8539E660L,0x62E9,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("8539E660-62E9-11CF-A5D6-28DB04C10000",KSPROPSETID_WaveTable);
#define KSPROPSETID_WaveTable DEFINE_GUIDNAMED(KSPROPSETID_WaveTable)

typedef enum {
  KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
  KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
  KSPROPERTY_WAVETABLE_MEMORY,
  KSPROPERTY_WAVETABLE_VERSION
} KSPROPERTY_WAVETABLE;

typedef struct {
  KSDATARANGE DataRange;
  GUID Technology;
  ULONG Channels;
  ULONG Notes;
  ULONG ChannelMask;
} KSDATARANGE_MUSIC,*PKSDATARANGE_MUSIC;

#define STATIC_KSEVENTSETID_Cyclic					\
	0x142C1AC0L,0x072A,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000",KSEVENTSETID_Cyclic);
#define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)

typedef enum {
  KSEVENT_CYCLIC_TIME_INTERVAL
} KSEVENT_CYCLIC_TIME;

#define STATIC_KSPROPSETID_Cyclic					\
	0x3FFEAEA0L,0x2BEE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000",KSPROPSETID_Cyclic);
#define KSPROPSETID_Cyclic DEFINE_GUIDNAMED(KSPROPSETID_Cyclic)

typedef enum {
  KSPROPERTY_CYCLIC_POSITION
} KSPROPERTY_CYCLIC;

#define STATIC_KSEVENTSETID_AudioControlChange				\
	0xE85E9698L,0xFA2F,0x11D1,0x95,0xBD,0x00,0xC0,0x4F,0xB9,0x25,0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3",KSEVENTSETID_AudioControlChange);
#define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)

typedef enum {
  KSEVENT_CONTROL_CHANGE
} KSEVENT_AUDIO_CONTROL_CHANGE;

#define STATIC_KSEVENTSETID_LoopedStreaming				\
	0x4682B940L,0xC6EF,0x11D0,0x96,0xD8,0x00,0xAA,0x00,0x51,0xE5,0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D",KSEVENTSETID_LoopedStreaming);
#define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)

typedef enum {
  KSEVENT_LOOPEDSTREAMING_POSITION
} KSEVENT_LOOPEDSTREAMING;

typedef struct {
  KSEVENTDATA KsEventData;
  DWORDLONG Position;
} LOOPEDSTREAMING_POSITION_EVENT_DATA,*PLOOPEDSTREAMING_POSITION_EVENT_DATA;

#define STATIC_KSPROPSETID_Sysaudio					\
	0xCBE3FAA0L,0xCC75,0x11D0,0xB4,0x65,0x00,0x00,0x1A,0x18,0x18,0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6",KSPROPSETID_Sysaudio);
#define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)

typedef enum {
  KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
  KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
  KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
  KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
  KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
  KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
  KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
  KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
  KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16
} KSPROPERTY_SYSAUDIO;

typedef struct {
  KSPROPERTY Property;
  GUID PinCategory;
  GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE,*PSYSAUDIO_CREATE_VIRTUAL_SOURCE;

typedef struct {
  KSPROPERTY Property;
  ULONG PinId;
  ULONG NodeId;
  ULONG Flags;
  ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH,*PSYSAUDIO_SELECT_GRAPH;

typedef struct {
  KSPROPERTY Property;
  ULONG Flags;
  ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO,*PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS	0x00000001

#define STATIC_KSPROPSETID_Sysaudio_Pin					\
	0xA3A53220L,0xC6E4,0x11D0,0xB4,0x65,0x00,0x00,0x1A,0x18,0x18,0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6",KSPROPSETID_Sysaudio_Pin);
#define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)

typedef enum {
  KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1
} KSPROPERTY_SYSAUDIO_PIN;

typedef struct {
  KSPROPERTY Property;
  ULONG MixerPinId;
  ULONG Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE,*PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

typedef struct {
  KSPROPERTY Property;
  ULONG NodeId;
  ULONG Reserved;
} KSNODEPROPERTY,*PKSNODEPROPERTY;

typedef struct {
  KSNODEPROPERTY NodeProperty;
  LONG Channel;
  ULONG Reserved;
} KSNODEPROPERTY_AUDIO_CHANNEL,*PKSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
  KSNODEPROPERTY NodeProperty;
  ULONG DevSpecificId;
  ULONG DeviceInfo;
  ULONG Length;
} KSNODEPROPERTY_AUDIO_DEV_SPECIFIC,*PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
  KSNODEPROPERTY NodeProperty;
  PVOID ListenerId;
#ifndef _WIN64
  ULONG Reserved;
#endif
} KSNODEPROPERTY_AUDIO_3D_LISTENER,*PKSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
  KSNODEPROPERTY NodeProperty;
  PVOID AppContext;
  ULONG Length;
#ifndef _WIN64
  ULONG Reserved;
#endif
} KSNODEPROPERTY_AUDIO_PROPERTY,*PKSNODEPROPERTY_AUDIO_PROPERTY;

#define STATIC_KSPROPSETID_AudioGfx					\
	0x79a9312eL,0x59ae,0x43b0,0xa3,0x50,0x8b,0x5,0x28,0x4c,0xab,0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24",KSPROPSETID_AudioGfx);
#define KSPROPSETID_AudioGfx DEFINE_GUIDNAMED(KSPROPSETID_AudioGfx)

typedef enum {
  KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
  KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} KSPROPERTY_AUDIOGFX;

#define STATIC_KSPROPSETID_Linear					\
	0x5A2FFE80L,0x16B9,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("5A2FFE80-16B9-11D0-A5D6-28DB04C10000",KSPROPSETID_Linear);
#define KSPROPSETID_Linear DEFINE_GUIDNAMED(KSPROPSETID_Linear)

typedef enum {
  KSPROPERTY_LINEAR_POSITION
} KSPROPERTY_LINEAR;

#define STATIC_KSDATAFORMAT_TYPE_MUSIC					\
	0xE725D360L,0x62CC,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000",KSDATAFORMAT_TYPE_MUSIC);
#define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)

#define STATIC_KSDATAFORMAT_TYPE_MIDI					\
	0x7364696DL,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71",KSDATAFORMAT_TYPE_MIDI);
#define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI				\
	0x1D262760L,0xE957,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000",KSDATAFORMAT_SUBTYPE_MIDI);
#define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS				\
	0x2CA15FA0L,0x6CFE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000",KSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI				\
	0x4995DAF0L,0x9EE6,0x11D0,0xA4,0x0E,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196",KSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)

typedef struct {
  ULONG TimeDeltaMs;

  ULONG ByteCount;
} KSMUSICFORMAT,*PKSMUSICFORMAT;

#define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM		\
	0x36523b11L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM);
#define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET			\
	0x36523b12L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_TYPE_STANDARD_PES_PACKET);
#define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER			\
	0x36523b13L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER);
#define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO		\
	0x36523b21L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO);
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO		\
	0x36523b22L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO);
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO		\
	0x36523b23L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO		\
	0x36523b24L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO			\
	0x36523b25L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO		\
	0x36523b31L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO		\
	0x36523b32L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO);
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO		\
	0x36523b33L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO		\
	0x36523b34L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO			\
	0x36523b35L,0x8ee5,0x11d1,0x8c,0xa3,0x00,0x60,0xb0,0x57,0x66,0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A",KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO				\
	0xa0af4f81L,0xe163,0x11d0,0xba,0xd9,0x00,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a",KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO				\
		0xa0af4f82L,0xe163,0x11d0,0xba,0xd9,0x00,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a",KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet				\
	0xe436eb80,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770",KSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload			\
	0xe436eb81,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770",KSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video				\
	0xe436eb86,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770",KSDATAFORMAT_SUBTYPE_MPEG1Video);
#define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO			\
	0x05589f82L,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a",KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES				\
	0xe06d8020L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_TYPE_MPEG2_PES);
#define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM				\
	0xe06d8022L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT			\
	0xe06d8023L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO				\
	0xe06d8026L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO			\
	0xe06d80e3L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)

#define STATIC_KSPROPSETID_Mpeg2Vid					\
	0xC8E11B60L,0x0CC9,0x11D0,0xBD,0x69,0x00,0x35,0x05,0xC1,0x03,0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9",KSPROPSETID_Mpeg2Vid);
#define KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED(KSPROPSETID_Mpeg2Vid)

typedef enum {
  KSPROPERTY_MPEG2VID_MODES,
  KSPROPERTY_MPEG2VID_CUR_MODE,
  KSPROPERTY_MPEG2VID_4_3_RECT,
  KSPROPERTY_MPEG2VID_16_9_RECT,
  KSPROPERTY_MPEG2VID_16_9_PANSCAN
} KSPROPERTY_MPEG2VID;

#define KSMPEGVIDMODE_PANSCAN	0x0001
#define KSMPEGVIDMODE_LTRBOX	0x0002
#define KSMPEGVIDMODE_SCALE	0x0004

typedef struct _KSMPEGVID_RECT {
  ULONG StartX;
  ULONG StartY;
  ULONG EndX;
  ULONG EndY;
} KSMPEGVID_RECT,*PKSMPEGVID_RECT;

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO				\
	0xe06d802bL,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO			\
	0xe06d80e5L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO				\
	0xe06d8032L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO			\
	0xe06d80e6L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO				\
	0xe06d802cL,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO				\
	0xe06d80e4L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_KSPROPSETID_AC3						\
	0xBFABE720L,0x6E1F,0x11D0,0xBC,0xF2,0x44,0x45,0x53,0x54,0x00,0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000",KSPROPSETID_AC3);
#define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)

typedef enum {
  KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
  KSPROPERTY_AC3_ALTERNATE_AUDIO,
  KSPROPERTY_AC3_DOWNMIX,
  KSPROPERTY_AC3_BIT_STREAM_MODE,
  KSPROPERTY_AC3_DIALOGUE_LEVEL,
  KSPROPERTY_AC3_LANGUAGE_CODE,
  KSPROPERTY_AC3_ROOM_TYPE
} KSPROPERTY_AC3;

typedef struct {
  WINBOOL fRepeatPreviousBlock;
  WINBOOL fErrorInCurrentBlock;
} KSAC3_ERROR_CONCEALMENT,*PKSAC3_ERROR_CONCEALMENT;

typedef struct {
  WINBOOL fStereo;
  ULONG DualMode;
} KSAC3_ALTERNATE_AUDIO,*PKSAC3_ALTERNATE_AUDIO;

#define KSAC3_ALTERNATE_AUDIO_1		1
#define KSAC3_ALTERNATE_AUDIO_2		2
#define KSAC3_ALTERNATE_AUDIO_BOTH	3

typedef struct {
  WINBOOL fDownMix;
  WINBOOL fDolbySurround;
} KSAC3_DOWNMIX,*PKSAC3_DOWNMIX;

typedef struct {
  LONG BitStreamMode;
} KSAC3_BIT_STREAM_MODE,*PKSAC3_BIT_STREAM_MODE;

#define KSAC3_SERVICE_MAIN_AUDIO	0
#define KSAC3_SERVICE_NO_DIALOG		1
#define KSAC3_SERVICE_VISUALLY_IMPAIRED	2
#define KSAC3_SERVICE_HEARING_IMPAIRED	3
#define KSAC3_SERVICE_DIALOG_ONLY	4
#define KSAC3_SERVICE_COMMENTARY	5
#define KSAC3_SERVICE_EMERGENCY_FLASH	6
#define KSAC3_SERVICE_VOICE_OVER	7

typedef struct {
  ULONG DialogueLevel;
} KSAC3_DIALOGUE_LEVEL,*PKSAC3_DIALOGUE_LEVEL;

typedef struct {
  WINBOOL fLargeRoom;
} KSAC3_ROOM_TYPE,*PKSAC3_ROOM_TYPE;

#define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO				\
	0xe06d8033L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO				\
	0xe06d8034L,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)

#define STATIC_KSPROPSETID_AudioDecoderOut				\
	0x6ca6e020L,0x43bd,0x11d0,0xbd,0x6a,0x00,0x35,0x05,0xc1,0x03,0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9",KSPROPSETID_AudioDecoderOut);
#define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)

typedef enum {
  KSPROPERTY_AUDDECOUT_MODES,
  KSPROPERTY_AUDDECOUT_CUR_MODE
} KSPROPERTY_AUDDECOUT;

#define KSAUDDECOUTMODE_STEREO_ANALOG	0x0001
#define KSAUDDECOUTMODE_PCM_51		0x0002
#define KSAUDDECOUTMODE_SPDIFF		0x0004

#define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE				\
	0xe06d802dL,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea",KSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)

#define STATIC_KSPROPSETID_DvdSubPic					\
	0xac390460L,0x43af,0x11d0,0xbd,0x6a,0x00,0x35,0x05,0xc1,0x03,0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9",KSPROPSETID_DvdSubPic);
#define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)

typedef enum {
  KSPROPERTY_DVDSUBPIC_PALETTE,
  KSPROPERTY_DVDSUBPIC_HLI,
  KSPROPERTY_DVDSUBPIC_COMPOSIT_ON
} KSPROPERTY_DVDSUBPIC;

typedef struct _KS_DVD_YCrCb {
  UCHAR Reserved;
  UCHAR Y;
  UCHAR Cr;
  UCHAR Cb;
} KS_DVD_YCrCb,*PKS_DVD_YCrCb;

typedef struct _KS_DVD_YUV {
  UCHAR Reserved;
  UCHAR Y;
  UCHAR V;
  UCHAR U;
} KS_DVD_YUV,*PKS_DVD_YUV;

typedef struct _KSPROPERTY_SPPAL {
  KS_DVD_YUV sppal[16];
} KSPROPERTY_SPPAL,*PKSPROPERTY_SPPAL;

typedef struct _KS_COLCON {
  UCHAR emph1col:4;
  UCHAR emph2col:4;
  UCHAR backcol:4;
  UCHAR patcol:4;
  UCHAR emph1con:4;
  UCHAR emph2con:4;
  UCHAR backcon:4;
  UCHAR patcon:4;
} KS_COLCON,*PKS_COLCON;

typedef struct _KSPROPERTY_SPHLI {
  USHORT HLISS;
  USHORT Reserved;
  ULONG StartPTM;
  ULONG EndPTM;
  USHORT StartX;
  USHORT StartY;
  USHORT StopX;
  USHORT StopY;
  KS_COLCON ColCon;
} KSPROPERTY_SPHLI,*PKSPROPERTY_SPHLI;

typedef WINBOOL KSPROPERTY_COMPOSIT_ON,*PKSPROPERTY_COMPOSIT_ON;

#define STATIC_KSPROPSETID_CopyProt					\
	0x0E8A0A40L,0x6AEF,0x11D0,0x9E,0xD0,0x00,0xA0,0x24,0xCA,0x19,0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3",KSPROPSETID_CopyProt);
#define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)

typedef enum {
  KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
  KSPROPERTY_DVDCOPY_DVD_KEY1,
  KSPROPERTY_DVDCOPY_DEC_KEY2,
  KSPROPERTY_DVDCOPY_TITLE_KEY,
  KSPROPERTY_COPY_MACROVISION,
  KSPROPERTY_DVDCOPY_REGION,
  KSPROPERTY_DVDCOPY_SET_COPY_STATE,
  KSPROPERTY_DVDCOPY_DISC_KEY = 0x80
} KSPROPERTY_COPYPROT;

typedef struct _KS_DVDCOPY_CHLGKEY {
  BYTE ChlgKey[10];
  BYTE Reserved[2];
} KS_DVDCOPY_CHLGKEY,*PKS_DVDCOPY_CHLGKEY;

typedef struct _KS_DVDCOPY_BUSKEY {
  BYTE BusKey[5];
  BYTE Reserved[1];
} KS_DVDCOPY_BUSKEY,*PKS_DVDCOPY_BUSKEY;

typedef struct _KS_DVDCOPY_DISCKEY {
  BYTE DiscKey[2048];
} KS_DVDCOPY_DISCKEY,*PKS_DVDCOPY_DISCKEY;

typedef struct _KS_DVDCOPY_REGION {
  UCHAR Reserved;
  UCHAR RegionData;
  UCHAR Reserved2[2];
} KS_DVDCOPY_REGION,*PKS_DVDCOPY_REGION;

typedef struct _KS_DVDCOPY_TITLEKEY {
  ULONG KeyFlags;
  ULONG ReservedNT[2];
  UCHAR TitleKey[6];
  UCHAR Reserved[2];
} KS_DVDCOPY_TITLEKEY,*PKS_DVDCOPY_TITLEKEY;

typedef struct _KS_COPY_MACROVISION {
  ULONG MACROVISIONLevel;
} KS_COPY_MACROVISION,*PKS_COPY_MACROVISION;

typedef struct _KS_DVDCOPY_SET_COPY_STATE {
  ULONG DVDCopyState;
} KS_DVDCOPY_SET_COPY_STATE,*PKS_DVDCOPY_SET_COPY_STATE;

typedef enum {
  KS_DVDCOPYSTATE_INITIALIZE,
  KS_DVDCOPYSTATE_INITIALIZE_TITLE,
  KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
  KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
  KS_DVDCOPYSTATE_DONE
} KS_DVDCOPYSTATE;

typedef enum {
  KS_MACROVISION_DISABLED,
  KS_MACROVISION_LEVEL1,
  KS_MACROVISION_LEVEL2,
  KS_MACROVISION_LEVEL3
} KS_COPY_MACROVISION_LEVEL,*PKS_COPY_MACROVISION_LEVEL;

#define KS_DVD_CGMS_RESERVED_MASK	0x00000078

#define KS_DVD_CGMS_COPY_PROTECT_MASK	0x00000018
#define KS_DVD_CGMS_COPY_PERMITTED	0x00000000
#define KS_DVD_CGMS_COPY_ONCE		0x00000010
#define KS_DVD_CGMS_NO_COPY		0x00000018

#define KS_DVD_COPYRIGHT_MASK		0x00000040
#define KS_DVD_NOT_COPYRIGHTED		0x00000000
#define KS_DVD_COPYRIGHTED		0x00000040

#define KS_DVD_SECTOR_PROTECT_MASK	0x00000020
#define KS_DVD_SECTOR_NOT_PROTECTED	0x00000000
#define KS_DVD_SECTOR_PROTECTED		0x00000020

#define STATIC_KSCATEGORY_TVTUNER					\
	0xa799a800L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4",KSCATEGORY_TVTUNER);
#define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)

#define STATIC_KSCATEGORY_CROSSBAR					\
	0xa799a801L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4",KSCATEGORY_CROSSBAR);
#define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)

#define STATIC_KSCATEGORY_TVAUDIO					\
	0xa799a802L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4",KSCATEGORY_TVAUDIO);
#define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)

#define STATIC_KSCATEGORY_VPMUX						\
	0xa799a803L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4",KSCATEGORY_VPMUX);
#define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)

#define STATIC_KSCATEGORY_VBICODEC					\
	0x07dad660L,0x22f1,0x11d1,0xa9,0xf4,0x00,0xc0,0x4f,0xbb,0xde,0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f",KSCATEGORY_VBICODEC);
#define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)

#define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo				\
	0x5a9b6a40L,0x1a22,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a",KSDATAFORMAT_SUBTYPE_VPVideo);
#define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)

#define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI				\
	0x5a9b6a41L,0x1a22,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a",KSDATAFORMAT_SUBTYPE_VPVBI);
#define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)

#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO				\
	0x05589f80L,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a",KSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)

#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2			\
	0xf72a76A0L,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba",KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)

#define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO				\
	0x0482dde1L,0x7817,0x11cf,0x8a,0x03,0x00,0xaa,0x00,0x6e,0xcb,0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65",KSDATAFORMAT_TYPE_ANALOGVIDEO);
#define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)

#define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO			\
	0x0482dde0L,0x7817,0x11cf,0x8a,0x03,0x00,0xaa,0x00,0x6e,0xcb,0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65",KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

#define STATIC_KSDATAFORMAT_TYPE_ANALOGAUDIO				\
	0x0482dee1L,0x7817,0x11cf,0x8a,0x03,0x00,0xaa,0x00,0x6e,0xcb,0x65
DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65",KSDATAFORMAT_TYPE_ANALOGAUDIO);
#define KSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGAUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_VBI				\
	0xf72a76e0L,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba",KSDATAFORMAT_SPECIFIER_VBI);
#define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)

#define STATIC_KSDATAFORMAT_TYPE_VBI					\
	0xf72a76e1L,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba",KSDATAFORMAT_TYPE_VBI);
#define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)

#define STATIC_KSDATAFORMAT_SUBTYPE_RAW8				\
	0xca20d9a0,0x3e3e,0x11d1,0x9b,0xf9,0x0,0xc0,0x4f,0xbb,0xde,0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf",KSDATAFORMAT_SUBTYPE_RAW8);
#define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)

#define STATIC_KSDATAFORMAT_SUBTYPE_CC					\
	0x33214cc1,0x11f,0x11d2,0xb4,0xb1,0x0,0xa0,0xd1,0x2,0xcf,0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE",KSDATAFORMAT_SUBTYPE_CC);
#define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS				\
	0xf72a76e2L,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba",KSDATAFORMAT_SUBTYPE_NABTS);
#define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT				\
	0xf72a76e3L,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba",KSDATAFORMAT_SUBTYPE_TELETEXT);
#define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)

#define KS_BI_RGB		0L
#define KS_BI_RLE8		1L
#define KS_BI_RLE4		2L
#define KS_BI_BITFIELDS		3L

typedef struct tagKS_RGBQUAD {
  BYTE rgbBlue;
  BYTE rgbGreen;
  BYTE rgbRed;
  BYTE rgbReserved;
} KS_RGBQUAD,*PKS_RGBQUAD;

#define KS_iPALETTE_COLORS	256
#define KS_iEGA_COLORS		16
#define KS_iMASK_COLORS		3
#define KS_iTRUECOLOR		16
#define KS_iRED			0
#define KS_iGREEN		1
#define KS_iBLUE		2
#define KS_iPALETTE		8
#define KS_iMAXBITS		8
#define KS_SIZE_EGA_PALETTE	(KS_iEGA_COLORS *sizeof(KS_RGBQUAD))
#define KS_SIZE_PALETTE		(KS_iPALETTE_COLORS *sizeof(KS_RGBQUAD))

typedef struct tagKS_BITMAPINFOHEADER {
  DWORD biSize;
  LONG biWidth;
  LONG biHeight;
  WORD biPlanes;
  WORD biBitCount;
  DWORD biCompression;
  DWORD biSizeImage;
  LONG biXPelsPerMeter;
  LONG biYPelsPerMeter;
  DWORD biClrUsed;
  DWORD biClrImportant;
} KS_BITMAPINFOHEADER,*PKS_BITMAPINFOHEADER;

typedef struct tag_KS_TRUECOLORINFO {
  DWORD dwBitMasks[KS_iMASK_COLORS];
  KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
} KS_TRUECOLORINFO,*PKS_TRUECOLORINFO;

#define KS_WIDTHBYTES(bits)	((DWORD)(((bits)+31) & (~31)) / 8)
#define KS_DIBWIDTHBYTES(bi)	(DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth *(DWORD)(bi).biBitCount)
#define KS__DIBSIZE(bi)		(KS_DIBWIDTHBYTES(bi) *(DWORD)(bi).biHeight)
#define KS_DIBSIZE(bi)		((bi).biHeight < 0 ? (-1)*(KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))

typedef LONGLONG REFERENCE_TIME;

typedef struct tagKS_VIDEOINFOHEADER {
  RECT rcSource;
  RECT rcTarget;
  DWORD dwBitRate;
  DWORD dwBitErrorRate;
  REFERENCE_TIME AvgTimePerFrame;
  KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER,*PKS_VIDEOINFOHEADER;

typedef struct tagKS_VIDEOINFO {
  RECT rcSource;
  RECT rcTarget;
  DWORD dwBitRate;
  DWORD dwBitErrorRate;
  REFERENCE_TIME AvgTimePerFrame;
  KS_BITMAPINFOHEADER bmiHeader;
  __MINGW_EXTENSION union {
    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
    DWORD dwBitMasks[KS_iMASK_COLORS];
    KS_TRUECOLORINFO TrueColorInfo;
  };
} KS_VIDEOINFO,*PKS_VIDEOINFO;

#define KS_SIZE_MASKS			(KS_iMASK_COLORS *sizeof(DWORD))
#define KS_SIZE_PREHEADER		(FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader))

#define KS_SIZE_VIDEOHEADER(pbmi)	((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)

typedef struct tagKS_VBIINFOHEADER {
  ULONG StartLine;
  ULONG EndLine;
  ULONG SamplingFrequency;
  ULONG MinLineStartTime;
  ULONG MaxLineStartTime;
  ULONG ActualLineStartTime;
  ULONG ActualLineEndTime;
  ULONG VideoStandard;
  ULONG SamplesPerLine;
  ULONG StrideInBytes;
  ULONG BufferSize;
} KS_VBIINFOHEADER,*PKS_VBIINFOHEADER;

#define KS_VBIDATARATE_NABTS		(5727272L)
#define KS_VBIDATARATE_CC		(503493L)
#define KS_VBISAMPLINGRATE_4X_NABTS	((long)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS	((long)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS	((long)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER		(KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

typedef struct tagKS_AnalogVideoInfo {
  RECT rcSource;
  RECT rcTarget;
  DWORD dwActiveWidth;
  DWORD dwActiveHeight;
  REFERENCE_TIME AvgTimePerFrame;
} KS_ANALOGVIDEOINFO,*PKS_ANALOGVIDEOINFO;

#define KS_TVTUNER_CHANGE_BEGIN_TUNE	0x0001L
#define KS_TVTUNER_CHANGE_END_TUNE	0x0002L

typedef struct tagKS_TVTUNER_CHANGE_INFO {
  DWORD dwFlags;
  DWORD dwCountryCode;
  DWORD dwAnalogVideoStandard;
  DWORD dwChannel;
} KS_TVTUNER_CHANGE_INFO,*PKS_TVTUNER_CHANGE_INFO;

typedef enum {
  KS_MPEG2Level_Low,
  KS_MPEG2Level_Main,
  KS_MPEG2Level_High1440,
  KS_MPEG2Level_High
} KS_MPEG2Level;

typedef enum {
  KS_MPEG2Profile_Simple,
  KS_MPEG2Profile_Main,
  KS_MPEG2Profile_SNRScalable,
  KS_MPEG2Profile_SpatiallyScalable,
  KS_MPEG2Profile_High
} KS_MPEG2Profile;

#define KS_INTERLACE_IsInterlaced		0x00000001
#define KS_INTERLACE_1FieldPerSample		0x00000002
#define KS_INTERLACE_Field1First		0x00000004
#define KS_INTERLACE_UNUSED			0x00000008
#define KS_INTERLACE_FieldPatternMask		0x00000030
#define KS_INTERLACE_FieldPatField1Only		0x00000000
#define KS_INTERLACE_FieldPatField2Only		0x00000010
#define KS_INTERLACE_FieldPatBothRegular	0x00000020
#define KS_INTERLACE_FieldPatBothIrregular	0x00000030
#define KS_INTERLACE_DisplayModeMask		0x000000c0
#define KS_INTERLACE_DisplayModeBobOnly		0x00000000
#define KS_INTERLACE_DisplayModeWeaveOnly	0x00000040
#define KS_INTERLACE_DisplayModeBobOrWeave	0x00000080

#define KS_MPEG2_DoPanScan			0x00000001
#define KS_MPEG2_DVDLine21Field1		0x00000002
#define KS_MPEG2_DVDLine21Field2		0x00000004
#define KS_MPEG2_SourceIsLetterboxed		0x00000008
#define KS_MPEG2_FilmCameraMode			0x00000010
#define KS_MPEG2_LetterboxAnalogOut		0x00000020
#define KS_MPEG2_DSS_UserData			0x00000040
#define KS_MPEG2_DVB_UserData			0x00000080
#define KS_MPEG2_27MhzTimebase			0x00000100

typedef struct tagKS_VIDEOINFOHEADER2 {
  RECT rcSource;
  RECT rcTarget;
  DWORD dwBitRate;
  DWORD dwBitErrorRate;
  REFERENCE_TIME AvgTimePerFrame;
  DWORD dwInterlaceFlags;
  DWORD dwCopyProtectFlags;
  DWORD dwPictAspectRatioX;
  DWORD dwPictAspectRatioY;
  DWORD dwReserved1;
  DWORD dwReserved2;
  KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER2,*PKS_VIDEOINFOHEADER2;

typedef struct tagKS_MPEG1VIDEOINFO {
  KS_VIDEOINFOHEADER hdr;
  DWORD dwStartTimeCode;
  DWORD cbSequenceHeader;
  BYTE bSequenceHeader[1];
} KS_MPEG1VIDEOINFO,*PKS_MPEG1VIDEOINFO;

#define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO	140
#define KS_SIZE_MPEG1VIDEOINFO(pv)	(FIELD_OFFSET(KS_MPEG1VIDEOINFO,bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv)	((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagKS_MPEGVIDEOINFO2 {
  KS_VIDEOINFOHEADER2 hdr;
  DWORD dwStartTimeCode;
  DWORD cbSequenceHeader;
  DWORD dwProfile;
  DWORD dwLevel;
  DWORD dwFlags;
  DWORD bSequenceHeader[1];
} KS_MPEGVIDEOINFO2,*PKS_MPEGVIDEOINFO2;

#define KS_SIZE_MPEGVIDEOINFO2(pv)	(FIELD_OFFSET(KS_MPEGVIDEOINFO2,bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv)	((const BYTE *)(pv)->bSequenceHeader)

#define KS_MPEGAUDIOINFO_27MhzTimebase	0x00000001

typedef struct tagKS_MPEAUDIOINFO {
  DWORD dwFlags;
  DWORD dwReserved1;
  DWORD dwReserved2;
  DWORD dwReserved3;
} KS_MPEGAUDIOINFO,*PKS_MPEGAUDIOINFO;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER {
  KSDATAFORMAT DataFormat;
  KS_VIDEOINFOHEADER VideoInfoHeader;
} KS_DATAFORMAT_VIDEOINFOHEADER,*PKS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2 {
  KSDATAFORMAT DataFormat;
  KS_VIDEOINFOHEADER2 VideoInfoHeader2;
} KS_DATAFORMAT_VIDEOINFOHEADER2,*PKS_DATAFORMAT_VIDEOINFOHEADER2;

typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE {
  KSDATAFORMAT DataFormat;
  KS_VIDEOINFO VideoInfo;
} KS_DATAFORMAT_VIDEOINFO_PALETTE,*PKS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagKS_DATAFORMAT_VBIINFOHEADER {
  KSDATAFORMAT DataFormat;
  KS_VBIINFOHEADER VBIInfoHeader;
} KS_DATAFORMAT_VBIINFOHEADER,*PKS_DATAFORMAT_VBIINFOHEADER;

typedef struct _KS_VIDEO_STREAM_CONFIG_CAPS {
  GUID guid;
  ULONG VideoStandard;
  SIZE InputSize;
  SIZE MinCroppingSize;
  SIZE MaxCroppingSize;
  int CropGranularityX;
  int CropGranularityY;
  int CropAlignX;
  int CropAlignY;
  SIZE MinOutputSize;
  SIZE MaxOutputSize;
  int OutputGranularityX;
  int OutputGranularityY;
  int StretchTapsX;
  int StretchTapsY;
  int ShrinkTapsX;
  int ShrinkTapsY;
  LONGLONG MinFrameInterval;
  LONGLONG MaxFrameInterval;
  LONG MinBitsPerSecond;
  LONG MaxBitsPerSecond;
} KS_VIDEO_STREAM_CONFIG_CAPS,*PKS_VIDEO_STREAM_CONFIG_CAPS;

typedef struct tagKS_DATARANGE_VIDEO {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_VIDEOINFOHEADER VideoInfoHeader;
} KS_DATARANGE_VIDEO,*PKS_DATARANGE_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO2 {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_VIDEOINFOHEADER2 VideoInfoHeader;
} KS_DATARANGE_VIDEO2,*PKS_DATARANGE_VIDEO2;

typedef struct tagKS_DATARANGE_MPEG1_VIDEO {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_MPEG1VIDEOINFO VideoInfoHeader;
} KS_DATARANGE_MPEG1_VIDEO,*PKS_DATARANGE_MPEG1_VIDEO;

typedef struct tagKS_DATARANGE_MPEG2_VIDEO {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_MPEGVIDEOINFO2 VideoInfoHeader;
} KS_DATARANGE_MPEG2_VIDEO,*PKS_DATARANGE_MPEG2_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO_PALETTE {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_VIDEOINFO VideoInfo;
} KS_DATARANGE_VIDEO_PALETTE,*PKS_DATARANGE_VIDEO_PALETTE;

typedef struct tagKS_DATARANGE_VIDEO_VBI {
  KSDATARANGE DataRange;
  WINBOOL bFixedSizeSamples;
  WINBOOL bTemporalCompression;
  DWORD StreamDescriptionFlags;
  DWORD MemoryAllocationFlags;
  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
  KS_VBIINFOHEADER VBIInfoHeader;
} KS_DATARANGE_VIDEO_VBI,*PKS_DATARANGE_VIDEO_VBI;

typedef struct tagKS_DATARANGE_ANALOGVIDEO {
  KSDATARANGE DataRange;
  KS_ANALOGVIDEOINFO AnalogVideoInfo;
} KS_DATARANGE_ANALOGVIDEO,*PKS_DATARANGE_ANALOGVIDEO;

#define KS_VIDEOSTREAM_PREVIEW		0x0001
#define KS_VIDEOSTREAM_CAPTURE		0x0002
#define KS_VIDEOSTREAM_VBI		0x0010
#define KS_VIDEOSTREAM_NABTS		0x0020
#define KS_VIDEOSTREAM_CC		0x0100
#define KS_VIDEOSTREAM_EDS		0x0200
#define KS_VIDEOSTREAM_TELETEXT		0x0400
#define KS_VIDEOSTREAM_STILL		0x1000
#define KS_VIDEOSTREAM_IS_VPE		0x8000

#define KS_VIDEO_ALLOC_VPE_SYSTEM	0x0001
#define KS_VIDEO_ALLOC_VPE_DISPLAY	0x0002
#define KS_VIDEO_ALLOC_VPE_AGP		0x0004

#define STATIC_KSPROPSETID_VBICAP_PROPERTIES				\
	0xf162c607,0x7b35,0x496f,0xad,0x7f,0x2d,0xca,0x3b,0x46,0xb7,0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718",KSPROPSETID_VBICAP_PROPERTIES);
#define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
  KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01
} KSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
  KSPROPERTY Property;
  ULONG StreamIndex;
  ULONG Status;
} VBICAP_PROPERTIES_PROTECTION_S,*PVBICAP_PROPERTIES_PROTECTION_S;

#define KS_VBICAP_PROTECTION_MV_PRESENT				0x0001L
#define KS_VBICAP_PROTECTION_MV_HARDWARE			0x0002L
#define KS_VBICAP_PROTECTION_MV_DETECTED			0x0004L

#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE			0x800
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE	0x810

#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE	0x820
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE	0x830

#define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE		0x840
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE	0x850

#define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE		0x860
#define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE		0x870

#define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE	0x880
#define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE	0x890

#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE	0x8A0
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE	0x8B0

#define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE	0x8F0

#define STATIC_KSDATAFORMAT_TYPE_NABTS					\
	0xe757bca0,0x39ac,0x11d1,0xa9,0xf5,0x0,0xc0,0x4f,0xbb,0xde,0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F",KSDATAFORMAT_TYPE_NABTS);
#define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC				\
	0xe757bca1,0x39ac,0x11d1,0xa9,0xf5,0x0,0xc0,0x4f,0xbb,0xde,0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F",KSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)

#define MAX_NABTS_VBI_LINES_PER_FIELD	11
#define NABTS_LINES_PER_BUNDLE		16
#define NABTS_PAYLOAD_PER_LINE		28
#define NABTS_BYTES_PER_LINE		36

typedef struct _NABTSFEC_BUFFER {
  ULONG dataSize;
  USHORT groupID;
  USHORT Reserved;
  UCHAR data[NABTS_LINES_PER_BUNDLE *NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER,*PNABTSFEC_BUFFER;

#define STATIC_KSPROPSETID_VBICodecFiltering				\
	0xcafeb0caL,0x8715,0x11d0,0xbd,0x6a,0x00,0x35,0xc0,0xed,0xba,0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe",KSPROPSETID_VBICodecFiltering);
#define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)

typedef enum {
  KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
  KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
  KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
  KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
  KSPROPERTY_VBICODECFILTERING_STATISTICS
} KSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
  DWORD DwordBitArray[32];
} VBICODECFILTERING_SCANLINES,*PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
  DWORD SubstreamMask[128];
} VBICODECFILTERING_NABTS_SUBSTREAMS,*PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
  DWORD SubstreamMask;
} VBICODECFILTERING_CC_SUBSTREAMS,*PVBICODECFILTERING_CC_SUBSTREAMS;

#define KS_CC_SUBSTREAM_ODD		0x0001L
#define KS_CC_SUBSTREAM_EVEN		0x0002L

#define KS_CC_SUBSTREAM_FIELD1_MASK	0x00F0L
#define KS_CC_SUBSTREAM_SERVICE_CC1	0x0010L
#define KS_CC_SUBSTREAM_SERVICE_CC2	0x0020L
#define KS_CC_SUBSTREAM_SERVICE_T1	0x0040L
#define KS_CC_SUBSTREAM_SERVICE_T2	0x0080L

#define KS_CC_SUBSTREAM_FIELD2_MASK	0x1F00L
#define KS_CC_SUBSTREAM_SERVICE_CC3	0x0100L
#define KS_CC_SUBSTREAM_SERVICE_CC4	0x0200L
#define KS_CC_SUBSTREAM_SERVICE_T3	0x0400L
#define KS_CC_SUBSTREAM_SERVICE_T4	0x0800L
#define KS_CC_SUBSTREAM_SERVICE_XDS	0x1000L

#define CC_MAX_HW_DECODE_LINES		12
typedef struct _CC_BYTE_PAIR {
  BYTE Decoded[2];
  USHORT Reserved;
} CC_BYTE_PAIR,*PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
  VBICODECFILTERING_SCANLINES ScanlinesRequested;
  ULONG fieldFlags;
  LONGLONG PictureNumber;
  CC_BYTE_PAIR Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD,*PCC_HW_FIELD;

#ifndef PACK_PRAGMAS_NOT_SUPPORTED
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
  BYTE Confidence;
  BYTE Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE,*PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT	1
typedef struct _NABTS_BUFFER {
  VBICODECFILTERING_SCANLINES ScanlinesRequested;
  LONGLONG PictureNumber;
  NABTS_BUFFER_LINE NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER,*PNABTS_BUFFER;
#ifndef PACK_PRAGMAS_NOT_SUPPORTED
#include <poppack.h>
#endif

#define WST_TVTUNER_CHANGE_BEGIN_TUNE	0x1000L
#define WST_TVTUNER_CHANGE_END_TUNE	0x2000L

#define MAX_WST_VBI_LINES_PER_FIELD	17
#define WST_BYTES_PER_LINE		42

typedef struct _WST_BUFFER_LINE {
  BYTE Confidence;
  BYTE Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE,*PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
  VBICODECFILTERING_SCANLINES ScanlinesRequested;
  WST_BUFFER_LINE WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER,*PWST_BUFFER;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
  DWORD InputSRBsProcessed;
  DWORD OutputSRBsProcessed;
  DWORD SRBsIgnored;
  DWORD InputSRBsMissing;
  DWORD OutputSRBsMissing;
  DWORD OutputFailures;
  DWORD InternalErrors;
  DWORD ExternalErrors;
  DWORD InputDiscontinuities;
  DWORD DSPFailures;
  DWORD TvTunerChanges;
  DWORD VBIHeaderChanges;
  DWORD LineConfidenceAvg;
  DWORD BytesOutput;
} VBICODECFILTERING_STATISTICS_COMMON,*PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
  DWORD SRBsProcessed;
  DWORD SRBsIgnored;
  DWORD SRBsMissing;
  DWORD InternalErrors;
  DWORD ExternalErrors;
  DWORD Discontinuities;
  DWORD LineConfidenceAvg;
  DWORD BytesOutput;
} VBICODECFILTERING_STATISTICS_COMMON_PIN,*PVBICODECFILTERING_STATISTICS_COMMON_PIN;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
  VBICODECFILTERING_STATISTICS_COMMON Common;
  DWORD FECBundleBadLines;
  DWORD FECQueueOverflows;
  DWORD FECCorrectedLines;
  DWORD FECUncorrectableLines;
  DWORD BundlesProcessed;
  DWORD BundlesSent2IP;
  DWORD FilteredLines;
} VBICODECFILTERING_STATISTICS_NABTS,*PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
} VBICODECFILTERING_STATISTICS_NABTS_PIN,*PVBICODECFILTERING_STATISTICS_NABTS_PIN;

typedef struct _VBICODECFILTERING_STATISTICS_CC {
  VBICODECFILTERING_STATISTICS_COMMON Common;
} VBICODECFILTERING_STATISTICS_CC,*PVBICODECFILTERING_STATISTICS_CC;

typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
} VBICODECFILTERING_STATISTICS_CC_PIN,*PVBICODECFILTERING_STATISTICS_CC_PIN;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
  VBICODECFILTERING_STATISTICS_COMMON Common;
} VBICODECFILTERING_STATISTICS_TELETEXT,*PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN,*PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_SCANLINES Scanlines;
} KSPROPERTY_VBICODECFILTERING_SCANLINES_S,*PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_NABTS_SUBSTREAMS Substreams;
} KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S,*PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_CC_SUBSTREAMS Substreams;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S,*PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_COMMON Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_NABTS Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_NABTS_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_CC Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
  KSPROPERTY Property;
  VBICODECFILTERING_STATISTICS_CC_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S,*PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

#define STATIC_PINNAME_VIDEO_CAPTURE					\
	0xfb6c4281,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#define STATIC_PINNAME_VIDEO_CC_CAPTURE					\
	0x1aad8061,0x12d,0x11d2,0xb4,0xb1,0x0,0xa0,0xd1,0x2,0xcf,0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE",PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE				\
	0x29703660,0x498a,0x11d2,0xb4,0xb1,0x0,0xa0,0xd1,0x2,0xcf,0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE",PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)

#define STATIC_PINNAME_VIDEO_PREVIEW					\
	0xfb6c4282,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN				\
	0xfb6c4283,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI					\
	0xfb6c4284,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#define STATIC_PINNAME_VIDEO_VIDEOPORT					\
	0xfb6c4285,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#define STATIC_PINNAME_VIDEO_NABTS					\
	0xfb6c4286,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS					\
	0xfb6c4287,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT					\
	0xfb6c4288,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC						\
	0xfb6c4289,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)

#define STATIC_PINNAME_VIDEO_STILL					\
	0xfb6c428A,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#define STATIC_PINNAME_VIDEO_TIMECODE					\
	0xfb6c428B,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI				\
	0xfb6c428C,0x353,0x11d1,0x90,0x5f,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA",PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)

#define KS_VIDEO_FLAG_FRAME		0x0000L
#define KS_VIDEO_FLAG_FIELD1		0x0001L
#define KS_VIDEO_FLAG_FIELD2		0x0002L

#define KS_VIDEO_FLAG_I_FRAME		0x0000L
#define KS_VIDEO_FLAG_P_FRAME		0x0010L
#define KS_VIDEO_FLAG_B_FRAME		0x0020L

typedef struct tagKS_FRAME_INFO {
  ULONG ExtendedHeaderSize;
  DWORD dwFrameFlags;
  LONGLONG PictureNumber;
  LONGLONG DropCount;
  HANDLE hDirectDraw;
  HANDLE hSurfaceHandle;
  RECT DirectDrawRect;

  DWORD Reserved1;
  DWORD Reserved2;
  DWORD Reserved3;
  DWORD Reserved4;
} KS_FRAME_INFO,*PKS_FRAME_INFO;

#define KS_VBI_FLAG_FIELD1		0x0001L
#define KS_VBI_FLAG_FIELD2		0x0002L

#define KS_VBI_FLAG_MV_PRESENT		0x0100L
#define KS_VBI_FLAG_MV_HARDWARE		0x0200L
#define KS_VBI_FLAG_MV_DETECTED		0x0400L

#define KS_VBI_FLAG_TVTUNER_CHANGE	0x0010L
#define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L

typedef struct tagKS_VBI_FRAME_INFO {
  ULONG ExtendedHeaderSize;
  DWORD dwFrameFlags;
  LONGLONG PictureNumber;
  LONGLONG DropCount;
  DWORD dwSamplingFrequency;
  KS_TVTUNER_CHANGE_INFO TvTunerChangeInfo;
  KS_VBIINFOHEADER VBIInfoHeader;
} KS_VBI_FRAME_INFO,*PKS_VBI_FRAME_INFO;

typedef enum
{
  KS_AnalogVideo_None = 0x00000000,
  KS_AnalogVideo_NTSC_M = 0x00000001,
  KS_AnalogVideo_NTSC_M_J = 0x00000002,
  KS_AnalogVideo_NTSC_433 = 0x00000004,
  KS_AnalogVideo_PAL_B = 0x00000010,
  KS_AnalogVideo_PAL_D = 0x00000020,
  KS_AnalogVideo_PAL_G = 0x00000040,
  KS_AnalogVideo_PAL_H = 0x00000080,
  KS_AnalogVideo_PAL_I = 0x00000100,
  KS_AnalogVideo_PAL_M = 0x00000200,
  KS_AnalogVideo_PAL_N = 0x00000400,
  KS_AnalogVideo_PAL_60 = 0x00000800,
  KS_AnalogVideo_SECAM_B = 0x00001000,
  KS_AnalogVideo_SECAM_D = 0x00002000,
  KS_AnalogVideo_SECAM_G = 0x00004000,
  KS_AnalogVideo_SECAM_H = 0x00008000,
  KS_AnalogVideo_SECAM_K = 0x00010000,
  KS_AnalogVideo_SECAM_K1 = 0x00020000,
  KS_AnalogVideo_SECAM_L = 0x00040000,
  KS_AnalogVideo_SECAM_L1 = 0x00080000,
  KS_AnalogVideo_PAL_N_COMBO = 0x00100000
} KS_AnalogVideoStandard;

#define KS_AnalogVideo_NTSC_Mask	0x00000007
#define KS_AnalogVideo_PAL_Mask		0x00100FF0
#define KS_AnalogVideo_SECAM_Mask	0x000FF000

#define STATIC_PROPSETID_ALLOCATOR_CONTROL				\
	0x53171960,0x148e,0x11d2,0x99,0x79,0x0,0x0,0xc0,0xcc,0x16,0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA",PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)

typedef enum {
  KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
  KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,
  KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
  KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE
} KSPROPERTY_ALLOCATOR_CONTROL;

typedef struct {
  ULONG CX;
  ULONG CY;
} KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S,*PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S;

typedef struct {
  ULONG InterleavedCapSupported;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S,*PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

typedef struct {
  ULONG InterleavedCapPossible;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S,*PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP				\
	0xC6E13360L,0x30AC,0x11d0,0xa1,0x8c,0x00,0xA0,0xC9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956",PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
  KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
  KSPROPERTY_VIDEOPROCAMP_CONTRAST,
  KSPROPERTY_VIDEOPROCAMP_HUE,
  KSPROPERTY_VIDEOPROCAMP_SATURATION,
  KSPROPERTY_VIDEOPROCAMP_SHARPNESS,
  KSPROPERTY_VIDEOPROCAMP_GAMMA,
  KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
  KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,
  KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,
  KSPROPERTY_VIDEOPROCAMP_GAIN,
  KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER,
  KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER_LIMIT,
  KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE_COMPONENT,
  KSPROPERTY_VIDEOPROCAMP_POWERLINE_FREQUENCY
} KSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
  KSPROPERTY Property;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_VIDEOPROCAMP_S,*PKSPROPERTY_VIDEOPROCAMP_S;

typedef struct {
  KSP_NODE NodeProperty;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_VIDEOPROCAMP_NODE_S,*PKSPROPERTY_VIDEOPROCAMP_NODE_S;

typedef struct {
  KSPROPERTY Property;
  LONG Value1;
  ULONG Flags;
  ULONG Capabilities;
  LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_S2,*PKSPROPERTY_VIDEOPROCAMP_S2;

typedef struct {
  KSP_NODE NodeProperty;
  LONG Value1;
  ULONG Flags;
  ULONG Capabilities;
  LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_NODE_S2,*PKSPROPERTY_VIDEOPROCAMP_NODE_S2;

#define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO	0X0001L
#define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL	0X0002L

#define STATIC_PROPSETID_VIDCAP_SELECTOR				\
	0x1ABDAECA,0x68B6,0x4F83,0x93,0x71,0xB4,0x13,0x90,0x7C,0x7B,0x9F
DEFINE_GUIDSTRUCT("1ABDAECA-68B6-4F83-9371-B413907C7B9F",PROPSETID_VIDCAP_SELECTOR);
#define PROPSETID_VIDCAP_SELECTOR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_SELECTOR)

typedef enum {
  KSPROPERTY_SELECTOR_SOURCE_NODE_ID,
  KSPROPERTY_SELECTOR_NUM_SOURCES
} KSPROPERTY_VIDCAP_SELECTOR,*PKSPROPERTY_VIDCAP_SELECTOR;

typedef struct {
  KSPROPERTY Property;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_SELECTOR_S,*PKSPROPERTY_SELECTOR_S;

typedef struct {
  KSP_NODE NodeProperty;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_SELECTOR_NODE_S,*PKSPROPERTY_SELECTOR_NODE_S;

#define STATIC_PROPSETID_TUNER						\
	0x6a2e0605L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956",PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
  KSPROPERTY_TUNER_CAPS,
  KSPROPERTY_TUNER_MODE_CAPS,
  KSPROPERTY_TUNER_MODE,
  KSPROPERTY_TUNER_STANDARD,
  KSPROPERTY_TUNER_FREQUENCY,
  KSPROPERTY_TUNER_INPUT,
  KSPROPERTY_TUNER_STATUS,
  KSPROPERTY_TUNER_IF_MEDIUM
} KSPROPERTY_TUNER;

typedef enum {
  KSPROPERTY_TUNER_MODE_TV = 0X0001,
  KSPROPERTY_TUNER_MODE_FM_RADIO = 0X0002,
  KSPROPERTY_TUNER_MODE_AM_RADIO = 0X0004,
  KSPROPERTY_TUNER_MODE_DSS = 0X0008,
  KSPROPERTY_TUNER_MODE_ATSC = 0X0010
} KSPROPERTY_TUNER_MODES;

typedef enum {
  KS_TUNER_TUNING_EXACT = 1,
  KS_TUNER_TUNING_FINE,
  KS_TUNER_TUNING_COARSE
} KS_TUNER_TUNING_FLAGS;

typedef enum {
  KS_TUNER_STRATEGY_PLL = 0X01,
  KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02,
  KS_TUNER_STRATEGY_DRIVER_TUNES = 0X04
} KS_TUNER_STRATEGY;

typedef struct {
  KSPROPERTY Property;
  ULONG ModesSupported;
  KSPIN_MEDIUM VideoMedium;
  KSPIN_MEDIUM TVAudioMedium;
  KSPIN_MEDIUM RadioAudioMedium;
} KSPROPERTY_TUNER_CAPS_S,*PKSPROPERTY_TUNER_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  KSPIN_MEDIUM IFMedium;
} KSPROPERTY_TUNER_IF_MEDIUM_S,*PKSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Mode;
  ULONG StandardsSupported;
  ULONG MinFrequency;
  ULONG MaxFrequency;
  ULONG TuningGranularity;
  ULONG NumberOfInputs;
  ULONG SettlingTime;
  ULONG Strategy;
} KSPROPERTY_TUNER_MODE_CAPS_S,*PKSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Mode;
} KSPROPERTY_TUNER_MODE_S,*PKSPROPERTY_TUNER_MODE_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Frequency;
  ULONG LastFrequency;
  ULONG TuningFlags;
  ULONG VideoSubChannel;
  ULONG AudioSubChannel;
  ULONG Channel;
  ULONG Country;
} KSPROPERTY_TUNER_FREQUENCY_S,*PKSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Standard;
} KSPROPERTY_TUNER_STANDARD_S,*PKSPROPERTY_TUNER_STANDARD_S;

typedef struct {
  KSPROPERTY Property;
  ULONG InputIndex;
} KSPROPERTY_TUNER_INPUT_S,*PKSPROPERTY_TUNER_INPUT_S;

typedef struct {
  KSPROPERTY Property;
  ULONG CurrentFrequency;
  ULONG PLLOffset;
  ULONG SignalStrength;
  ULONG Busy;
} KSPROPERTY_TUNER_STATUS_S,*PKSPROPERTY_TUNER_STATUS_S;

#define STATIC_EVENTSETID_TUNER						\
	0x6a2e0606L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956",EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
  KSEVENT_TUNER_CHANGED
} KSEVENT_TUNER;

#define STATIC_KSNODETYPE_VIDEO_STREAMING				\
	0xDFF229E1L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E1-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_STREAMING);
#define KSNODETYPE_VIDEO_STREAMING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_STREAMING)

#define STATIC_KSNODETYPE_VIDEO_INPUT_TERMINAL				\
	0xDFF229E2L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E2-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_INPUT_TERMINAL);
#define KSNODETYPE_VIDEO_INPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_TERMINAL				\
	0xDFF229E3L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E3-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_OUTPUT_TERMINAL);
#define KSNODETYPE_VIDEO_OUTPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_SELECTOR				\
	0xDFF229E4L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E4-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_SELECTOR);
#define KSNODETYPE_VIDEO_SELECTOR DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_SELECTOR)

#define STATIC_KSNODETYPE_VIDEO_PROCESSING				\
	0xDFF229E5L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E5-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_PROCESSING);
#define KSNODETYPE_VIDEO_PROCESSING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_PROCESSING)

#define STATIC_KSNODETYPE_VIDEO_CAMERA_TERMINAL				\
	0xDFF229E6L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E6-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_CAMERA_TERMINAL);
#define KSNODETYPE_VIDEO_CAMERA_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_CAMERA_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_INPUT_MTT				\
	0xDFF229E7L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E7-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_INPUT_MTT);
#define KSNODETYPE_VIDEO_INPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_MTT)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_MTT				\
	0xDFF229E8L,0xF70F,0x11D0,0xB9,0x17,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("DFF229E8-F70F-11D0-B917-00A0C9223196",KSNODETYPE_VIDEO_OUTPUT_MTT);
#define KSNODETYPE_VIDEO_OUTPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_MTT)

#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER				\
	0x6a2e0610L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956",PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
  KSPROPERTY_VIDEOENCODER_CAPS,
  KSPROPERTY_VIDEOENCODER_STANDARD,
  KSPROPERTY_VIDEOENCODER_COPYPROTECTION,
  KSPROPERTY_VIDEOENCODER_CC_ENABLE
} KSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
  KSPROPERTY Property;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_VIDEOENCODER_S,*PKSPROPERTY_VIDEOENCODER_S;

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER				\
	0xC6E13350L,0x30AC,0x11d0,0xA1,0x8C,0x00,0xA0,0xC9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956",PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
  KSPROPERTY_VIDEODECODER_CAPS,
  KSPROPERTY_VIDEODECODER_STANDARD,
  KSPROPERTY_VIDEODECODER_STATUS,
  KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
  KSPROPERTY_VIDEODECODER_VCR_TIMING
} KSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
  KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT = 0X0001,
  KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002,
  KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004
} KS_VIDEODECODER_FLAGS;

typedef struct {
  KSPROPERTY Property;
  ULONG StandardsSupported;
  ULONG Capabilities;
  ULONG SettlingTime;
  ULONG HSyncPerVSync;
} KSPROPERTY_VIDEODECODER_CAPS_S,*PKSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  ULONG NumberOfLines;
  ULONG SignalLocked;
} KSPROPERTY_VIDEODECODER_STATUS_S,*PKSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Value;
} KSPROPERTY_VIDEODECODER_S,*PKSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER					\
	0x6a2e0621L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956",EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
  KSEVENT_VIDEODECODER_CHANGED
} KSEVENT_VIDEODECODER;

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL				\
	0xC6E13370L,0x30AC,0x11d0,0xa1,0x8C,0x00,0xA0,0xC9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956",PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
  KSPROPERTY_CAMERACONTROL_PAN,
  KSPROPERTY_CAMERACONTROL_TILT,
  KSPROPERTY_CAMERACONTROL_ROLL,
  KSPROPERTY_CAMERACONTROL_ZOOM,
  KSPROPERTY_CAMERACONTROL_EXPOSURE,
  KSPROPERTY_CAMERACONTROL_IRIS,
  KSPROPERTY_CAMERACONTROL_FOCUS,
  KSPROPERTY_CAMERACONTROL_SCANMODE,
  KSPROPERTY_CAMERACONTROL_PRIVACY,
  KSPROPERTY_CAMERACONTROL_PANTILT,
  KSPROPERTY_CAMERACONTROL_PAN_RELATIVE,
  KSPROPERTY_CAMERACONTROL_TILT_RELATIVE,
  KSPROPERTY_CAMERACONTROL_ROLL_RELATIVE,
  KSPROPERTY_CAMERACONTROL_ZOOM_RELATIVE,
  KSPROPERTY_CAMERACONTROL_EXPOSURE_RELATIVE,
  KSPROPERTY_CAMERACONTROL_IRIS_RELATIVE,
  KSPROPERTY_CAMERACONTROL_FOCUS_RELATIVE,
  KSPROPERTY_CAMERACONTROL_PANTILT_RELATIVE,
  KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH
} KSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
  KSPROPERTY Property;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_CAMERACONTROL_S,*PKSPROPERTY_CAMERACONTROL_S;

typedef struct {
  KSP_NODE NodeProperty;
  LONG Value;
  ULONG Flags;
  ULONG Capabilities;
} KSPROPERTY_CAMERACONTROL_NODE_S,PKSPROPERTY_CAMERACONTROL_NODE_S;

typedef struct {
  KSPROPERTY Property;
  LONG Value1;
  ULONG Flags;
  ULONG Capabilities;
  LONG Value2;
} KSPROPERTY_CAMERACONTROL_S2,*PKSPROPERTY_CAMERACONTROL_S2;

typedef struct {
  KSP_NODE NodeProperty;
  LONG Value1;
  ULONG Flags;
  ULONG Capabilities;
  LONG Value2;
} KSPROPERTY_CAMERACONTROL_NODE_S2,*PKSPROPERTY_CAMERACONTROL_NODE_S2;

typedef struct {
  KSPROPERTY Property;
  LONG lOcularFocalLength;
  LONG lObjectiveFocalLengthMin;
  LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S,*PKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S;

typedef struct {
  KSNODEPROPERTY NodeProperty;
  LONG lOcularFocalLength;
  LONG lObjectiveFocalLengthMin;
  LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S,*PKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S;

#define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO	0X0001L
#define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL	0X0002L

#define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE	0X0000L
#define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE	0X0010L

#ifndef __EDevCtrl__
#define __EDevCtrl__

#define STATIC_PROPSETID_EXT_DEVICE					\
	0xB5730A90L,0x1A2C,0x11cf,0x8c,0x23,0x00,0xAA,0x00,0x6B,0x68,0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814",PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)

typedef enum {
  KSPROPERTY_EXTDEVICE_ID,
  KSPROPERTY_EXTDEVICE_VERSION,
  KSPROPERTY_EXTDEVICE_POWER_STATE,
  KSPROPERTY_EXTDEVICE_PORT,
  KSPROPERTY_EXTDEVICE_CAPABILITIES
} KSPROPERTY_EXTDEVICE;

typedef struct tagDEVCAPS{
  LONG CanRecord;
  LONG CanRecordStrobe;
  LONG HasAudio;
  LONG HasVideo;
  LONG UsesFiles;
  LONG CanSave;
  LONG DeviceType;
  LONG TCRead;
  LONG TCWrite;
  LONG CTLRead;
  LONG IndexRead;
  LONG Preroll;
  LONG Postroll;
  LONG SyncAcc;
  LONG NormRate;
  LONG CanPreview;
  LONG CanMonitorSrc;
  LONG CanTest;
  LONG VideoIn;
  LONG AudioIn;
  LONG Calibrate;
  LONG SeekType;
  LONG SimulatedHardware;
} DEVCAPS,*PDEVCAPS;

typedef struct {
  KSPROPERTY Property;
  union {
    DEVCAPS Capabilities;
    ULONG DevPort;
    ULONG PowerState;
    WCHAR pawchString[MAX_PATH];
    DWORD NodeUniqueID[2];
  } u;
} KSPROPERTY_EXTDEVICE_S,*PKSPROPERTY_EXTDEVICE_S;

#define STATIC_PROPSETID_EXT_TRANSPORT					\
	0xA03CD5F0L,0x3045,0x11cf,0x8c,0x44,0x00,0xAA,0x00,0x6B,0x68,0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814",PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)

typedef enum {
  KSPROPERTY_EXTXPORT_CAPABILITIES,
  KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,
  KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE,
  KSPROPERTY_EXTXPORT_LOAD_MEDIUM,
  KSPROPERTY_EXTXPORT_MEDIUM_INFO,
  KSPROPERTY_EXTXPORT_STATE,
  KSPROPERTY_EXTXPORT_STATE_NOTIFY,
  KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,
  KSPROPERTY_EXTXPORT_ATN_SEARCH,
  KSPROPERTY_EXTXPORT_RTC_SEARCH,
  KSPROPERTY_RAW_AVC_CMD
} KSPROPERTY_EXTXPORT;

typedef struct tagTRANSPORTSTATUS {
  LONG Mode;
  LONG LastError;
  LONG RecordInhibit;
  LONG ServoLock;
  LONG MediaPresent;
  LONG MediaLength;
  LONG MediaSize;
  LONG MediaTrackCount;
  LONG MediaTrackLength;
  LONG MediaTrackSide;
  LONG MediaType;
  LONG LinkMode;
  LONG NotifyOn;
} TRANSPORTSTATUS,*PTRANSPORTSTATUS;

typedef struct tagTRANSPORTBASICPARMS {
  LONG TimeFormat;
  LONG TimeReference;
  LONG Superimpose;
  LONG EndStopAction;
  LONG RecordFormat;
  LONG StepFrames;
  LONG SetpField;
  LONG Preroll;
  LONG RecPreroll;
  LONG Postroll;
  LONG EditDelay;
  LONG PlayTCDelay;
  LONG RecTCDelay;
  LONG EditField;
  LONG FrameServo;
  LONG ColorFrameServo;
  LONG ServoRef;
  LONG WarnGenlock;
  LONG SetTracking;
  TCHAR VolumeName[40];
  LONG Ballistic[20];
  LONG Speed;
  LONG CounterFormat;
  LONG TunerChannel;
  LONG TunerNumber;
  LONG TimerEvent;
  LONG TimerStartDay;
  LONG TimerStartTime;
  LONG TimerStopDay;
  LONG TimerStopTime;
} TRANSPORTBASICPARMS,*PTRANSPORTBASICPARMS;

typedef struct tagTRANSPORTVIDEOPARMS {
  LONG OutputMode;
  LONG Input;
} TRANSPORTVIDEOPARMS,*PTRANSPORTVIDEOPARMS;

typedef struct tagTRANSPORTAUDIOPARMS {
  LONG EnableOutput;
  LONG EnableRecord;
  LONG EnableSelsync;
  LONG Input;
  LONG MonitorSource;
} TRANSPORTAUDIOPARMS,*PTRANSPORTAUDIOPARMS;

typedef struct {
  WINBOOL MediaPresent;
  ULONG MediaType;
  WINBOOL RecordInhibit;
} MEDIUM_INFO,*PMEDIUM_INFO;

typedef struct {
  ULONG Mode;
  ULONG State;
} TRANSPORT_STATE,*PTRANSPORT_STATE;

typedef struct {
  KSPROPERTY Property;
  union {
    ULONG Capabilities;
    ULONG SignalMode;
    ULONG LoadMedium;
    MEDIUM_INFO MediumInfo;
    TRANSPORT_STATE XPrtState;
    struct {
      BYTE frame;
      BYTE second;
      BYTE minute;
      BYTE hour;
    } Timecode;
    DWORD dwTimecode;
    DWORD dwAbsTrackNumber;
    struct {
      ULONG PayloadSize;
      BYTE Payload[512];
    } RawAVC;
  } u;
} KSPROPERTY_EXTXPORT_S,*PKSPROPERTY_EXTXPORT_S;

typedef struct {
  KSP_NODE NodeProperty;
  union {
    ULONG Capabilities;
    ULONG SignalMode;
    ULONG LoadMedium;
    MEDIUM_INFO MediumInfo;
    TRANSPORT_STATE XPrtState;
    struct {
      BYTE frame;
      BYTE second;
      BYTE minute;
      BYTE hour;
    } Timecode;
    DWORD dwTimecode;
    DWORD dwAbsTrackNumber;
    struct {
      ULONG PayloadSize;
      BYTE Payload[512];
    } RawAVC;
  } u;
} KSPROPERTY_EXTXPORT_NODE_S,*PKSPROPERTY_EXTXPORT_NODE_S;

#define STATIC_PROPSETID_TIMECODE_READER				\
	0x9B496CE1L,0x811B,0x11cf,0x8C,0x77,0x00,0xAA,0x00,0x6B,0x68,0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814",PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)

typedef enum {
  KSPROPERTY_TIMECODE_READER,
  KSPROPERTY_ATN_READER,
  KSPROPERTY_RTC_READER
} KSPROPERTY_TIMECODE;

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
  struct {
    WORD wFrameRate;
    WORD wFrameFract;
    DWORD dwFrames;
  };
  DWORDLONG qw;
} TIMECODE;
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE {
  LONGLONG qwTick;
  TIMECODE timecode;
  DWORD dwUser;
  DWORD dwFlags;
} TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;
#endif /* TIMECODE_DEFINED */

typedef struct {
  KSPROPERTY Property;
  TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_S,*PKSPROPERTY_TIMECODE_S;

typedef struct {
  KSP_NODE NodeProperty;
  TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_NODE_S,*PKSPROPERTY_TIMECODE_NODE_S;

#define STATIC_KSEVENTSETID_EXTDEV_Command				\
	0x109c7988L,0xb3cb,0x11d2,0xb4,0x8e,0x00,0x60,0x97,0xb3,0x39,0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b",KSEVENTSETID_EXTDEV_Command);
#define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)

typedef enum {
  KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
  KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
  KSEVENT_EXTDEV_COMMAND_BUSRESET,
  KSEVENT_EXTDEV_TIMECODE_UPDATE,
  KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,
  KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,
  KSEVENT_EXTDEV_NOTIFY_REMOVAL,
  KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE
} KSEVENT_DEVCMD;
#endif /* __EDevCtrl__ */

#define STATIC_PROPSETID_VIDCAP_CROSSBAR				\
	0x6a2e0640L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956",PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
  KSPROPERTY_CROSSBAR_CAPS,
  KSPROPERTY_CROSSBAR_PININFO,
  KSPROPERTY_CROSSBAR_CAN_ROUTE,
  KSPROPERTY_CROSSBAR_ROUTE
} KSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
  KSPROPERTY Property;
  ULONG NumberOfInputs;
  ULONG NumberOfOutputs;
} KSPROPERTY_CROSSBAR_CAPS_S,*PKSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  KSPIN_DATAFLOW Direction;
  ULONG Index;
  ULONG PinType;
  ULONG RelatedPinIndex;
  KSPIN_MEDIUM Medium;
} KSPROPERTY_CROSSBAR_PININFO_S,*PKSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
  KSPROPERTY Property;
  ULONG IndexInputPin;
  ULONG IndexOutputPin;
  ULONG CanRoute;
} KSPROPERTY_CROSSBAR_ROUTE_S,*PKSPROPERTY_CROSSBAR_ROUTE_S;

#define STATIC_EVENTSETID_CROSSBAR					\
	0x6a2e0641L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956",EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
  KSEVENT_CROSSBAR_CHANGED
} KSEVENT_CROSSBAR;

typedef enum {
  KS_PhysConn_Video_Tuner = 1,
  KS_PhysConn_Video_Composite,
  KS_PhysConn_Video_SVideo,
  KS_PhysConn_Video_RGB,
  KS_PhysConn_Video_YRYBY,
  KS_PhysConn_Video_SerialDigital,
  KS_PhysConn_Video_ParallelDigital,
  KS_PhysConn_Video_SCSI,
  KS_PhysConn_Video_AUX,
  KS_PhysConn_Video_1394,
  KS_PhysConn_Video_USB,
  KS_PhysConn_Video_VideoDecoder,
  KS_PhysConn_Video_VideoEncoder,
  KS_PhysConn_Video_SCART,
  KS_PhysConn_Audio_Tuner = 4096,
  KS_PhysConn_Audio_Line,
  KS_PhysConn_Audio_Mic,
  KS_PhysConn_Audio_AESDigital,
  KS_PhysConn_Audio_SPDIFDigital,
  KS_PhysConn_Audio_SCSI,
  KS_PhysConn_Audio_AUX,
  KS_PhysConn_Audio_1394,
  KS_PhysConn_Audio_USB,
  KS_PhysConn_Audio_AudioDecoder
} KS_PhysicalConnectorType;

#define STATIC_PROPSETID_VIDCAP_TVAUDIO					\
	0x6a2e0650L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956",PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
  KSPROPERTY_TVAUDIO_CAPS,
  KSPROPERTY_TVAUDIO_MODE,
  KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES
} KSPROPERTY_VIDCAP_TVAUDIO;

#define KS_TVAUDIO_MODE_MONO	0x0001
#define KS_TVAUDIO_MODE_STEREO	0x0002
#define KS_TVAUDIO_MODE_LANG_A	0x0010
#define KS_TVAUDIO_MODE_LANG_B	0x0020
#define KS_TVAUDIO_MODE_LANG_C	0x0040

typedef struct {
  KSPROPERTY Property;
  ULONG Capabilities;
  KSPIN_MEDIUM InputMedium;
  KSPIN_MEDIUM OutputMedium;
} KSPROPERTY_TVAUDIO_CAPS_S,*PKSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  ULONG Mode;
} KSPROPERTY_TVAUDIO_S,*PKSPROPERTY_TVAUDIO_S;

#define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO				\
	0x6a2e0651L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956",KSEVENTSETID_VIDCAP_TVAUDIO);
#define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
  KSEVENT_TVAUDIO_CHANGED
} KSEVENT_TVAUDIO;

#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION			\
	0xC6E13343L,0x30AC,0x11d0,0xA1,0x8C,0x00,0xA0,0xC9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956",PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
  KSPROPERTY_VIDEOCOMPRESSION_GETINFO,
  KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
  KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
  KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
  KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,
  KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,
  KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE
} KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
  KS_CompressionCaps_CanQuality = 1,
  KS_CompressionCaps_CanCrunch = 2,
  KS_CompressionCaps_CanKeyFrame = 4,
  KS_CompressionCaps_CanBFrame = 8,
  KS_CompressionCaps_CanWindow = 0x10
} KS_CompressionCaps;

typedef enum {
  KS_StreamingHint_FrameInterval = 0x0100,
  KS_StreamingHint_KeyFrameRate = 0x0200,
  KS_StreamingHint_PFrameRate = 0x0400,
  KS_StreamingHint_CompQuality = 0x0800,
  KS_StreamingHint_CompWindowSize = 0x1000
} KS_VideoStreamingHints;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  LONG DefaultKeyFrameRate;
  LONG DefaultPFrameRate;
  LONG DefaultQuality;
  LONG NumberOfQualitySettings;
  LONG Capabilities;
} KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S,*PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  LONG Value;
} KSPROPERTY_VIDEOCOMPRESSION_S,*PKSPROPERTY_VIDEOCOMPRESSION_S;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  LONG Value;
  ULONG Flags;
} KSPROPERTY_VIDEOCOMPRESSION_S1,*PKSPROPERTY_VIDEOCOMPRESSION_S1;

#define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY				\
	0xe436eb7fL,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770",KSDATAFORMAT_SUBTYPE_OVERLAY);
#define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_KSPROPSETID_OverlayUpdate				\
	0x490EA5CFL,0x7681,0x11D1,0xA2,0x1C,0x00,0xA0,0xC9,0x22,0x31,0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196",KSPROPSETID_OverlayUpdate);
#define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)

typedef enum {
  KSPROPERTY_OVERLAYUPDATE_INTERESTS,
  KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
  KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
  KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
  KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
  KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
  KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} KSPROPERTY_OVERLAYUPDATE;

typedef struct {
  ULONG PelsWidth;
  ULONG PelsHeight;
  ULONG BitsPerPel;
  WCHAR DeviceID[1];
} KSDISPLAYCHANGE,*PKSDISPLAYCHANGE;

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_INTERESTS,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(ULONG),				\
				NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_PALETTE,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				0,					\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_COLORKEY,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				sizeof(COLORKEY),			\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_CLIPLIST,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				2 *sizeof(RECT) + sizeof(RGNDATAHEADER),\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				2 *sizeof(RECT),			\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)	\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,	\
				NULL,					\
				sizeof(KSPROPERTY),			\
				sizeof(KSDISPLAYCHANGE),		\
				(Handler),				\
				NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)		\
	DEFINE_KSPROPERTY_ITEM(						\
				KSPROPERTY_OVERLAYUPDATE_COLORREF,	\
				(Handler),				\
				sizeof(KSPROPERTY),			\
				sizeof(COLORREF),			\
				NULL,					\
				NULL, 0, NULL, NULL, 0)

#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL				\
	0x6a2e0670L,0x28e4,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956",PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
  KSPROPERTY_VIDEOCONTROL_CAPS,
  KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
  KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
  KSPROPERTY_VIDEOCONTROL_MODE
} KSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
  KS_VideoControlFlag_FlipHorizontal = 0x0001,
  KS_VideoControlFlag_FlipVertical = 0x0002,
  KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,
  KS_Obsolete_VideoControlFlag_Trigger = 0x0020,
  KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
  KS_VideoControlFlag_Trigger = 0x0008
} KS_VideoControlFlags;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  ULONG VideoControlCaps;
} KSPROPERTY_VIDEOCONTROL_CAPS_S,*PKSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  LONG Mode;
} KSPROPERTY_VIDEOCONTROL_MODE_S,*PKSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  ULONG RangeIndex;
  SIZE Dimensions;
  LONGLONG CurrentActualFrameRate;
  LONGLONG CurrentMaxAvailableFrameRate;
} KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S,*PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

typedef struct {
  KSPROPERTY Property;
  ULONG StreamIndex;
  ULONG RangeIndex;
  SIZE Dimensions;
} KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S,*PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES				\
	0xC6E13344L,0x30AC,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956",PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
  KSPROPERTY_DROPPEDFRAMES_CURRENT
} KSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
  KSPROPERTY Property;
  LONGLONG PictureNumber;
  LONGLONG DropCount;
  ULONG AverageFrameSize;
} KSPROPERTY_DROPPEDFRAMES_CURRENT_S,*PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

#define STATIC_KSPROPSETID_VPConfig					\
	0xbc29a660L,0x30e3,0x11d0,0x9e,0x69,0x00,0xc0,0x4f,0xd7,0xc1,0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b",KSPROPSETID_VPConfig);
#define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)

#define STATIC_KSPROPSETID_VPVBIConfig					\
	0xec529b00L,0x1a1f,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a",KSPROPSETID_VPVBIConfig);
#define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)

typedef enum {
  KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
  KSPROPERTY_VPCONFIG_GETCONNECTINFO,
  KSPROPERTY_VPCONFIG_SETCONNECTINFO,
  KSPROPERTY_VPCONFIG_VPDATAINFO,
  KSPROPERTY_VPCONFIG_MAXPIXELRATE,
  KSPROPERTY_VPCONFIG_INFORMVPINPUT,
  KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
  KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
  KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
  KSPROPERTY_VPCONFIG_INVERTPOLARITY,
  KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
  KSPROPERTY_VPCONFIG_SCALEFACTOR,
  KSPROPERTY_VPCONFIG_DDRAWHANDLE,
  KSPROPERTY_VPCONFIG_VIDEOPORTID,
  KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
  KSPROPERTY_VPCONFIG_SURFACEPARAMS
} KSPROPERTY_VPCONFIG;

#define STATIC_CLSID_KsIBasicAudioInterfaceHandler			\
	0xb9f8ac3e,0x0f71,0x11d2,0xb7,0x2c,0x00,0xc0,0x4f,0xb6,0xbd,0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d",CLSID_KsIBasicAudioInterfaceHandler);
#define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)

#ifdef __IVPType__
typedef struct {
  AMVPSIZE Size;
  DWORD MaxPixelsPerSecond;
  DWORD Reserved;
} KSVPMAXPIXELRATE,*PKSVPMAXPIXELRATE;

typedef struct {
  KSPROPERTY Property;
  AMVPSIZE Size;
} KSVPSIZE_PROP,*PKSVPSIZE_PROP;

typedef struct {
  DWORD dwPitch;
  DWORD dwXOrigin;
  DWORD dwYOrigin;
} KSVPSURFACEPARAMS,*PKSVPSURFACEPARAMS;
#else /* __IVPType__ */

#ifndef __DDRAW_INCLUDED__
#define DDPF_FOURCC 0x00000004l

typedef struct _DDPIXELFORMAT
{
  DWORD dwSize;
  DWORD dwFlags;
  DWORD dwFourCC;
  __MINGW_EXTENSION union
  {
    DWORD dwRGBBitCount;
    DWORD dwYUVBitCount;
    DWORD dwZBufferBitDepth;
    DWORD dwAlphaBitDepth;
  };
  __MINGW_EXTENSION union
  {
    DWORD dwRBitMask;
    DWORD dwYBitMask;
  };
  __MINGW_EXTENSION union
  {
    DWORD dwGBitMask;
    DWORD dwUBitMask;
  };
  __MINGW_EXTENSION union
  {
    DWORD dwBBitMask;
    DWORD dwVBitMask;
  };
  __MINGW_EXTENSION union
  {
    DWORD dwRGBAlphaBitMask;
    DWORD dwYUVAlphaBitMask;
    DWORD dwRGBZBitMask;
    DWORD dwYUVZBitMask;
  };
} DDPIXELFORMAT,*LPDDPIXELFORMAT;
#endif /* __DDRAW_INCLUDED__ */

#ifndef __DVP_INCLUDED__
typedef struct _DDVIDEOPORTCONNECT {
  DWORD dwSize;
  DWORD dwPortWidth;
  GUID guidTypeID;
  DWORD dwFlags;
  ULONG_PTR dwReserved1;
} DDVIDEOPORTCONNECT,*LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH						\
	0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL						\
	0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8
#endif /* __DVP_INCLUDED__ */

typedef enum
{
  KS_PixAspectRatio_NTSC4x3,
  KS_PixAspectRatio_NTSC16x9,
  KS_PixAspectRatio_PAL4x3,
  KS_PixAspectRatio_PAL16x9
} KS_AMPixAspectRatio;

typedef enum
{
  KS_AMVP_DO_NOT_CARE,
  KS_AMVP_BEST_BANDWIDTH,
  KS_AMVP_INPUT_SAME_AS_OUTPUT
} KS_AMVP_SELECTFORMATBY;

typedef enum
{
  KS_AMVP_MODE_WEAVE,
  KS_AMVP_MODE_BOBINTERLEAVED,
  KS_AMVP_MODE_BOBNONINTERLEAVED,
  KS_AMVP_MODE_SKIPEVEN,
  KS_AMVP_MODE_SKIPODD
} KS_AMVP_MODE;

typedef struct tagKS_AMVPDIMINFO
{
  DWORD dwFieldWidth;
  DWORD dwFieldHeight;
  DWORD dwVBIWidth;
  DWORD dwVBIHeight;
  RECT rcValidRegion;
} KS_AMVPDIMINFO,*PKS_AMVPDIMINFO;

typedef struct tagKS_AMVPDATAINFO
{
  DWORD dwSize;
  DWORD dwMicrosecondsPerField;
  KS_AMVPDIMINFO amvpDimInfo;
  DWORD dwPictAspectRatioX;
  DWORD dwPictAspectRatioY;
  WINBOOL bEnableDoubleClock;
  WINBOOL bEnableVACT;
  WINBOOL bDataIsInterlaced;
  LONG lHalfLinesOdd;
  WINBOOL bFieldPolarityInverted;
  DWORD dwNumLinesInVREF;
  LONG lHalfLinesEven;
  DWORD dwReserved1;
} KS_AMVPDATAINFO,*PKS_AMVPDATAINFO;

typedef struct tagKS_AMVPSIZE
{
  DWORD dwWidth;
  DWORD dwHeight;
} KS_AMVPSIZE,*PKS_AMVPSIZE;

typedef struct {
  KS_AMVPSIZE Size;
  DWORD MaxPixelsPerSecond;
  DWORD Reserved;
} KSVPMAXPIXELRATE,*PKSVPMAXPIXELRATE;

typedef struct {
  KSPROPERTY Property;
  KS_AMVPSIZE Size;
} KSVPSIZE_PROP,*PKSVPSIZE_PROP;

typedef struct {
  DWORD dwPitch;
  DWORD dwXOrigin;
  DWORD dwYOrigin;
} KSVPSURFACEPARAMS,*PKSVPSURFACEPARAMS;
#endif /* __IVPType__ */

#define STATIC_KSEVENTSETID_VPNotify					\
	0x20c5598eL,0xd3c8,0x11d0,0x8d,0xfc,0x00,0xc0,0x4f,0xd7,0xc0,0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b",KSEVENTSETID_VPNotify);
#define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)

typedef enum {
  KSEVENT_VPNOTIFY_FORMATCHANGE
} KSEVENT_VPNOTIFY;

#define STATIC_KSEVENTSETID_VIDCAPTOSTI					\
	0xdb47de20,0xf628,0x11d1,0xba,0x41,0x0,0xa0,0xc9,0xd,0x2b,0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05",KSEVENTSETID_VIDCAPTOSTI);
#define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)

typedef enum {
  KSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
  KSEVENT_VIDCAP_AUTO_UPDATE,
  KSEVENT_VIDCAP_SEARCH
} KSEVENT_VIDCAPTOSTI;

typedef enum {
  KSPROPERTY_EXTENSION_UNIT_INFO,
  KSPROPERTY_EXTENSION_UNIT_CONTROL,
  KSPROPERTY_EXTENSION_UNIT_PASS_THROUGH = 0xffff
} KSPROPERTY_EXTENSION_UNIT,*PKSPROPERTY_EXTENSION_UNIT;

#define STATIC_KSEVENTSETID_VPVBINotify					\
	0xec529b01L,0x1a1f,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a",KSEVENTSETID_VPVBINotify);
#define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)

typedef enum {
  KSEVENT_VPVBINOTIFY_FORMATCHANGE
} KSEVENT_VPVBINOTIFY;

#define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data				\
	0x670aea80L,0x3a82,0x11d0,0xb7,0x9b,0x00,0xaa,0x00,0x37,0x67,0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7",KSDATAFORMAT_TYPE_AUXLine21Data);
#define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair			\
	0x6e8d4a22L,0x310c,0x11d0,0xb7,0x9a,0x00,0xaa,0x00,0x37,0x67,0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7",KSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket			\
	0x6e8d4a23L,0x310c,0x11d0,0xb7,0x9a,0x00,0xaa,0x00,0x37,0x67,0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7",KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _KSGOP_USERDATA {
  ULONG sc;
  ULONG reserved1;
  BYTE cFields;
  CHAR l21Data[3];
} KSGOP_USERDATA,*PKSGOP_USERDATA;

#define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK			\
	0xed0b916a,0x044d,0x11d1,0xaa,0x78,0x00,0xc0,0x4f,0xc3,0x1d,0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60",KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define KS_AM_UseNewCSSKey			0x1

#define STATIC_KSPROPSETID_TSRateChange					\
	0xa503c5c0,0x1d1d,0x11d1,0xad,0x80,0x44,0x45,0x53,0x54,0x0,0x0
DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000",KSPROPSETID_TSRateChange);
#define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)

typedef enum {
  KS_AM_RATE_SimpleRateChange = 1,
  KS_AM_RATE_ExactRateChange = 2,
  KS_AM_RATE_MaxFullDataRate = 3,
  KS_AM_RATE_Step = 4
} KS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
  REFERENCE_TIME StartTime;
  LONG Rate;
} KS_AM_SimpleRateChange,*PKS_AM_SimpleRateChange;

typedef struct {
  REFERENCE_TIME OutputZeroTime;
  LONG Rate;
} KS_AM_ExactRateChange,*PKS_AM_ExactRateChange;

typedef LONG KS_AM_MaxFullDataRate;
typedef DWORD KS_AM_Step;

#define STATIC_KSCATEGORY_ENCODER					\
	0x19689bf6,0xc384,0x48fd,0xad,0x51,0x90,0xe5,0x8c,0x79,0xf7,0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B",KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)

#define STATIC_KSCATEGORY_MULTIPLEXER					\
	0x7a5de1d3,0x1a1,0x452c,0xb4,0x81,0x4f,0xa2,0xb9,0x62,0x71,0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8",KSCATEGORY_MULTIPLEXER);
#define KSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE					\
	0x49cc4c43,0xca83,0x4ad4,0xa9,0xaf,0xf3,0x69,0x6a,0xf6,0x66,0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF",ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE					\
	0x703f16a9,0x3d48,0x44a1,0xb0,0x77,0x1,0x8d,0xff,0x91,0x5d,0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19",ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE					\
	0xee5fb25c,0xc713,0x40d1,0x9d,0x58,0xc0,0xd7,0x24,0x1e,0x25,0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F",ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#define STATIC_CODECAPI_CHANGELISTS					\
	0x62b12acf,0xf6b0,0x47d9,0x94,0x56,0x96,0xf2,0x2c,0x4e,0x0b,0x9d
DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D",CODECAPI_CHANGELISTS);
#define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS)

#define STATIC_CODECAPI_VIDEO_ENCODER					\
	0x7112e8e1,0x3d03,0x47ef,0x8e,0x60,0x03,0xf1,0xcf,0x53,0x73,0x01
DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301",CODECAPI_VIDEO_ENCODER);
#define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER)

#define STATIC_CODECAPI_AUDIO_ENCODER					\
	0xb9d19a3e,0xf897,0x429c,0xbc,0x46,0x81,0x38,0xb7,0x27,0x2b,0x2d
DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D",CODECAPI_AUDIO_ENCODER);
#define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER)

#define STATIC_CODECAPI_SETALLDEFAULTS					\
	0x6c5e6a7c,0xacf8,0x4f55,0xa9,0x99,0x1a,0x62,0x81,0x09,0x05,0x1b
DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B",CODECAPI_SETALLDEFAULTS);
#define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS)

#define STATIC_CODECAPI_ALLSETTINGS					\
	0x6a577e92,0x83e1,0x4113,0xad,0xc2,0x4f,0xce,0xc3,0x2f,0x83,0xa1
DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1",CODECAPI_ALLSETTINGS);
#define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS)

#define STATIC_CODECAPI_SUPPORTSEVENTS					\
	0x0581af97,0x7693,0x4dbd,0x9d,0xca,0x3f,0x9e,0xbd,0x65,0x85,0xa1
DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1",CODECAPI_SUPPORTSEVENTS);
#define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS)

#define STATIC_CODECAPI_CURRENTCHANGELIST				\
	0x1cb14e83,0x7d72,0x4657,0x83,0xfd,0x47,0xa2,0xc5,0xb9,0xd1,0x3d
DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D",CODECAPI_CURRENTCHANGELIST);
#define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST)
#endif /* __ENCODER_API_GUIDS__ */

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__
typedef enum {
  ConstantBitRate = 0,
  VariableBitRateAverage,
  VariableBitRatePeak
} VIDEOENCODER_BITRATE_MODE;
#endif /* __ENCODER_API_DEFINES__ */

#define STATIC_KSPROPSETID_Jack\
    0x4509f757, 0x2d46, 0x4637, 0x8e, 0x62, 0xce, 0x7d, 0xb9, 0x44, 0xf5, 0x7b
DEFINE_GUIDSTRUCT("4509F757-2D46-4637-8E62-CE7DB944F57B", KSPROPSETID_Jack);
#define KSPROPSETID_Jack DEFINE_GUIDNAMED(KSPROPSETID_Jack)

typedef enum {
    KSPROPERTY_JACK_DESCRIPTION = 1,
    KSPROPERTY_JACK_DESCRIPTION2,
    KSPROPERTY_JACK_SINK_INFO
} KSPROPERTY_JACK;

typedef enum
{
    eConnTypeUnknown,
    eConnType3Point5mm,
    eConnTypeQuarter,
    eConnTypeAtapiInternal,
    eConnTypeRCA,
    eConnTypeOptical,
    eConnTypeOtherDigital,
    eConnTypeOtherAnalog,
    eConnTypeMultichannelAnalogDIN,
    eConnTypeXlrProfessional,
    eConnTypeRJ11Modem,
    eConnTypeCombination
} EPcxConnectionType;

typedef enum
{
    eGeoLocRear = 0x1,
    eGeoLocFront,
    eGeoLocLeft,
    eGeoLocRight,
    eGeoLocTop,
    eGeoLocBottom,
    eGeoLocRearPanel,
    eGeoLocRiser,
    eGeoLocInsideMobileLid,
    eGeoLocDrivebay,
    eGeoLocHDMI,
    eGeoLocOutsideMobileLid,
    eGeoLocATAPI,
    eGeoLocReserved5,
    eGeoLocReserved6,
    EPcxGeoLocation_enum_count
} EPcxGeoLocation;

typedef enum
{
    eGenLocPrimaryBox = 0,
    eGenLocInternal,
    eGenLocSeparate,
    eGenLocOther,
    EPcxGenLocation_enum_count
} EPcxGenLocation;

typedef enum
{
    ePortConnJack = 0,
    ePortConnIntegratedDevice,
    ePortConnBothIntegratedAndJack,
    ePortConnUnknown
} EPxcPortConnection;

typedef struct 
{
    DWORD                 ChannelMapping;
    COLORREF              Color;
    EPcxConnectionType    ConnectionType;
    EPcxGeoLocation       GeoLocation;
    EPcxGenLocation       GenLocation;
    EPxcPortConnection    PortConnection;
    BOOL                  IsConnected;
} KSJACK_DESCRIPTION, *PKSJACK_DESCRIPTION;

typedef enum 
{
    KSJACK_SINK_CONNECTIONTYPE_HDMI = 0,           
    KSJACK_SINK_CONNECTIONTYPE_DISPLAYPORT,         
} KSJACK_SINK_CONNECTIONTYPE;

#define MAX_SINK_DESCRIPTION_NAME_LENGTH 32
typedef struct _tagKSJACK_SINK_INFORMATION
{
  KSJACK_SINK_CONNECTIONTYPE ConnType;              
  WORD  ManufacturerId;                            
  WORD  ProductId;                                  
  WORD  AudioLatency;                               
  BOOL  HDCPCapable;                                
  BOOL  AICapable;                                  
  UCHAR SinkDescriptionLength;                      
  WCHAR SinkDescription[MAX_SINK_DESCRIPTION_NAME_LENGTH];
  LUID  PortId;                                 
}  KSJACK_SINK_INFORMATION, *PKSJACK_SINK_INFORMATION;

#define JACKDESC2_PRESENCE_DETECT_CAPABILITY       0x00000001 
#define JACKDESC2_DYNAMIC_FORMAT_CHANGE_CAPABILITY 0x00000002

typedef struct _tagKSJACK_DESCRIPTION2
{
  DWORD              DeviceStateInfo;
  DWORD              JackCapabilities;
} KSJACK_DESCRIPTION2, *PKSJACK_DESCRIPTION2;

/* Additional structs for Windows Vista and later */
typedef struct _tagKSRTAUDIO_BUFFER_PROPERTY {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
} KSRTAUDIO_BUFFER_PROPERTY, *PKSRTAUDIO_BUFFER_PROPERTY;

typedef struct _tagKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
    ULONG       NotificationCount;
} KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION, *PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION;

typedef struct _tagKSRTAUDIO_BUFFER {
    PVOID   BufferAddress;
    ULONG   ActualBufferSize;
    BOOL    CallMemoryBarrier;
} KSRTAUDIO_BUFFER, *PKSRTAUDIO_BUFFER;

typedef struct _tagKSRTAUDIO_HWLATENCY {
    ULONG   FifoSize;
    ULONG   ChipsetDelay;
    ULONG   CodecDelay;
} KSRTAUDIO_HWLATENCY, *PKSRTAUDIO_HWLATENCY;

typedef struct _tagKSRTAUDIO_HWREGISTER_PROPERTY {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
} KSRTAUDIO_HWREGISTER_PROPERTY, *PKSRTAUDIO_HWREGISTER_PROPERTY;

typedef struct _tagKSRTAUDIO_HWREGISTER {
    PVOID       Register;
    ULONG       Width;
    ULONGLONG   Numerator;
    ULONGLONG   Denominator;
    ULONG       Accuracy;
} KSRTAUDIO_HWREGISTER, *PKSRTAUDIO_HWREGISTER;

typedef struct _tagKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY {
    KSPROPERTY  Property;
    HANDLE      NotificationEvent;
} KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY, *PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY;


#endif /* _KSMEDIA_ */

/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __KSPROXY__
#define __KSPROXY__

#ifdef __cplusplus
extern "C" {
#endif

#undef KSDDKAPI
#ifdef _KSDDK_
#define KSDDKAPI
#else
#define KSDDKAPI DECLSPEC_IMPORT
#endif

#define STATIC_IID_IKsObject						\
	0x423c13a2L,0x2070,0x11d0,0x9e,0xf7,0x00,0xaa,0x00,0xa2,0x16,0xa1

#define STATIC_IID_IKsPinEx						\
	0x7bb38260L,0xd19c,0x11d2,0xb3,0x8a,0x00,0xa0,0xc9,0x5e,0xc2,0x2e

#define STATIC_IID_IKsPin						\
	0xb61178d1L,0xa2d9,0x11cf,0x9e,0x53,0x00,0xaa,0x00,0xa2,0x16,0xa1

#define STATIC_IID_IKsPinPipe						\
	0xe539cd90L,0xa8b4,0x11d1,0x81,0x89,0x00,0xa0,0xc9,0x06,0x28,0x02

#define STATIC_IID_IKsDataTypeHandler					\
	0x5ffbaa02L,0x49a3,0x11d0,0x9f,0x36,0x00,0xaa,0x00,0xa2,0x16,0xa1

#define STATIC_IID_IKsDataTypeCompletion				\
	0x827D1A0EL,0x0F73,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96

#define STATIC_IID_IKsInterfaceHandler					\
	0xD3ABC7E0L,0x9A61,0x11D0,0xA4,0x0D,0x00,0xA0,0xC9,0x22,0x31,0x96

#define STATIC_IID_IKsClockPropertySet					\
	0x5C5CBD84L,0xE755,0x11D0,0xAC,0x18,0x00,0xA0,0xC9,0x22,0x31,0x96

#define STATIC_IID_IKsAllocator						\
	0x8da64899L,0xc0d9,0x11d0,0x84,0x13,0x00,0x00,0xf8,0x22,0xfe,0x8a

#define STATIC_IID_IKsAllocatorEx					\
	0x091bb63aL,0x603f,0x11d1,0xb0,0x67,0x00,0xa0,0xc9,0x06,0x28,0x02

#ifndef STATIC_IID_IKsPropertySet
#define STATIC_IID_IKsPropertySet					\
	0x31EFAC30L,0x515C,0x11d0,0xA9,0xAA,0x00,0xAA,0x00,0x61,0xBE,0x93
#endif

#define STATIC_IID_IKsTopology						\
	0x28F54683L,0x06FD,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl						\
	0x28F54685L,0x06FD,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96
#endif

#define STATIC_IID_IKsAggregateControl					\
	0x7F40EAC0L,0x3947,0x11D2,0x87,0x4E,0x00,0xA0,0xC9,0x22,0x31,0x96

#define STATIC_CLSID_Proxy						\
	0x17CCA71BL,0xECD7,0x11D0,0xB9,0x08,0x00,0xA0,0xC9,0x22,0x31,0x96

#ifdef _KS_

DEFINE_GUIDEX(IID_IKsObject);

DEFINE_GUIDEX(IID_IKsPin);

DEFINE_GUIDEX(IID_IKsPinEx);

DEFINE_GUIDEX(IID_IKsPinPipe);

DEFINE_GUIDEX(IID_IKsDataTypeHandler);

DEFINE_GUIDEX(IID_IKsDataTypeCompletion);

DEFINE_GUIDEX(IID_IKsInterfaceHandler);

DEFINE_GUIDEX(IID_IKsClockPropertySet);

DEFINE_GUIDEX(IID_IKsAllocator);

DEFINE_GUIDEX(IID_IKsAllocatorEx);

#define IID_IKsQualityForwarder KSCATEGORY_QUALITY
#define STATIC_IID_IKsQualityForwarder STATIC_KSCATEGORY_QUALITY

typedef enum {
  KsAllocatorMode_User,
  KsAllocatorMode_Kernel
} KSALLOCATORMODE;

typedef enum {
  FramingProp_Uninitialized,
  FramingProp_None,
  FramingProp_Old,
  FramingProp_Ex
} FRAMING_PROP;

typedef FRAMING_PROP *PFRAMING_PROP;

typedef enum {
  Framing_Cache_Update,
  Framing_Cache_ReadLast,
  Framing_Cache_ReadOrig,
  Framing_Cache_Write
} FRAMING_CACHE_OPS;

typedef struct {
  LONGLONG MinTotalNominator;
  LONGLONG MaxTotalNominator;
  LONGLONG TotalDenominator;
} OPTIMAL_WEIGHT_TOTALS;

typedef struct IPin IPin;
typedef struct IKsPin IKsPin;
typedef struct IKsAllocator IKsAllocator;
typedef struct IKsAllocatorEx IKsAllocatorEx;

#define AllocatorStrategy_DontCare			0
#define AllocatorStrategy_MinimizeNumberOfFrames	0x00000001
#define AllocatorStrategy_MinimizeFrameSize		0x00000002
#define AllocatorStrategy_MinimizeNumberOfAllocators	0x00000004
#define AllocatorStrategy_MaximizeSpeed			0x00000008

#define PipeFactor_None					0
#define PipeFactor_UserModeUpstream			0x00000001
#define PipeFactor_UserModeDownstream			0x00000002
#define PipeFactor_MemoryTypes				0x00000004
#define PipeFactor_Flags				0x00000008
#define PipeFactor_PhysicalRanges			0x00000010
#define PipeFactor_OptimalRanges			0x00000020
#define PipeFactor_FixedCompression			0x00000040
#define PipeFactor_UnknownCompression			0x00000080

#define PipeFactor_Buffers				0x00000100
#define PipeFactor_Align				0x00000200
#define PipeFactor_PhysicalEnd				0x00000400
#define PipeFactor_LogicalEnd				0x00000800

typedef enum {
  PipeState_DontCare,
  PipeState_RangeNotFixed,
  PipeState_RangeFixed,
  PipeState_CompressionUnknown,
  PipeState_Finalized
} PIPE_STATE;

typedef struct _PIPE_DIMENSIONS {
  KS_COMPRESSION AllocatorPin;
  KS_COMPRESSION MaxExpansionPin;
  KS_COMPRESSION EndPin;
} PIPE_DIMENSIONS,*PPIPE_DIMENSIONS;

typedef enum {
  Pipe_Allocator_None,
  Pipe_Allocator_FirstPin,
  Pipe_Allocator_LastPin,
  Pipe_Allocator_MiddlePin
} PIPE_ALLOCATOR_PLACE;

typedef PIPE_ALLOCATOR_PLACE *PPIPE_ALLOCATOR_PLACE;

typedef enum {
  KS_MemoryTypeDontCare = 0,
  KS_MemoryTypeKernelPaged,
  KS_MemoryTypeKernelNonPaged,
  KS_MemoryTypeDeviceHostMapped,
  KS_MemoryTypeDeviceSpecific,
  KS_MemoryTypeUser,
  KS_MemoryTypeAnyHost
} KS_LogicalMemoryType;

typedef KS_LogicalMemoryType *PKS_LogicalMemoryType;

typedef struct _PIPE_TERMINATION {
  ULONG Flags;
  ULONG OutsideFactors;
  ULONG Weigth;
  KS_FRAMING_RANGE PhysicalRange;
  KS_FRAMING_RANGE_WEIGHTED OptimalRange;
  KS_COMPRESSION Compression;
} PIPE_TERMINATION;

typedef struct _ALLOCATOR_PROPERTIES_EX
{
  long cBuffers;
  long cbBuffer;
  long cbAlign;
  long cbPrefix;

  GUID MemoryType;
  GUID BusType;
  PIPE_STATE State;
  PIPE_TERMINATION Input;
  PIPE_TERMINATION Output;
  ULONG Strategy;
  ULONG Flags;
  ULONG Weight;
  KS_LogicalMemoryType LogicalMemoryType;
  PIPE_ALLOCATOR_PLACE AllocatorPlace;
  PIPE_DIMENSIONS Dimensions;
  KS_FRAMING_RANGE PhysicalRange;
  IKsAllocatorEx *PrevSegment;
  ULONG CountNextSegments;
  IKsAllocatorEx **NextSegments;
  ULONG InsideFactors;
  ULONG NumberPins;
} ALLOCATOR_PROPERTIES_EX;

typedef ALLOCATOR_PROPERTIES_EX *PALLOCATOR_PROPERTIES_EX;

#ifdef __STREAMS__

struct IKsClockPropertySet;
#undef INTERFACE
#define INTERFACE IKsClockPropertySet
DECLARE_INTERFACE_(IKsClockPropertySet,IUnknown)
{
  STDMETHOD(KsGetTime)			(THIS_
						LONGLONG *Time
					) PURE;
  STDMETHOD(KsSetTime)			(THIS_
						LONGLONG Time
					) PURE;
  STDMETHOD(KsGetPhysicalTime)		(THIS_
						LONGLONG *Time
					) PURE;
  STDMETHOD(KsSetPhysicalTime)		(THIS_
						LONGLONG Time
					) PURE;
  STDMETHOD(KsGetCorrelatedTime)	(THIS_
						KSCORRELATED_TIME *CorrelatedTime
					) PURE;
  STDMETHOD(KsSetCorrelatedTime)	(THIS_
						KSCORRELATED_TIME *CorrelatedTime
					) PURE;
  STDMETHOD(KsGetCorrelatedPhysicalTime)(THIS_
						KSCORRELATED_TIME *CorrelatedTime
					) PURE;
  STDMETHOD(KsSetCorrelatedPhysicalTime)(THIS_
						KSCORRELATED_TIME *CorrelatedTime
					) PURE;
  STDMETHOD(KsGetResolution)		(THIS_
						KSRESOLUTION *Resolution
					) PURE;
  STDMETHOD(KsGetState)			(THIS_
						KSSTATE *State
					) PURE;
};

struct IKsAllocator;
#undef INTERFACE
#define INTERFACE IKsAllocator
DECLARE_INTERFACE_(IKsAllocator,IUnknown)
{
  STDMETHOD_(HANDLE,KsGetAllocatorHandle)(THIS) PURE;
  STDMETHOD_(KSALLOCATORMODE,KsGetAllocatorMode)(THIS) PURE;
  STDMETHOD(KsGetAllocatorStatus)	(THIS_
						PKSSTREAMALLOCATOR_STATUS AllocatorStatus
					) PURE;
  STDMETHOD_(VOID,KsSetAllocatorMode)	(THIS_
						KSALLOCATORMODE Mode
					) PURE;
};

struct IKsAllocatorEx;
#undef INTERFACE
#define INTERFACE IKsAllocatorEx
DECLARE_INTERFACE_(IKsAllocatorEx,IKsAllocator)
{
  STDMETHOD_(PALLOCATOR_PROPERTIES_EX,KsGetProperties)(THIS) PURE;
  STDMETHOD_(VOID,KsSetProperties)	(THIS_
						PALLOCATOR_PROPERTIES_EX
					) PURE;
  STDMETHOD_(VOID,KsSetAllocatorHandle)	(THIS_
						HANDLE AllocatorHandle
					) PURE;
  STDMETHOD_(HANDLE,KsCreateAllocatorAndGetHandle)(THIS_
						IKsPin *KsPin
					) PURE;
};

typedef enum {
  KsPeekOperation_PeekOnly,
  KsPeekOperation_AddRef
} KSPEEKOPERATION;

typedef struct _KSSTREAM_SEGMENT *PKSSTREAM_SEGMENT;
struct IKsPin;

#undef INTERFACE
#define INTERFACE IKsPin
DECLARE_INTERFACE_(IKsPin,IUnknown)
{
  STDMETHOD(KsQueryMediums)		(THIS_
						PKSMULTIPLE_ITEM *MediumList
					) PURE;
  STDMETHOD(KsQueryInterfaces)		(THIS_
						PKSMULTIPLE_ITEM *InterfaceList
					) PURE;
  STDMETHOD(KsCreateSinkPinHandle)	(THIS_
						KSPIN_INTERFACE& Interface,
						KSPIN_MEDIUM& Medium
					) PURE;
  STDMETHOD(KsGetCurrentCommunication)	(THIS_
						KSPIN_COMMUNICATION *Communication,
						KSPIN_INTERFACE *Interface,
						KSPIN_MEDIUM *Medium
					) PURE;
  STDMETHOD(KsPropagateAcquire)		(THIS) PURE;
  STDMETHOD(KsDeliver)			(THIS_
						IMediaSample *Sample,
						ULONG Flags
					) PURE;
  STDMETHOD(KsMediaSamplesCompleted)	(THIS_
						PKSSTREAM_SEGMENT StreamSegment
					) PURE;
  STDMETHOD_(IMemAllocator *,KsPeekAllocator)(THIS_
						KSPEEKOPERATION Operation
					) PURE;
  STDMETHOD(KsReceiveAllocator)		(THIS_
						IMemAllocator *MemAllocator
					) PURE;
  STDMETHOD(KsRenegotiateAllocator)	(THIS) PURE;
  STDMETHOD_(LONG,KsIncrementPendingIoCount)(THIS) PURE;
  STDMETHOD_(LONG,KsDecrementPendingIoCount)(THIS) PURE;
  STDMETHOD(KsQualityNotify)		(THIS_
						ULONG Proportion,
						REFERENCE_TIME TimeDelta
					) PURE;
};

struct IKsPinEx;
#undef INTERFACE
#define INTERFACE IKsPinEx
DECLARE_INTERFACE_(IKsPinEx,IKsPin)
{
  STDMETHOD_(VOID,KsNotifyError)	(THIS_
						IMediaSample *Sample,
						HRESULT hr
					) PURE;
};

struct IKsPinPipe;
#undef INTERFACE
#define INTERFACE IKsPinPipe
DECLARE_INTERFACE_(IKsPinPipe,IUnknown)
{
  STDMETHOD(KsGetPinFramingCache)	(THIS_
						PKSALLOCATOR_FRAMING_EX *FramingEx,
						PFRAMING_PROP FramingProp,
						FRAMING_CACHE_OPS Option
					) PURE;
  STDMETHOD(KsSetPinFramingCache)	(THIS_
						PKSALLOCATOR_FRAMING_EX FramingEx,
						PFRAMING_PROP FramingProp,
						FRAMING_CACHE_OPS Option
					) PURE;
  STDMETHOD_(IPin*,KsGetConnectedPin)	(THIS) PURE;
  STDMETHOD_(IKsAllocatorEx*,KsGetPipe)	(THIS_
						KSPEEKOPERATION Operation
					) PURE;
  STDMETHOD(KsSetPipe)			(THIS_
						IKsAllocatorEx *KsAllocator
					) PURE;
  STDMETHOD_(ULONG,KsGetPipeAllocatorFlag)(THIS) PURE;
  STDMETHOD(KsSetPipeAllocatorFlag)	(THIS_
						ULONG Flag
					) PURE;
  STDMETHOD_(GUID,KsGetPinBusCache)	(THIS) PURE;
  STDMETHOD(KsSetPinBusCache)		(THIS_
						GUID Bus
					) PURE;
  STDMETHOD_(PWCHAR,KsGetPinName)	(THIS) PURE;
  STDMETHOD_(PWCHAR,KsGetFilterName)	(THIS) PURE;
};

struct IKsPinFactory;
#undef INTERFACE
#define INTERFACE IKsPinFactory
DECLARE_INTERFACE_(IKsPinFactory,IUnknown)
{
  STDMETHOD(KsPinFactory)		(THIS_
						ULONG *PinFactory
					) PURE;
};

typedef enum {
  KsIoOperation_Write,
  KsIoOperation_Read
} KSIOOPERATION;

struct IKsDataTypeHandler;
#undef INTERFACE
#define INTERFACE IKsDataTypeHandler
DECLARE_INTERFACE_(IKsDataTypeHandler,IUnknown)
{
  STDMETHOD(KsCompleteIoOperation)	(THIS_
						IMediaSample *Sample,
						PVOID StreamHeader,
						KSIOOPERATION IoOperation,
						WINBOOL Cancelled
					) PURE;
  STDMETHOD(KsIsMediaTypeInRanges)	(THIS_
						PVOID DataRanges
					) PURE;
  STDMETHOD(KsPrepareIoOperation)	(THIS_
						IMediaSample *Sample,
						PVOID StreamHeader,
						KSIOOPERATION IoOperation
					) PURE;
  STDMETHOD(KsQueryExtendedSize)	(THIS_
						ULONG *ExtendedSize
					) PURE;
  STDMETHOD(KsSetMediaType)		(THIS_
						const AM_MEDIA_TYPE *AmMediaType
					) PURE;
};

struct IKsDataTypeCompletion;
#undef INTERFACE
#define INTERFACE IKsDataTypeCompletion
DECLARE_INTERFACE_(IKsDataTypeCompletion,IUnknown)
{
  STDMETHOD(KsCompleteMediaType)	(THIS_
						HANDLE FilterHandle,
						ULONG PinFactoryId,
						AM_MEDIA_TYPE *AmMediaType
					) PURE;
};

struct IKsInterfaceHandler;
#undef INTERFACE
#define INTERFACE IKsInterfaceHandler
DECLARE_INTERFACE_(IKsInterfaceHandler,IUnknown)
{
  STDMETHOD(KsSetPin)			(THIS_
						IKsPin *KsPin
					) PURE;
  STDMETHOD(KsProcessMediaSamples)	(THIS_
						IKsDataTypeHandler *KsDataTypeHandler,
						IMediaSample **SampleList,
						PLONG SampleCount,
						KSIOOPERATION IoOperation,
						PKSSTREAM_SEGMENT *StreamSegment
					) PURE;
  STDMETHOD(KsCompleteIo)		(THIS_
						PKSSTREAM_SEGMENT StreamSegment
					) PURE;
};

typedef struct _KSSTREAM_SEGMENT {
  IKsInterfaceHandler *KsInterfaceHandler;
  IKsDataTypeHandler *KsDataTypeHandler;
  KSIOOPERATION IoOperation;
  HANDLE CompletionEvent;
} KSSTREAM_SEGMENT;

struct IKsObject;
#undef INTERFACE
#define INTERFACE IKsObject
DECLARE_INTERFACE_(IKsObject,IUnknown)
{
  STDMETHOD_(HANDLE,KsGetObjectHandle)	(THIS) PURE;
};

struct IKsQualityForwarder;
#undef INTERFACE
#define INTERFACE IKsQualityForwarder
DECLARE_INTERFACE_(IKsQualityForwarder,IKsObject)
{
  STDMETHOD_(VOID,KsFlushClient)	(THIS_
						IKsPin *Pin
					) PURE;
};

struct IKsNotifyEvent;
#undef INTERFACE
#define INTERFACE IKsNotifyEvent
DECLARE_INTERFACE_(IKsNotifyEvent,IUnknown)
{
  STDMETHOD(KsNotifyEvent)		(THIS_
						ULONG Event,
						ULONG_PTR lParam1,
						ULONG_PTR lParam2
					) PURE;
};

KSDDKAPI HRESULT WINAPI KsResolveRequiredAttributes(PKSDATARANGE DataRange,PKSMULTIPLE_ITEM Attributes);
KSDDKAPI HRESULT WINAPI KsOpenDefaultDevice(REFGUID Category,ACCESS_MASK Access,PHANDLE DeviceHandle);
KSDDKAPI HRESULT WINAPI KsSynchronousDeviceControl(HANDLE Handle,ULONG IoControl,PVOID InBuffer,ULONG InLength,PVOID OutBuffer,ULONG OutLength,PULONG BytesReturned);
KSDDKAPI HRESULT WINAPI KsGetMultiplePinFactoryItems(HANDLE FilterHandle,ULONG PinFactoryId,ULONG PropertyId,PVOID *Items);
KSDDKAPI HRESULT WINAPI KsGetMediaTypeCount(HANDLE FilterHandle,ULONG PinFactoryId,ULONG *MediaTypeCount);
KSDDKAPI HRESULT WINAPI KsGetMediaType(int Position,AM_MEDIA_TYPE *AmMediaType,HANDLE FilterHandle,ULONG PinFactoryId);
#endif /* __STREAMS__ */

#ifndef _IKsPropertySet_
DEFINE_GUIDEX(IID_IKsPropertySet);
#endif

#ifndef _IKsControl_
DEFINE_GUIDEX(IID_IKsControl);
#endif

DEFINE_GUIDEX(IID_IKsAggregateControl);
#ifndef _IKsTopology_
DEFINE_GUIDEX(IID_IKsTopology);
#endif
DEFINE_GUIDSTRUCT("17CCA71B-ECD7-11D0-B908-00A0C9223196",CLSID_Proxy);
#define CLSID_Proxy DEFINE_GUIDNAMED(CLSID_Proxy)

#else /* _KS_ */

#ifndef _IKsPropertySet_
DEFINE_GUID(IID_IKsPropertySet,STATIC_IID_IKsPropertySet);
#endif

DEFINE_GUID(CLSID_Proxy,STATIC_CLSID_Proxy);

#endif /* _KS_ */

#ifndef _IKsPropertySet_
#define _IKsPropertySet_
#define KSPROPERTY_SUPPORT_GET 1
#define KSPROPERTY_SUPPORT_SET 2

#ifdef DECLARE_INTERFACE_
struct IKsPropertySet;
#undef INTERFACE
#define INTERFACE IKsPropertySet
DECLARE_INTERFACE_(IKsPropertySet,IUnknown)
{
  STDMETHOD(Set)			(THIS_
						REFGUID PropSet,
						ULONG Id,
						LPVOID InstanceData,
						ULONG InstanceLength,
						LPVOID PropertyData,
						ULONG DataLength
					) PURE;
  STDMETHOD(Get)			(THIS_
						REFGUID PropSet,
						ULONG Id,
						LPVOID InstanceData,
						ULONG InstanceLength,
						LPVOID PropertyData,
						ULONG DataLength,
						ULONG *BytesReturned
					) PURE;
  STDMETHOD(QuerySupported)		(THIS_
						REFGUID PropSet,
						ULONG Id,
						ULONG *TypeSupport
					) PURE;
};
#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsPropertySet_ */

#ifndef _IKsControl_
#define _IKsControl_
#ifdef DECLARE_INTERFACE_
struct IKsControl;
#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl,IUnknown)
{
  STDMETHOD(KsProperty)			(THIS_
						PKSPROPERTY Property,
						ULONG PropertyLength,
						LPVOID PropertyData,
						ULONG DataLength,
						ULONG *BytesReturned
					) PURE;
  STDMETHOD(KsMethod)			(THIS_
						PKSMETHOD Method,
						ULONG MethodLength,
						LPVOID MethodData,
						ULONG DataLength,
						ULONG *BytesReturned
					) PURE;
  STDMETHOD(KsEvent)			(THIS_
						PKSEVENT Event,
						ULONG EventLength,
						LPVOID EventData,
						ULONG DataLength,
						ULONG *BytesReturned
					) PURE;
};
#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#ifdef DECLARE_INTERFACE_
struct IKsAggregateControl;
#undef INTERFACE
#define INTERFACE IKsAggregateControl
DECLARE_INTERFACE_(IKsAggregateControl,IUnknown)
{
  STDMETHOD(KsAddAggregate)		(THIS_
						REFGUID AggregateClass
					) PURE;
  STDMETHOD(KsRemoveAggregate)		(THIS_
						REFGUID AggregateClass
					) PURE;
};
#endif /* DECLARE_INTERFACE_ */

#ifndef _IKsTopology_
#define _IKsTopology_
#ifdef DECLARE_INTERFACE_
struct IKsTopology;
#undef INTERFACE
#define INTERFACE IKsTopology
DECLARE_INTERFACE_(IKsTopology,IUnknown)
{
  STDMETHOD(CreateNodeInstance)		(THIS_
						ULONG NodeId,
						ULONG Flags,
						ACCESS_MASK DesiredAccess,
						IUnknown *UnkOuter,
						REFGUID InterfaceId,
						LPVOID *Interface
					) PURE;
};
#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsTopology_ */

#ifdef __cplusplus
}
#endif

#endif /* __KSPROXY__ */

/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
		0x36523B13,0x8EE5,0x11d1,0x8C,0xA3,0x00,0x60,0xB0,0x57,0x66,0x4A)

OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
		0xe06d8020,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIATYPE_MPEG2_SECTIONS,
		0x455f176c,0x4b06,0x47ce,0x9a,0xef,0x8c,0xae,0xf7,0x3d,0xf7,0xb5)

OUR_GUID_ENTRY(MEDIASUBTYPE_ATSC_SI,
		0xb3c7397c,0xd303,0x414d,0xb3,0x3c,0x4e,0xd2,0xc9,0xd2,0x97,0x33)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVB_SI,
		0xe9dd31a3,0x221d,0x4adb,0x85,0x32,0x9a,0xf3,0x9,0xc1,0xa4,0x8)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2DATA,
		0xc892e55b,0x252d,0x42b5,0xa3,0x16,0xd9,0x97,0xe7,0xa5,0xd9,0x95)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
		0xe06d8026,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
		0xe06d80e3,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
		0xf72a76A0L,0xeb0a,0x11d0,0xac,0xe4,0x0,0x0,0xc0,0xcc,0x16,0xba)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
		0xe06d8022,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
		0xe06d8023,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE,
		0x138aa9a4,0x1ee2,0x4c5b,0x98,0x8e,0x19,0xab,0xfd,0xbc,0x8a,0x11)

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
		0xe06d802b,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
		0xe06d802c,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
		0xe06d802d,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
		0xe06d8032,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DTS,
		0xe06d8033,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_SDDS,
		0xe06d8034,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
		0xed0b916a,0x044d,0x11d1,0xaa,0x78,0x00,0xc0,0x04f,0xc3,0x1d,0x60)

OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
		0xe06d802e,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,
		0xe06d802f,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
		0xe06d8030,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
		0xe06d8031,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_MPEG2Video,
		0xe06d80e3,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_DolbyAC3,
		0xe06d80e4,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
		0xe06d80e5,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
		0xe06d80e6,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x05f,0x6c,0xbb,0xea)

OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
		0xBFABE720,0x6E1F,0x11D0,0xBC,0xF2,0x44,0x45,0x53,0x54,0x00,0x00)

OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
		0xac390460,0x43af,0x11d0,0xbd,0x6a,0x00,0x35,0x05,0xc1,0x03,0xa9)

OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
		0x0E8A0A40,0x6AEF,0x11D0,0x9E,0xD0,0x00,0xA0,0x24,0xCA,0x19,0xB3)

OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange,
		0xa503c5c0,0x1d1d,0x11d1,0xad,0x80,0x44,0x45,0x53,0x54,0x0,0x0)

OUR_GUID_ENTRY(AM_KSPROPSETID_DVD_RateChange,
		0x3577eb09,0x9582,0x477f,0xb2,0x9c,0xb0,0xc4,0x52,0xa4,0xff,0x9a)

OUR_GUID_ENTRY(AM_KSPROPSETID_DvdKaraoke,
		0xae4720ae,0xaa71,0x42d8,0xb8,0x2a,0xff,0xfd,0xf5,0x8b,0x76,0xfd)

OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
		0xc830acbd,0xab07,0x492f,0x88,0x52,0x45,0xb6,0x98,0x7c,0x29,0x79)

OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
		0x65E8773DL,0x8F56,0x11D0,0xA3,0xB9,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
		0x65E8773EL,0x8F56,0x11D0,0xA3,0xB9,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
		0x1E84C900L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00)

OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
		0x6994AD04L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
		0x6994AD05L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
		0xa799a800L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4)

OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
		0xa799a801L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4)

OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
		0xa799a802L,0xa46d,0x11d0,0xa1,0x8c,0x00,0xa0,0x24,0x01,0xdc,0xd4)

OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
		0x07dad660L,0x22f1,0x11d1,0xa9,0xf4,0x00,0xc0,0x4f,0xbb,0xde,0x8f)

OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC_MI,
		0x9c24a977,0x951,0x451a,0x80,0x6,0xe,0x49,0xbd,0x28,0xcd,0x5f)

OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
		0x0A4252A0L,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00)

OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
		0xD3ABC7E0L,0x9A61,0x11D0,0xA4,0x0D,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
		0x5FFBAA02L,0x49A3,0x11D0,0x9F,0x36,0x00,0xAA,0x00,0xA2,0x16,0xA1)

OUR_GUID_ENTRY(IID_IKsPin,
		0xb61178d1L,0xa2d9,0x11cf,0x9e,0x53,0x00,0xaa,0x00,0xa2,0x16,0xa1)

OUR_GUID_ENTRY(IID_IKsControl,
		0x28F54685L,0x06FD,0x11D2,0xB2,0x7A,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(IID_IKsPinFactory,
		0xCD5EBE6BL,0x8B6E,0x11D1,0x8A,0xE0,0x00,0xA0,0xC9,0x22,0x31,0x96)

OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
		0x1A8766A0L,0x62CE,0x11CF,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00)



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for mmdeviceapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mmdeviceapi_h__
#define __mmdeviceapi_h__

#if __GNUC__ >=3
#pragma GCC system_header
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMMNotificationClient_FWD_DEFINED__
#define __IMMNotificationClient_FWD_DEFINED__
typedef interface IMMNotificationClient IMMNotificationClient;
#endif 	/* __IMMNotificationClient_FWD_DEFINED__ */


#ifndef __IMMDevice_FWD_DEFINED__
#define __IMMDevice_FWD_DEFINED__
typedef interface IMMDevice IMMDevice;
#endif 	/* __IMMDevice_FWD_DEFINED__ */


#ifndef __IMMDeviceCollection_FWD_DEFINED__
#define __IMMDeviceCollection_FWD_DEFINED__
typedef interface IMMDeviceCollection IMMDeviceCollection;
#endif 	/* __IMMDeviceCollection_FWD_DEFINED__ */


#ifndef __IMMEndpoint_FWD_DEFINED__
#define __IMMEndpoint_FWD_DEFINED__
typedef interface IMMEndpoint IMMEndpoint;
#endif 	/* __IMMEndpoint_FWD_DEFINED__ */


#ifndef __IMMDeviceEnumerator_FWD_DEFINED__
#define __IMMDeviceEnumerator_FWD_DEFINED__
typedef interface IMMDeviceEnumerator IMMDeviceEnumerator;
#endif 	/* __IMMDeviceEnumerator_FWD_DEFINED__ */


#ifndef __IMMDeviceActivator_FWD_DEFINED__
#define __IMMDeviceActivator_FWD_DEFINED__
typedef interface IMMDeviceActivator IMMDeviceActivator;
#endif 	/* __IMMDeviceActivator_FWD_DEFINED__ */


#ifndef __MMDeviceEnumerator_FWD_DEFINED__
#define __MMDeviceEnumerator_FWD_DEFINED__

#ifdef __cplusplus
typedef class MMDeviceEnumerator MMDeviceEnumerator;
#else
typedef struct MMDeviceEnumerator MMDeviceEnumerator;
#endif /* __cplusplus */

#endif 	/* __MMDeviceEnumerator_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "unknwn.h"
// (amalg) #include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mmdeviceapi_0000_0000 */
/* [local] */ 

#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
#define E_UNSUPPORTED_TYPE HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE)
#define DEVICE_STATE_ACTIVE      0x00000001
#define DEVICE_STATE_DISABLED    0x00000002
#define DEVICE_STATE_NOTPRESENT  0x00000004
#define DEVICE_STATE_UNPLUGGED   0x00000008
#define DEVICE_STATEMASK_ALL     0x0000000f
#ifdef DEFINE_PROPERTYKEY
#undef DEFINE_PROPERTYKEY
#endif
#ifdef INITGUID
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
#endif // INITGUID
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FormFactor, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 0); 
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_ControlPanelPageProvider, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 1); 
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Association, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 2);
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_PhysicalSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 3);
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_GUID, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 4);
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Disable_SysFx, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 5);
#define ENDPOINT_SYSFX_ENABLED          0x00000000  // System Effects are enabled.
#define ENDPOINT_SYSFX_DISABLED         0x00000001  // System Effects are disabled.
DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FullRangeSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 6);
DEFINE_PROPERTYKEY(PKEY_AudioEngine_DeviceFormat, 0xf19f064d, 0x82c, 0x4e27, 0xbc, 0x73, 0x68, 0x82, 0xa1, 0xbb, 0x8e, 0x4c, 0); 
typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS
    {
    DWORD cbDirectXAudioActivationParams;
    GUID guidAudioSession;
    DWORD dwAudioStreamFlags;
    } 	DIRECTX_AUDIO_ACTIVATION_PARAMS;

typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS *PDIRECTX_AUDIO_ACTIVATION_PARAMS;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0001
    {	eRender	= 0,
	eCapture	= ( eRender + 1 ) ,
	eAll	= ( eCapture + 1 ) ,
	EDataFlow_enum_count	= ( eAll + 1 ) 
    } 	EDataFlow;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0002
    {	eConsole	= 0,
	eMultimedia	= ( eConsole + 1 ) ,
	eCommunications	= ( eMultimedia + 1 ) ,
	ERole_enum_count	= ( eCommunications + 1 ) 
    } 	ERole;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0003
    {	RemoteNetworkDevice	= 0,
	Speakers	= ( RemoteNetworkDevice + 1 ) ,
	LineLevel	= ( Speakers + 1 ) ,
	Headphones	= ( LineLevel + 1 ) ,
	Microphone	= ( Headphones + 1 ) ,
	Headset	= ( Microphone + 1 ) ,
	Handset	= ( Headset + 1 ) ,
	UnknownDigitalPassthrough	= ( Handset + 1 ) ,
	SPDIF	= ( UnknownDigitalPassthrough + 1 ) ,
	HDMI	= ( SPDIF + 1 ) ,
	UnknownFormFactor	= ( HDMI + 1 ) 
    } 	EndpointFormFactor;



extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_s_ifspec;

#ifndef __IMMNotificationClient_INTERFACE_DEFINED__
#define __IMMNotificationClient_INTERFACE_DEFINED__

/* interface IMMNotificationClient */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMNotificationClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7991EEC9-7E89-4D85-8390-6C703CEC60C0")
    IMMNotificationClient : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceStateChanged( 
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId,
            /* [in] */ 
            __in  DWORD dwNewState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceAdded( 
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceRemoved( 
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged( 
            /* [in] */ 
            __in  EDataFlow flow,
            /* [in] */ 
            __in  ERole role,
            /* [in] */ 
            __in  LPCWSTR pwstrDefaultDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPropertyValueChanged( 
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId,
            /* [in] */ 
            __in  const PROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMNotificationClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMNotificationClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMNotificationClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMNotificationClient * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceStateChanged )( 
            IMMNotificationClient * This,
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId,
            /* [in] */ 
            __in  DWORD dwNewState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceAdded )( 
            IMMNotificationClient * This,
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceRemoved )( 
            IMMNotificationClient * This,
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDefaultDeviceChanged )( 
            IMMNotificationClient * This,
            /* [in] */ 
            __in  EDataFlow flow,
            /* [in] */ 
            __in  ERole role,
            /* [in] */ 
            __in  LPCWSTR pwstrDefaultDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPropertyValueChanged )( 
            IMMNotificationClient * This,
            /* [in] */ 
            __in  LPCWSTR pwstrDeviceId,
            /* [in] */ 
            __in  const PROPERTYKEY key);
        
        END_INTERFACE
    } IMMNotificationClientVtbl;

    interface IMMNotificationClient
    {
        CONST_VTBL struct IMMNotificationClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMNotificationClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMNotificationClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMNotificationClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMNotificationClient_OnDeviceStateChanged(This,pwstrDeviceId,dwNewState)	\
    ( (This)->lpVtbl -> OnDeviceStateChanged(This,pwstrDeviceId,dwNewState) ) 

#define IMMNotificationClient_OnDeviceAdded(This,pwstrDeviceId)	\
    ( (This)->lpVtbl -> OnDeviceAdded(This,pwstrDeviceId) ) 

#define IMMNotificationClient_OnDeviceRemoved(This,pwstrDeviceId)	\
    ( (This)->lpVtbl -> OnDeviceRemoved(This,pwstrDeviceId) ) 

#define IMMNotificationClient_OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId)	\
    ( (This)->lpVtbl -> OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId) ) 

#define IMMNotificationClient_OnPropertyValueChanged(This,pwstrDeviceId,key)	\
    ( (This)->lpVtbl -> OnPropertyValueChanged(This,pwstrDeviceId,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMNotificationClient_INTERFACE_DEFINED__ */


#ifndef __IMMDevice_INTERFACE_DEFINED__
#define __IMMDevice_INTERFACE_DEFINED__

/* interface IMMDevice */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D666063F-1587-4E43-81F1-B948E807363F")
    IMMDevice : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ 
            __in  REFIID iid,
            /* [in] */ 
            __in  DWORD dwClsCtx,
            /* [unique][in] */ 
            __in_opt  PROPVARIANT *pActivationParams,
            /* [iid_is][out] */ 
            __out  void **ppInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenPropertyStore( 
            /* [in] */ 
            __in  DWORD stgmAccess,
            /* [out] */ 
            __out  IPropertyStore **ppProperties) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ 
            __deref_out  LPWSTR *ppstrId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ 
            __out  DWORD *pdwState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMDevice * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IMMDevice * This,
            /* [in] */ 
            __in  REFIID iid,
            /* [in] */ 
            __in  DWORD dwClsCtx,
            /* [unique][in] */ 
            __in_opt  PROPVARIANT *pActivationParams,
            /* [iid_is][out] */ 
            __out  void **ppInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OpenPropertyStore )( 
            IMMDevice * This,
            /* [in] */ 
            __in  DWORD stgmAccess,
            /* [out] */ 
            __out  IPropertyStore **ppProperties);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IMMDevice * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppstrId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMMDevice * This,
            /* [out] */ 
            __out  DWORD *pdwState);
        
        END_INTERFACE
    } IMMDeviceVtbl;

    interface IMMDevice
    {
        CONST_VTBL struct IMMDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMDevice_Activate(This,iid,dwClsCtx,pActivationParams,ppInterface)	\
    ( (This)->lpVtbl -> Activate(This,iid,dwClsCtx,pActivationParams,ppInterface) ) 

#define IMMDevice_OpenPropertyStore(This,stgmAccess,ppProperties)	\
    ( (This)->lpVtbl -> OpenPropertyStore(This,stgmAccess,ppProperties) ) 

#define IMMDevice_GetId(This,ppstrId)	\
    ( (This)->lpVtbl -> GetId(This,ppstrId) ) 

#define IMMDevice_GetState(This,pdwState)	\
    ( (This)->lpVtbl -> GetState(This,pdwState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMDevice_INTERFACE_DEFINED__ */


#ifndef __IMMDeviceCollection_INTERFACE_DEFINED__
#define __IMMDeviceCollection_INTERFACE_DEFINED__

/* interface IMMDeviceCollection */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMDeviceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0BD7A1BE-7A1A-44DB-8397-CC5392387B5E")
    IMMDeviceCollection : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ 
            __out  UINT *pcDevices) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ 
            __in  UINT nDevice,
            /* [out] */ 
            __out  IMMDevice **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMDeviceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMDeviceCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMDeviceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMDeviceCollection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMMDeviceCollection * This,
            /* [out] */ 
            __out  UINT *pcDevices);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IMMDeviceCollection * This,
            /* [in] */ 
            __in  UINT nDevice,
            /* [out] */ 
            __out  IMMDevice **ppDevice);
        
        END_INTERFACE
    } IMMDeviceCollectionVtbl;

    interface IMMDeviceCollection
    {
        CONST_VTBL struct IMMDeviceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMDeviceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMDeviceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMDeviceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMDeviceCollection_GetCount(This,pcDevices)	\
    ( (This)->lpVtbl -> GetCount(This,pcDevices) ) 

#define IMMDeviceCollection_Item(This,nDevice,ppDevice)	\
    ( (This)->lpVtbl -> Item(This,nDevice,ppDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMDeviceCollection_INTERFACE_DEFINED__ */


#ifndef __IMMEndpoint_INTERFACE_DEFINED__
#define __IMMEndpoint_INTERFACE_DEFINED__

/* interface IMMEndpoint */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMEndpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BE09788-6894-4089-8586-9A2A6C265AC5")
    IMMEndpoint : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
            /* [out] */ 
            __out  EDataFlow *pDataFlow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMEndpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMEndpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMEndpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMEndpoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
            IMMEndpoint * This,
            /* [out] */ 
            __out  EDataFlow *pDataFlow);
        
        END_INTERFACE
    } IMMEndpointVtbl;

    interface IMMEndpoint
    {
        CONST_VTBL struct IMMEndpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMEndpoint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMEndpoint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMEndpoint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMEndpoint_GetDataFlow(This,pDataFlow)	\
    ( (This)->lpVtbl -> GetDataFlow(This,pDataFlow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMEndpoint_INTERFACE_DEFINED__ */


#ifndef __IMMDeviceEnumerator_INTERFACE_DEFINED__
#define __IMMDeviceEnumerator_INTERFACE_DEFINED__

/* interface IMMDeviceEnumerator */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMDeviceEnumerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A95664D2-9614-4F35-A746-DE8DB63617E6")
    IMMDeviceEnumerator : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumAudioEndpoints( 
            /* [in] */ 
            __in  EDataFlow dataFlow,
            /* [in] */ 
            __in  DWORD dwStateMask,
            /* [out] */ 
            __out  IMMDeviceCollection **ppDevices) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultAudioEndpoint( 
            /* [in] */ 
            __in  EDataFlow dataFlow,
            /* [in] */ 
            __in  ERole role,
            /* [out] */ 
            __out  IMMDevice **ppEndpoint) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevice( 
            /*  */ 
            __in  LPCWSTR pwstrId,
            /* [out] */ 
            __out  IMMDevice **ppDevice) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterEndpointNotificationCallback( 
            /* [in] */ 
            __in  IMMNotificationClient *pClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterEndpointNotificationCallback( 
            /* [in] */ 
            __in  IMMNotificationClient *pClient) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMDeviceEnumeratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMDeviceEnumerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMDeviceEnumerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMDeviceEnumerator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumAudioEndpoints )( 
            IMMDeviceEnumerator * This,
            /* [in] */ 
            __in  EDataFlow dataFlow,
            /* [in] */ 
            __in  DWORD dwStateMask,
            /* [out] */ 
            __out  IMMDeviceCollection **ppDevices);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioEndpoint )( 
            IMMDeviceEnumerator * This,
            /* [in] */ 
            __in  EDataFlow dataFlow,
            /* [in] */ 
            __in  ERole role,
            /* [out] */ 
            __out  IMMDevice **ppEndpoint);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IMMDeviceEnumerator * This,
            /*  */ 
            __in  LPCWSTR pwstrId,
            /* [out] */ 
            __out  IMMDevice **ppDevice);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterEndpointNotificationCallback )( 
            IMMDeviceEnumerator * This,
            /* [in] */ 
            __in  IMMNotificationClient *pClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterEndpointNotificationCallback )( 
            IMMDeviceEnumerator * This,
            /* [in] */ 
            __in  IMMNotificationClient *pClient);
        
        END_INTERFACE
    } IMMDeviceEnumeratorVtbl;

    interface IMMDeviceEnumerator
    {
        CONST_VTBL struct IMMDeviceEnumeratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMDeviceEnumerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMDeviceEnumerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMDeviceEnumerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMDeviceEnumerator_EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices)	\
    ( (This)->lpVtbl -> EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices) ) 

#define IMMDeviceEnumerator_GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint)	\
    ( (This)->lpVtbl -> GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint) ) 

#define IMMDeviceEnumerator_GetDevice(This,pwstrId,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,pwstrId,ppDevice) ) 

#define IMMDeviceEnumerator_RegisterEndpointNotificationCallback(This,pClient)	\
    ( (This)->lpVtbl -> RegisterEndpointNotificationCallback(This,pClient) ) 

#define IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(This,pClient)	\
    ( (This)->lpVtbl -> UnregisterEndpointNotificationCallback(This,pClient) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMDeviceEnumerator_INTERFACE_DEFINED__ */


#ifndef __IMMDeviceActivator_INTERFACE_DEFINED__
#define __IMMDeviceActivator_INTERFACE_DEFINED__

/* interface IMMDeviceActivator */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IMMDeviceActivator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B0D0EA4-D0A9-4B0E-935B-09516746FAC0")
    IMMDeviceActivator : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ 
            __in  REFIID iid,
            /* [in] */ 
            __in  IMMDevice *pDevice,
            /* [in] */ 
            __in_opt  PROPVARIANT *pActivationParams,
            /* [iid_is][out] */ 
            __out  void **ppInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMDeviceActivatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMMDeviceActivator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMMDeviceActivator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMMDeviceActivator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IMMDeviceActivator * This,
            /* [in] */ 
            __in  REFIID iid,
            /* [in] */ 
            __in  IMMDevice *pDevice,
            /* [in] */ 
            __in_opt  PROPVARIANT *pActivationParams,
            /* [iid_is][out] */ 
            __out  void **ppInterface);
        
        END_INTERFACE
    } IMMDeviceActivatorVtbl;

    interface IMMDeviceActivator
    {
        CONST_VTBL struct IMMDeviceActivatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMDeviceActivator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMMDeviceActivator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMMDeviceActivator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMMDeviceActivator_Activate(This,iid,pDevice,pActivationParams,ppInterface)	\
    ( (This)->lpVtbl -> Activate(This,iid,pDevice,pActivationParams,ppInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMMDeviceActivator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmdeviceapi_0000_0006 */
/* [local] */ 

typedef /* [public] */ struct __MIDL___MIDL_itf_mmdeviceapi_0000_0006_0001
    {
    LPARAM AddPageParam;
    IMMDevice *pEndpoint;
    IMMDevice *pPnpInterface;
    IMMDevice *pPnpDevnode;
    } 	AudioExtensionParams;



extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_s_ifspec;


#ifndef __MMDeviceAPILib_LIBRARY_DEFINED__
#define __MMDeviceAPILib_LIBRARY_DEFINED__

/* library MMDeviceAPILib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MMDeviceAPILib;

EXTERN_C const CLSID CLSID_MMDeviceEnumerator;

#ifdef __cplusplus

class DECLSPEC_UUID("BCDE0395-E52F-467C-8E3D-C4579291692E")
MMDeviceEnumerator;
#endif
#endif /* __MMDeviceAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif



#ifndef PID_FIRST_USABLE
#define PID_FIRST_USABLE 2
#endif

#ifndef REFPROPERTYKEY
#ifdef __cplusplus
#define REFPROPERTYKEY const PROPERTYKEY &
#else // !__cplusplus
#define REFPROPERTYKEY const PROPERTYKEY * __MIDL_CONST
#endif // __cplusplus
#endif //REFPROPERTYKEY

#ifdef DEFINE_PROPERTYKEY
#undef DEFINE_PROPERTYKEY
#endif

#ifdef INITGUID
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
#endif // INITGUID

#ifndef IsEqualPropertyKey
#define IsEqualPropertyKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#endif  // IsEqualPropertyKey



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for propsys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propsys_h__
#define __propsys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInitializeWithFile_FWD_DEFINED__
#define __IInitializeWithFile_FWD_DEFINED__
typedef interface IInitializeWithFile IInitializeWithFile;
#endif 	/* __IInitializeWithFile_FWD_DEFINED__ */


#ifndef __IInitializeWithStream_FWD_DEFINED__
#define __IInitializeWithStream_FWD_DEFINED__
typedef interface IInitializeWithStream IInitializeWithStream;
#endif 	/* __IInitializeWithStream_FWD_DEFINED__ */


#ifndef __IPropertyStore_FWD_DEFINED__
#define __IPropertyStore_FWD_DEFINED__
typedef interface IPropertyStore IPropertyStore;
#endif 	/* __IPropertyStore_FWD_DEFINED__ */


#ifndef __INamedPropertyStore_FWD_DEFINED__
#define __INamedPropertyStore_FWD_DEFINED__
typedef interface INamedPropertyStore INamedPropertyStore;
#endif 	/* __INamedPropertyStore_FWD_DEFINED__ */


#ifndef __IObjectWithPropertyKey_FWD_DEFINED__
#define __IObjectWithPropertyKey_FWD_DEFINED__
typedef interface IObjectWithPropertyKey IObjectWithPropertyKey;
#endif 	/* __IObjectWithPropertyKey_FWD_DEFINED__ */


#ifndef __IPropertyChange_FWD_DEFINED__
#define __IPropertyChange_FWD_DEFINED__
typedef interface IPropertyChange IPropertyChange;
#endif 	/* __IPropertyChange_FWD_DEFINED__ */


#ifndef __IPropertyChangeArray_FWD_DEFINED__
#define __IPropertyChangeArray_FWD_DEFINED__
typedef interface IPropertyChangeArray IPropertyChangeArray;
#endif 	/* __IPropertyChangeArray_FWD_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_FWD_DEFINED__
#define __IPropertyStoreCapabilities_FWD_DEFINED__
typedef interface IPropertyStoreCapabilities IPropertyStoreCapabilities;
#endif 	/* __IPropertyStoreCapabilities_FWD_DEFINED__ */


#ifndef __IPropertyStoreCache_FWD_DEFINED__
#define __IPropertyStoreCache_FWD_DEFINED__
typedef interface IPropertyStoreCache IPropertyStoreCache;
#endif 	/* __IPropertyStoreCache_FWD_DEFINED__ */


#ifndef __IPropertyEnumType_FWD_DEFINED__
#define __IPropertyEnumType_FWD_DEFINED__
typedef interface IPropertyEnumType IPropertyEnumType;
#endif 	/* __IPropertyEnumType_FWD_DEFINED__ */


#ifndef __IPropertyEnumTypeList_FWD_DEFINED__
#define __IPropertyEnumTypeList_FWD_DEFINED__
typedef interface IPropertyEnumTypeList IPropertyEnumTypeList;
#endif 	/* __IPropertyEnumTypeList_FWD_DEFINED__ */


#ifndef __IPropertyDescription_FWD_DEFINED__
#define __IPropertyDescription_FWD_DEFINED__
typedef interface IPropertyDescription IPropertyDescription;
#endif 	/* __IPropertyDescription_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_FWD_DEFINED__
#define __IPropertyDescriptionAliasInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionAliasInfo IPropertyDescriptionAliasInfo;
#endif 	/* __IPropertyDescriptionAliasInfo_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_FWD_DEFINED__
#define __IPropertyDescriptionSearchInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionSearchInfo IPropertyDescriptionSearchInfo;
#endif 	/* __IPropertyDescriptionSearchInfo_FWD_DEFINED__ */


#ifndef __IPropertySystem_FWD_DEFINED__
#define __IPropertySystem_FWD_DEFINED__
typedef interface IPropertySystem IPropertySystem;
#endif 	/* __IPropertySystem_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionList_FWD_DEFINED__
#define __IPropertyDescriptionList_FWD_DEFINED__
typedef interface IPropertyDescriptionList IPropertyDescriptionList;
#endif 	/* __IPropertyDescriptionList_FWD_DEFINED__ */


#ifndef __IPropertyStoreFactory_FWD_DEFINED__
#define __IPropertyStoreFactory_FWD_DEFINED__
typedef interface IPropertyStoreFactory IPropertyStoreFactory;
#endif 	/* __IPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_FWD_DEFINED__
#define __IDelayedPropertyStoreFactory_FWD_DEFINED__
typedef interface IDelayedPropertyStoreFactory IDelayedPropertyStoreFactory;
#endif 	/* __IDelayedPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IPersistSerializedPropStorage_FWD_DEFINED__
#define __IPersistSerializedPropStorage_FWD_DEFINED__
typedef interface IPersistSerializedPropStorage IPersistSerializedPropStorage;
#endif 	/* __IPersistSerializedPropStorage_FWD_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_FWD_DEFINED__
#define __IPropertySystemChangeNotify_FWD_DEFINED__
typedef interface IPropertySystemChangeNotify IPropertySystemChangeNotify;
#endif 	/* __IPropertySystemChangeNotify_FWD_DEFINED__ */


#ifndef __ICreateObject_FWD_DEFINED__
#define __ICreateObject_FWD_DEFINED__
typedef interface ICreateObject ICreateObject;
#endif 	/* __ICreateObject_FWD_DEFINED__ */


#ifndef __InMemoryPropertyStore_FWD_DEFINED__
#define __InMemoryPropertyStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class InMemoryPropertyStore InMemoryPropertyStore;
#else
typedef struct InMemoryPropertyStore InMemoryPropertyStore;
#endif /* __cplusplus */

#endif 	/* __InMemoryPropertyStore_FWD_DEFINED__ */


#ifndef __PropertySystem_FWD_DEFINED__
#define __PropertySystem_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertySystem PropertySystem;
#else
typedef struct PropertySystem PropertySystem;
#endif /* __cplusplus */

#endif 	/* __PropertySystem_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "objidl.h"
// (amalg) #include "oleidl.h"
// (amalg) #include "ocidl.h"
// (amalg) #include "shtypes.h"
// (amalg) #include "structuredquery.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_propsys_0000_0000 */
/* [local] */ 

#ifndef PSSTDAPI
#if defined(_PROPSYS_)
#define PSSTDAPI          STDAPI
#define PSSTDAPI_(type)   STDAPI_(type)
#else
#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // PSSTDAPI
#if 0
typedef PROPERTYKEY *REFPROPERTYKEY;

#endif // 0
#include <propkeydef.h>


extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_s_ifspec;

#ifndef __IInitializeWithFile_INTERFACE_DEFINED__
#define __IInitializeWithFile_INTERFACE_DEFINED__

/* interface IInitializeWithFile */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7d14566-0509-4cce-a71f-0a554233bd9b")
    IInitializeWithFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeWithFile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeWithFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeWithFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithFile * This,
            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithFileVtbl;

    interface IInitializeWithFile
    {
        CONST_VTBL struct IInitializeWithFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithFile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithFile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithFile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithFile_Initialize(This,pszFilePath,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pszFilePath,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithFile_INTERFACE_DEFINED__ */


#ifndef __IInitializeWithStream_INTERFACE_DEFINED__
#define __IInitializeWithStream_INTERFACE_DEFINED__

/* interface IInitializeWithStream */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b824b49d-22ac-4161-ac8a-9916e8fa3f7f")
    IInitializeWithStream : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IStream *pstream,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeWithStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeWithStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeWithStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithStream * This,
            /* [in] */ IStream *pstream,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithStreamVtbl;

    interface IInitializeWithStream
    {
        CONST_VTBL struct IInitializeWithStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithStream_Initialize(This,pstream,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pstream,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_RemoteInitialize_Proxy( 
    IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IInitializeWithStream_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitializeWithStream_INTERFACE_DEFINED__ */


#ifndef __IPropertyStore_INTERFACE_DEFINED__
#define __IPropertyStore_INTERFACE_DEFINED__

/* interface IPropertyStore */
/* [unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")
    IPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out DWORD *cProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyStore * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStore * This);
        
        END_INTERFACE
    } IPropertyStoreVtbl;

    interface IPropertyStore
    {
        CONST_VTBL struct IPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStore_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStore_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStore_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStore_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStore_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0003 */
/* [local] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertyStore *LPPROPERTYSTORE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_s_ifspec;

#ifndef __INamedPropertyStore_INTERFACE_DEFINED__
#define __INamedPropertyStore_INTERFACE_DEFINED__

/* interface INamedPropertyStore */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_INamedPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71604b0f-97b0-4764-8577-2f13e98a1422")
    INamedPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNamedValue( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedValue( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedValue )( 
            INamedPropertyStore * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamedValue )( 
            INamedPropertyStore * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
            INamedPropertyStore * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameAt )( 
            INamedPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        END_INTERFACE
    } INamedPropertyStoreVtbl;

    interface INamedPropertyStore
    {
        CONST_VTBL struct INamedPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedPropertyStore_GetNamedValue(This,pszName,ppropvar)	\
    ( (This)->lpVtbl -> GetNamedValue(This,pszName,ppropvar) ) 

#define INamedPropertyStore_SetNamedValue(This,pszName,propvar)	\
    ( (This)->lpVtbl -> SetNamedValue(This,pszName,propvar) ) 

#define INamedPropertyStore_GetNameCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetNameCount(This,pdwCount) ) 

#define INamedPropertyStore_GetNameAt(This,iProp,pbstrName)	\
    ( (This)->lpVtbl -> GetNameAt(This,iProp,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0004 */
/* [local] */ 

/* [v1_enum] */ 
enum tagGETPROPERTYSTOREFLAGS
    {	GPS_DEFAULT	= 0,
	GPS_HANDLERPROPERTIESONLY	= 0x1,
	GPS_READWRITE	= 0x2,
	GPS_TEMPORARY	= 0x4,
	GPS_FASTPROPERTIESONLY	= 0x8,
	GPS_OPENSLOWITEM	= 0x10,
	GPS_DELAYCREATION	= 0x20,
	GPS_BESTEFFORT	= 0x40,
	GPS_MASK_VALID	= 0x7f
    } ;
typedef int GETPROPERTYSTOREFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_s_ifspec;

#ifndef __IObjectWithPropertyKey_INTERFACE_DEFINED__
#define __IObjectWithPropertyKey_INTERFACE_DEFINED__

/* interface IObjectWithPropertyKey */
/* [uuid][object] */ 


EXTERN_C const IID IID_IObjectWithPropertyKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc0ca0a7-c316-4fd2-9031-3e628e6d4f23")
    IObjectWithPropertyKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyKey( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithPropertyKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithPropertyKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithPropertyKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IObjectWithPropertyKey * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        END_INTERFACE
    } IObjectWithPropertyKeyVtbl;

    interface IObjectWithPropertyKey
    {
        CONST_VTBL struct IObjectWithPropertyKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithPropertyKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithPropertyKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithPropertyKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithPropertyKey_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IObjectWithPropertyKey_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithPropertyKey_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0005 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagPKA_FLAGS
    {	PKA_SET	= 0,
	PKA_APPEND	= ( PKA_SET + 1 ) ,
	PKA_DELETE	= ( PKA_APPEND + 1 ) 
    } 	PKA_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_s_ifspec;

#ifndef __IPropertyChange_INTERFACE_DEFINED__
#define __IPropertyChange_INTERFACE_DEFINED__

/* interface IPropertyChange */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f917bc8a-1bba-4478-a245-1bde03eb9431")
    IPropertyChange : public IObjectWithPropertyKey
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ApplyToPropVariant( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyChange * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyToPropVariant )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut);
        
        END_INTERFACE
    } IPropertyChangeVtbl;

    interface IPropertyChange
    {
        CONST_VTBL struct IPropertyChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChange_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IPropertyChange_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 


#define IPropertyChange_ApplyToPropVariant(This,propvarIn,ppropvarOut)	\
    ( (This)->lpVtbl -> ApplyToPropVariant(This,propvarIn,ppropvarOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChange_INTERFACE_DEFINED__ */


#ifndef __IPropertyChangeArray_INTERFACE_DEFINED__
#define __IPropertyChangeArray_INTERFACE_DEFINED__

/* interface IPropertyChangeArray */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChangeArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("380f5cad-1b5e-42f2-805d-637fd392d31e")
    IPropertyChangeArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcOperations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendOrReplace( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT iIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeyInArray( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyChangeArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyChangeArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyChangeArray * This,
            /* [out] */ __RPC__out UINT *pcOperations);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *AppendOrReplace )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeyInArray )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyChangeArrayVtbl;

    interface IPropertyChangeArray
    {
        CONST_VTBL struct IPropertyChangeArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChangeArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChangeArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChangeArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChangeArray_GetCount(This,pcOperations)	\
    ( (This)->lpVtbl -> GetCount(This,pcOperations) ) 

#define IPropertyChangeArray_GetAt(This,iIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iIndex,riid,ppv) ) 

#define IPropertyChangeArray_InsertAt(This,iIndex,ppropChange)	\
    ( (This)->lpVtbl -> InsertAt(This,iIndex,ppropChange) ) 

#define IPropertyChangeArray_Append(This,ppropChange)	\
    ( (This)->lpVtbl -> Append(This,ppropChange) ) 

#define IPropertyChangeArray_AppendOrReplace(This,ppropChange)	\
    ( (This)->lpVtbl -> AppendOrReplace(This,ppropChange) ) 

#define IPropertyChangeArray_RemoveAt(This,iIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,iIndex) ) 

#define IPropertyChangeArray_IsKeyInArray(This,key)	\
    ( (This)->lpVtbl -> IsKeyInArray(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChangeArray_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_INTERFACE_DEFINED__
#define __IPropertyStoreCapabilities_INTERFACE_DEFINED__

/* interface IPropertyStoreCapabilities */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8e2d566-186e-4d49-bf41-6909ead56acc")
    IPropertyStoreCapabilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsPropertyWritable( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPropertyWritable )( 
            IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyStoreCapabilitiesVtbl;

    interface IPropertyStoreCapabilities
    {
        CONST_VTBL struct IPropertyStoreCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCapabilities_IsPropertyWritable(This,key)	\
    ( (This)->lpVtbl -> IsPropertyWritable(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCapabilities_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCache_INTERFACE_DEFINED__
#define __IPropertyStoreCache_INTERFACE_DEFINED__

/* interface IPropertyStoreCache */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum _PSC_STATE
    {	PSC_NORMAL	= 0,
	PSC_NOTINSOURCE	= 1,
	PSC_DIRTY	= 2,
	PSC_READONLY	= 3
    } 	PSC_STATE;


EXTERN_C const IID IID_IPropertyStoreCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3017056d-9a91-4e90-937d-746c72abbf4f")
    IPropertyStoreCache : public IPropertyStore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyStoreCache * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyStoreCache * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueAndState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAndState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state);
        
        END_INTERFACE
    } IPropertyStoreCacheVtbl;

    interface IPropertyStoreCache
    {
        CONST_VTBL struct IPropertyStoreCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCache_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStoreCache_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStoreCache_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStoreCache_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStoreCache_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IPropertyStoreCache_GetState(This,key,pstate)	\
    ( (This)->lpVtbl -> GetState(This,key,pstate) ) 

#define IPropertyStoreCache_GetValueAndState(This,key,ppropvar,pstate)	\
    ( (This)->lpVtbl -> GetValueAndState(This,key,ppropvar,pstate) ) 

#define IPropertyStoreCache_SetState(This,key,state)	\
    ( (This)->lpVtbl -> SetState(This,key,state) ) 

#define IPropertyStoreCache_SetValueAndState(This,key,ppropvar,state)	\
    ( (This)->lpVtbl -> SetValueAndState(This,key,ppropvar,state) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCache_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumType_INTERFACE_DEFINED__
#define __IPropertyEnumType_INTERFACE_DEFINED__

/* interface IPropertyEnumType */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPENUMTYPE
    {	PET_DISCRETEVALUE	= 0,
	PET_RANGEDVALUE	= 1,
	PET_DEFAULTVALUE	= 2,
	PET_ENDRANGE	= 3
    } ;
typedef enum tagPROPENUMTYPE PROPENUMTYPE;


EXTERN_C const IID IID_IPropertyEnumType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11e1fbf9-2d56-4a6b-8db3-7cd193a471f2")
    IPropertyEnumType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnumType( 
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeMinValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeSetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayText( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyEnumType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyEnumType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyEnumType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
        
        END_INTERFACE
    } IPropertyEnumTypeVtbl;

    interface IPropertyEnumType
    {
        CONST_VTBL struct IPropertyEnumTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumType_GetEnumType(This,penumtype)	\
    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 

#define IPropertyEnumType_GetValue(This,ppropvar)	\
    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 

#define IPropertyEnumType_GetRangeMinValue(This,ppropvarMin)	\
    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 

#define IPropertyEnumType_GetRangeSetValue(This,ppropvarSet)	\
    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 

#define IPropertyEnumType_GetDisplayText(This,ppszDisplay)	\
    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumType_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumTypeList_INTERFACE_DEFINED__
#define __IPropertyEnumTypeList_INTERFACE_DEFINED__

/* interface IPropertyEnumTypeList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyEnumTypeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a99400f4-3d84-4557-94ba-1242fb2cc9a6")
    IPropertyEnumTypeList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pctypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionAt( 
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindMatchingIndex( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyEnumTypeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyEnumTypeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyEnumTypeList * This,
            /* [out] */ __RPC__out UINT *pctypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyEnumTypeList * This,
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionAt )( 
            IPropertyEnumTypeList * This,
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FindMatchingIndex )( 
            IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex);
        
        END_INTERFACE
    } IPropertyEnumTypeListVtbl;

    interface IPropertyEnumTypeList
    {
        CONST_VTBL struct IPropertyEnumTypeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumTypeList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumTypeList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumTypeList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumTypeList_GetCount(This,pctypes)	\
    ( (This)->lpVtbl -> GetCount(This,pctypes) ) 

#define IPropertyEnumTypeList_GetAt(This,itype,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,itype,riid,ppv) ) 

#define IPropertyEnumTypeList_GetConditionAt(This,nIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetConditionAt(This,nIndex,riid,ppv) ) 

#define IPropertyEnumTypeList_FindMatchingIndex(This,propvarCmp,pnIndex)	\
    ( (This)->lpVtbl -> FindMatchingIndex(This,propvarCmp,pnIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumTypeList_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescription_INTERFACE_DEFINED__
#define __IPropertyDescription_INTERFACE_DEFINED__

/* interface IPropertyDescription */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPDESC_TYPE_FLAGS
    {	PDTF_DEFAULT	= 0,
	PDTF_MULTIPLEVALUES	= 0x1,
	PDTF_ISINNATE	= 0x2,
	PDTF_ISGROUP	= 0x4,
	PDTF_CANGROUPBY	= 0x8,
	PDTF_CANSTACKBY	= 0x10,
	PDTF_ISTREEPROPERTY	= 0x20,
	PDTF_INCLUDEINFULLTEXTQUERY	= 0x40,
	PDTF_ISVIEWABLE	= 0x80,
	PDTF_ISQUERYABLE	= 0x100,
	PDTF_ISSYSTEMPROPERTY	= 0x80000000,
	PDTF_MASK_ALL	= 0x800001ff
    } ;
typedef int PROPDESC_TYPE_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_VIEW_FLAGS
    {	PDVF_DEFAULT	= 0,
	PDVF_CENTERALIGN	= 0x1,
	PDVF_RIGHTALIGN	= 0x2,
	PDVF_BEGINNEWGROUP	= 0x4,
	PDVF_FILLAREA	= 0x8,
	PDVF_SORTDESCENDING	= 0x10,
	PDVF_SHOWONLYIFPRESENT	= 0x20,
	PDVF_SHOWBYDEFAULT	= 0x40,
	PDVF_SHOWINPRIMARYLIST	= 0x80,
	PDVF_SHOWINSECONDARYLIST	= 0x100,
	PDVF_HIDELABEL	= 0x200,
	PDVF_HIDDEN	= 0x800,
	PDVF_CANWRAP	= 0x1000,
	PDVF_MASK_ALL	= 0x1bff
    } ;
typedef int PROPDESC_VIEW_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_DISPLAYTYPE
    {	PDDT_STRING	= 0,
	PDDT_NUMBER	= 1,
	PDDT_BOOLEAN	= 2,
	PDDT_DATETIME	= 3,
	PDDT_ENUMERATED	= 4
    } ;
typedef enum tagPROPDESC_DISPLAYTYPE PROPDESC_DISPLAYTYPE;

/* [v1_enum] */ 
enum tagPROPDESC_GROUPING_RANGE
    {	PDGR_DISCRETE	= 0,
	PDGR_ALPHANUMERIC	= 1,
	PDGR_SIZE	= 2,
	PDGR_DYNAMIC	= 3,
	PDGR_DATE	= 4,
	PDGR_PERCENT	= 5,
	PDGR_ENUMERATED	= 6
    } ;
typedef enum tagPROPDESC_GROUPING_RANGE PROPDESC_GROUPING_RANGE;

/* [v1_enum] */ 
enum tagPROPDESC_FORMAT_FLAGS
    {	PDFF_DEFAULT	= 0,
	PDFF_PREFIXNAME	= 0x1,
	PDFF_FILENAME	= 0x2,
	PDFF_ALWAYSKB	= 0x4,
	PDFF_RESERVED_RIGHTTOLEFT	= 0x8,
	PDFF_SHORTTIME	= 0x10,
	PDFF_LONGTIME	= 0x20,
	PDFF_HIDETIME	= 0x40,
	PDFF_SHORTDATE	= 0x80,
	PDFF_LONGDATE	= 0x100,
	PDFF_HIDEDATE	= 0x200,
	PDFF_RELATIVEDATE	= 0x400,
	PDFF_USEEDITINVITATION	= 0x800,
	PDFF_READONLY	= 0x1000,
	PDFF_NOAUTOREADINGORDER	= 0x2000
    } ;
typedef int PROPDESC_FORMAT_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_SORTDESCRIPTION
    {	PDSD_GENERAL	= 0,
	PDSD_A_Z	= 1,
	PDSD_LOWEST_HIGHEST	= 2,
	PDSD_SMALLEST_BIGGEST	= 3,
	PDSD_OLDEST_NEWEST	= 4
    } ;
typedef enum tagPROPDESC_SORTDESCRIPTION PROPDESC_SORTDESCRIPTION;

/* [v1_enum] */ 
enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE
    {	PDRDT_GENERAL	= 0,
	PDRDT_DATE	= 1,
	PDRDT_SIZE	= 2,
	PDRDT_COUNT	= 3,
	PDRDT_REVISION	= 4,
	PDRDT_LENGTH	= 5,
	PDRDT_DURATION	= 6,
	PDRDT_SPEED	= 7,
	PDRDT_RATE	= 8,
	PDRDT_RATING	= 9,
	PDRDT_PRIORITY	= 10
    } ;
typedef enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE PROPDESC_RELATIVEDESCRIPTION_TYPE;

/* [v1_enum] */ 
enum tagPROPDESC_AGGREGATION_TYPE
    {	PDAT_DEFAULT	= 0,
	PDAT_FIRST	= 1,
	PDAT_SUM	= 2,
	PDAT_AVERAGE	= 3,
	PDAT_DATERANGE	= 4,
	PDAT_UNION	= 5,
	PDAT_MAX	= 6,
	PDAT_MIN	= 7
    } ;
typedef enum tagPROPDESC_AGGREGATION_TYPE PROPDESC_AGGREGATION_TYPE;

/* [v1_enum] */ 
enum tagPROPDESC_CONDITION_TYPE
    {	PDCOT_NONE	= 0,
	PDCOT_STRING	= 1,
	PDCOT_SIZE	= 2,
	PDCOT_DATETIME	= 3,
	PDCOT_BOOLEAN	= 4,
	PDCOT_NUMBER	= 5
    } ;
typedef enum tagPROPDESC_CONDITION_TYPE PROPDESC_CONDITION_TYPE;


EXTERN_C const IID IID_IPropertyDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f79d558-3e96-4549-a1d1-7d75d2288814")
    IPropertyDescription : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
            /* [out] */ __RPC__out VARTYPE *pvartype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditInvitation( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnWidth( 
            /* [out] */ __RPC__out UINT *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayType( 
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnState( 
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupingRange( 
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescriptionType( 
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescription( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescription( 
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescriptionLabel( 
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAggregationType( 
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumTypeList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CoerceToCanonicalValue( 
            /* [out][in] */ PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueCanonical( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescription * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescription * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescription * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescription * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        END_INTERFACE
    } IPropertyDescriptionVtbl;

    interface IPropertyDescription
    {
        CONST_VTBL struct IPropertyDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescription_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescription_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescription_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescription_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescription_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescription_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescription_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescription_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescription_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescription_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescription_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescription_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescription_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescription_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescription_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescription_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescription_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescription_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescription_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescription_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescription_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_RemoteCoerceToCanonicalValue_Proxy( 
    IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);


void __RPC_STUB IPropertyDescription_RemoteCoerceToCanonicalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyDescription_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionAliasInfo */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionAliasInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f67104fc-2af9-46fd-b32d-243c1404f3d1")
    IPropertyDescriptionAliasInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSortByAlias( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalSortByAliases( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionAliasInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionAliasInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionAliasInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortByAlias )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdditionalSortByAliases )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionAliasInfoVtbl;

    interface IPropertyDescriptionAliasInfo
    {
        CONST_VTBL struct IPropertyDescriptionAliasInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionAliasInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionAliasInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionAliasInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionAliasInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionAliasInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionAliasInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionAliasInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionAliasInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionAliasInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionAliasInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionAliasInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionAliasInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionAliasInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionAliasInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionAliasInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionAliasInfo_GetSortByAlias(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSortByAlias(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_GetAdditionalSortByAliases(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetAdditionalSortByAliases(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionSearchInfo */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPDESC_SEARCHINFO_FLAGS
    {	PDSIF_DEFAULT	= 0,
	PDSIF_ININVERTEDINDEX	= 0x1,
	PDSIF_ISCOLUMN	= 0x2,
	PDSIF_ISCOLUMNSPARSE	= 0x4
    } ;
typedef int PROPDESC_SEARCHINFO_FLAGS;

typedef /* [v1_enum] */ 
enum tagPROPDESC_COLUMNINDEX_TYPE
    {	PDCIT_NONE	= 0,
	PDCIT_ONDISK	= 1,
	PDCIT_INMEMORY	= 2
    } 	PROPDESC_COLUMNINDEX_TYPE;


EXTERN_C const IID IID_IPropertyDescriptionSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("078f91bd-29a2-440f-924e-46a291524520")
    IPropertyDescriptionSearchInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSearchInfoFlags( 
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnIndexType( 
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProjectionString( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
            /* [out] */ __RPC__out UINT *pcbMaxSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSearchInfoFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnIndexType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType);
        
        HRESULT ( STDMETHODCALLTYPE *GetProjectionString )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcbMaxSize);
        
        END_INTERFACE
    } IPropertyDescriptionSearchInfoVtbl;

    interface IPropertyDescriptionSearchInfo
    {
        CONST_VTBL struct IPropertyDescriptionSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionSearchInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionSearchInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionSearchInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionSearchInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionSearchInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionSearchInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionSearchInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionSearchInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionSearchInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionSearchInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionSearchInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionSearchInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionSearchInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionSearchInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionSearchInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionSearchInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionSearchInfo_GetSearchInfoFlags(This,ppdsiFlags)	\
    ( (This)->lpVtbl -> GetSearchInfoFlags(This,ppdsiFlags) ) 

#define IPropertyDescriptionSearchInfo_GetColumnIndexType(This,ppdciType)	\
    ( (This)->lpVtbl -> GetColumnIndexType(This,ppdciType) ) 

#define IPropertyDescriptionSearchInfo_GetProjectionString(This,ppszProjection)	\
    ( (This)->lpVtbl -> GetProjectionString(This,ppszProjection) ) 

#define IPropertyDescriptionSearchInfo_GetMaxSize(This,pcbMaxSize)	\
    ( (This)->lpVtbl -> GetMaxSize(This,pcbMaxSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0014 */
/* [local] */ 

/* [v1_enum] */ 
enum tagPROPDESC_ENUMFILTER
    {	PDEF_ALL	= 0,
	PDEF_SYSTEM	= 1,
	PDEF_NONSYSTEM	= 2,
	PDEF_VIEWABLE	= 3,
	PDEF_QUERYABLE	= 4,
	PDEF_INFULLTEXTQUERY	= 5,
	PDEF_COLUMN	= 6
    } ;
typedef enum tagPROPDESC_ENUMFILTER PROPDESC_ENUMFILTER;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_s_ifspec;

#ifndef __IPropertySystem_INTERFACE_DEFINED__
#define __IPropertySystem_INTERFACE_DEFINED__

/* interface IPropertySystem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca724e8a-c3e6-442b-88a4-6fb0db8035a3")
    IPropertySystem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionByName( 
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionListFromString( 
            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratePropertyDescriptions( 
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplayAlloc( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPropertySchema( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterPropertySchema( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshPropertySchema( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySystem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionByName )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionListFromString )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratePropertyDescriptions )( 
            IPropertySystem * This,
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplayAlloc )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPropertySchema )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterPropertySchema )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshPropertySchema )( 
            IPropertySystem * This);
        
        END_INTERFACE
    } IPropertySystemVtbl;

    interface IPropertySystem
    {
        CONST_VTBL struct IPropertySystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystem_GetPropertyDescription(This,propkey,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescription(This,propkey,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv) ) 

#define IPropertySystem_EnumeratePropertyDescriptions(This,filterOn,riid,ppv)	\
    ( (This)->lpVtbl -> EnumeratePropertyDescriptions(This,filterOn,riid,ppv) ) 

#define IPropertySystem_FormatForDisplay(This,key,propvar,pdff,pszText,cchText)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,key,propvar,pdff,pszText,cchText) ) 

#define IPropertySystem_FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay) ) 

#define IPropertySystem_RegisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> RegisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_UnregisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> UnregisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_RefreshPropertySchema(This)	\
    ( (This)->lpVtbl -> RefreshPropertySchema(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystem_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionList_INTERFACE_DEFINED__
#define __IPropertyDescriptionList_INTERFACE_DEFINED__

/* interface IPropertyDescriptionList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f9fc1d0-c39b-4b26-817f-011967d3440e")
    IPropertyDescriptionList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcElem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyDescriptionList * This,
            /* [out] */ __RPC__out UINT *pcElem);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyDescriptionList * This,
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionListVtbl;

    interface IPropertyDescriptionList
    {
        CONST_VTBL struct IPropertyDescriptionListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionList_GetCount(This,pcElem)	\
    ( (This)->lpVtbl -> GetCount(This,pcElem) ) 

#define IPropertyDescriptionList_GetAt(This,iElem,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iElem,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionList_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreFactory_INTERFACE_DEFINED__
#define __IPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc110b6d-57e8-4148-a9c6-91015ab2f3a5")
    IPropertyStoreFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            IPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyStoreFactoryVtbl;

    interface IPropertyStoreFactory
    {
        CONST_VTBL struct IPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreFactory_INTERFACE_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
#define __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IDelayedPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDelayedPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40d4577f-e237-4bdb-bd69-58f089431b6a")
    IDelayedPropertyStoreFactory : public IPropertyStoreFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDelayedPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelayedPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelayedPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelayedPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            IDelayedPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelayedPropertyStore )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IDelayedPropertyStoreFactoryVtbl;

    interface IDelayedPropertyStoreFactory
    {
        CONST_VTBL struct IDelayedPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelayedPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelayedPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelayedPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelayedPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IDelayedPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 


#define IDelayedPropertyStoreFactory_GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv)	\
    ( (This)->lpVtbl -> GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0018 */
/* [local] */ 

/* [v1_enum] */ 
enum tagPERSIST_SPROPSTORE_FLAGS
    {	FPSPS_READONLY	= 0x1
    } ;
typedef int PERSIST_SPROPSTORE_FLAGS;

typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE;

typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;

typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_s_ifspec;

#ifndef __IPersistSerializedPropStorage_INTERFACE_DEFINED__
#define __IPersistSerializedPropStorage_INTERFACE_DEFINED__

/* interface IPersistSerializedPropStorage */
/* [object][local][unique][uuid] */ 


EXTERN_C const IID IID_IPersistSerializedPropStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e318ad57-0aa0-450f-aca5-6fab7103d917")
    IPersistSerializedPropStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyStorage( 
            /* [in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [in] */ 
            __in  DWORD cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorage( 
            /* [out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [out] */ 
            __out  DWORD *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistSerializedPropStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistSerializedPropStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistSerializedPropStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [in] */ 
            __in  DWORD cb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [out] */ 
            __out  DWORD *pcb);
        
        END_INTERFACE
    } IPersistSerializedPropStorageVtbl;

    interface IPersistSerializedPropStorage
    {
        CONST_VTBL struct IPersistSerializedPropStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistSerializedPropStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistSerializedPropStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistSerializedPropStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistSerializedPropStorage_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define IPersistSerializedPropStorage_SetPropertyStorage(This,psps,cb)	\
    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 

#define IPersistSerializedPropStorage_GetPropertyStorage(This,ppsps,pcb)	\
    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistSerializedPropStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_INTERFACE_DEFINED__
#define __IPropertySystemChangeNotify_INTERFACE_DEFINED__

/* interface IPropertySystemChangeNotify */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystemChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa955fd9-38be-4879-a6ce-824cf52d609f")
    IPropertySystemChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SchemaRefreshed( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySystemChangeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySystemChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySystemChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *SchemaRefreshed )( 
            IPropertySystemChangeNotify * This);
        
        END_INTERFACE
    } IPropertySystemChangeNotifyVtbl;

    interface IPropertySystemChangeNotify
    {
        CONST_VTBL struct IPropertySystemChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystemChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystemChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystemChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystemChangeNotify_SchemaRefreshed(This)	\
    ( (This)->lpVtbl -> SchemaRefreshed(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystemChangeNotify_INTERFACE_DEFINED__ */


#ifndef __ICreateObject_INTERFACE_DEFINED__
#define __ICreateObject_INTERFACE_DEFINED__

/* interface ICreateObject */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ICreateObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75121952-e0d0-43e5-9380-1d80483acf72")
    ICreateObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            ICreateObject * This,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ICreateObjectVtbl;

    interface ICreateObject
    {
        CONST_VTBL struct ICreateObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateObject_CreateObject(This,clsid,pUnkOuter,riid,ppv)	\
    ( (This)->lpVtbl -> CreateObject(This,clsid,pUnkOuter,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0021 */
/* [local] */ 

// Format a property value for display purposes
PSSTDAPI PSFormatForDisplay(
    __in REFPROPERTYKEY propkey,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdfFlags,
    __out_ecount(cchText) LPWSTR pwszText,
    __in DWORD cchText);

PSSTDAPI PSFormatForDisplayAlloc(
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out PWSTR *ppszDisplay);

PSSTDAPI PSFormatPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out LPWSTR *ppszDisplay);


#define PKEY_PIDSTR_MAX     10   // will take care of any long integer value
#define GUIDSTRING_MAX      (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)  // "{12345678-1234-1234-1234-123456789012}"
#define PKEYSTR_MAX         (GUIDSTRING_MAX + 1 + PKEY_PIDSTR_MAX)

// Convert a PROPERTYKEY to and from a PWSTR
PSSTDAPI PSStringFromPropertyKey(
    __in REFPROPERTYKEY pkey,
    __out_ecount(cch) LPWSTR psz,
    __in UINT cch);

PSSTDAPI PSPropertyKeyFromString(
    __in LPCWSTR pszString,
    __out PROPERTYKEY *pkey);


// Creates an in-memory property store
// Returns an IPropertyStore, IPersistSerializedPropStorage, and related interfaces interface
PSSTDAPI PSCreateMemoryPropertyStore(
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only, delay-bind multiplexing property store
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateDelayedMultiplexPropertyStore(
    __in GETPROPERTYSTOREFLAGS flags,
    __in IDelayedPropertyStoreFactory *pdpsf,
    __in_ecount(cStores) const DWORD *rgStoreIds,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only property store from one or more sources (which each must support either IPropertyStore or IPropertySetStorage)
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateMultiplexPropertyStore(
    __in_ecount(cStores) IUnknown **prgpunkStores,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a container for IPropertyChanges
// Returns an IPropertyChangeArray interface
PSSTDAPI PSCreatePropertyChangeArray(
    __in_ecount_opt(cChanges) const PROPERTYKEY *rgpropkey,
    __in_ecount_opt(cChanges) const PKA_FLAGS *rgflags,
    __in_ecount_opt(cChanges) const PROPVARIANT *rgpropvar,
    __in UINT cChanges,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a simple property change
// Returns an IPropertyChange interface
PSSTDAPI PSCreateSimplePropertyChange(
    __in PKA_FLAGS flags,
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property description
// Returns an IPropertyDescription interface
PSSTDAPI PSGetPropertyDescription(
    __in REFPROPERTYKEY propkey,
    __in REFIID riid,
    __deref_out void **ppv);

PSSTDAPI PSGetPropertyDescriptionByName(
    __in LPCWSTR pszCanonicalName,
    __in REFIID riid,
    __deref_out void **ppv);


// Lookup a per-machine registered file property handler
PSSTDAPI PSLookupPropertyHandlerCLSID(
    __in PCWSTR pszFilePath,
    __out CLSID *pclsid);
// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandler(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// punkCreateObject supports ICreateObject
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandlerWithCreateObject(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in IUnknown *punkCreateObject,
    __in REFIID riid,
    __deref_out void **ppv);


// Get or set a property value from a store
PSSTDAPI PSGetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __out PROPVARIANT *ppropvar);

PSSTDAPI PSSetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in REFPROPVARIANT propvar);


// Interact with the set of property descriptions
PSSTDAPI PSRegisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSUnregisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSRefreshPropertySchema();

// Returns either: IPropertyDescriptionList or IEnumUnknown interfaces
PSSTDAPI PSEnumeratePropertyDescriptions(
    __in PROPDESC_ENUMFILTER filterOn,
    __in REFIID riid,
    __deref_out void **ppv);


// Convert between a PROPERTYKEY and its canonical name
PSSTDAPI PSGetPropertyKeyFromName(
    __in PCWSTR pszName,
    __out PROPERTYKEY *ppropkey);

PSSTDAPI PSGetNameFromPropertyKey(
    __in REFPROPERTYKEY propkey,
    __deref_out PWSTR *ppszCanonicalName);


// Coerce and canonicalize a property value
PSSTDAPI PSCoerceToCanonicalValue(
    __in REFPROPERTYKEY key,
    __inout PROPVARIANT *ppropvar);


// Convert a 'prop:' string into a list of property descriptions
// Returns an IPropertyDescriptionList interface
PSSTDAPI PSGetPropertyDescriptionListFromString(
    __in LPCWSTR pszPropList,
    __in REFIID riid,
    __deref_out void **ppv);


// Wrap an IPropertySetStorage interface in an IPropertyStore interface
// Returns an IPropertyStore or related interface
PSSTDAPI PSCreatePropertyStoreFromPropertySetStorage(
    __in IPropertySetStorage *ppss,
    DWORD grfMode,
    REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore or IPropertySetStorage
// On success, the returned ppv is guaranteed to support IPropertyStore.
// If punkSource already supports IPropertyStore, no wrapper is created.
PSSTDAPI PSCreatePropertyStoreFromObject(
    __in IUnknown *punk,
    __in DWORD grfMode,
    __in REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore
// riid may be IPropertyStore, IPropertySetStorage, IPropertyStoreCapabilities, or IObjectProvider
PSSTDAPI PSCreateAdapterFromPropertyStore(
    __in IPropertyStore *pps,
    __in REFIID riid,
    __deref_out void **ppv);


// Talk to the property system using an interface
// Returns an IPropertySystem interface
PSSTDAPI PSGetPropertySystem(
    __in REFIID riid,
    __deref_out void **ppv);


// Obtain a value from serialized property storage
PSSTDAPI PSGetPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in REFPROPERTYKEY rpkey, 
    __out PROPVARIANT *ppropvar);


// Obtain a named value from serialized property storage
PSSTDAPI PSGetNamedPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in LPCWSTR pszName, 
    __out PROPVARIANT *ppropvar);




extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_s_ifspec;


#ifndef __PropSysObjects_LIBRARY_DEFINED__
#define __PropSysObjects_LIBRARY_DEFINED__

/* library PropSysObjects */
/* [version][lcid][uuid] */ 


EXTERN_C const IID LIBID_PropSysObjects;

EXTERN_C const CLSID CLSID_InMemoryPropertyStore;

#ifdef __cplusplus

class DECLSPEC_UUID("9a02e012-6303-4e1e-b9a1-630f802592c5")
InMemoryPropertyStore;
#endif

EXTERN_C const CLSID CLSID_PropertySystem;

#ifdef __cplusplus

class DECLSPEC_UUID("b8967f85-58ae-4f46-9fb2-5d7904798f4b")
PropertySystem;
#endif
#endif /* __PropSysObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Proxy( 
    IInitializeWithStream * This,
    /* [in] */ IStream *pstream,
    /* [in] */ DWORD grfMode);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Stub( 
    IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);

/* [local] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Proxy( 
    IPropertyDescription * This,
    /* [out][in] */ PROPVARIANT *ppropvar);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Stub( 
    IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif



#pragma once

#if __GNUC__ >=3
#pragma GCC system_header
#endif

#define RPC_range(min,max)

#define __RPC__in           
#define __RPC__in_string
#define __RPC__in_opt_string
#define __RPC__deref_opt_in_opt
#define __RPC__opt_in_opt_string
#define __RPC__in_ecount(size) 
#define __RPC__in_ecount_full(size)
#define __RPC__in_ecount_full_string(size)
#define __RPC__in_ecount_part(size, length)
#define __RPC__in_ecount_full_opt(size)
#define __RPC__in_ecount_full_opt_string(size)
#define __RPC__inout_ecount_full_opt_string(size)
#define __RPC__in_ecount_part_opt(size, length)

#define __RPC__deref_in 
#define __RPC__deref_in_string
#define __RPC__deref_opt_in
#define __RPC__deref_in_opt
#define __RPC__deref_in_ecount(size) 
#define __RPC__deref_in_ecount_part(size, length) 
#define __RPC__deref_in_ecount_full(size) 
#define __RPC__deref_in_ecount_full_opt(size)
#define __RPC__deref_in_ecount_full_string(size)
#define __RPC__deref_in_ecount_full_opt_string(size)
#define __RPC__deref_in_ecount_opt(size) 
#define __RPC__deref_in_ecount_opt_string(size)
#define __RPC__deref_in_ecount_part_opt(size, length) 

// [out]
#define __RPC__out     
#define __RPC__out_ecount(size) 
#define __RPC__out_ecount_part(size, length) 
#define __RPC__out_ecount_full(size)
#define __RPC__out_ecount_full_string(size)

// [in,out] 
#define __RPC__inout                                   
#define __RPC__inout_string
#define __RPC__opt_inout
#define __RPC__inout_ecount(size)                     
#define __RPC__inout_ecount_part(size, length)    
#define __RPC__inout_ecount_full(size)          
#define __RPC__inout_ecount_full_string(size)          

// [in,unique] 
#define __RPC__in_opt       
#define __RPC__in_ecount_opt(size)   


// [in,out,unique] 
#define __RPC__inout_opt    
#define __RPC__inout_ecount_opt(size)  
#define __RPC__inout_ecount_part_opt(size, length) 
#define __RPC__inout_ecount_full_opt(size)     
#define __RPC__inout_ecount_full_string(size)

// [out] **
#define __RPC__deref_out   
#define __RPC__deref_out_string
#define __RPC__deref_out_opt 
#define __RPC__deref_out_opt_string
#define __RPC__deref_out_ecount(size) 
#define __RPC__deref_out_ecount_part(size, length) 
#define __RPC__deref_out_ecount_full(size)  
#define __RPC__deref_out_ecount_full_string(size)


// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout    
#define __RPC__deref_inout_string
#define __RPC__deref_inout_opt 
#define __RPC__deref_inout_opt_string
#define __RPC__deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size)
#define __RPC__deref_inout_ecount_opt(size) 
#define __RPC__deref_inout_ecount_part_opt(size, length) 
#define __RPC__deref_inout_ecount_full_opt(size) 
#define __RPC__deref_inout_ecount_full_opt_string(size) 

// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout  
#define __RPC__deref_opt_inout_string
#define __RPC__deref_opt_inout_ecount(size)     
#define __RPC__deref_opt_inout_ecount_part(size, length) 
#define __RPC__deref_opt_inout_ecount_full(size) 
#define __RPC__deref_opt_inout_ecount_full_string(size)

#define __RPC__deref_out_ecount_opt(size) 
#define __RPC__deref_out_ecount_part_opt(size, length) 
#define __RPC__deref_out_ecount_full_opt(size) 
#define __RPC__deref_out_ecount_full_opt_string(size)

#define __RPC__deref_opt_inout_opt      
#define __RPC__deref_opt_inout_opt_string
#define __RPC__deref_opt_inout_ecount_opt(size)   
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
#define __RPC__deref_opt_inout_ecount_full_opt(size) 
#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 

#define __RPC_full_pointer  
#define __RPC_unique_pointer
#define __RPC_ref_pointer
#define __RPC_string                               
#pragma once

#if __GNUC__ >=3
#pragma GCC system_header
#endif

/*#define __null*/ // << Conflicts with GCC internal type __null
#define __notnull
#define __maybenull
#define __readonly
#define __notreadonly
#define __maybereadonly
#define __valid
#define __notvalid
#define __maybevalid
#define __readableTo(extent)
#define __elem_readableTo(size)
#define __byte_readableTo(size)
#define __writableTo(size)
#define __elem_writableTo(size)
#define __byte_writableTo(size)
#define __deref
#define __pre
#define __post
#define __precond(expr)
#define __postcond(expr)
#define __exceptthat
#define __execeptthat
#define __inner_success(expr)
#define __inner_checkReturn
#define __inner_typefix(ctype)
#define __inner_override
#define __inner_callback
#define __inner_blocksOn(resource)
#define __inner_fallthrough_dec
#define __inner_fallthrough
#define __refparam
#define __inner_control_entrypoint(category)
#define __inner_data_entrypoint(category)

#define __ecount(size)
#define __bcount(size)
#define __in
#define __in_ecount(size)
#define __in_bcount(size)
#define __in_z
#define __in_ecount_z(size)
#define __in_bcount_z(size)
#define __in_nz
#define __in_ecount_nz(size)
#define __in_bcount_nz(size)
#define __out
#define __out_ecount(size)
#define __out_bcount(size)
#define __out_ecount_part(size,length)
#define __out_bcount_part(size,length)
#define __out_ecount_full(size)
#define __out_bcount_full(size)
#define __out_z
#define __out_z_opt
#define __out_ecount_z(size)
#define __out_bcount_z(size)
#define __out_ecount_part_z(size,length)
#define __out_bcount_part_z(size,length)
#define __out_ecount_full_z(size)
#define __out_bcount_full_z(size)
#define __out_nz
#define __out_nz_opt
#define __out_ecount_nz(size)
#define __out_bcount_nz(size)
#define __inout
#define __inout_ecount(size)
#define __inout_bcount(size)
#define __inout_ecount_part(size,length)
#define __inout_bcount_part(size,length)
#define __inout_ecount_full(size)
#define __inout_bcount_full(size)
#define __inout_z
#define __inout_ecount_z(size)
#define __inout_bcount_z(size)
#define __inout_nz
#define __inout_ecount_nz(size)
#define __inout_bcount_nz(size)
#define __ecount_opt(size)
#define __bcount_opt(size)
#define __in_opt
#define __in_ecount_opt(size)
#define __in_bcount_opt(size)
#define __in_z_opt
#define __in_ecount_z_opt(size)
#define __in_bcount_z_opt(size)
#define __in_nz_opt
#define __in_ecount_nz_opt(size)
#define __in_bcount_nz_opt(size)
#define __out_opt
#define __out_ecount_opt(size)
#define __out_bcount_opt(size)
#define __out_ecount_part_opt(size,length)
#define __out_bcount_part_opt(size,length)
#define __out_ecount_full_opt(size)
#define __out_bcount_full_opt(size)
#define __out_ecount_z_opt(size)
#define __out_bcount_z_opt(size)
#define __out_ecount_part_z_opt(size,length)
#define __out_bcount_part_z_opt(size,length)
#define __out_ecount_full_z_opt(size)
#define __out_bcount_full_z_opt(size)
#define __out_ecount_nz_opt(size)
#define __out_bcount_nz_opt(size)
#define __inout_opt
#define __inout_ecount_opt(size)
#define __inout_bcount_opt(size)
#define __inout_ecount_part_opt(size,length)
#define __inout_bcount_part_opt(size,length)
#define __inout_ecount_full_opt(size)
#define __inout_bcount_full_opt(size)
#define __inout_z_opt
#define __inout_ecount_z_opt(size)
#define __inout_ecount_z_opt(size)
#define __inout_bcount_z_opt(size)
#define __inout_nz_opt
#define __inout_ecount_nz_opt(size)
#define __inout_bcount_nz_opt(size)
#define __deref_ecount(size)
#define __deref_bcount(size)
#define __deref_out
#define __deref_out_ecount(size)
#define __deref_out_bcount(size)
#define __deref_out_ecount_part(size,length)
#define __deref_out_bcount_part(size,length)
#define __deref_out_ecount_full(size)
#define __deref_out_bcount_full(size)
#define __deref_out_z
#define __deref_out_ecount_z(size)
#define __deref_out_bcount_z(size)
#define __deref_out_nz
#define __deref_out_ecount_nz(size)
#define __deref_out_bcount_nz(size)
#define __deref_inout
#define __deref_inout_z
#define __deref_inout_ecount(size)
#define __deref_inout_bcount(size)
#define __deref_inout_ecount_part(size,length)
#define __deref_inout_bcount_part(size,length)
#define __deref_inout_ecount_full(size)
#define __deref_inout_bcount_full(size)
#define __deref_inout_z
#define __deref_inout_ecount_z(size)
#define __deref_inout_bcount_z(size)
#define __deref_inout_nz
#define __deref_inout_ecount_nz(size)
#define __deref_inout_bcount_nz(size)
#define __deref_ecount_opt(size)
#define __deref_bcount_opt(size)
#define __deref_out_opt
#define __deref_out_ecount_opt(size)
#define __deref_out_bcount_opt(size)
#define __deref_out_ecount_part_opt(size,length)
#define __deref_out_bcount_part_opt(size,length)
#define __deref_out_ecount_full_opt(size)
#define __deref_out_bcount_full_opt(size)
#define __deref_out_z_opt
#define __deref_out_ecount_z_opt(size)
#define __deref_out_bcount_z_opt(size)
#define __deref_out_nz_opt
#define __deref_out_ecount_nz_opt(size)
#define __deref_out_bcount_nz_opt(size)
#define __deref_inout_opt
#define __deref_inout_ecount_opt(size)
#define __deref_inout_bcount_opt(size)
#define __deref_inout_ecount_part_opt(size,length)
#define __deref_inout_bcount_part_opt(size,length)
#define __deref_inout_ecount_full_opt(size)
#define __deref_inout_bcount_full_opt(size)
#define __deref_inout_z_opt
#define __deref_inout_ecount_z_opt(size)
#define __deref_inout_bcount_z_opt(size)
#define __deref_inout_nz_opt
#define __deref_inout_ecount_nz_opt(size)
#define __deref_inout_bcount_nz_opt(size)
#define __deref_opt_ecount(size)
#define __deref_opt_bcount(size)
#define __deref_opt_out
#define __deref_opt_out_z
#define __deref_opt_out_ecount(size)
#define __deref_opt_out_bcount(size)
#define __deref_opt_out_ecount_part(size,length)
#define __deref_opt_out_bcount_part(size,length)
#define __deref_opt_out_ecount_full(size)
#define __deref_opt_out_bcount_full(size)
#define __deref_opt_inout
#define __deref_opt_inout_ecount(size)
#define __deref_opt_inout_bcount(size)
#define __deref_opt_inout_ecount_part(size,length)
#define __deref_opt_inout_bcount_part(size,length)
#define __deref_opt_inout_ecount_full(size)
#define __deref_opt_inout_bcount_full(size)
#define __deref_opt_inout_z
#define __deref_opt_inout_ecount_z(size)
#define __deref_opt_inout_bcount_z(size)
#define __deref_opt_inout_nz
#define __deref_opt_inout_ecount_nz(size)
#define __deref_opt_inout_bcount_nz(size)
#define __deref_opt_ecount_opt(size)
#define __deref_opt_bcount_opt(size)
#define __deref_opt_out_opt
#define __deref_opt_out_ecount_opt(size)
#define __deref_opt_out_bcount_opt(size)
#define __deref_opt_out_ecount_part_opt(size,length)
#define __deref_opt_out_bcount_part_opt(size,length)
#define __deref_opt_out_ecount_full_opt(size)
#define __deref_opt_out_bcount_full_opt(size)
#define __deref_opt_out_z_opt
#define __deref_opt_out_ecount_z_opt(size)
#define __deref_opt_out_bcount_z_opt(size)
#define __deref_opt_out_nz_opt
#define __deref_opt_out_ecount_nz_opt(size)
#define __deref_opt_out_bcount_nz_opt(size)
#define __deref_opt_inout_opt
#define __deref_opt_inout_ecount_opt(size)
#define __deref_opt_inout_bcount_opt(size)
#define __deref_opt_inout_ecount_part_opt(size,length)
#define __deref_opt_inout_bcount_part_opt(size,length)
#define __deref_opt_inout_ecount_full_opt(size)
#define __deref_opt_inout_bcount_full_opt(size)
#define __deref_opt_inout_z_opt
#define __deref_opt_inout_ecount_z_opt(size)
#define __deref_opt_inout_bcount_z_opt(size)
#define __deref_opt_inout_nz_opt
#define __deref_opt_inout_ecount_nz_opt(size)
#define __deref_opt_inout_bcount_nz_opt(size)

#define __success(expr)
#define __nullterminated
#define __nullnullterminated
#define __reserved
#define __checkReturn
#define __typefix(ctype)
#define __override
#define __callback
#define __format_string
#define __blocksOn(resource)
#define __control_entrypoint(category)
#define __data_entrypoint(category)

#ifndef __fallthrough
    #define __fallthrough __inner_fallthrough
#endif

#ifndef __analysis_assume
    #define __analysis_assume(expr)
#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for structuredquery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

// (amalg) #include "rpc.h"
// (amalg) #include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// (amalg) #include "windows.h"
// (amalg) #include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __structuredquery_h__
#define __structuredquery_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IQueryParser_FWD_DEFINED__
#define __IQueryParser_FWD_DEFINED__
typedef interface IQueryParser IQueryParser;
#endif 	/* __IQueryParser_FWD_DEFINED__ */


#ifndef __IConditionFactory_FWD_DEFINED__
#define __IConditionFactory_FWD_DEFINED__
typedef interface IConditionFactory IConditionFactory;
#endif 	/* __IConditionFactory_FWD_DEFINED__ */


#ifndef __IQuerySolution_FWD_DEFINED__
#define __IQuerySolution_FWD_DEFINED__
typedef interface IQuerySolution IQuerySolution;
#endif 	/* __IQuerySolution_FWD_DEFINED__ */


#ifndef __ICondition_FWD_DEFINED__
#define __ICondition_FWD_DEFINED__
typedef interface ICondition ICondition;
#endif 	/* __ICondition_FWD_DEFINED__ */


#ifndef __IConditionGenerator_FWD_DEFINED__
#define __IConditionGenerator_FWD_DEFINED__
typedef interface IConditionGenerator IConditionGenerator;
#endif 	/* __IConditionGenerator_FWD_DEFINED__ */


#ifndef __IRichChunk_FWD_DEFINED__
#define __IRichChunk_FWD_DEFINED__
typedef interface IRichChunk IRichChunk;
#endif 	/* __IRichChunk_FWD_DEFINED__ */


#ifndef __IInterval_FWD_DEFINED__
#define __IInterval_FWD_DEFINED__
typedef interface IInterval IInterval;
#endif 	/* __IInterval_FWD_DEFINED__ */


#ifndef __IMetaData_FWD_DEFINED__
#define __IMetaData_FWD_DEFINED__
typedef interface IMetaData IMetaData;
#endif 	/* __IMetaData_FWD_DEFINED__ */


#ifndef __IEntity_FWD_DEFINED__
#define __IEntity_FWD_DEFINED__
typedef interface IEntity IEntity;
#endif 	/* __IEntity_FWD_DEFINED__ */


#ifndef __IRelationship_FWD_DEFINED__
#define __IRelationship_FWD_DEFINED__
typedef interface IRelationship IRelationship;
#endif 	/* __IRelationship_FWD_DEFINED__ */


#ifndef __INamedEntity_FWD_DEFINED__
#define __INamedEntity_FWD_DEFINED__
typedef interface INamedEntity INamedEntity;
#endif 	/* __INamedEntity_FWD_DEFINED__ */


#ifndef __ISchemaProvider_FWD_DEFINED__
#define __ISchemaProvider_FWD_DEFINED__
typedef interface ISchemaProvider ISchemaProvider;
#endif 	/* __ISchemaProvider_FWD_DEFINED__ */


#ifndef __ITokenCollection_FWD_DEFINED__
#define __ITokenCollection_FWD_DEFINED__
typedef interface ITokenCollection ITokenCollection;
#endif 	/* __ITokenCollection_FWD_DEFINED__ */


#ifndef __INamedEntityCollector_FWD_DEFINED__
#define __INamedEntityCollector_FWD_DEFINED__
typedef interface INamedEntityCollector INamedEntityCollector;
#endif 	/* __INamedEntityCollector_FWD_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_FWD_DEFINED__
#define __ISchemaLocalizerSupport_FWD_DEFINED__
typedef interface ISchemaLocalizerSupport ISchemaLocalizerSupport;
#endif 	/* __ISchemaLocalizerSupport_FWD_DEFINED__ */


#ifndef __IQueryParserManager_FWD_DEFINED__
#define __IQueryParserManager_FWD_DEFINED__
typedef interface IQueryParserManager IQueryParserManager;
#endif 	/* __IQueryParserManager_FWD_DEFINED__ */


#ifndef __QueryParser_FWD_DEFINED__
#define __QueryParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParser QueryParser;
#else
typedef struct QueryParser QueryParser;
#endif /* __cplusplus */

#endif 	/* __QueryParser_FWD_DEFINED__ */


#ifndef __NegationCondition_FWD_DEFINED__
#define __NegationCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class NegationCondition NegationCondition;
#else
typedef struct NegationCondition NegationCondition;
#endif /* __cplusplus */

#endif 	/* __NegationCondition_FWD_DEFINED__ */


#ifndef __CompoundCondition_FWD_DEFINED__
#define __CompoundCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompoundCondition CompoundCondition;
#else
typedef struct CompoundCondition CompoundCondition;
#endif /* __cplusplus */

#endif 	/* __CompoundCondition_FWD_DEFINED__ */


#ifndef __LeafCondition_FWD_DEFINED__
#define __LeafCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class LeafCondition LeafCondition;
#else
typedef struct LeafCondition LeafCondition;
#endif /* __cplusplus */

#endif 	/* __LeafCondition_FWD_DEFINED__ */


#ifndef __ConditionFactory_FWD_DEFINED__
#define __ConditionFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConditionFactory ConditionFactory;
#else
typedef struct ConditionFactory ConditionFactory;
#endif /* __cplusplus */

#endif 	/* __ConditionFactory_FWD_DEFINED__ */


#ifndef __Interval_FWD_DEFINED__
#define __Interval_FWD_DEFINED__

#ifdef __cplusplus
typedef class Interval Interval;
#else
typedef struct Interval Interval;
#endif /* __cplusplus */

#endif 	/* __Interval_FWD_DEFINED__ */


#ifndef __QueryParserManager_FWD_DEFINED__
#define __QueryParserManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParserManager QueryParserManager;
#else
typedef struct QueryParserManager QueryParserManager;
#endif /* __cplusplus */

#endif 	/* __QueryParserManager_FWD_DEFINED__ */


/* header files for imported files */
// (amalg) #include "oaidl.h"
// (amalg) #include "ocidl.h"
// (amalg) #include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_structuredquery_0000_0000 */
/* [local] */ 











typedef /* [v1_enum] */ 
enum tagCONDITION_TYPE
    {	CT_AND_CONDITION	= 0,
	CT_OR_CONDITION	= ( CT_AND_CONDITION + 1 ) ,
	CT_NOT_CONDITION	= ( CT_OR_CONDITION + 1 ) ,
	CT_LEAF_CONDITION	= ( CT_NOT_CONDITION + 1 ) 
    } 	CONDITION_TYPE;

typedef /* [v1_enum] */ 
enum tagCONDITION_OPERATION
    {	COP_IMPLICIT	= 0,
	COP_EQUAL	= ( COP_IMPLICIT + 1 ) ,
	COP_NOTEQUAL	= ( COP_EQUAL + 1 ) ,
	COP_LESSTHAN	= ( COP_NOTEQUAL + 1 ) ,
	COP_GREATERTHAN	= ( COP_LESSTHAN + 1 ) ,
	COP_LESSTHANOREQUAL	= ( COP_GREATERTHAN + 1 ) ,
	COP_GREATERTHANOREQUAL	= ( COP_LESSTHANOREQUAL + 1 ) ,
	COP_VALUE_STARTSWITH	= ( COP_GREATERTHANOREQUAL + 1 ) ,
	COP_VALUE_ENDSWITH	= ( COP_VALUE_STARTSWITH + 1 ) ,
	COP_VALUE_CONTAINS	= ( COP_VALUE_ENDSWITH + 1 ) ,
	COP_VALUE_NOTCONTAINS	= ( COP_VALUE_CONTAINS + 1 ) ,
	COP_DOSWILDCARDS	= ( COP_VALUE_NOTCONTAINS + 1 ) ,
	COP_WORD_EQUAL	= ( COP_DOSWILDCARDS + 1 ) ,
	COP_WORD_STARTSWITH	= ( COP_WORD_EQUAL + 1 ) ,
	COP_APPLICATION_SPECIFIC	= ( COP_WORD_STARTSWITH + 1 ) 
    } 	CONDITION_OPERATION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_SINGLE_OPTION
    {	SQSO_SCHEMA	= 0,
	SQSO_LOCALE_WORD_BREAKING	= ( SQSO_SCHEMA + 1 ) ,
	SQSO_WORD_BREAKER	= ( SQSO_LOCALE_WORD_BREAKING + 1 ) ,
	SQSO_NATURAL_SYNTAX	= ( SQSO_WORD_BREAKER + 1 ) ,
	SQSO_AUTOMATIC_WILDCARD	= ( SQSO_NATURAL_SYNTAX + 1 ) ,
	SQSO_TRACE_LEVEL	= ( SQSO_AUTOMATIC_WILDCARD + 1 ) ,
	SQSO_LANGUAGE_KEYWORDS	= ( SQSO_TRACE_LEVEL + 1 ) 
    } 	STRUCTURED_QUERY_SINGLE_OPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_MULTIOPTION
    {	SQMO_VIRTUAL_PROPERTY	= 0,
	SQMO_DEFAULT_PROPERTY	= ( SQMO_VIRTUAL_PROPERTY + 1 ) ,
	SQMO_GENERATOR_FOR_TYPE	= ( SQMO_DEFAULT_PROPERTY + 1 ) 
    } 	STRUCTURED_QUERY_MULTIOPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_PARSE_ERROR
    {	SQPE_NONE	= 0,
	SQPE_EXTRA_OPENING_PARENTHESIS	= ( SQPE_NONE + 1 ) ,
	SQPE_EXTRA_CLOSING_PARENTHESIS	= ( SQPE_EXTRA_OPENING_PARENTHESIS + 1 ) ,
	SQPE_IGNORED_MODIFIER	= ( SQPE_EXTRA_CLOSING_PARENTHESIS + 1 ) ,
	SQPE_IGNORED_CONNECTOR	= ( SQPE_IGNORED_MODIFIER + 1 ) ,
	SQPE_IGNORED_KEYWORD	= ( SQPE_IGNORED_CONNECTOR + 1 ) ,
	SQPE_UNHANDLED	= ( SQPE_IGNORED_KEYWORD + 1 ) 
    } 	STRUCTURED_QUERY_PARSE_ERROR;

/* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_RESOLVE_OPTION
    {	SQRO_DONT_RESOLVE_DATETIME	= 0x1,
	SQRO_ALWAYS_ONE_INTERVAL	= 0x2,
	SQRO_DONT_SIMPLIFY_CONDITION_TREES	= 0x4,
	SQRO_DONT_MAP_RELATIONS	= 0x8,
	SQRO_DONT_RESOLVE_RANGES	= 0x10,
	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS	= 0x20,
	SQRO_DONT_SPLIT_WORDS	= 0x40,
	SQRO_IGNORE_PHRASE_ORDER	= 0x80
    } ;
typedef int STRUCTURED_QUERY_RESOLVE_OPTION;

typedef /* [v1_enum] */ 
enum tagINTERVAL_LIMIT_KIND
    {	ILK_EXPLICIT_INCLUDED	= 0,
	ILK_EXPLICIT_EXCLUDED	= ( ILK_EXPLICIT_INCLUDED + 1 ) ,
	ILK_NEGATIVE_INFINITY	= ( ILK_EXPLICIT_EXCLUDED + 1 ) ,
	ILK_POSITIVE_INFINITY	= ( ILK_NEGATIVE_INFINITY + 1 ) 
    } 	INTERVAL_LIMIT_KIND;

typedef /* [v1_enum] */ 
enum tagQUERY_PARSER_MANAGER_OPTION
    {	QPMO_SCHEMA_BINARY_NAME	= 0,
	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_SCHEMA_BINARY_NAME + 1 ) ,
	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_LOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_APPEND_LCID_TO_LOCALIZED_PATH	= ( QPMO_LOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_LOCALIZER_SUPPORT	= ( QPMO_APPEND_LCID_TO_LOCALIZED_PATH + 1 ) 
    } 	QUERY_PARSER_MANAGER_OPTION;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_s_ifspec;

#ifndef __IQueryParser_INTERFACE_DEFINED__
#define __IQueryParser_INTERFACE_DEFINED__

/* interface IQueryParser */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQueryParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")
    IQueryParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMultiOption( 
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchemaProvider( 
            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestateToString( 
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyValue( 
            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestatePropertyValueToString( 
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryParser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Parse )( 
            IQueryParser * This,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetMultiOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchemaProvider )( 
            IQueryParser * This,
            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE *RestateToString )( 
            IQueryParser * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePropertyValue )( 
            IQueryParser * This,
            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE *RestatePropertyValueToString )( 
            IQueryParser * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
        
        END_INTERFACE
    } IQueryParserVtbl;

    interface IQueryParser
    {
        CONST_VTBL struct IQueryParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryParser_Parse(This,pszInputString,pCustomProperties,ppSolution)	\
    ( (This)->lpVtbl -> Parse(This,pszInputString,pCustomProperties,ppSolution) ) 

#define IQueryParser_SetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 

#define IQueryParser_GetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> GetOption(This,option,pOptionValue) ) 

#define IQueryParser_SetMultiOption(This,option,pszOptionKey,pOptionValue)	\
    ( (This)->lpVtbl -> SetMultiOption(This,option,pszOptionKey,pOptionValue) ) 

#define IQueryParser_GetSchemaProvider(This,ppSchemaProvider)	\
    ( (This)->lpVtbl -> GetSchemaProvider(This,ppSchemaProvider) ) 

#define IQueryParser_RestateToString(This,pCondition,fUseEnglish,ppszQueryString)	\
    ( (This)->lpVtbl -> RestateToString(This,pCondition,fUseEnglish,ppszQueryString) ) 

#define IQueryParser_ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)	\
    ( (This)->lpVtbl -> ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution) ) 

#define IQueryParser_RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)	\
    ( (This)->lpVtbl -> RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryParser_INTERFACE_DEFINED__ */


#ifndef __IConditionFactory_INTERFACE_DEFINED__
#define __IConditionFactory_INTERFACE_DEFINED__

/* interface IConditionFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")
    IConditionFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MakeNot( 
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeAndOr( 
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeLeaf( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConditionFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConditionFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConditionFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
            IConditionFactory * This,
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
            IConditionFactory * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
            IConditionFactory * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IConditionFactory * This,
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree);
        
        END_INTERFACE
    } IConditionFactoryVtbl;

    interface IConditionFactory
    {
        CONST_VTBL struct IConditionFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConditionFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConditionFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConditionFactory_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 

#define IConditionFactory_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 

#define IConditionFactory_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 

#define IConditionFactory_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConditionFactory_INTERFACE_DEFINED__ */


#ifndef __IQuerySolution_INTERFACE_DEFINED__
#define __IQuerySolution_INTERFACE_DEFINED__

/* interface IQuerySolution */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQuerySolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")
    IQuerySolution : public IConditionFactory
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ 
            __out_opt  ICondition **ppQueryNode,
            /* [out] */ 
            __out_opt  IEntity **ppMainType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrors( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLexicalData( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszInputString,
            /* [out] */ 
            __out_opt  ITokenCollection **ppTokens,
            /* [out] */ 
            __out_opt  LCID *pLocale,
            /* [out] */ 
            __out_opt  IUnknown **ppWordBreaker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuerySolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQuerySolution * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQuerySolution * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
            IQuerySolution * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
            IQuerySolution * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IQuerySolution * This,
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IQuerySolution * This,
            /* [out] */ 
            __out_opt  ICondition **ppQueryNode,
            /* [out] */ 
            __out_opt  IEntity **ppMainType);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrors )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetLexicalData )( 
            IQuerySolution * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszInputString,
            /* [out] */ 
            __out_opt  ITokenCollection **ppTokens,
            /* [out] */ 
            __out_opt  LCID *pLocale,
            /* [out] */ 
            __out_opt  IUnknown **ppWordBreaker);
        
        END_INTERFACE
    } IQuerySolutionVtbl;

    interface IQuerySolution
    {
        CONST_VTBL struct IQuerySolutionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuerySolution_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQuerySolution_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQuerySolution_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQuerySolution_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 

#define IQuerySolution_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 

#define IQuerySolution_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 

#define IQuerySolution_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 


#define IQuerySolution_GetQuery(This,ppQueryNode,ppMainType)	\
    ( (This)->lpVtbl -> GetQuery(This,ppQueryNode,ppMainType) ) 

#define IQuerySolution_GetErrors(This,riid,ppParseErrors)	\
    ( (This)->lpVtbl -> GetErrors(This,riid,ppParseErrors) ) 

#define IQuerySolution_GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)	\
    ( (This)->lpVtbl -> GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQuerySolution_INTERFACE_DEFINED__ */


#ifndef __ICondition_INTERFACE_DEFINED__
#define __ICondition_INTERFACE_DEFINED__

/* interface ICondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FC988D4-C935-4b97-A973-46282EA175C8")
    ICondition : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubConditions( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetComparisonInfo( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszPropertyName,
            /* [out] */ 
            __out_opt  CONDITION_OPERATION *pOperation,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueType( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueNormalization( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputTerms( 
            /* [out] */ 
            __out_opt  IRichChunk **ppPropertyTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppOperationTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppValueTerm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICondition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            ICondition * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            ICondition * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            ICondition * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            ICondition * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
            ICondition * This,
            /* [out] */ __RPC__out ULARGE_INTEGER *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            ICondition * This,
            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubConditions )( 
            ICondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetComparisonInfo )( 
            ICondition * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszPropertyName,
            /* [out] */ 
            __out_opt  CONDITION_OPERATION *pOperation,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueType )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueNormalization )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetInputTerms )( 
            ICondition * This,
            /* [out] */ 
            __out_opt  IRichChunk **ppPropertyTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppOperationTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppValueTerm);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc);
        
        END_INTERFACE
    } IConditionVtbl;

    interface ICondition
    {
        CONST_VTBL struct IConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICondition_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define ICondition_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define ICondition_Load(This,pStm)	\
    ( (This)->lpVtbl -> Load(This,pStm) ) 

#define ICondition_Save(This,pStm,fClearDirty)	\
    ( (This)->lpVtbl -> Save(This,pStm,fClearDirty) ) 

#define ICondition_GetSizeMax(This,pcbSize)	\
    ( (This)->lpVtbl -> GetSizeMax(This,pcbSize) ) 


#define ICondition_GetConditionType(This,pNodeType)	\
    ( (This)->lpVtbl -> GetConditionType(This,pNodeType) ) 

#define ICondition_GetSubConditions(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSubConditions(This,riid,ppv) ) 

#define ICondition_GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)	\
    ( (This)->lpVtbl -> GetComparisonInfo(This,ppszPropertyName,pOperation,pValue) ) 

#define ICondition_GetValueType(This,ppszValueTypeName)	\
    ( (This)->lpVtbl -> GetValueType(This,ppszValueTypeName) ) 

#define ICondition_GetValueNormalization(This,ppszNormalization)	\
    ( (This)->lpVtbl -> GetValueNormalization(This,ppszNormalization) ) 

#define ICondition_GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)	\
    ( (This)->lpVtbl -> GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm) ) 

#define ICondition_Clone(This,ppc)	\
    ( (This)->lpVtbl -> Clone(This,ppc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICondition_INTERFACE_DEFINED__ */


#ifndef __IConditionGenerator_INTERFACE_DEFINED__
#define __IConditionGenerator_INTERFACE_DEFINED__

/* interface IConditionGenerator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92D2CC58-4386-45a3-B98C-7E0CE64A4117")
    IConditionGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecognizeNamedEntities( 
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateForLeaf( 
            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ __RPC__out BOOL *pNoStringQuery,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConditionGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConditionGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE *RecognizeNamedEntities )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateForLeaf )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ __RPC__out BOOL *pNoStringQuery,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IConditionGenerator * This,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IConditionGeneratorVtbl;

    interface IConditionGenerator
    {
        CONST_VTBL struct IConditionGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConditionGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConditionGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConditionGenerator_Initialize(This,pSchemaProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pSchemaProvider) ) 

#define IConditionGenerator_RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)	\
    ( (This)->lpVtbl -> RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities) ) 

#define IConditionGenerator_GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)	\
    ( (This)->lpVtbl -> GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression) ) 

#define IConditionGenerator_DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConditionGenerator_INTERFACE_DEFINED__ */


#ifndef __IRichChunk_INTERFACE_DEFINED__
#define __IRichChunk_INTERFACE_DEFINED__

/* interface IRichChunk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRichChunk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FDEF69C-DBC9-454e-9910-B34F3C64B510")
    IRichChunk : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ 
            __out_opt  ULONG *pFirstPos,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRichChunkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRichChunk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRichChunk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRichChunk * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IRichChunk * This,
            /* [out] */ 
            __out_opt  ULONG *pFirstPos,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue);
        
        END_INTERFACE
    } IRichChunkVtbl;

    interface IRichChunk
    {
        CONST_VTBL struct IRichChunkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRichChunk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRichChunk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRichChunk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRichChunk_GetData(This,pFirstPos,pLength,ppsz,pValue)	\
    ( (This)->lpVtbl -> GetData(This,pFirstPos,pLength,ppsz,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRichChunk_INTERFACE_DEFINED__ */


#ifndef __IInterval_INTERFACE_DEFINED__
#define __IInterval_INTERFACE_DEFINED__

/* interface IInterval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInterval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")
    IInterval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLimits( 
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIntervalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterval * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterval * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLimits )( 
            IInterval * This,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper);
        
        END_INTERFACE
    } IIntervalVtbl;

    interface IInterval
    {
        CONST_VTBL struct IIntervalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterval_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInterval_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInterval_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInterval_GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)	\
    ( (This)->lpVtbl -> GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInterval_INTERFACE_DEFINED__ */


#ifndef __IMetaData_INTERFACE_DEFINED__
#define __IMetaData_INTERFACE_DEFINED__

/* interface IMetaData */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IMetaData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("780102B0-C43B-4876-BC7B-5E9BA5C88794")
    IMetaData : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszKey,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetaData * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetaData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetaData * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IMetaData * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszKey,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszValue);
        
        END_INTERFACE
    } IMetaDataVtbl;

    interface IMetaData
    {
        CONST_VTBL struct IMetaDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMetaData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMetaData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMetaData_GetData(This,ppszKey,ppszValue)	\
    ( (This)->lpVtbl -> GetData(This,ppszKey,ppszValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMetaData_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0000_0008 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_s_ifspec;

#ifndef __IEntity_INTERFACE_DEFINED__
#define __IEntity_INTERFACE_DEFINED__

/* interface IEntity */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")
    IEntity : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Base( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Relationships( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelationship( 
            /* [in] */ __RPC__in LPCWSTR pszRelationName,
            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NamedEntities( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedEntity( 
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEntity * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
            IEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *Base )( 
            IEntity * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity);
        
        HRESULT ( STDMETHODCALLTYPE *Relationships )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelationship )( 
            IEntity * This,
            /* [in] */ __RPC__in LPCWSTR pszRelationName,
            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE *NamedEntities )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedEntity )( 
            IEntity * This,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IEntityVtbl;

    interface IEntity
    {
        CONST_VTBL struct IEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEntity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEntity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEntity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEntity_Name(This,ppszName)	\
    ( (This)->lpVtbl -> Name(This,ppszName) ) 

#define IEntity_Base(This,pBaseEntity)	\
    ( (This)->lpVtbl -> Base(This,pBaseEntity) ) 

#define IEntity_Relationships(This,riid,pRelationships)	\
    ( (This)->lpVtbl -> Relationships(This,riid,pRelationships) ) 

#define IEntity_GetRelationship(This,pszRelationName,pRelationship)	\
    ( (This)->lpVtbl -> GetRelationship(This,pszRelationName,pRelationship) ) 

#define IEntity_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define IEntity_NamedEntities(This,riid,pNamedEntities)	\
    ( (This)->lpVtbl -> NamedEntities(This,riid,pNamedEntities) ) 

#define IEntity_GetNamedEntity(This,pszValue,ppNamedEntity)	\
    ( (This)->lpVtbl -> GetNamedEntity(This,pszValue,ppNamedEntity) ) 

#define IEntity_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEntity_INTERFACE_DEFINED__ */


#ifndef __IRelationship_INTERFACE_DEFINED__
#define __IRelationship_INTERFACE_DEFINED__

/* interface IRelationship */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IRelationship;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2769280B-5108-498c-9C7F-A51239B63147")
    IRelationship : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsReal( 
            /* [retval][out] */ __RPC__out BOOL *pIsReal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destination( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRelationshipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRelationship * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRelationship * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRelationship * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
            IRelationship * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *IsReal )( 
            IRelationship * This,
            /* [retval][out] */ __RPC__out BOOL *pIsReal);
        
        HRESULT ( STDMETHODCALLTYPE *Destination )( 
            IRelationship * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            IRelationship * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IRelationship * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IRelationshipVtbl;

    interface IRelationship
    {
        CONST_VTBL struct IRelationshipVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRelationship_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRelationship_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRelationship_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRelationship_Name(This,ppszName)	\
    ( (This)->lpVtbl -> Name(This,ppszName) ) 

#define IRelationship_IsReal(This,pIsReal)	\
    ( (This)->lpVtbl -> IsReal(This,pIsReal) ) 

#define IRelationship_Destination(This,pDestinationEntity)	\
    ( (This)->lpVtbl -> Destination(This,pDestinationEntity) ) 

#define IRelationship_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define IRelationship_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRelationship_INTERFACE_DEFINED__ */


#ifndef __INamedEntity_INTERFACE_DEFINED__
#define __INamedEntity_INTERFACE_DEFINED__

/* interface INamedEntity */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_INamedEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")
    INamedEntity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedEntity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            INamedEntity * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            INamedEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } INamedEntityVtbl;

    interface INamedEntity
    {
        CONST_VTBL struct INamedEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedEntity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedEntity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedEntity_GetValue(This,ppszValue)	\
    ( (This)->lpVtbl -> GetValue(This,ppszValue) ) 

#define INamedEntity_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedEntity_INTERFACE_DEFINED__ */


#ifndef __ISchemaProvider_INTERFACE_DEFINED__
#define __ISchemaProvider_INTERFACE_DEFINED__

/* interface ISchemaProvider */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ISchemaProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")
    ISchemaProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Entities( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootEntity( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntity( 
            /* [in] */ __RPC__in LPCWSTR pszEntityName,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveBinary( 
            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupAuthoredNamedEntity( 
            /* [in] */ __RPC__in_opt IEntity *pEntity,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ __RPC__out ULONG *pcTokensLength,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Entities )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities);
        
        HRESULT ( STDMETHODCALLTYPE *RootEntity )( 
            ISchemaProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntity )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in LPCWSTR pszEntityName,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE *Localize )( 
            ISchemaProvider * This,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport);
        
        HRESULT ( STDMETHODCALLTYPE *SaveBinary )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath);
        
        HRESULT ( STDMETHODCALLTYPE *LookupAuthoredNamedEntity )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in_opt IEntity *pEntity,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ __RPC__out ULONG *pcTokensLength,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
        
        END_INTERFACE
    } ISchemaProviderVtbl;

    interface ISchemaProvider
    {
        CONST_VTBL struct ISchemaProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaProvider_Entities(This,riid,pEntities)	\
    ( (This)->lpVtbl -> Entities(This,riid,pEntities) ) 

#define ISchemaProvider_RootEntity(This,pRootEntity)	\
    ( (This)->lpVtbl -> RootEntity(This,pRootEntity) ) 

#define ISchemaProvider_GetEntity(This,pszEntityName,pEntity)	\
    ( (This)->lpVtbl -> GetEntity(This,pszEntityName,pEntity) ) 

#define ISchemaProvider_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define ISchemaProvider_Localize(This,lcid,pSchemaLocalizerSupport)	\
    ( (This)->lpVtbl -> Localize(This,lcid,pSchemaLocalizerSupport) ) 

#define ISchemaProvider_SaveBinary(This,pszSchemaBinaryPath)	\
    ( (This)->lpVtbl -> SaveBinary(This,pszSchemaBinaryPath) ) 

#define ISchemaProvider_LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)	\
    ( (This)->lpVtbl -> LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaProvider_INTERFACE_DEFINED__ */


#ifndef __ITokenCollection_INTERFACE_DEFINED__
#define __ITokenCollection_INTERFACE_DEFINED__

/* interface ITokenCollection */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ITokenCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D8B4F2-F577-4adb-A335-C2AE88416FAB")
    ITokenCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NumberOfTokens( 
            __RPC__in ULONG *pCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToken( 
            /* [in] */ ULONG i,
            /* [out] */ 
            __out_opt  ULONG *pBegin,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITokenCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITokenCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITokenCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITokenCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *NumberOfTokens )( 
            ITokenCollection * This,
            __RPC__in ULONG *pCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ITokenCollection * This,
            /* [in] */ ULONG i,
            /* [out] */ 
            __out_opt  ULONG *pBegin,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz);
        
        END_INTERFACE
    } ITokenCollectionVtbl;

    interface ITokenCollection
    {
        CONST_VTBL struct ITokenCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITokenCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITokenCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITokenCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITokenCollection_NumberOfTokens(This,pCount)	\
    ( (This)->lpVtbl -> NumberOfTokens(This,pCount) ) 

#define ITokenCollection_GetToken(This,i,pBegin,pLength,ppsz)	\
    ( (This)->lpVtbl -> GetToken(This,i,pBegin,pLength,ppsz) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITokenCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0000_0013 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_structuredquery_0000_0013_0001
    {	NEC_LOW	= 0,
	NEC_MEDIUM	= ( NEC_LOW + 1 ) ,
	NEC_HIGH	= ( NEC_MEDIUM + 1 ) 
    } 	NAMED_ENTITY_CERTAINTY;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_s_ifspec;

#ifndef __INamedEntityCollector_INTERFACE_DEFINED__
#define __INamedEntityCollector_INTERFACE_DEFINED__

/* interface INamedEntityCollector */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_INamedEntityCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")
    INamedEntityCollector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ __RPC__in_opt IEntity *pType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedEntityCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedEntityCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedEntityCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            INamedEntityCollector * This,
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ __RPC__in_opt IEntity *pType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty);
        
        END_INTERFACE
    } INamedEntityCollectorVtbl;

    interface INamedEntityCollector
    {
        CONST_VTBL struct INamedEntityCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntityCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedEntityCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedEntityCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedEntityCollector_Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)	\
    ( (This)->lpVtbl -> Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedEntityCollector_INTERFACE_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_INTERFACE_DEFINED__
#define __ISchemaLocalizerSupport_INTERFACE_DEFINED__

/* interface ISchemaLocalizerSupport */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ISchemaLocalizerSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")
    ISchemaLocalizerSupport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLocalizerSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaLocalizerSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaLocalizerSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaLocalizerSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Localize )( 
            ISchemaLocalizerSupport * This,
            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString);
        
        END_INTERFACE
    } ISchemaLocalizerSupportVtbl;

    interface ISchemaLocalizerSupport
    {
        CONST_VTBL struct ISchemaLocalizerSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLocalizerSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaLocalizerSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaLocalizerSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaLocalizerSupport_Localize(This,pszGlobalString,ppszLocalString)	\
    ( (This)->lpVtbl -> Localize(This,pszGlobalString,ppszLocalString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaLocalizerSupport_INTERFACE_DEFINED__ */


#ifndef __IQueryParserManager_INTERFACE_DEFINED__
#define __IQueryParserManager_INTERFACE_DEFINED__

/* interface IQueryParserManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryParserManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A879E3C4-AF77-44fb-8F37-EBD1487CF920")
    IQueryParserManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateLoadedParser( 
            /* [in] */ __RPC__in LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeOptions( 
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryParserManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryParserManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryParserManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLoadedParser )( 
            IQueryParserManager * This,
            /* [in] */ __RPC__in LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeOptions )( 
            IQueryParserManager * This,
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IQueryParserManager * This,
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        END_INTERFACE
    } IQueryParserManagerVtbl;

    interface IQueryParserManager
    {
        CONST_VTBL struct IQueryParserManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParserManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryParserManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryParserManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryParserManager_CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)	\
    ( (This)->lpVtbl -> CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser) ) 

#define IQueryParserManager_InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)	\
    ( (This)->lpVtbl -> InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser) ) 

#define IQueryParserManager_SetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryParserManager_INTERFACE_DEFINED__ */



#ifndef __StructuredQuery1_LIBRARY_DEFINED__
#define __StructuredQuery1_LIBRARY_DEFINED__

/* library StructuredQuery1 */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_StructuredQuery1;

EXTERN_C const CLSID CLSID_QueryParser;

#ifdef __cplusplus

class DECLSPEC_UUID("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")
QueryParser;
#endif

EXTERN_C const CLSID CLSID_NegationCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")
NegationCondition;
#endif

EXTERN_C const CLSID CLSID_CompoundCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("116F8D13-101E-4fa5-84D4-FF8279381935")
CompoundCondition;
#endif

EXTERN_C const CLSID CLSID_LeafCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")
LeafCondition;
#endif

EXTERN_C const CLSID CLSID_ConditionFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")
ConditionFactory;
#endif

EXTERN_C const CLSID CLSID_Interval;

#ifdef __cplusplus

class DECLSPEC_UUID("D957171F-4BF9-4de2-BCD5-C70A7CA55836")
Interval;
#endif

EXTERN_C const CLSID CLSID_QueryParserManager;

#ifdef __cplusplus

class DECLSPEC_UUID("5088B39A-29B4-4d9d-8245-4EE289222F66")
QueryParserManager;
#endif
#endif /* __StructuredQuery1_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
/*
 * Portable Audio I/O Library WASAPI implementation
 * Copyright (c) 2006-2010 David Viens, Dmitry Kostjuchenko
 *
 * Based on the Open Source API proposed by Ross Bencina
 * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however,
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also
 * requested that these non-binding requests be included along with the
 * license above.
 */

/** @file
 @ingroup hostapi_src
 @brief WASAPI implementation of support for a host API.
 @note pa_wasapi currently requires minimum VC 2005, and the latest Vista SDK
*/

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <assert.h>

// WinRT
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
	#define PA_WINRT
	#define INITGUID
#endif

// WASAPI
#include <mmreg.h>  // must be before other Wasapi headers
#if defined(_MSC_VER) && (_MSC_VER >= 1400)
	#include <Avrt.h>
	#define COBJMACROS
	#include <Audioclient.h>
	#include <endpointvolume.h>
	#define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
	#include <mmdeviceapi.h>
	#include <functiondiscoverykeys.h>
    #include <devicetopology.h>	// Used to get IKsJackDescription interface
	#undef INITGUID
#endif
#ifndef __MWERKS__
	#include <malloc.h>
	#include <memory.h>
#endif

// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_win_wasapi.h"
// (amalg) #include "pa_debugprint.h"
// (amalg) #include "pa_ringbuffer.h"
// (amalg) #include "pa_win_coinitialize.h"

#if !defined(NTDDI_VERSION)
 
    #undef WINVER
    #undef _WIN32_WINNT
    #define WINVER       0x0600 // VISTA
	#define _WIN32_WINNT WINVER

	#ifndef _AVRT_ //<< fix MinGW dummy compile by defining missing type: AVRT_PRIORITY
        typedef enum _AVRT_PRIORITY
        {
            AVRT_PRIORITY_LOW = -1,
            AVRT_PRIORITY_NORMAL,
            AVRT_PRIORITY_HIGH,
            AVRT_PRIORITY_CRITICAL
        } AVRT_PRIORITY, *PAVRT_PRIORITY;
	#endif

	#include <basetyps.h> // << for IID/CLSID
    #include <rpcsal.h>
    #include <sal.h>

	#ifndef __LPCGUID_DEFINED__
		#define __LPCGUID_DEFINED__
		typedef const GUID *LPCGUID;
	#endif

    #ifndef PROPERTYKEY_DEFINED
        #define PROPERTYKEY_DEFINED
        typedef struct _tagpropertykey
        {
            GUID fmtid;
            DWORD pid;
        } 	PROPERTYKEY;
    #endif

    #ifdef __midl_proxy
        #define __MIDL_CONST
    #else
        #define __MIDL_CONST const
    #endif

    #ifdef WIN64
        #include <wtypes.h>
        typedef LONG NTSTATUS;
        #define FASTCALL
        #include <oleidl.h>
        #include <objidl.h>
     #else
        typedef struct _BYTE_BLOB
        {
            unsigned long clSize;
            unsigned char abData[ 1 ];
        } 	BYTE_BLOB;
        typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *UP_BYTE_BLOB;
        typedef LONGLONG REFERENCE_TIME;
        #define NONAMELESSUNION
    #endif
    
    #ifndef WAVE_FORMAT_IEEE_FLOAT
        #define WAVE_FORMAT_IEEE_FLOAT 0x0003 // 32-bit floating-point
    #endif    
    
    #ifndef __MINGW_EXTENSION
        #if defined(__GNUC__) || defined(__GNUG__)
            #define __MINGW_EXTENSION __extension__
        #else
            #define __MINGW_EXTENSION
        #endif
    #endif 

    #include <sdkddkver.h>
    #include <propkeydef.h>
    #define COBJMACROS
    #define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
    #include <audioclient.h>
    #include <mmdeviceapi.h>
    #include <endpointvolume.h>
    #include <functiondiscoverykeys.h>
	#include <devicetopology.h>	// Used to get IKsJackDescription interface
    #undef INITGUID

#endif // NTDDI_VERSION

// Missing declarations for WinRT
#ifdef PA_WINRT

	#define DEVICE_STATE_ACTIVE 0x00000001

	typedef	enum _EDataFlow
	{	
		eRender					= 0,
		eCapture				= ( eRender + 1 ) ,
		eAll					= ( eCapture + 1 ) ,
		EDataFlow_enum_count	= ( eAll + 1 )
	}
	EDataFlow;

	typedef enum _EndpointFormFactor
	{	
		RemoteNetworkDevice			= 0,
		Speakers					= ( RemoteNetworkDevice + 1 ) ,
		LineLevel					= ( Speakers + 1 ) ,
		Headphones					= ( LineLevel + 1 ) ,
		Microphone					= ( Headphones + 1 ) ,
		Headset						= ( Microphone + 1 ) ,
		Handset						= ( Headset + 1 ) ,
		UnknownDigitalPassthrough	= ( Handset + 1 ) ,
		SPDIF						= ( UnknownDigitalPassthrough + 1 ) ,
		HDMI						= ( SPDIF + 1 ) ,
		UnknownFormFactor			= ( HDMI + 1 ) 
	} 	
	EndpointFormFactor;

#endif

#ifndef GUID_SECT
    #define GUID_SECT
#endif

#define __DEFINE_GUID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const GUID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
#define __DEFINE_IID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const IID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
#define __DEFINE_CLSID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const CLSID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
#define PA_DEFINE_CLSID(className, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    __DEFINE_CLSID(pa_CLSID_##className, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)
#define PA_DEFINE_IID(interfaceName, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    __DEFINE_IID(pa_IID_##interfaceName, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)

// "1CB9AD4C-DBFA-4c32-B178-C2F568A703B2"
PA_DEFINE_IID(IAudioClient,         1cb9ad4c, dbfa, 4c32, b1, 78, c2, f5, 68, a7, 03, b2);
// "726778CD-F60A-4EDA-82DE-E47610CD78AA"
PA_DEFINE_IID(IAudioClient2,        726778cd, f60a, 4eda, 82, de, e4, 76, 10, cd, 78, aa);
// "1BE09788-6894-4089-8586-9A2A6C265AC5"
PA_DEFINE_IID(IMMEndpoint,          1be09788, 6894, 4089, 85, 86, 9a, 2a, 6c, 26, 5a, c5);
// "A95664D2-9614-4F35-A746-DE8DB63617E6"
PA_DEFINE_IID(IMMDeviceEnumerator,  a95664d2, 9614, 4f35, a7, 46, de, 8d, b6, 36, 17, e6);
// "BCDE0395-E52F-467C-8E3D-C4579291692E"
PA_DEFINE_CLSID(IMMDeviceEnumerator,bcde0395, e52f, 467c, 8e, 3d, c4, 57, 92, 91, 69, 2e);
// "F294ACFC-3146-4483-A7BF-ADDCA7C260E2"
PA_DEFINE_IID(IAudioRenderClient,   f294acfc, 3146, 4483, a7, bf, ad, dc, a7, c2, 60, e2);
// "C8ADBD64-E71E-48a0-A4DE-185C395CD317"
PA_DEFINE_IID(IAudioCaptureClient,  c8adbd64, e71e, 48a0, a4, de, 18, 5c, 39, 5c, d3, 17);
// *2A07407E-6497-4A18-9787-32F79BD0D98F*  Or this??
PA_DEFINE_IID(IDeviceTopology,      2A07407E, 6497, 4A18, 97, 87, 32, f7, 9b, d0, d9, 8f);
// *AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9*
PA_DEFINE_IID(IPart,                AE2DE0E4, 5BCA, 4F2D, aa, 46, 5d, 13, f8, fd, b3, a9);
// *4509F757-2D46-4637-8E62-CE7DB944F57B*
PA_DEFINE_IID(IKsJackDescription,   4509F757, 2D46, 4637, 8e, 62, ce, 7d, b9, 44, f5, 7b);

// Media formats:
__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_PCM,        0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_ADPCM,      0x00000002, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, 0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );

#ifdef __IAudioClient2_INTERFACE_DEFINED__
typedef enum _pa_AUDCLNT_STREAMOPTIONS { 
	pa_AUDCLNT_STREAMOPTIONS_NONE          = 0x00,
	pa_AUDCLNT_STREAMOPTIONS_RAW           = 0x01,
	pa_AUDCLNT_STREAMOPTIONS_MATCH_FORMAT  = 0x02
} pa_AUDCLNT_STREAMOPTIONS;
typedef struct _pa_AudioClientProperties {
	UINT32                   cbSize;
	BOOL                     bIsOffload;
	AUDIO_STREAM_CATEGORY    eCategory;
	pa_AUDCLNT_STREAMOPTIONS Options;
} pa_AudioClientProperties;
#define PA_AUDIOCLIENTPROPERTIES_SIZE_CATEGORY (sizeof(pa_AudioClientProperties) - sizeof(pa_AUDCLNT_STREAMOPTIONS))
#define PA_AUDIOCLIENTPROPERTIES_SIZE_OPTIONS   sizeof(pa_AudioClientProperties)
#endif // __IAudioClient2_INTERFACE_DEFINED__

/* use CreateThread for CYGWIN/Windows Mobile, _beginthreadex for all others */
#if !defined(__CYGWIN__) && !defined(_WIN32_WCE)
	#define CREATE_THREAD(PROC) (HANDLE)_beginthreadex( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
	#define PA_THREAD_FUNC static unsigned WINAPI
	#define PA_THREAD_ID unsigned
#else
	#define CREATE_THREAD(PROC) CreateThread( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
	#define PA_THREAD_FUNC static DWORD WINAPI
	#define PA_THREAD_ID DWORD
#endif

// Thread function forward decl.
PA_THREAD_FUNC ProcThreadEvent(void *param);
PA_THREAD_FUNC ProcThreadPoll(void *param);

// Availabe from Windows 7
#ifndef AUDCLNT_E_BUFFER_ERROR
	#define AUDCLNT_E_BUFFER_ERROR AUDCLNT_ERR(0x018)
#endif
#ifndef AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
	#define AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED AUDCLNT_ERR(0x019)
#endif
#ifndef AUDCLNT_E_INVALID_DEVICE_PERIOD
	#define AUDCLNT_E_INVALID_DEVICE_PERIOD AUDCLNT_ERR(0x020)
#endif

#define MAX_STR_LEN 512

enum { S_INPUT = 0, S_OUTPUT = 1, S_COUNT = 2, S_FULLDUPLEX = 0 };

// Number of packets which compose single contignous buffer. With trial and error it was calculated
// that WASAPI Input sub-system uses 6 packets per whole buffer. Please provide more information
// or corrections if available.
enum { WASAPI_PACKETS_PER_INPUT_BUFFER = 6 };

#define STATIC_ARRAY_SIZE(array) (sizeof(array)/sizeof(array[0]))

#define PRINT(x) PA_DEBUG(x);

#define PA_SKELETON_SET_LAST_HOST_ERROR( errorCode, errorText ) \
    PaUtil_SetLastHostErrorInfo( paWASAPI, errorCode, errorText )

#define PA_WASAPI__IS_FULLDUPLEX(STREAM) ((STREAM)->in.clientProc && (STREAM)->out.clientProc)

#ifndef IF_FAILED_JUMP
#define IF_FAILED_JUMP(hr, label) if(FAILED(hr)) goto label;
#endif

#ifndef IF_FAILED_INTERNAL_ERROR_JUMP
#define IF_FAILED_INTERNAL_ERROR_JUMP(hr, error, label) if(FAILED(hr)) { error = paInternalError; goto label; }
#endif

#define SAFE_CLOSE(h) if ((h) != NULL) { CloseHandle((h)); (h) = NULL; }
#define SAFE_RELEASE(punk) if ((punk) != NULL) { (punk)->lpVtbl->Release((punk)); (punk) = NULL; }

// Mixer function
typedef void (*MixMonoToStereoF) (void *__to, void *__from, UINT32 count);

// AVRT is the new "multimedia schedulling stuff"
#ifndef PA_WINRT
typedef BOOL   (WINAPI *FAvRtCreateThreadOrderingGroup)  (PHANDLE,PLARGE_INTEGER,GUID*,PLARGE_INTEGER);
typedef BOOL   (WINAPI *FAvRtDeleteThreadOrderingGroup)  (HANDLE);
typedef BOOL   (WINAPI *FAvRtWaitOnThreadOrderingGroup)  (HANDLE);
typedef HANDLE (WINAPI *FAvSetMmThreadCharacteristics)   (LPCSTR,LPDWORD);
typedef BOOL   (WINAPI *FAvRevertMmThreadCharacteristics)(HANDLE);
typedef BOOL   (WINAPI *FAvSetMmThreadPriority)          (HANDLE,AVRT_PRIORITY);
static HMODULE hDInputDLL = 0;
FAvRtCreateThreadOrderingGroup   pAvRtCreateThreadOrderingGroup = NULL;
FAvRtDeleteThreadOrderingGroup   pAvRtDeleteThreadOrderingGroup = NULL;
FAvRtWaitOnThreadOrderingGroup   pAvRtWaitOnThreadOrderingGroup = NULL;
FAvSetMmThreadCharacteristics    pAvSetMmThreadCharacteristics = NULL;
FAvRevertMmThreadCharacteristics pAvRevertMmThreadCharacteristics = NULL;
FAvSetMmThreadPriority           pAvSetMmThreadPriority = NULL;
#endif

#define _GetProc(fun, type, name)  {                                                        \
                                        fun = (type) GetProcAddress(hDInputDLL,name);       \
                                        if (fun == NULL) {                                  \
                                            PRINT(("GetProcAddr failed for %s" ,name));     \
                                            return FALSE;                                   \
                                        }                                                   \
                                    }                                                       \

// ------------------------------------------------------------------------------------------
/* prototypes for functions declared in this file */
#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
#ifdef __cplusplus
}
#endif /* __cplusplus */
// dummy entry point for other compilers and sdks
// currently built using RC1 SDK (5600)
//#if _MSC_VER < 1400
//PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
//{
    //return paNoError;
//}
//#else

// ------------------------------------------------------------------------------------------
static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );

// ------------------------------------------------------------------------------------------
/*
 These are fields that can be gathered from IDevice and IAudioDevice PRIOR to Initialize, and
 done in first pass i assume that neither of these will cause the Driver to "load", but again,
 who knows how they implement their stuff
 */
typedef struct PaWasapiDeviceInfo
{
    // Device
#ifndef PA_WINRT
    IMMDevice *device;
#endif

	// from GetId
    WCHAR szDeviceID[MAX_STR_LEN];

	// from GetState
    DWORD state;

    // Fields filled from IAudioDevice (_prior_ to Initialize)
    // from GetDevicePeriod(
    REFERENCE_TIME DefaultDevicePeriod;
    REFERENCE_TIME MinimumDevicePeriod;

	// Default format (setup through Control Panel by user)
	WAVEFORMATEXTENSIBLE DefaultFormat;

    // Fields filled from IMMEndpoint'sGetDataFlow
    EDataFlow flow;

	// Formfactor
	EndpointFormFactor formFactor;
}
PaWasapiDeviceInfo;

// ------------------------------------------------------------------------------------------
/* PaWasapiHostApiRepresentation - host api datastructure specific to this implementation */
typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface       callbackStreamInterface;
    PaUtilStreamInterface       blockingStreamInterface;

    PaUtilAllocationGroup      *allocations;

    /* implementation specific data goes here */

    PaWinUtilComInitializationResult comInitializationResult;

    //in case we later need the synch
#ifndef PA_WINRT
    IMMDeviceEnumerator *enumerator;
#endif

    //this is the REAL number of devices, whether they are usefull to PA or not!
    UINT32 deviceCount;

    WCHAR defaultRenderer [MAX_STR_LEN];
    WCHAR defaultCapturer [MAX_STR_LEN];

    PaWasapiDeviceInfo *devInfo;

	// Is true when WOW64 Vista/7 Workaround is needed
	BOOL useWOW64Workaround;
}
PaWasapiHostApiRepresentation;

// ------------------------------------------------------------------------------------------
/* PaWasapiAudioClientParams - audio client parameters */
typedef struct PaWasapiAudioClientParams
{
	PaWasapiDeviceInfo *device_info;
	PaStreamParameters  stream_params;
	PaWasapiStreamInfo  wasapi_params;
	UINT32              frames_per_buffer;
	double              sample_rate;
	BOOL                blocking;
	BOOL                full_duplex;
	BOOL                wow64_workaround;
}
PaWasapiAudioClientParams;

// ------------------------------------------------------------------------------------------
/* PaWasapiStream - a stream data structure specifically for this implementation */
typedef struct PaWasapiSubStream
{
    IAudioClient        *clientParent;
#ifndef PA_WINRT
	IStream				*clientStream;
#endif
	IAudioClient		*clientProc;

    WAVEFORMATEXTENSIBLE wavex;
    UINT32               bufferSize;
    REFERENCE_TIME       deviceLatency;
    REFERENCE_TIME       period;
	double				 latencySeconds;
    UINT32				 framesPerHostCallback;
	AUDCLNT_SHAREMODE    shareMode;
	UINT32               streamFlags; // AUDCLNT_STREAMFLAGS_EVENTCALLBACK, ...
	UINT32               flags;
	PaWasapiAudioClientParams params; //!< parameters

	// Buffers
	UINT32               buffers;			//!< number of buffers used (from host side)
	UINT32               framesPerBuffer;	//!< number of frames per 1 buffer
	BOOL                 userBufferAndHostMatch;

	// Used for Mono >> Stereo workaround, if driver does not support it
	// (in Exclusive mode WASAPI usually refuses to operate with Mono (1-ch)
	void                *monoBuffer;	 //!< pointer to buffer
	UINT32               monoBufferSize; //!< buffer size in bytes
	MixMonoToStereoF     monoMixer;		 //!< pointer to mixer function

	PaUtilRingBuffer    *tailBuffer;       //!< buffer with trailing sample for blocking mode operations (only for Input)
	void                *tailBufferMemory; //!< tail buffer memory region
}
PaWasapiSubStream;

// ------------------------------------------------------------------------------------------
/* PaWasapiHostProcessor - redirects processing data */
typedef struct PaWasapiHostProcessor
{
    PaWasapiHostProcessorCallback processor;
    void *userData;
}
PaWasapiHostProcessor;

// ------------------------------------------------------------------------------------------
typedef struct PaWasapiStream
{
	/* IMPLEMENT ME: rename this */
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer      cpuLoadMeasurer;
    PaUtilBufferProcessor      bufferProcessor;

    // input
	PaWasapiSubStream          in;
    IAudioCaptureClient       *captureClientParent;
#ifndef PA_WINRT
	IStream                   *captureClientStream;
#endif
	IAudioCaptureClient       *captureClient;
    IAudioEndpointVolume      *inVol;

	// output
	PaWasapiSubStream          out;
    IAudioRenderClient        *renderClientParent;
#ifndef PA_WINRT
	IStream                   *renderClientStream;
#endif
	IAudioRenderClient        *renderClient;
	IAudioEndpointVolume      *outVol;

	// event handles for event-driven processing mode
	HANDLE event[S_COUNT];

	// buffer mode
	PaUtilHostBufferSizeMode bufferMode;

	// must be volatile to avoid race condition on user query while
	// thread is being started
    volatile BOOL running;

    PA_THREAD_ID dwThreadId;
    HANDLE hThread;
	HANDLE hCloseRequest;
	HANDLE hThreadStart;        //!< signalled by thread on start
	HANDLE hThreadExit;         //!< signalled by thread on exit
	HANDLE hBlockingOpStreamRD;
	HANDLE hBlockingOpStreamWR;

    // Host callback Output overrider
	PaWasapiHostProcessor hostProcessOverrideOutput;

    // Host callback Input overrider
	PaWasapiHostProcessor hostProcessOverrideInput;

	// Defines blocking/callback interface used
	BOOL bBlocking;

	// Av Task (MM thread management)
	HANDLE hAvTask;

	// Thread priority level
	PaWasapiThreadPriority nThreadPriority;
}
PaWasapiStream;

// COM marshaling
static HRESULT MarshalSubStreamComPointers(PaWasapiSubStream *substream);
static HRESULT MarshalStreamComPointers(PaWasapiStream *stream);
static HRESULT UnmarshalSubStreamComPointers(PaWasapiSubStream *substream);
static HRESULT UnmarshalStreamComPointers(PaWasapiStream *stream);
static void ReleaseUnmarshaledSubComPointers(PaWasapiSubStream *substream);
static void ReleaseUnmarshaledComPointers(PaWasapiStream *stream);

// Local stream methods
static void _StreamOnStop(PaWasapiStream *stream);
static void _StreamFinish(PaWasapiStream *stream);
static void _StreamCleanup(PaWasapiStream *stream);
static HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
static HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
static void *PaWasapi_ReallocateMemory(void *ptr, size_t size);
static void PaWasapi_FreeMemory(void *ptr);

// Local statics

// ------------------------------------------------------------------------------------------
#define LogHostError(HRES) __LogHostError(HRES, __FUNCTION__, __FILE__, __LINE__)
static HRESULT __LogHostError(HRESULT res, const char *func, const char *file, int line)
{
    const char *text = NULL;
    switch (res)
	{
	case S_OK: return res;
	case E_POINTER                              :text ="E_POINTER"; break;
	case E_INVALIDARG                           :text ="E_INVALIDARG"; break;

	case AUDCLNT_E_NOT_INITIALIZED              :text ="AUDCLNT_E_NOT_INITIALIZED"; break;
	case AUDCLNT_E_ALREADY_INITIALIZED          :text ="AUDCLNT_E_ALREADY_INITIALIZED"; break;
	case AUDCLNT_E_WRONG_ENDPOINT_TYPE          :text ="AUDCLNT_E_WRONG_ENDPOINT_TYPE"; break;
	case AUDCLNT_E_DEVICE_INVALIDATED           :text ="AUDCLNT_E_DEVICE_INVALIDATED"; break;
	case AUDCLNT_E_NOT_STOPPED                  :text ="AUDCLNT_E_NOT_STOPPED"; break;
	case AUDCLNT_E_BUFFER_TOO_LARGE             :text ="AUDCLNT_E_BUFFER_TOO_LARGE"; break;
	case AUDCLNT_E_OUT_OF_ORDER                 :text ="AUDCLNT_E_OUT_OF_ORDER"; break;
	case AUDCLNT_E_UNSUPPORTED_FORMAT           :text ="AUDCLNT_E_UNSUPPORTED_FORMAT"; break;
	case AUDCLNT_E_INVALID_SIZE                 :text ="AUDCLNT_E_INVALID_SIZE"; break;
	case AUDCLNT_E_DEVICE_IN_USE                :text ="AUDCLNT_E_DEVICE_IN_USE"; break;
	case AUDCLNT_E_BUFFER_OPERATION_PENDING     :text ="AUDCLNT_E_BUFFER_OPERATION_PENDING"; break;
	case AUDCLNT_E_THREAD_NOT_REGISTERED        :text ="AUDCLNT_E_THREAD_NOT_REGISTERED"; break;
	case AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED   :text ="AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED"; break;
	case AUDCLNT_E_ENDPOINT_CREATE_FAILED       :text ="AUDCLNT_E_ENDPOINT_CREATE_FAILED"; break;
	case AUDCLNT_E_SERVICE_NOT_RUNNING          :text ="AUDCLNT_E_SERVICE_NOT_RUNNING"; break;
	case AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     :text ="AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED"; break;
	case AUDCLNT_E_EXCLUSIVE_MODE_ONLY          :text ="AUDCLNT_E_EXCLUSIVE_MODE_ONLY"; break;
	case AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL :text ="AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL"; break;
	case AUDCLNT_E_EVENTHANDLE_NOT_SET          :text ="AUDCLNT_E_EVENTHANDLE_NOT_SET"; break;
	case AUDCLNT_E_INCORRECT_BUFFER_SIZE        :text ="AUDCLNT_E_INCORRECT_BUFFER_SIZE"; break;
	case AUDCLNT_E_BUFFER_SIZE_ERROR            :text ="AUDCLNT_E_BUFFER_SIZE_ERROR"; break;
	case AUDCLNT_E_CPUUSAGE_EXCEEDED            :text ="AUDCLNT_E_CPUUSAGE_EXCEEDED"; break;
	case AUDCLNT_E_BUFFER_ERROR					:text ="AUDCLNT_E_BUFFER_ERROR"; break;
	case AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED		:text ="AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED"; break;
	case AUDCLNT_E_INVALID_DEVICE_PERIOD		:text ="AUDCLNT_E_INVALID_DEVICE_PERIOD"; break;

	case AUDCLNT_S_BUFFER_EMPTY                 :text ="AUDCLNT_S_BUFFER_EMPTY"; break;
	case AUDCLNT_S_THREAD_ALREADY_REGISTERED    :text ="AUDCLNT_S_THREAD_ALREADY_REGISTERED"; break;
	case AUDCLNT_S_POSITION_STALLED				:text ="AUDCLNT_S_POSITION_STALLED"; break;

	// other windows common errors:
	case CO_E_NOTINITIALIZED                    :text ="CO_E_NOTINITIALIZED: you must call CoInitialize() before Pa_OpenStream()"; break;

	default:
		text = "UNKNOWN ERROR";
    }
	PRINT(("WASAPI ERROR HRESULT: 0x%X : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", res, text, func, file, line));
	PA_SKELETON_SET_LAST_HOST_ERROR(res, text);
	return res;
}

// ------------------------------------------------------------------------------------------
#define LogPaError(PAERR) __LogPaError(PAERR, __FUNCTION__, __FILE__, __LINE__)
static PaError __LogPaError(PaError err, const char *func, const char *file, int line)
{
	if (err == paNoError)
		return err;
	PRINT(("WASAPI ERROR PAERROR: %i : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", err, Pa_GetErrorText(err), func, file, line));
	return err;
}

// ------------------------------------------------------------------------------------------
/*! \class ThreadSleepScheduler
           Allows to emulate thread sleep of less than 1 millisecond under Windows. Scheduler
		   calculates number of times the thread must run untill next sleep of 1 millisecond.
		   It does not make thread sleeping for real number of microseconds but rather controls
		   how many of imaginary microseconds the thread task can allow thread to sleep.
*/
typedef struct ThreadIdleScheduler
{
	UINT32 m_idle_microseconds; //!< number of microseconds to sleep
	UINT32 m_next_sleep;        //!< next sleep round
	UINT32 m_i;					//!< current round iterator position
	UINT32 m_resolution;		//!< resolution in number of milliseconds
}
ThreadIdleScheduler;
//! Setup scheduler.
static void ThreadIdleScheduler_Setup(ThreadIdleScheduler *sched, UINT32 resolution, UINT32 microseconds)
{
	assert(microseconds != 0);
	assert(resolution != 0);
	assert((resolution * 1000) >= microseconds);

	memset(sched, 0, sizeof(*sched));

	sched->m_idle_microseconds = microseconds;
	sched->m_resolution        = resolution;
	sched->m_next_sleep        = (resolution * 1000) / microseconds;
}
//! Iterate and check if can sleep.
static UINT32 ThreadIdleScheduler_NextSleep(ThreadIdleScheduler *sched)
{
	// advance and check if thread can sleep
	if (++ sched->m_i == sched->m_next_sleep)
	{
		sched->m_i = 0;
		return sched->m_resolution;
	}
	return 0;
}

// ------------------------------------------------------------------------------------------
/*static double nano100ToMillis(REFERENCE_TIME ref)
{
    //  1 nano = 0.000000001 seconds
    //100 nano = 0.0000001   seconds
    //100 nano = 0.0001   milliseconds
    return ((double)ref)*0.0001;
}*/

// ------------------------------------------------------------------------------------------
static double nano100ToSeconds(REFERENCE_TIME ref)
{
    //  1 nano = 0.000000001 seconds
    //100 nano = 0.0000001   seconds
    //100 nano = 0.0001   milliseconds
    return ((double)ref)*0.0000001;
}

// ------------------------------------------------------------------------------------------
/*static REFERENCE_TIME MillisTonano100(double ref)
{
    //  1 nano = 0.000000001 seconds
    //100 nano = 0.0000001   seconds
    //100 nano = 0.0001   milliseconds
    return (REFERENCE_TIME)(ref/0.0001);
}*/

// ------------------------------------------------------------------------------------------
static REFERENCE_TIME SecondsTonano100(double ref)
{
    //  1 nano = 0.000000001 seconds
    //100 nano = 0.0000001   seconds
    //100 nano = 0.0001   milliseconds
    return (REFERENCE_TIME)(ref/0.0000001);
}

// ------------------------------------------------------------------------------------------
// Makes Hns period from frames and sample rate
static REFERENCE_TIME MakeHnsPeriod(UINT32 nFrames, DWORD nSamplesPerSec)
{
	return (REFERENCE_TIME)((10000.0 * 1000 / nSamplesPerSec * nFrames) + 0.5);
}

// ------------------------------------------------------------------------------------------
// Converts PaSampleFormat to bits per sample value
static WORD PaSampleFormatToBitsPerSample(PaSampleFormat format_id)
{
	switch (format_id & ~paNonInterleaved)
	{
		case paFloat32:
		case paInt32: return 32;
		case paInt24: return 24;
		case paInt16: return 16;
		case paInt8:
		case paUInt8: return 8;
	}
	return 0;
}

// ------------------------------------------------------------------------------------------
// Converts PaSampleFormat to bits per sample value
/*static WORD PaSampleFormatToBytesPerSample(PaSampleFormat format_id)
{
	return PaSampleFormatToBitsPerSample(format_id) >> 3; // 'bits/8'
}*/

// ------------------------------------------------------------------------------------------
// Converts Hns period into number of frames
static UINT32 MakeFramesFromHns(REFERENCE_TIME hnsPeriod, UINT32 nSamplesPerSec)
{
    UINT32 nFrames = (UINT32)(	// frames =
        1.0 * hnsPeriod *		// hns *
        nSamplesPerSec /		// (frames / s) /
        1000 /					// (ms / s) /
        10000					// (hns / s) /
        + 0.5					// rounding
    );
	return nFrames;
}

// Aligning function type
typedef UINT32 (*ALIGN_FUNC) (UINT32 v, UINT32 align);

// ------------------------------------------------------------------------------------------
// Aligns 'v' backwards
static UINT32 ALIGN_BWD(UINT32 v, UINT32 align)
{
	return ((v - (align ? v % align : 0)));
}

// ------------------------------------------------------------------------------------------
// Aligns 'v' forward
static UINT32 ALIGN_FWD(UINT32 v, UINT32 align)
{
	UINT32 remainder = (align ? (v % align) : 0);
	if (remainder == 0)
		return v;
	return v + (align - remainder);
}

// ------------------------------------------------------------------------------------------
// Get next value power of 2
UINT32 ALIGN_NEXT_POW2(UINT32 v)
{
	UINT32 v2 = 1;
	while (v > (v2 <<= 1)) { }
	v = v2;
	return v;
}

// ------------------------------------------------------------------------------------------
// Aligns WASAPI buffer to 128 byte packet boundary. HD Audio will fail to play if buffer
// is misaligned. This problem was solved in Windows 7 were AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
// is thrown although we must align for Vista anyway.
static UINT32 AlignFramesPerBuffer(UINT32 nFrames, UINT32 nSamplesPerSec, UINT32 nBlockAlign,
								   ALIGN_FUNC pAlignFunc)
{
#define HDA_PACKET_SIZE (128)

	long frame_bytes = nFrames * nBlockAlign;
	long packets;
	(void)nSamplesPerSec;

	// align to packet size
	frame_bytes  = pAlignFunc(frame_bytes, HDA_PACKET_SIZE); // use ALIGN_FWD if bigger but safer period is more desired

	// atlest 1 frame must be available
	if (frame_bytes < HDA_PACKET_SIZE)
		frame_bytes = HDA_PACKET_SIZE;

	nFrames      = frame_bytes / nBlockAlign;
	packets      = frame_bytes / HDA_PACKET_SIZE;

	frame_bytes = packets * HDA_PACKET_SIZE;
	nFrames     = frame_bytes / nBlockAlign;

	return nFrames;

#undef HDA_PACKET_SIZE
}

// ------------------------------------------------------------------------------------------
static UINT32 GetFramesSleepTime(UINT32 nFrames, UINT32 nSamplesPerSec)
{
	REFERENCE_TIME nDuration;
	if (nSamplesPerSec == 0)
		return 0;
#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000
	// Calculate the actual duration of the allocated buffer.
	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
	return (UINT32)(nDuration/REFTIMES_PER_MILLISEC/2);
}

// ------------------------------------------------------------------------------------------
static UINT32 GetFramesSleepTimeMicroseconds(UINT32 nFrames, UINT32 nSamplesPerSec)
{
	REFERENCE_TIME nDuration;
	if (nSamplesPerSec == 0)
		return 0;
#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000
	// Calculate the actual duration of the allocated buffer.
	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
	return (UINT32)(nDuration/10/2);
}

// ------------------------------------------------------------------------------------------
#ifndef PA_WINRT
static BOOL SetupAVRT()
{
    hDInputDLL = LoadLibraryA("avrt.dll");
    if (hDInputDLL == NULL)
        return FALSE;

    _GetProc(pAvRtCreateThreadOrderingGroup,  FAvRtCreateThreadOrderingGroup,  "AvRtCreateThreadOrderingGroup");
    _GetProc(pAvRtDeleteThreadOrderingGroup,  FAvRtDeleteThreadOrderingGroup,  "AvRtDeleteThreadOrderingGroup");
    _GetProc(pAvRtWaitOnThreadOrderingGroup,  FAvRtWaitOnThreadOrderingGroup,  "AvRtWaitOnThreadOrderingGroup");
    _GetProc(pAvSetMmThreadCharacteristics,   FAvSetMmThreadCharacteristics,   "AvSetMmThreadCharacteristicsA");
	_GetProc(pAvRevertMmThreadCharacteristics,FAvRevertMmThreadCharacteristics,"AvRevertMmThreadCharacteristics");
    _GetProc(pAvSetMmThreadPriority,          FAvSetMmThreadPriority,          "AvSetMmThreadPriority");

	return pAvRtCreateThreadOrderingGroup &&
		pAvRtDeleteThreadOrderingGroup &&
		pAvRtWaitOnThreadOrderingGroup &&
		pAvSetMmThreadCharacteristics &&
		pAvRevertMmThreadCharacteristics &&
		pAvSetMmThreadPriority;
}
#endif

// ------------------------------------------------------------------------------------------
static void CloseAVRT()
{
#ifndef PA_WINRT
	if (hDInputDLL != NULL)
		FreeLibrary(hDInputDLL);
	hDInputDLL = NULL;
#endif
}

// ------------------------------------------------------------------------------------------
static BOOL IsWow64()
{
#ifndef PA_WINRT

	// http://msdn.microsoft.com/en-us/library/ms684139(VS.85).aspx

	typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
	LPFN_ISWOW64PROCESS fnIsWow64Process;

    BOOL bIsWow64 = FALSE;

    // IsWow64Process is not available on all supported versions of Windows.
    // Use GetModuleHandle to get a handle to the DLL that contains the function
    // and GetProcAddress to get a pointer to the function if available.

    fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress(
        GetModuleHandleA("kernel32"), "IsWow64Process");

    if (fnIsWow64Process == NULL)
		return FALSE;

    if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64))
		return FALSE;

    return bIsWow64;

#else

	return FALSE;

#endif
}

// ------------------------------------------------------------------------------------------
typedef enum EWindowsVersion
{
	WINDOWS_UNKNOWN = 0,
	WINDOWS_VISTA_SERVER2008,
	WINDOWS_7_SERVER2008R2,
	WINDOWS_8_SERVER2012,
	WINDOWS_8_1_SERVER2012R2,
	WINDOWS_10_SERVER2016,
	WINDOWS_FUTURE
}
EWindowsVersion;
// Alternative way for checking Windows version (allows to check version on Windows 8.1 and up)
#ifndef PA_WINRT
static BOOL IsWindowsVersionOrGreater(WORD wMajorVersion, WORD wMinorVersion, WORD wServicePackMajor)
{
	typedef ULONGLONG (NTAPI *LPFN_VERSETCONDITIONMASK)(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
	typedef BOOL (WINAPI *LPFN_VERIFYVERSIONINFO)(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);

	LPFN_VERSETCONDITIONMASK fnVerSetConditionMask;
	LPFN_VERIFYVERSIONINFO fnVerifyVersionInfo;
	OSVERSIONINFOEXA osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };
	DWORDLONG dwlConditionMask;

	fnVerSetConditionMask = (LPFN_VERSETCONDITIONMASK)GetProcAddress(GetModuleHandleA("kernel32"), "VerSetConditionMask");
	fnVerifyVersionInfo = (LPFN_VERIFYVERSIONINFO)GetProcAddress(GetModuleHandleA("kernel32"), "VerifyVersionInfoA");

	if ((fnVerSetConditionMask == NULL) || (fnVerifyVersionInfo == NULL))
		return FALSE;

	dwlConditionMask = fnVerSetConditionMask(
		fnVerSetConditionMask(
			fnVerSetConditionMask(
				0, VER_MAJORVERSION,     VER_GREATER_EQUAL),
				   VER_MINORVERSION,     VER_GREATER_EQUAL),
				   VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);

	osvi.dwMajorVersion    = wMajorVersion;
	osvi.dwMinorVersion    = wMinorVersion;
	osvi.wServicePackMajor = wServicePackMajor;

	return (fnVerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, dwlConditionMask) != FALSE);
}
#endif
// Get Windows version
static EWindowsVersion GetWindowsVersion()
{
#ifndef PA_WINRT
	static EWindowsVersion version = WINDOWS_UNKNOWN;

	if (version == WINDOWS_UNKNOWN)
	{
		DWORD dwVersion = 0;
		DWORD dwMajorVersion = 0;
		DWORD dwMinorVersion = 0;
		DWORD dwBuild = 0;

		typedef DWORD (WINAPI *LPFN_GETVERSION)(VOID);
		LPFN_GETVERSION fnGetVersion;

		fnGetVersion = (LPFN_GETVERSION)GetProcAddress(GetModuleHandleA("kernel32"), "GetVersion");
		if (fnGetVersion != NULL)
		{
			PRINT(("WASAPI: getting Windows version with GetVersion()\n"));

			dwVersion = fnGetVersion();

			// Get the Windows version
			dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
			dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));

			// Get the build number
			if (dwVersion < 0x80000000)
				dwBuild = (DWORD)(HIWORD(dwVersion));

			switch (dwMajorVersion)
			{
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				break; // skip lower
			case 6:
				switch (dwMinorVersion)
				{
				case 0:  version = WINDOWS_VISTA_SERVER2008;	break;
				case 1:	 version = WINDOWS_7_SERVER2008R2;		break;
				case 2:	 version = WINDOWS_8_SERVER2012;  		break;
				case 3:	 version = WINDOWS_8_1_SERVER2012R2;	break;
				default: version = WINDOWS_FUTURE;				break;
				}
				break;
			case 10:
				switch (dwMinorVersion)
				{
				case 0:	 version = WINDOWS_10_SERVER2016;		break;
				default: version = WINDOWS_FUTURE;				break;
				}
				break;
			default:
				version = WINDOWS_FUTURE;
				break;
			}
		}
		else
		{
			PRINT(("WASAPI: getting Windows version with VerifyVersionInfo()\n"));

			if (IsWindowsVersionOrGreater(10, 0, 0))
				version = WINDOWS_10_SERVER2016;
			else
			if (IsWindowsVersionOrGreater(6, 3, 0))
				version = WINDOWS_8_1_SERVER2012R2;
			else
			if (IsWindowsVersionOrGreater(6, 2, 0))
				version = WINDOWS_8_SERVER2012;
			else
			if (IsWindowsVersionOrGreater(6, 1, 0))
				version = WINDOWS_7_SERVER2008R2;
			else
			if (IsWindowsVersionOrGreater(6, 0, 0))
				version = WINDOWS_VISTA_SERVER2008;
			else
				version = WINDOWS_FUTURE;
		}

		PRINT(("WASAPI: Windows version = %d\n", version));
	}

	return version;
#else
	return WINDOWS_8_SERVER2012;
#endif
}

// ------------------------------------------------------------------------------------------
static BOOL UseWOW64Workaround()
{
	// note: WOW64 bug is common to Windows Vista x64, thus we fall back to safe Poll-driven
	//       method. Windows 7 x64 seems has WOW64 bug fixed.

	return (IsWow64() && (GetWindowsVersion() == WINDOWS_VISTA_SERVER2008));
}

// ------------------------------------------------------------------------------------------
static UINT32 GetAudioClientVersion()
{
	if (GetWindowsVersion() >= WINDOWS_10_SERVER2016)
		return 3;
	else
	if (GetWindowsVersion() >= WINDOWS_8_SERVER2012)
		return 2;

	return 1;
}

// ------------------------------------------------------------------------------------------
static const IID *GetAudioClientIID()
{
	static const IID *cli_iid = NULL;
	if (cli_iid == NULL)
	{
		UINT32 cli_version = GetAudioClientVersion();
		if (cli_version <= 1)
		{
			cli_iid = &pa_IID_IAudioClient;
		}
		else
		{
			switch (cli_version)
			{
			case 3:  cli_iid = &pa_IID_IAudioClient2; cli_version = 2; break; // use IAudioClient2 for Windows 10+ until IAudioClient3 functions are required
			default: cli_iid = &pa_IID_IAudioClient2; cli_version = 2; break;
			}
		}

		PRINT(("WASAPI: IAudioClient version = %d\n", cli_version));
	}

	return cli_iid;
}

// ------------------------------------------------------------------------------------------
typedef enum EMixerDir { MIX_DIR__1TO2, MIX_DIR__2TO1, MIX_DIR__2TO1_L } EMixerDir;

// ------------------------------------------------------------------------------------------
#define _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(TYPE)\
	TYPE * __restrict to   = __to;\
	TYPE * __restrict from = __from;\
	TYPE * __restrict end  = from + count;\
	while (from != end)\
	{\
		*to ++ = *from;\
		*to ++ = *from;\
		++ from;\
	}

// ------------------------------------------------------------------------------------------
#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(TYPE)\
	TYPE * __restrict to   = (TYPE *)__to;\
	TYPE * __restrict from = (TYPE *)__from;\
	TYPE * __restrict end  = to + count;\
	while (to != end)\
	{\
		*to ++ = (TYPE)((float)(from[0] + from[1]) * 0.5f);\
		from += 2;\
	}

// ------------------------------------------------------------------------------------------
#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(TYPE)\
	TYPE * __restrict to   = (TYPE *)__to;\
	TYPE * __restrict from = (TYPE *)__from;\
	TYPE * __restrict end  = to + count;\
	while (to != end)\
	{\
		*to ++ = (TYPE)(((INT32)from[0] + (INT32)from[1]) >> 1);\
		from += 2;\
	}

// ------------------------------------------------------------------------------------------
#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(TYPE)\
	TYPE * __restrict to   = (TYPE *)__to;\
	TYPE * __restrict from = (TYPE *)__from;\
	TYPE * __restrict end  = to + count;\
	while (to != end)\
	{\
		*to ++ = (TYPE)(((INT64)from[0] + (INT64)from[1]) >> 1);\
		from += 2;\
	}

// ------------------------------------------------------------------------------------------
#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(TYPE)\
	TYPE * __restrict to   = (TYPE *)__to;\
	TYPE * __restrict from = (TYPE *)__from;\
	TYPE * __restrict end  = to + count;\
	while (to != end)\
	{\
		*to ++ = from[0];\
		from += 2;\
	}

// ------------------------------------------------------------------------------------------
static void _MixMonoToStereo_1TO2_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(BYTE); }
static void _MixMonoToStereo_1TO2_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(short); }
static void _MixMonoToStereo_1TO2_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); /* !!! int24 data is contained in 32-bit containers*/ }
static void _MixMonoToStereo_1TO2_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); }
static void _MixMonoToStereo_1TO2_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(float); }

// ------------------------------------------------------------------------------------------
static void _MixMonoToStereo_2TO1_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(BYTE); }
static void _MixMonoToStereo_2TO1_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(short); }
static void _MixMonoToStereo_2TO1_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(int); /* !!! int24 data is contained in 32-bit containers*/ }
static void _MixMonoToStereo_2TO1_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(int); }
static void _MixMonoToStereo_2TO1_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(float); }

// ------------------------------------------------------------------------------------------
static void _MixMonoToStereo_2TO1_8_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(BYTE); }
static void _MixMonoToStereo_2TO1_16_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(short); }
static void _MixMonoToStereo_2TO1_24_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); /* !!! int24 data is contained in 32-bit containers*/ }
static void _MixMonoToStereo_2TO1_32_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); }
static void _MixMonoToStereo_2TO1_32f_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(float); }

// ------------------------------------------------------------------------------------------
static MixMonoToStereoF _GetMonoToStereoMixer(PaSampleFormat format, EMixerDir dir)
{
	switch (dir)
	{
	case MIX_DIR__1TO2:
		switch (format & ~paNonInterleaved)
		{
		case paUInt8:	return _MixMonoToStereo_1TO2_8;
		case paInt16:	return _MixMonoToStereo_1TO2_16;
		case paInt24:	return _MixMonoToStereo_1TO2_24;
		case paInt32:	return _MixMonoToStereo_1TO2_32;
		case paFloat32: return _MixMonoToStereo_1TO2_32f;
		}
		break;

	case MIX_DIR__2TO1:
		switch (format & ~paNonInterleaved)
		{
		case paUInt8:	return _MixMonoToStereo_2TO1_8;
		case paInt16:	return _MixMonoToStereo_2TO1_16;
		case paInt24:	return _MixMonoToStereo_2TO1_24;
		case paInt32:	return _MixMonoToStereo_2TO1_32;
		case paFloat32: return _MixMonoToStereo_2TO1_32f;
		}
		break;

	case MIX_DIR__2TO1_L:
		switch (format & ~paNonInterleaved)
		{
		case paUInt8:	return _MixMonoToStereo_2TO1_8_L;
		case paInt16:	return _MixMonoToStereo_2TO1_16_L;
		case paInt24:	return _MixMonoToStereo_2TO1_24_L;
		case paInt32:	return _MixMonoToStereo_2TO1_32_L;
		case paFloat32: return _MixMonoToStereo_2TO1_32f_L;
		}
		break;
	}

	return NULL;
}

// ------------------------------------------------------------------------------------------
#ifdef PA_WINRT
typedef struct PaActivateAudioInterfaceCompletionHandler
{
	IActivateAudioInterfaceCompletionHandler parent;
	volatile LONG refs;
	volatile LONG done;
	struct
	{
		const IID *iid;
		void **obj;
	}
	in;
	struct
	{
		HRESULT hr;
	}
	out;
}
PaActivateAudioInterfaceCompletionHandler;

static HRESULT (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_QueryInterface)( 
    IActivateAudioInterfaceCompletionHandler *This, REFIID riid, void **ppvObject)
{
	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;

	// From MSDN:
	// "The IAgileObject interface is a marker interface that indicates that an object 
	//  is free threaded and can be called from any apartment."
	if (IsEqualIID(riid, &IID_IUnknown) || 
		IsEqualIID(riid, &IID_IAgileObject))
	{
		IActivateAudioInterfaceCompletionHandler_AddRef((IActivateAudioInterfaceCompletionHandler *)handler);
		(*ppvObject) = handler;
		return S_OK;
	}

	return E_NOINTERFACE;
}
        
static ULONG (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_AddRef)( 
    IActivateAudioInterfaceCompletionHandler *This)
{
	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;

	return InterlockedIncrement(&handler->refs);
}
        
static ULONG (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_Release)( 
    IActivateAudioInterfaceCompletionHandler *This)
{
	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;
	ULONG refs;

	if ((refs = InterlockedDecrement(&handler->refs)) == 0)
	{
		PaUtil_FreeMemory(handler->parent.lpVtbl);
		PaUtil_FreeMemory(handler);
	}

	return refs;
}
        
static HRESULT (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_ActivateCompleted)( 
    IActivateAudioInterfaceCompletionHandler *This, IActivateAudioInterfaceAsyncOperation *activateOperation)
{
	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;

    HRESULT hr = S_OK;
    HRESULT hrActivateResult = S_OK;
    IUnknown *punkAudioInterface = NULL;
 
    // Check for a successful activation result
    hr = IActivateAudioInterfaceAsyncOperation_GetActivateResult(activateOperation, &hrActivateResult, &punkAudioInterface);
    if (SUCCEEDED(hr) && SUCCEEDED(hrActivateResult))
    {
        // Get pointer to the requested audio interface
        IUnknown_QueryInterface(punkAudioInterface, handler->in.iid, handler->in.obj);
        if ((*handler->in.obj) == NULL)
            hrActivateResult = E_FAIL;
	}
	SAFE_RELEASE(punkAudioInterface);

	if (SUCCEEDED(hr))
		handler->out.hr = hrActivateResult;
	else
		handler->out.hr = hr;
	
	// Got client object, stop busy waiting in ActivateAudioInterface
	InterlockedExchange(&handler->done, TRUE);

	return hr;
}

static IActivateAudioInterfaceCompletionHandler *CreateActivateAudioInterfaceCompletionHandler(const IID *iid, void **obj)
{
	PaActivateAudioInterfaceCompletionHandler *handler = PaUtil_AllocateMemory(sizeof(PaActivateAudioInterfaceCompletionHandler));
	ZeroMemory(handler, sizeof(*handler));
	handler->parent.lpVtbl = PaUtil_AllocateMemory(sizeof(*handler->parent.lpVtbl));
	handler->parent.lpVtbl->QueryInterface    = &PaActivateAudioInterfaceCompletionHandler_QueryInterface;
	handler->parent.lpVtbl->AddRef            = &PaActivateAudioInterfaceCompletionHandler_AddRef;
	handler->parent.lpVtbl->Release           = &PaActivateAudioInterfaceCompletionHandler_Release;
	handler->parent.lpVtbl->ActivateCompleted = &PaActivateAudioInterfaceCompletionHandler_ActivateCompleted;
	handler->refs = 1;
	handler->in.iid = iid;
	handler->in.obj = obj;
	return (IActivateAudioInterfaceCompletionHandler *)handler;
}
#endif

// ------------------------------------------------------------------------------------------
#ifdef PA_WINRT
static HRESULT ActivateAudioInterface_WINRT(const PaWasapiDeviceInfo *deviceInfo, const IID *iid, void **obj)
{
#define PA_WASAPI_DEVICE_PATH_LEN 64
	
	PaError result = paNoError;
	HRESULT hr = S_OK;
	IActivateAudioInterfaceAsyncOperation *asyncOp = NULL;
	IActivateAudioInterfaceCompletionHandler *handler = CreateActivateAudioInterfaceCompletionHandler(iid, obj);
	PaActivateAudioInterfaceCompletionHandler *handlerImpl = (PaActivateAudioInterfaceCompletionHandler *)handler;
	OLECHAR devicePath[PA_WASAPI_DEVICE_PATH_LEN] = { 0 };

	// Get device path in form L"{DEVICE_GUID}"
	switch (deviceInfo->flow)
	{
	case eRender:
		StringFromGUID2(&DEVINTERFACE_AUDIO_RENDER, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
		break;
	case eCapture:
		StringFromGUID2(&DEVINTERFACE_AUDIO_CAPTURE, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
		break;
	default:
		return S_FALSE;
	}	

	// Async operation will call back to IActivateAudioInterfaceCompletionHandler::ActivateCompleted 
	// which must be an agile interface implementation
    hr = ActivateAudioInterfaceAsync(devicePath, iid, NULL, handler, &asyncOp);
    IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

	// Wait in busy loop for async operation to complete
	// Use Interlocked API here to ensure that ->done variable is read every time through the loop
	while (SUCCEEDED(hr) && !InterlockedOr(&handlerImpl->done, 0))
	{
		Sleep(1);
	}

	hr = handlerImpl->out.hr;

error:

	SAFE_RELEASE(asyncOp);
	SAFE_RELEASE(handler);

    return hr;
	
#undef PA_WASAPI_DEVICE_PATH_LEN
}
#endif

// ------------------------------------------------------------------------------------------
static HRESULT ActivateAudioInterface(const PaWasapiDeviceInfo *deviceInfo, IAudioClient **client)
{
#ifndef PA_WINRT
	return IMMDevice_Activate(deviceInfo->device, GetAudioClientIID(), CLSCTX_ALL, NULL, (void **)client);
#else
	return ActivateAudioInterface_WINRT(deviceInfo, GetAudioClientIID(), (void **)client);
#endif
}

// ------------------------------------------------------------------------------------------
#ifdef PA_WINRT
static DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
	SetEvent(hObjectToSignal);
	return WaitForSingleObjectEx(hObjectToWaitOn, dwMilliseconds, bAlertable);
}
#endif

// ------------------------------------------------------------------------------------------
PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    PaWasapiHostApiRepresentation *paWasapi;
    PaDeviceInfo *deviceInfoArray;
    HRESULT hr = S_OK;
	UINT i;
#ifndef PA_WINRT
    IMMDeviceCollection* pEndPoints = NULL;
#else
	WAVEFORMATEX *mixFormat;
#endif

#ifndef PA_WINRT
    if (!SetupAVRT())
	{
        PRINT(("WASAPI: No AVRT! (not VISTA?)"));
        return paNoError;
    }
#endif

    paWasapi = (PaWasapiHostApiRepresentation *)PaUtil_AllocateMemory( sizeof(PaWasapiHostApiRepresentation) );
    if (paWasapi == NULL)
	{
        result = paInsufficientMemory;
        goto error;
    }
	
    memset( paWasapi, 0, sizeof(PaWasapiHostApiRepresentation) ); /* ensure all fields are zeroed. especially paWasapi->allocations */

    result = PaWinUtil_CoInitialize( paWASAPI, &paWasapi->comInitializationResult );
    if( result != paNoError )
    {
        goto error;
    }

    paWasapi->allocations = PaUtil_CreateAllocationGroup();
    if (paWasapi->allocations == NULL)
	{
        result = paInsufficientMemory;
        goto error;
    }

    *hostApi                             = &paWasapi->inheritedHostApiRep;
    (*hostApi)->info.structVersion		 = 1;
    (*hostApi)->info.type				 = paWASAPI;
    (*hostApi)->info.name				 = "Windows WASAPI";
    (*hostApi)->info.deviceCount		 = 0;
    (*hostApi)->info.defaultInputDevice	 = paNoDevice;
    (*hostApi)->info.defaultOutputDevice = paNoDevice;

#ifndef PA_WINRT
    paWasapi->enumerator = NULL;
    hr = CoCreateInstance(&pa_CLSID_IMMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER,
             &pa_IID_IMMDeviceEnumerator, (void **)&paWasapi->enumerator);
    
	// We need to set the result to a value otherwise we will return paNoError
	// [IF_FAILED_JUMP(hResult, error);]
	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

    // getting default device ids in the eMultimedia "role"
    {
        {
            IMMDevice *defaultRenderer = NULL;
            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eRender, eMultimedia, &defaultRenderer);
            if (hr != S_OK)
			{
				if (hr != E_NOTFOUND) {
					// We need to set the result to a value otherwise we will return paNoError
					// [IF_FAILED_JUMP(hResult, error);]
					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
				}
			}
			else
			{
				WCHAR *pszDeviceId = NULL;
				hr = IMMDevice_GetId(defaultRenderer, &pszDeviceId);
				// We need to set the result to a value otherwise we will return paNoError
				// [IF_FAILED_JUMP(hResult, error);]
				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
				wcsncpy(paWasapi->defaultRenderer, pszDeviceId, MAX_STR_LEN-1);
				CoTaskMemFree(pszDeviceId);
				IMMDevice_Release(defaultRenderer);
			}
        }

        {
            IMMDevice *defaultCapturer = NULL;
            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eCapture, eMultimedia, &defaultCapturer);
            if (hr != S_OK)
			{
				if (hr != E_NOTFOUND) {
					// We need to set the result to a value otherwise we will return paNoError
					// [IF_FAILED_JUMP(hResult, error);]
					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
				}
			}
			else
			{
				WCHAR *pszDeviceId = NULL;
				hr = IMMDevice_GetId(defaultCapturer, &pszDeviceId);
				// We need to set the result to a value otherwise we will return paNoError
				// [IF_FAILED_JUMP(hResult, error);]
				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
				wcsncpy(paWasapi->defaultCapturer, pszDeviceId, MAX_STR_LEN-1);
				CoTaskMemFree(pszDeviceId);
				IMMDevice_Release(defaultCapturer);
			}
        }
    }

    hr = IMMDeviceEnumerator_EnumAudioEndpoints(paWasapi->enumerator, eAll, DEVICE_STATE_ACTIVE, &pEndPoints);
	// We need to set the result to a value otherwise we will return paNoError
	// [IF_FAILED_JUMP(hResult, error);]
	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

    hr = IMMDeviceCollection_GetCount(pEndPoints, &paWasapi->deviceCount);
	// We need to set the result to a value otherwise we will return paNoError
	// [IF_FAILED_JUMP(hResult, error);]
	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

#else
	paWasapi->deviceCount = 2;
#endif

    paWasapi->devInfo = (PaWasapiDeviceInfo *)PaUtil_AllocateMemory(sizeof(PaWasapiDeviceInfo) * paWasapi->deviceCount);
    if (paWasapi->devInfo == NULL)
	{
        result = paInsufficientMemory;
        goto error;
    }
	for (i = 0; i < paWasapi->deviceCount; ++i)
		memset(&paWasapi->devInfo[i], 0, sizeof(PaWasapiDeviceInfo));

    if (paWasapi->deviceCount > 0)
    {
        (*hostApi)->deviceInfos = (PaDeviceInfo **)PaUtil_GroupAllocateMemory(
                paWasapi->allocations, sizeof(PaDeviceInfo *) * paWasapi->deviceCount);
        if ((*hostApi)->deviceInfos == NULL)
		{
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all device info structs in a contiguous block */
        deviceInfoArray = (PaDeviceInfo *)PaUtil_GroupAllocateMemory(
                paWasapi->allocations, sizeof(PaDeviceInfo) * paWasapi->deviceCount);
        if (deviceInfoArray == NULL)
		{
            result = paInsufficientMemory;
            goto error;
        }

        for (i = 0; i < paWasapi->deviceCount; ++i)
		{
            PaDeviceInfo *deviceInfo  = &deviceInfoArray[i];
            deviceInfo->structVersion = 2;
            deviceInfo->hostApi       = hostApiIndex;

			PA_DEBUG(("WASAPI: device idx: %02d\n", i));
			PA_DEBUG(("WASAPI: ---------------\n"));

		#ifndef PA_WINRT
            hr = IMMDeviceCollection_Item(pEndPoints, i, &paWasapi->devInfo[i].device);
			// We need to set the result to a value otherwise we will return paNoError
			// [IF_FAILED_JUMP(hResult, error);]
			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

            // getting ID
            {
                WCHAR *pszDeviceId = NULL;
                hr = IMMDevice_GetId(paWasapi->devInfo[i].device, &pszDeviceId);
				// We need to set the result to a value otherwise we will return paNoError
				// [IF_FAILED_JUMP(hr, error);]
				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
                wcsncpy(paWasapi->devInfo[i].szDeviceID, pszDeviceId, MAX_STR_LEN-1);
                CoTaskMemFree(pszDeviceId);

                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultCapturer) == 0)
				{// we found the default input!
                    (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
                }
                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultRenderer) == 0)
				{// we found the default output!
                    (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
                }
            }

            hr = IMMDevice_GetState(paWasapi->devInfo[i].device, &paWasapi->devInfo[i].state);
			// We need to set the result to a value otherwise we will return paNoError
			// [IF_FAILED_JUMP(hResult, error);]
			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

            if (paWasapi->devInfo[i].state != DEVICE_STATE_ACTIVE)
			{
                PRINT(("WASAPI device: %d is not currently available (state:%d)\n", i, paWasapi->devInfo[i].state));
            }

            {
                IPropertyStore *pProperty;
                hr = IMMDevice_OpenPropertyStore(paWasapi->devInfo[i].device, STGM_READ, &pProperty);
				// We need to set the result to a value otherwise we will return paNoError
				// [IF_FAILED_JUMP(hResult, error);]
				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

                // "Friendly" Name
                {
					char *deviceName;
                    PROPVARIANT value;
                    PropVariantInit(&value);
                    hr = IPropertyStore_GetValue(pProperty, &PKEY_Device_FriendlyName, &value);
					// We need to set the result to a value otherwise we will return paNoError
					// [IF_FAILED_JUMP(hResult, error);]
					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
                    deviceInfo->name = NULL;
                    deviceName = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
                    if (deviceName == NULL)
					{
                        result = paInsufficientMemory;
                        goto error;
                    }
					if (value.pwszVal)
						WideCharToMultiByte(CP_UTF8, 0, value.pwszVal, (int)wcslen(value.pwszVal), deviceName, MAX_STR_LEN - 1, 0, 0);
					else
						_snprintf(deviceName, MAX_STR_LEN - 1, "baddev%d", i);
                    deviceInfo->name = deviceName;
                    PropVariantClear(&value);
					PA_DEBUG(("WASAPI:%d| name[%s]\n", i, deviceInfo->name));
                }

                // Default format
                {
                    PROPVARIANT value;
                    PropVariantInit(&value);
                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEngine_DeviceFormat, &value);
					// We need to set the result to a value otherwise we will return paNoError
					// [IF_FAILED_JUMP(hResult, error);]
					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
					memcpy(&paWasapi->devInfo[i].DefaultFormat, value.blob.pBlobData, min(sizeof(paWasapi->devInfo[i].DefaultFormat), value.blob.cbSize));
                    // cleanup
                    PropVariantClear(&value);
                }

                // Formfactor
                {
                    PROPVARIANT value;
                    PropVariantInit(&value);
                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEndpoint_FormFactor, &value);
					// We need to set the result to a value otherwise we will return paNoError
					// [IF_FAILED_JUMP(hResult, error);]
					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
					// set
					#if defined(DUMMYUNIONNAME) && defined(NONAMELESSUNION)
						// avoid breaking strict-aliasing rules in such line: (EndpointFormFactor)(*((UINT *)(((WORD *)&value.wReserved3)+1)));
						UINT v;
						memcpy(&v, (((WORD *)&value.wReserved3)+1), sizeof(v));
						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)v;
					#else
						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)value.uintVal;
					#endif
					PA_DEBUG(("WASAPI:%d| form-factor[%d]\n", i, paWasapi->devInfo[i].formFactor));
                    // cleanup
                    PropVariantClear(&value);
                }

				SAFE_RELEASE(pProperty);
            }
			
            // Endpoint data
            {
                IMMEndpoint *endpoint = NULL;
                hr = IMMDevice_QueryInterface(paWasapi->devInfo[i].device, &pa_IID_IMMEndpoint, (void **)&endpoint);
                if (SUCCEEDED(hr))
				{
                    hr = IMMEndpoint_GetDataFlow(endpoint, &paWasapi->devInfo[i].flow);
                    SAFE_RELEASE(endpoint);
                }
            }
		#endif

            // Getting a temporary IAudioClient for more fields
            // we make sure NOT to call Initialize yet!
            {
			#ifdef PA_WINRT
				// Set flow as ActivateAudioInterface depends on it and selects corresponding 
				// direction for the Audio Client
				paWasapi->devInfo[i].flow = (i == 0 ? eRender : eCapture);
			#endif

				// Create temp Audio Client instance to query additional details
                IAudioClient *tmpClient = NULL;
                hr = ActivateAudioInterface(&paWasapi->devInfo[i], &tmpClient);
				// We need to set the result to a value otherwise we will return paNoError
				// [IF_FAILED_JUMP(hResult, error);]
				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);

				// Get latency
                hr = IAudioClient_GetDevicePeriod(tmpClient,
                    &paWasapi->devInfo[i].DefaultDevicePeriod,
                    &paWasapi->devInfo[i].MinimumDevicePeriod);
				if (FAILED(hr))
				{
					PA_DEBUG(("WASAPI:%d| failed getting min/default periods by IAudioClient::GetDevicePeriod() with error[%08X], will use 30000/100000 hns\n", i, (UINT32)hr));

					// assign WASAPI common values
					paWasapi->devInfo[i].DefaultDevicePeriod = 100000;
					paWasapi->devInfo[i].MinimumDevicePeriod = 30000;

					// ignore error, let continue further without failing with paInternalError
					hr = S_OK;
				}
				
			#ifdef PA_WINRT
				// Get mix format which will treat as default device format
				hr = IAudioClient_GetMixFormat(tmpClient, &mixFormat);
				if (SUCCEEDED(hr))
				{
					// Default device
					if (i == 0)
						(*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
					else
						(*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;

					// State
					paWasapi->devInfo[i].state = DEVICE_STATE_ACTIVE;

					// Default format
					memcpy(&paWasapi->devInfo[i].DefaultFormat, mixFormat, min(sizeof(paWasapi->devInfo[i].DefaultFormat), sizeof(*mixFormat)));
					CoTaskMemFree(mixFormat);

					// Form-factor
					paWasapi->devInfo[i].formFactor = UnknownFormFactor;

					// Name
                    deviceInfo->name = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
                    if (deviceInfo->name == NULL)
					{
						SAFE_RELEASE(tmpClient);
                        result = paInsufficientMemory;
                        goto error;
                    }
					_snprintf((char *)deviceInfo->name, MAX_STR_LEN - 1, "WASAPI_%s:%d", (i == 0 ? "Output" : "Input"), i);
					PA_DEBUG(("WASAPI:%d| name[%s]\n", i, deviceInfo->name));
				}
			#endif

				// Release tmp client
				SAFE_RELEASE(tmpClient);

				if (hr != S_OK)
				{
					//davidv: this happened with my hardware, previously for that same device in DirectSound:
					//Digital Output (Realtek AC'97 Audio)'s GUID: {0x38f2cf50,0x7b4c,0x4740,0x86,0xeb,0xd4,0x38,0x66,0xd8,0xc8, 0x9f}
					//so something must be _really_ wrong with this device, TODO handle this better. We kind of need GetMixFormat
					LogHostError(hr);
					// We need to set the result to a value otherwise we will return paNoError
					result = paInternalError;
					goto error;
				}
            }
			
            // we can now fill in portaudio device data
            deviceInfo->maxInputChannels  = 0;
            deviceInfo->maxOutputChannels = 0;
			deviceInfo->defaultSampleRate = paWasapi->devInfo[i].DefaultFormat.Format.nSamplesPerSec;
            switch (paWasapi->devInfo[i].flow)
			{
			case eRender: {
                deviceInfo->maxOutputChannels		 = paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
                deviceInfo->defaultHighOutputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
                deviceInfo->defaultLowOutputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
					deviceInfo->maxOutputChannels, (float)deviceInfo->defaultHighOutputLatency, (float)deviceInfo->defaultLowOutputLatency));
				break;}
			case eCapture: {
                deviceInfo->maxInputChannels		= paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
                deviceInfo->defaultHighInputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
                deviceInfo->defaultLowInputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
					deviceInfo->maxInputChannels, (float)deviceInfo->defaultHighInputLatency, (float)deviceInfo->defaultLowInputLatency));
				break; }
            default:
                PRINT(("WASAPI:%d| bad Data Flow!\n", i));
				// We need to set the result to a value otherwise we will return paNoError
				result = paInternalError;
                //continue; // do not skip from list, allow to initialize
				 break;
            }

            (*hostApi)->deviceInfos[i] = deviceInfo;
            ++(*hostApi)->info.deviceCount;
        }
    }

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &paWasapi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &paWasapi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );


	// findout if platform workaround is required
	paWasapi->useWOW64Workaround = UseWOW64Workaround();

#ifndef PA_WINRT
    SAFE_RELEASE(pEndPoints);
#endif

	PRINT(("WASAPI: initialized ok\n"));

    return paNoError;

error:

	PRINT(("WASAPI: failed %s error[%d|%s]\n", __FUNCTION__, result, Pa_GetErrorText(result)));

#ifndef PA_WINRT
    SAFE_RELEASE(pEndPoints);
#endif

	Terminate((PaUtilHostApiRepresentation *)paWasapi);

	// Safety if error was not set so that we do not think initialize was a success
	if (result == paNoError) {
		result = paInternalError;
	}

    return result;
}

// ------------------------------------------------------------------------------------------
static void Terminate( PaUtilHostApiRepresentation *hostApi )
{
	UINT i;
    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
	if (paWasapi == NULL)
		return;

	// Release IMMDeviceEnumerator
#ifndef PA_WINRT
    SAFE_RELEASE(paWasapi->enumerator);
#endif

	// Release device info bound objects and device info itself
    for (i = 0; i < paWasapi->deviceCount; ++i)
	{
        PaWasapiDeviceInfo *info = &paWasapi->devInfo[i];
	#ifndef PA_WINRT
        SAFE_RELEASE(info->device);
	#else
		(void)info;
	#endif
    }
    PaUtil_FreeMemory(paWasapi->devInfo);

    if (paWasapi->allocations)
	{
        PaUtil_FreeAllAllocations(paWasapi->allocations);
        PaUtil_DestroyAllocationGroup(paWasapi->allocations);
    }

    PaWinUtil_CoUninitialize( paWASAPI, &paWasapi->comInitializationResult );

    PaUtil_FreeMemory(paWasapi);

	// Close AVRT
	CloseAVRT();
}

// ------------------------------------------------------------------------------------------
static PaWasapiHostApiRepresentation *_GetHostApi(PaError *_error)
{
	PaError error;

	PaUtilHostApiRepresentation *pApi;
	if ((error = PaUtil_GetHostApiRepresentation(&pApi, paWASAPI)) != paNoError)
	{
		if (_error != NULL)
			(*_error) = error;

		return NULL;
	}
	return (PaWasapiHostApiRepresentation *)pApi;
}

// ------------------------------------------------------------------------------------------
int PaWasapi_GetDeviceDefaultFormat( void *pFormat, unsigned int nFormatSize, PaDeviceIndex nDevice )
{
	PaError ret;
	PaWasapiHostApiRepresentation *paWasapi;
	UINT32 size;
	PaDeviceIndex index;

	if (pFormat == NULL)
		return paBadBufferPtr;
	if (nFormatSize <= 0)
		return paBufferTooSmall;

	// Get API
	paWasapi = _GetHostApi(&ret);
	if (paWasapi == NULL)
		return ret;

	// Get device index
	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
    if (ret != paNoError)
        return ret;

	// Validate index
	if ((UINT32)index >= paWasapi->deviceCount)
		return paInvalidDevice;

	size = min(nFormatSize, (UINT32)sizeof(paWasapi->devInfo[ index ].DefaultFormat));
	memcpy(pFormat, &paWasapi->devInfo[ index ].DefaultFormat, size);

	return size;
}

// ------------------------------------------------------------------------------------------
int PaWasapi_GetDeviceRole( PaDeviceIndex nDevice )
{
	PaError ret;
	PaDeviceIndex index;

	// Get API
	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
	if (paWasapi == NULL)
		return paNotInitialized;

	// Get device index
	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
    if (ret != paNoError)
        return ret;

	// Validate index
	if ((UINT32)index >= paWasapi->deviceCount)
		return paInvalidDevice;

	return paWasapi->devInfo[ index ].formFactor;
}

// ------------------------------------------------------------------------------------------
PaError PaWasapi_GetFramesPerHostBuffer( PaStream *pStream, unsigned int *nInput, unsigned int *nOutput )
{
    PaWasapiStream *stream = (PaWasapiStream *)pStream;
	if (stream == NULL)
		return paBadStreamPtr;

	if (nInput != NULL)
		(*nInput) = stream->in.framesPerHostCallback;

	if (nOutput != NULL)
		(*nOutput) = stream->out.framesPerHostCallback;

	return paNoError;
}

// ------------------------------------------------------------------------------------------
static void LogWAVEFORMATEXTENSIBLE(const WAVEFORMATEXTENSIBLE *in)
{
    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;
	switch (old->wFormatTag)
	{
	case WAVE_FORMAT_EXTENSIBLE: {

		PRINT(("wFormatTag     =WAVE_FORMAT_EXTENSIBLE\n"));

		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
		{
			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\n"));
		}
		else
		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
		{
			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_PCM\n"));
		}
		else
		{
			PRINT(("SubFormat      =CUSTOM GUID{%d:%d:%d:%d%d%d%d%d%d%d%d}\n",
										in->SubFormat.Data1,
										in->SubFormat.Data2,
										in->SubFormat.Data3,
										(int)in->SubFormat.Data4[0],
										(int)in->SubFormat.Data4[1],
										(int)in->SubFormat.Data4[2],
										(int)in->SubFormat.Data4[3],
										(int)in->SubFormat.Data4[4],
										(int)in->SubFormat.Data4[5],
										(int)in->SubFormat.Data4[6],
										(int)in->SubFormat.Data4[7]));
		}
		PRINT(("Samples.wValidBitsPerSample =%d\n",  in->Samples.wValidBitsPerSample));
		PRINT(("dwChannelMask  =0x%X\n",in->dwChannelMask));

		break; }

	case WAVE_FORMAT_PCM:        PRINT(("wFormatTag     =WAVE_FORMAT_PCM\n")); break;
	case WAVE_FORMAT_IEEE_FLOAT: PRINT(("wFormatTag     =WAVE_FORMAT_IEEE_FLOAT\n")); break;
	default: 
		PRINT(("wFormatTag     =UNKNOWN(%d)\n",old->wFormatTag)); break;
	}

	PRINT(("nChannels      =%d\n",old->nChannels));
	PRINT(("nSamplesPerSec =%d\n",old->nSamplesPerSec));
	PRINT(("nAvgBytesPerSec=%d\n",old->nAvgBytesPerSec));
	PRINT(("nBlockAlign    =%d\n",old->nBlockAlign));
	PRINT(("wBitsPerSample =%d\n",old->wBitsPerSample));
	PRINT(("cbSize         =%d\n",old->cbSize));
}

// ------------------------------------------------------------------------------------------
static PaSampleFormat WaveToPaFormat(const WAVEFORMATEXTENSIBLE *in)
{
    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;

    switch (old->wFormatTag)
	{
    case WAVE_FORMAT_EXTENSIBLE: {
        if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
		{
            if (in->Samples.wValidBitsPerSample == 32)
                return paFloat32;
        }
        else
		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
		{
            switch (old->wBitsPerSample)
			{
                case 32: return paInt32;
                case 24: return paInt24;
                case  8: return paUInt8;
                case 16: return paInt16;
            }
        }
		break; }

    case WAVE_FORMAT_IEEE_FLOAT:
		return paFloat32;

    case WAVE_FORMAT_PCM: {
        switch (old->wBitsPerSample)
		{
            case 32: return paInt32;
            case 24: return paInt24;
            case  8: return paUInt8;
            case 16: return paInt16;
        }
		break; }
    }

    return paCustomFormat;
}

// ------------------------------------------------------------------------------------------
static PaError MakeWaveFormatFromParams(WAVEFORMATEXTENSIBLE *wavex, const PaStreamParameters *params,
									double sampleRate)
{
	WORD bitsPerSample;
	WAVEFORMATEX *old;
	DWORD channelMask = 0;
	PaWasapiStreamInfo *streamInfo = (PaWasapiStreamInfo *)params->hostApiSpecificStreamInfo;

	// Get user assigned channel mask
	if ((streamInfo != NULL) && (streamInfo->flags & paWinWasapiUseChannelMask))
		channelMask = streamInfo->channelMask;

	// Convert PaSampleFormat to bits per sample
	if ((bitsPerSample = PaSampleFormatToBitsPerSample(params->sampleFormat)) == 0)
		return paSampleFormatNotSupported;

    memset(wavex, 0, sizeof(*wavex));

    old					 = (WAVEFORMATEX *)wavex;
    old->nChannels       = (WORD)params->channelCount;
    old->nSamplesPerSec  = (DWORD)sampleRate;
	if ((old->wBitsPerSample = bitsPerSample) > 16)
	{
		old->wBitsPerSample = 32; // 20 or 24 bits must go in 32 bit containers (ints)
	}
    old->nBlockAlign     = (old->nChannels * (old->wBitsPerSample/8));
    old->nAvgBytesPerSec = (old->nSamplesPerSec * old->nBlockAlign);

    // WAVEFORMATEX
    if ((params->channelCount <= 2) && ((bitsPerSample == 16) || (bitsPerSample == 8)))
	{
        old->cbSize		= 0;
        old->wFormatTag	= WAVE_FORMAT_PCM;
    }
    // WAVEFORMATEXTENSIBLE
    else
	{
        old->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
        old->cbSize		= sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);

        if ((params->sampleFormat & ~paNonInterleaved) == paFloat32)
            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
        else
            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;

        wavex->Samples.wValidBitsPerSample = bitsPerSample; //no extra padding!

		// Set channel mask
		if (channelMask != 0)
		{
			wavex->dwChannelMask = channelMask;
		}
		else
		{
			switch (params->channelCount)
			{
			case 1:  wavex->dwChannelMask = PAWIN_SPEAKER_MONO; break;
			case 2:  wavex->dwChannelMask = PAWIN_SPEAKER_STEREO; break;
			case 3:  wavex->dwChannelMask = PAWIN_SPEAKER_STEREO|SPEAKER_LOW_FREQUENCY; break;
			case 4:  wavex->dwChannelMask = PAWIN_SPEAKER_QUAD; break;
			case 5:  wavex->dwChannelMask = PAWIN_SPEAKER_QUAD|SPEAKER_LOW_FREQUENCY; break;
#ifdef PAWIN_SPEAKER_5POINT1_SURROUND
			case 6:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1_SURROUND; break;
#else
			case 6:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1; break;
#endif
#ifdef PAWIN_SPEAKER_5POINT1_SURROUND
			case 7:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1_SURROUND|SPEAKER_BACK_CENTER; break;
#else
			case 7:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1|SPEAKER_BACK_CENTER; break;
#endif	
#ifdef PAWIN_SPEAKER_7POINT1_SURROUND
			case 8:  wavex->dwChannelMask = PAWIN_SPEAKER_7POINT1_SURROUND; break;
#else
			case 8:  wavex->dwChannelMask = PAWIN_SPEAKER_7POINT1; break;
#endif

			default: wavex->dwChannelMask = 0;
			}
		}
	}
    return paNoError;
}

// ------------------------------------------------------------------------------------------
/*static void wasapiFillWFEXT( WAVEFORMATEXTENSIBLE* pwfext, PaSampleFormat sampleFormat, double sampleRate, int channelCount)
{
    PA_DEBUG(( "sampleFormat = %lx\n" , sampleFormat ));
    PA_DEBUG(( "sampleRate = %f\n" , sampleRate ));
    PA_DEBUG(( "chanelCount = %d\n", channelCount ));

    pwfext->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
    pwfext->Format.nChannels = (WORD)channelCount;
    pwfext->Format.nSamplesPerSec = (DWORD)sampleRate;
    if(channelCount == 1)
        pwfext->dwChannelMask = PAWIN_SPEAKER_DIRECTOUT;
    else
        pwfext->dwChannelMask = PAWIN_SPEAKER_STEREO;
    if(sampleFormat == paFloat32)
    {
        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
        pwfext->Format.wBitsPerSample = 32;
        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
        pwfext->Samples.wValidBitsPerSample = 32;
        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
    }
    else if(sampleFormat == paInt32)
    {
        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
        pwfext->Format.wBitsPerSample = 32;
        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
        pwfext->Samples.wValidBitsPerSample = 32;
        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
    }
    else if(sampleFormat == paInt24)
    {
        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
        pwfext->Format.wBitsPerSample = 32; // 24-bit in 32-bit int container
        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
        pwfext->Samples.wValidBitsPerSample = 24;
        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
    }
    else if(sampleFormat == paInt16)
    {
        pwfext->Format.nBlockAlign = (WORD)(channelCount * 2);
        pwfext->Format.wBitsPerSample = 16;
        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
        pwfext->Samples.wValidBitsPerSample = 16;
        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
    }
    pwfext->Format.nAvgBytesPerSec = pwfext->Format.nSamplesPerSec * pwfext->Format.nBlockAlign;
}*/

// ------------------------------------------------------------------------------------------
static PaError GetClosestFormat(IAudioClient *myClient, double sampleRate,
	const PaStreamParameters *_params, AUDCLNT_SHAREMODE shareMode, WAVEFORMATEXTENSIBLE *outWavex,
	BOOL output)
{
	PaError answer                   = paInvalidSampleRate;
	WAVEFORMATEX *sharedClosestMatch = NULL;
	HRESULT hr                       = !S_OK;
	PaStreamParameters params       = (*_params);
	(void)output;

	/* It was not noticed that 24-bit Input producing no output while device accepts this format.
	   To fix this issue let's ask for 32-bits and let PA converters convert host 32-bit data
	   to 24-bit for user-space. The bug concerns Vista, if Windows 7 supports 24-bits for Input
	   please report to PortAudio developers to exclude Windows 7.
	*/
	/*if ((params.sampleFormat == paInt24) && (output == FALSE))
		params.sampleFormat = paFloat32;*/ // <<< The silence was due to missing Int32_To_Int24_Dither implementation

    MakeWaveFormatFromParams(outWavex, &params, sampleRate);

	hr = IAudioClient_IsFormatSupported(myClient, shareMode, &outWavex->Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
	if (hr == S_OK)
		answer = paFormatIsSupported;
    else
	if (sharedClosestMatch)
	{
		WORD bitsPerSample;
        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)sharedClosestMatch;

		GUID subf_guid = GUID_NULL;
		if (sharedClosestMatch->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
		{
			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEXTENSIBLE));
			subf_guid = ext->SubFormat;
		}
		else
			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEX));

        CoTaskMemFree(sharedClosestMatch);

		// Make supported by default
		answer = paFormatIsSupported;

		// Validate SampleRate
		if ((DWORD)sampleRate != outWavex->Format.nSamplesPerSec)
			return paInvalidSampleRate;

		// Validate Channel count
		if ((WORD)params.channelCount != outWavex->Format.nChannels)
		{
			// If mono, then driver does not support 1 channel, we use internal workaround
			// of tiny software mixing functionality, e.g. we provide to user buffer 1 channel
			// but then mix into 2 for device buffer
			if ((params.channelCount == 1) && (outWavex->Format.nChannels == 2))
				return paFormatIsSupported;
			else
				return paInvalidChannelCount;
		}

		// Validate Sample format
		if ((bitsPerSample = PaSampleFormatToBitsPerSample(params.sampleFormat)) == 0)
			return paSampleFormatNotSupported;

		// Validate Sample format: bit size (WASAPI does not limit 'bit size')
		//if (bitsPerSample != outWavex->Format.wBitsPerSample)
		//	return paSampleFormatNotSupported;

		// Validate Sample format: paFloat32 (WASAPI does not limit 'bit type')
		//if ((params->sampleFormat == paFloat32) && (subf_guid != KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
		//	return paSampleFormatNotSupported;

		// Validate Sample format: paInt32 (WASAPI does not limit 'bit type')
		//if ((params->sampleFormat == paInt32) && (subf_guid != KSDATAFORMAT_SUBTYPE_PCM))
		//	return paSampleFormatNotSupported;
	}
	else
	{
		static const int BestToWorst[] = { paFloat32, paInt24, paInt16 };
		int i;

		// Try combination stereo and we will use built-in mono-stereo mixer then
		if (params.channelCount == 1)
		{
			WAVEFORMATEXTENSIBLE stereo = { 0 };

			PaStreamParameters stereo_params = params;
			stereo_params.channelCount = 2;

			MakeWaveFormatFromParams(&stereo, &stereo_params, sampleRate);

			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &stereo.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
			if (hr == S_OK)
			{
				memcpy(outWavex, &stereo, sizeof(WAVEFORMATEXTENSIBLE));
				CoTaskMemFree(sharedClosestMatch);
				return (answer = paFormatIsSupported);
			}

			// Try selecting suitable sample type
			for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
			{
				WAVEFORMATEXTENSIBLE sample = { 0 };

				PaStreamParameters sample_params = stereo_params;
				sample_params.sampleFormat = BestToWorst[i];

				MakeWaveFormatFromParams(&sample, &sample_params, sampleRate);

				hr = IAudioClient_IsFormatSupported(myClient, shareMode, &sample.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
				if (hr == S_OK)
				{
					memcpy(outWavex, &sample, sizeof(WAVEFORMATEXTENSIBLE));
					CoTaskMemFree(sharedClosestMatch);
					return (answer = paFormatIsSupported);
				}
			}
		}

		// Try selecting suitable sample type
		for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
		{
			WAVEFORMATEXTENSIBLE spfmt = { 0 };

			PaStreamParameters spfmt_params = params;
			spfmt_params.sampleFormat = BestToWorst[i];

			MakeWaveFormatFromParams(&spfmt, &spfmt_params, sampleRate);

			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &spfmt.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
			if (hr == S_OK)
			{
				memcpy(outWavex, &spfmt, sizeof(WAVEFORMATEXTENSIBLE));
				CoTaskMemFree(sharedClosestMatch);
				answer = paFormatIsSupported;
				break;
			}
		}

		// Nothing helped
		LogHostError(hr);
	}

	return answer;
}

// ------------------------------------------------------------------------------------------
static PaError IsStreamParamsValid(struct PaUtilHostApiRepresentation *hostApi,
                                   const  PaStreamParameters *inputParameters,
                                   const  PaStreamParameters *outputParameters,
                                   double sampleRate)
{
	if (hostApi == NULL)
		return paHostApiNotFound;
	if ((UINT32)sampleRate == 0)
		return paInvalidSampleRate;

	if (inputParameters != NULL)
    {
        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
		if (inputParameters->sampleFormat & paCustomFormat)
            return paSampleFormatNotSupported;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if (inputParameters->device == paUseHostApiSpecificDeviceSpecification)
            return paInvalidDevice;

        /* check that input device can support inputChannelCount */
        if (inputParameters->channelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels)
            return paInvalidChannelCount;

        /* validate inputStreamInfo */
        if (inputParameters->hostApiSpecificStreamInfo)
		{
			PaWasapiStreamInfo *inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
	        if ((inputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
	            (inputStreamInfo->version != 1) ||
                (inputStreamInfo->hostApiType != paWASAPI))
	        {
	            return paIncompatibleHostApiSpecificStreamInfo;
	        }
		}

        return paNoError;
    }

    if (outputParameters != NULL)
    {
        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if (outputParameters->sampleFormat & paCustomFormat)
            return paSampleFormatNotSupported;

        /* unless alternate device specification is supported, reject the use of
            paUseHostApiSpecificDeviceSpecification */
        if (outputParameters->device == paUseHostApiSpecificDeviceSpecification)
            return paInvalidDevice;

        /* check that output device can support outputChannelCount */
        if (outputParameters->channelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels)
            return paInvalidChannelCount;

        /* validate outputStreamInfo */
        if(outputParameters->hostApiSpecificStreamInfo)
        {
			PaWasapiStreamInfo *outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
	        if ((outputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
	            (outputStreamInfo->version != 1) ||
                (outputStreamInfo->hostApiType != paWASAPI))
	        {
	            return paIncompatibleHostApiSpecificStreamInfo;
	        }
        }

		return paNoError;
    }

	return (inputParameters || outputParameters ? paNoError : paInternalError);
}

// ------------------------------------------------------------------------------------------
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const  PaStreamParameters *inputParameters,
                                  const  PaStreamParameters *outputParameters,
                                  double sampleRate )
{
	IAudioClient *tmpClient = NULL;
	PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;

	// Validate PaStreamParameters
	PaError error;
	if ((error = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
		return error;

    if (inputParameters != NULL)
    {
		WAVEFORMATEXTENSIBLE wavex;
		HRESULT hr;
		PaError answer;
		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
		inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;

		if (inputStreamInfo && (inputStreamInfo->flags & paWinWasapiExclusive))
			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;

		hr = ActivateAudioInterface(&paWasapi->devInfo[inputParameters->device], &tmpClient);
		if (hr != S_OK)
		{
			LogHostError(hr);
			return paInvalidDevice;
		}

		answer = GetClosestFormat(tmpClient, sampleRate, inputParameters, shareMode, &wavex, FALSE);
		SAFE_RELEASE(tmpClient);

		if (answer != paFormatIsSupported)
			return answer;
    }

    if (outputParameters != NULL)
    {
		HRESULT hr;
		WAVEFORMATEXTENSIBLE wavex;
		PaError answer;
		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
        outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;

		if (outputStreamInfo && (outputStreamInfo->flags & paWinWasapiExclusive))
			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;

		hr = ActivateAudioInterface(&paWasapi->devInfo[outputParameters->device], &tmpClient);
		if (hr != S_OK)
		{
			LogHostError(hr);
			return paInvalidDevice;
		}

		answer = GetClosestFormat(tmpClient, sampleRate, outputParameters, shareMode, &wavex, TRUE);
		SAFE_RELEASE(tmpClient);

		if (answer != paFormatIsSupported)
			return answer;
    }

    return paFormatIsSupported;
}

// ------------------------------------------------------------------------------------------
static PaUint32 PaUtil_GetFramesPerHostBuffer(PaUint32 userFramesPerBuffer, PaTime suggestedLatency, double sampleRate, PaUint32 TimerJitterMs)
{
	PaUint32 frames = userFramesPerBuffer + max( userFramesPerBuffer, (PaUint32)(suggestedLatency * sampleRate) );
    frames += (PaUint32)((sampleRate * 0.001) * TimerJitterMs);
	return frames;
}

// ------------------------------------------------------------------------------------------
static void _RecalculateBuffersCount(PaWasapiSubStream *sub, UINT32 userFramesPerBuffer, UINT32 framesPerLatency, BOOL fullDuplex)
{
	// Count buffers (must be at least 1)
	sub->buffers = (userFramesPerBuffer ? framesPerLatency / userFramesPerBuffer : 0);
	if (sub->buffers == 0)
		sub->buffers = 1;

	// Determine amount of buffers used:
	// - Full-duplex mode will lead to period difference, thus only 1.
	// - Input mode, only 1, as WASAPI allows extraction of only 1 packet.
	// - For Shared mode we use double buffering.
	if ((sub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) || fullDuplex)
	{
		// Exclusive mode does not allow >1 buffers be used for Event interface, e.g. GetBuffer
		// call must acquire max buffer size and it all must be processed.
		if (sub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)
			sub->userBufferAndHostMatch = 1;

		// Use paUtilBoundedHostBufferSize because exclusive mode will starve and produce
		// bad quality of audio
		sub->buffers = 1;
	}
}

// ------------------------------------------------------------------------------------------
static void _CalculateAlignedPeriod(PaWasapiSubStream *pSub, UINT32 *nFramesPerLatency,
									ALIGN_FUNC pAlignFunc)
{
	// Align frames to HD Audio packet size of 128 bytes for Exclusive mode only.
	// Not aligning on Windows Vista will cause Event timeout, although Windows 7 will
	// return AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED error to realign buffer. Aligning is necessary
	// for Exclusive mode only! when audio data is feeded directly to hardware.
	if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
	{
		(*nFramesPerLatency) = AlignFramesPerBuffer((*nFramesPerLatency),
			pSub->wavex.Format.nSamplesPerSec, pSub->wavex.Format.nBlockAlign, pAlignFunc);
	}

	// Calculate period
	pSub->period = MakeHnsPeriod((*nFramesPerLatency), pSub->wavex.Format.nSamplesPerSec);
}

// ------------------------------------------------------------------------------------------
static HRESULT CreateAudioClient(PaWasapiStream *pStream, PaWasapiSubStream *pSub, BOOL output, PaError *pa_error)
{
	PaError error;
    HRESULT hr;

	const PaWasapiDeviceInfo *pInfo  = pSub->params.device_info;
	const PaStreamParameters *params = &pSub->params.stream_params;
	UINT32 framesPerLatency          = pSub->params.frames_per_buffer;
	double sampleRate                = pSub->params.sample_rate;
	//BOOL blocking                    = pSub->params.blocking;
	BOOL fullDuplex                  = pSub->params.full_duplex;

	const UINT32 userFramesPerBuffer = framesPerLatency;
    IAudioClient *audioClient	     = NULL;

	// Assume default failure due to some reason
	(*pa_error) = paInvalidDevice;

	// Validate parameters
    if (!pSub || !pInfo || !params)
	{
		(*pa_error) = paBadStreamPtr;
        return E_POINTER;
	}
	if ((UINT32)sampleRate == 0)
	{
		(*pa_error) = paInvalidSampleRate;
        return E_INVALIDARG;
	}

    // Get the audio client
    hr = ActivateAudioInterface(pInfo, &audioClient);
	if (hr != S_OK)
	{
		(*pa_error) = paInsufficientMemory;
		LogHostError(hr);
		goto done;
	}

	// Get closest format
	if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
	{
		(*pa_error) = error;
		LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
		goto done; // fail, format not supported
	}

	// Check for Mono <<>> Stereo workaround
	if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
	{
		/*if (blocking)
		{
			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
			goto done; // fail, blocking mode not supported
		}*/

		// select mixer
		pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
		if (pSub->monoMixer == NULL)
		{
			(*pa_error) = paInvalidChannelCount;
			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
			goto done; // fail, no mixer for format
		}
	}

#if 0
	// Add suggestd latency
	framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);
#else
	// Calculate host buffer size
	if ((pSub->shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE) &&
		(!pSub->streamFlags || ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
	{
		framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
			params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
			(pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);
	}
	else
	{
		REFERENCE_TIME overall;

		// Work 1:1 with user buffer (only polling allows to use >1)
		framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);

		// Use Polling if overall latency is > 5ms as it allows to use 100% CPU in a callback,
		// or user specified latency parameter
		overall = MakeHnsPeriod(framesPerLatency, pSub->wavex.Format.nSamplesPerSec);
		if ((overall >= (106667*2)/*21.33ms*/) || ((INT32)(params->suggestedLatency*100000.0) != 0/*0.01 msec granularity*/))
		{
			framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
				params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
				(streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);

			// Use Polling interface
			pSub->streamFlags &= ~AUDCLNT_STREAMFLAGS_EVENTCALLBACK;
			PRINT(("WASAPI: CreateAudioClient: forcing POLL mode\n"));
		}
	}
#endif

	// For full-duplex output resize buffer to be the same as for input
	if (output && fullDuplex)
		framesPerLatency = pStream->in.framesPerHostCallback;

	// Avoid 0 frames
	if (framesPerLatency == 0)
		framesPerLatency = MakeFramesFromHns(pInfo->DefaultDevicePeriod, pSub->wavex.Format.nSamplesPerSec);

	// Exclusive Input stream renders data in 6 packets, we must set then the size of
	// single packet, total buffer size, e.g. required latency will be PacketSize * 6
	if (!output && (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE))
	{
		// Do it only for Polling mode
		if ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)
		{
			framesPerLatency /= WASAPI_PACKETS_PER_INPUT_BUFFER;
		}
	}

	// Calculate aligned period
	_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);

	/*! Enforce min/max period for device in Shared mode to avoid bad audio quality.
        Avoid doing so for Exclusive mode as alignment will suffer.
	*/
	if (pSub->shareMode == AUDCLNT_SHAREMODE_SHARED)
	{
		if (pSub->period < pInfo->DefaultDevicePeriod)
		{
			pSub->period = pInfo->DefaultDevicePeriod;
			// Recalculate aligned period
			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
		}
	}
	else
	{
		if (pSub->period < pInfo->MinimumDevicePeriod)
		{
			pSub->period = pInfo->MinimumDevicePeriod;
			// Recalculate aligned period
			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_FWD);
		}
	}

	/*! Windows 7 does not allow to set latency lower than minimal device period and will
	    return error: AUDCLNT_E_INVALID_DEVICE_PERIOD. Under Vista we enforce the same behavior
	    manually for unified behavior on all platforms.
	*/
	{
		/*!	AUDCLNT_E_BUFFER_SIZE_ERROR: Applies to Windows 7 and later.
			Indicates that the buffer duration value requested by an exclusive-mode client is
			out of range. The requested duration value for pull mode must not be greater than
			500 milliseconds; for push mode the duration value must not be greater than 2 seconds.
		*/
		if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
		{
			static const REFERENCE_TIME MAX_BUFFER_EVENT_DURATION = 500  * 10000;
			static const REFERENCE_TIME MAX_BUFFER_POLL_DURATION  = 2000 * 10000;

			if (pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)	// pull mode, max 500ms
			{
				if (pSub->period > MAX_BUFFER_EVENT_DURATION)
				{
					pSub->period = MAX_BUFFER_EVENT_DURATION;
					// Recalculate aligned period
					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
				}
			}
			else														// push mode, max 2000ms
			{
				if (pSub->period > MAX_BUFFER_POLL_DURATION)
				{
					pSub->period = MAX_BUFFER_POLL_DURATION;
					// Recalculate aligned period
					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
				}
			}
		}
	}

	// Set Raw mode (applicable only to IAudioClient2)
#ifdef __IAudioClient2_INTERFACE_DEFINED__
	if (GetAudioClientVersion() >= 2)
	{
		pa_AudioClientProperties audioProps = { 0 };
		audioProps.cbSize     = sizeof(pa_AudioClientProperties);
		audioProps.bIsOffload = FALSE;
		audioProps.eCategory  = (AUDIO_STREAM_CATEGORY)pSub->params.wasapi_params.streamCategory;
		switch (pSub->params.wasapi_params.streamOption)
		{
		case eStreamOptionRaw:
			if (GetWindowsVersion() >= WINDOWS_8_1_SERVER2012R2)
				audioProps.Options = pa_AUDCLNT_STREAMOPTIONS_RAW;
			break;
		case eStreamOptionMatchFormat:
			if (GetWindowsVersion() >= WINDOWS_10_SERVER2016)
				audioProps.Options = pa_AUDCLNT_STREAMOPTIONS_MATCH_FORMAT;
			break;
		}

		hr = IAudioClient2_SetClientProperties((IAudioClient2 *)audioClient, (AudioClientProperties *)&audioProps);
		if (hr != S_OK)
		{
			PRINT(("WASAPI: IAudioClient2_SetClientProperties(Category = %d, Options = %d) failed with error = %08X\n", audioProps.eCategory, audioProps.Options, (UINT32)hr));
		}
		else
		{
			PRINT(("WASAPI: IAudioClient2 set properties: IsOffload = %d, Category = %d, Options = %d\n", audioProps.bIsOffload, audioProps.eCategory, audioProps.Options));
		}
	}
#endif

	// Open the stream and associate it with an audio session
    hr = IAudioClient_Initialize(audioClient,
        pSub->shareMode,
        pSub->streamFlags,
		pSub->period,
		(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
		&pSub->wavex.Format,
        NULL);

	/*! WASAPI is tricky on large device buffer, sometimes 2000ms can be allocated sometimes
	    less. There is no known guaranteed level thus we make subsequent tries by decreasing
		buffer by 100ms per try.
	*/
	while ((hr == E_OUTOFMEMORY) && (pSub->period > (100 * 10000)))
	{
		PRINT(("WASAPI: CreateAudioClient: decreasing buffer size to %d milliseconds\n", (pSub->period / 10000)));

		// Decrease by 100ms and try again
		pSub->period -= (100 * 10000);

		// Recalculate aligned period
		framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
		_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);

        // Release the previous allocations
        SAFE_RELEASE(audioClient);

        // Create a new audio client
        hr = ActivateAudioInterface(pInfo, &audioClient);
    	if (hr != S_OK)
		{
			(*pa_error) = paInsufficientMemory;
			LogHostError(hr);
			goto done;
		}

		// Open the stream and associate it with an audio session
		hr = IAudioClient_Initialize(audioClient,
			pSub->shareMode,
			pSub->streamFlags,
			pSub->period,
			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
			&pSub->wavex.Format,
			NULL);
	}

	/*! WASAPI buffer size failure. Fallback to using default size.
	*/
	if (hr == AUDCLNT_E_BUFFER_SIZE_ERROR)
	{
		// Use default
		pSub->period = pInfo->DefaultDevicePeriod;

		PRINT(("WASAPI: CreateAudioClient: correcting buffer size to device default\n"));

        // Release the previous allocations
        SAFE_RELEASE(audioClient);

        // Create a new audio client
        hr = ActivateAudioInterface(pInfo, &audioClient);
    	if (hr != S_OK)
		{
			(*pa_error) = paInsufficientMemory;
			LogHostError(hr);
			goto done;
		}

		// Open the stream and associate it with an audio session
		hr = IAudioClient_Initialize(audioClient,
			pSub->shareMode,
			pSub->streamFlags,
			pSub->period,
			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
			&pSub->wavex.Format,
			NULL);
	}

    /*! If the requested buffer size is not aligned. Can be triggered by Windows 7 and up.
	    Should not be be triggered ever as we do align buffers always with _CalculateAlignedPeriod.
	*/
    if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED)
    {
		UINT32 frames = 0;

        // Get the next aligned frame
        hr = IAudioClient_GetBufferSize(audioClient, &frames);
		if (hr != S_OK)
		{
			(*pa_error) = paInvalidDevice;
			LogHostError(hr);
			goto done;
		}

		PRINT(("WASAPI: CreateAudioClient: aligning buffer size to % frames\n", frames));

        // Release the previous allocations
        SAFE_RELEASE(audioClient);

        // Create a new audio client
        hr = ActivateAudioInterface(pInfo, &audioClient);
    	if (hr != S_OK)
		{
			(*pa_error) = paInsufficientMemory;
			LogHostError(hr);
			goto done;
		}

		// Get closest format
		if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
		{
			(*pa_error) = error;
			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT); // fail, format not supported
			goto done;
		}

		// Check for Mono >> Stereo workaround
		if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
		{
			/*if (blocking)
			{
				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
				goto done; // fail, blocking mode not supported
			}*/

			// Select mixer
			pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
			if (pSub->monoMixer == NULL)
			{
				(*pa_error) = paInvalidChannelCount;
				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
				goto done; // fail, no mixer for format
			}
		}

		// Calculate period
		pSub->period = MakeHnsPeriod(frames, pSub->wavex.Format.nSamplesPerSec);

        // Open the stream and associate it with an audio session
        hr = IAudioClient_Initialize(audioClient,
            pSub->shareMode,
            pSub->streamFlags,
			pSub->period,
			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
            &pSub->wavex.Format,
            NULL);
    	if (hr != S_OK)
		{
			(*pa_error) = paInvalidDevice;
			LogHostError(hr);
			goto done;
		}
    }
    else
	if (hr != S_OK)
    {
		(*pa_error) = paInvalidDevice;
		LogHostError(hr);
		goto done;
    }

    // Set client
	pSub->clientParent = audioClient;
    IAudioClient_AddRef(pSub->clientParent);

	// Recalculate buffers count
	_RecalculateBuffersCount(pSub,
		userFramesPerBuffer,
		MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec),
		fullDuplex);

	// No error, client is succesfully created
	(*pa_error) = paNoError;

done:

    // Clean up
    SAFE_RELEASE(audioClient);
    return hr;
}

// ------------------------------------------------------------------------------------------
static PaError ActivateAudioClientOutput(PaWasapiStream *stream)
{
	HRESULT hr;
	PaError result;

	UINT32 maxBufferSize   = 0;
	PaTime buffer_latency  = 0;
	UINT32 framesPerBuffer = stream->out.params.frames_per_buffer;

	// Create Audio client
	hr = CreateAudioClient(stream, &stream->out, TRUE, &result);
    if (hr != S_OK)
	{
		LogPaError(result);
		goto error;
    }
	LogWAVEFORMATEXTENSIBLE(&stream->out.wavex);

	// Activate volume
	stream->outVol = NULL;
    /*hr = info->device->Activate(
        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
        (void**)&stream->outVol);
    if (hr != S_OK)
        return paInvalidDevice;*/

    // Get max possible buffer size to check if it is not less than that we request
    hr = IAudioClient_GetBufferSize(stream->out.clientParent, &maxBufferSize);
    if (hr != S_OK)
	{
		LogHostError(hr);
		LogPaError(result = paInvalidDevice);
		goto error;
	}

    // Correct buffer to max size if it maxed out result of GetBufferSize
	stream->out.bufferSize = maxBufferSize;

	// Get interface latency (actually uneeded as we calculate latency from the size
	// of maxBufferSize).
    hr = IAudioClient_GetStreamLatency(stream->out.clientParent, &stream->out.deviceLatency);
    if (hr != S_OK)
	{
		LogHostError(hr);
		LogPaError(result = paInvalidDevice);
		goto error;
	}
	//stream->out.latencySeconds = nano100ToSeconds(stream->out.deviceLatency);

    // Number of frames that are required at each period
	stream->out.framesPerHostCallback = maxBufferSize;

	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
	stream->out.framesPerBuffer =
		(stream->out.userBufferAndHostMatch ? stream->out.framesPerHostCallback : framesPerBuffer);

	// Calculate buffer latency
	buffer_latency = (PaTime)maxBufferSize / stream->out.wavex.Format.nSamplesPerSec;

	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
	stream->out.latencySeconds = buffer_latency;

	PRINT(("WASAPI::OpenStream(output): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->out.framesPerHostCallback, (float)(stream->out.latencySeconds*1000.0f), (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->out.params.wow64_workaround ? "YES" : "NO"), (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));

	return paNoError;

error:

	return result;
}

// ------------------------------------------------------------------------------------------
static PaError ActivateAudioClientInput(PaWasapiStream *stream)
{
	HRESULT hr;
	PaError result;

	UINT32 maxBufferSize   = 0;
	PaTime buffer_latency  = 0;
	UINT32 framesPerBuffer = stream->in.params.frames_per_buffer;

	// Create Audio client
	hr = CreateAudioClient(stream, &stream->in, FALSE, &result);
    if (hr != S_OK)
	{
		LogPaError(result);
		goto error;
    }
	LogWAVEFORMATEXTENSIBLE(&stream->in.wavex);

	// Create volume mgr
	stream->inVol = NULL;
    /*hr = info->device->Activate(
        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
        (void**)&stream->inVol);
    if (hr != S_OK)
        return paInvalidDevice;*/

    // Get max possible buffer size to check if it is not less than that we request
    hr = IAudioClient_GetBufferSize(stream->in.clientParent, &maxBufferSize);
    if (hr != S_OK)
	{
		LogHostError(hr);
		LogPaError(result = paInvalidDevice);
		goto error;
	}

    // Correct buffer to max size if it maxed out result of GetBufferSize
	stream->in.bufferSize = maxBufferSize;

	// Get interface latency (actually uneeded as we calculate latency from the size
	// of maxBufferSize).
    hr = IAudioClient_GetStreamLatency(stream->in.clientParent, &stream->in.deviceLatency);
    if (hr != S_OK)
	{
		LogHostError(hr);
		LogPaError(result = paInvalidDevice);
		goto error;
	}
	//stream->in.latencySeconds = nano100ToSeconds(stream->in.deviceLatency);

    // Number of frames that are required at each period
	stream->in.framesPerHostCallback = maxBufferSize;

	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
	stream->in.framesPerBuffer =
		(stream->in.userBufferAndHostMatch ? stream->in.framesPerHostCallback : framesPerBuffer);

	// Calculate buffer latency
	buffer_latency = (PaTime)maxBufferSize / stream->in.wavex.Format.nSamplesPerSec;

	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
	stream->in.latencySeconds = buffer_latency;

	PRINT(("WASAPI::OpenStream(input): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->in.framesPerHostCallback, (float)(stream->in.latencySeconds*1000.0f), (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->in.params.wow64_workaround ? "YES" : "NO"), (stream->in.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));

	return paNoError;

error:

	return result;
}

// ------------------------------------------------------------------------------------------
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result = paNoError;
	HRESULT hr;
    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
    PaWasapiStream *stream = NULL;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;
	PaWasapiDeviceInfo *info = NULL;
	ULONG framesPerHostCallback;
	PaUtilHostBufferSizeMode bufferMode;
	const BOOL fullDuplex = ((inputParameters != NULL) && (outputParameters != NULL));

	// validate PaStreamParameters
	if ((result = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
		return LogPaError(result);

    // Validate platform specific flags
    if ((streamFlags & paPlatformSpecificFlags) != 0)
	{
		LogPaError(result = paInvalidFlag); /* unexpected platform specific flag */
		goto error;
	}

	// Allocate memory for PaWasapiStream
    if ((stream = (PaWasapiStream *)PaUtil_AllocateMemory(sizeof(PaWasapiStream))) == NULL)
	{
        LogPaError(result = paInsufficientMemory);
        goto error;
    }

	// Default thread priority is Audio: for exclusive mode we will use Pro Audio.
	stream->nThreadPriority = eThreadPriorityAudio;

	// Set default number of frames: paFramesPerBufferUnspecified
	if (framesPerBuffer == paFramesPerBufferUnspecified)
	{
		UINT32 framesPerBufferIn  = 0, framesPerBufferOut = 0;
		if (inputParameters != NULL)
		{
			info = &paWasapi->devInfo[inputParameters->device];
			framesPerBufferIn = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
		}
		if (outputParameters != NULL)
		{
			info = &paWasapi->devInfo[outputParameters->device];
			framesPerBufferOut = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
		}
		// choosing maximum default size
		framesPerBuffer = max(framesPerBufferIn, framesPerBufferOut);
	}
	if (framesPerBuffer == 0)
		framesPerBuffer = ((UINT32)sampleRate / 100) * 2;

	// Try create device: Input
	if (inputParameters != NULL)
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        info              = &paWasapi->devInfo[inputParameters->device];

		// default Shared Mode
		stream->in.shareMode = AUDCLNT_SHAREMODE_SHARED;

		// PaWasapiStreamInfo
		if (inputParameters->hostApiSpecificStreamInfo != NULL)
		{
			memcpy(&stream->in.params.wasapi_params, inputParameters->hostApiSpecificStreamInfo, min(sizeof(stream->in.params.wasapi_params), ((PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo)->size));
			stream->in.params.wasapi_params.size = sizeof(stream->in.params.wasapi_params);

			stream->in.params.stream_params.hostApiSpecificStreamInfo = &stream->in.params.wasapi_params;
			inputStreamInfo = &stream->in.params.wasapi_params;

			stream->in.flags = inputStreamInfo->flags;

			// Exclusive Mode
			if (inputStreamInfo->flags & paWinWasapiExclusive)
			{
				// Boost thread priority
				stream->nThreadPriority = eThreadPriorityProAudio;
				// Make Exclusive
				stream->in.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
			}

			// explicit thread priority level
			if (inputStreamInfo->flags & paWinWasapiThreadPriority)
			{
				if ((inputStreamInfo->threadPriority > eThreadPriorityNone) &&
					(inputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
					stream->nThreadPriority = inputStreamInfo->threadPriority;
			}
		}

		// Choose processing mode
		stream->in.streamFlags = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
		if (paWasapi->useWOW64Workaround)
			stream->in.streamFlags = 0; // polling interface
		else
		if (streamCallback == NULL)
			stream->in.streamFlags = 0; // polling interface
		else
		if ((inputStreamInfo != NULL) && (inputStreamInfo->flags & paWinWasapiPolling))
			stream->in.streamFlags = 0; // polling interface
		else
		if (fullDuplex)
			stream->in.streamFlags = 0; // polling interface is implemented for full-duplex mode also

		// Fill parameters for Audio Client creation
		stream->in.params.device_info       = info;
		stream->in.params.stream_params     = (*inputParameters);
		stream->in.params.frames_per_buffer = framesPerBuffer;
		stream->in.params.sample_rate       = sampleRate;
		stream->in.params.blocking          = (streamCallback == NULL);
		stream->in.params.full_duplex       = fullDuplex;
		stream->in.params.wow64_workaround  = paWasapi->useWOW64Workaround;

		// Create and activate audio client
		hr = ActivateAudioClientInput(stream);
        if (hr != S_OK)
		{
			LogPaError(result = paInvalidDevice);
			goto error;
        }

		// Get closest format
        hostInputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->in.wavex), inputSampleFormat );

        // Set user-side custom host processor
        if ((inputStreamInfo != NULL) &&
            (inputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
        {
            stream->hostProcessOverrideInput.processor = inputStreamInfo->hostProcessorInput;
            stream->hostProcessOverrideInput.userData = userData;
        }

		// Only get IAudioCaptureClient input once here instead of getting it at multiple places based on the use
		hr = IAudioClient_GetService(stream->in.clientParent, &pa_IID_IAudioCaptureClient, (void **)&stream->captureClientParent);
		if (hr != S_OK)
		{
			LogHostError(hr);
			LogPaError(result = paUnanticipatedHostError);
			goto error;
		}

		// Create ring buffer for blocking mode (It is needed because we fetch Input packets, not frames,
		// and thus we have to save partial packet if such remains unread)
		if (stream->in.params.blocking == TRUE)
		{
			UINT32 bufferFrames = ALIGN_NEXT_POW2((stream->in.framesPerHostCallback / WASAPI_PACKETS_PER_INPUT_BUFFER) * 2);
			UINT32 frameSize    = stream->in.wavex.Format.nBlockAlign;

			// buffer
			if ((stream->in.tailBuffer = PaUtil_AllocateMemory(sizeof(PaUtilRingBuffer))) == NULL)
			{
				LogPaError(result = paInsufficientMemory);
				goto error;
			}
			memset(stream->in.tailBuffer, 0, sizeof(PaUtilRingBuffer));

			// buffer memory region
			stream->in.tailBufferMemory = PaUtil_AllocateMemory(frameSize * bufferFrames);
			if (stream->in.tailBufferMemory == NULL)
			{
				LogPaError(result = paInsufficientMemory);
				goto error;
			}

			// initialize
			if (PaUtil_InitializeRingBuffer(stream->in.tailBuffer, frameSize, bufferFrames,	stream->in.tailBufferMemory) != 0)
			{
				LogPaError(result = paInternalError);
				goto error;
			}
		}
	}
    else
    {
        inputChannelCount = 0;
        inputSampleFormat = hostInputSampleFormat = paInt16; /* Surpress 'uninitialised var' warnings. */
    }

	// Try create device: Output
    if (outputParameters != NULL)
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
		info               = &paWasapi->devInfo[outputParameters->device];

		// default Shared Mode
		stream->out.shareMode = AUDCLNT_SHAREMODE_SHARED;

		// set PaWasapiStreamInfo
		if (outputParameters->hostApiSpecificStreamInfo != NULL)
		{
			memcpy(&stream->out.params.wasapi_params, outputParameters->hostApiSpecificStreamInfo, min(sizeof(stream->out.params.wasapi_params), ((PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo)->size));
			stream->out.params.wasapi_params.size = sizeof(stream->out.params.wasapi_params);

			stream->out.params.stream_params.hostApiSpecificStreamInfo = &stream->out.params.wasapi_params;
			outputStreamInfo = &stream->out.params.wasapi_params;

			stream->out.flags = outputStreamInfo->flags;

			// Exclusive Mode
			if (outputStreamInfo->flags & paWinWasapiExclusive)
			{
				// Boost thread priority
				stream->nThreadPriority = eThreadPriorityProAudio;
				// Make Exclusive
				stream->out.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
			}

			// explicit thread priority level
			if (outputStreamInfo->flags & paWinWasapiThreadPriority)
			{
				if ((outputStreamInfo->threadPriority > eThreadPriorityNone) &&
					(outputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
					stream->nThreadPriority = outputStreamInfo->threadPriority;
			}
		}

		// Choose processing mode
		stream->out.streamFlags = (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
		if (paWasapi->useWOW64Workaround)
			stream->out.streamFlags = 0; // polling interface
		else
		if (streamCallback == NULL)
			stream->out.streamFlags = 0; // polling interface
		else
		if ((outputStreamInfo != NULL) && (outputStreamInfo->flags & paWinWasapiPolling))
			stream->out.streamFlags = 0; // polling interface
		else
		if (fullDuplex)
			stream->out.streamFlags = 0; // polling interface is implemented for full-duplex mode also

		// Fill parameters for Audio Client creation
		stream->out.params.device_info       = info;
		stream->out.params.stream_params     = (*outputParameters);
		stream->out.params.frames_per_buffer = framesPerBuffer;
		stream->out.params.sample_rate       = sampleRate;
		stream->out.params.blocking          = (streamCallback == NULL);
		stream->out.params.full_duplex       = fullDuplex;
		stream->out.params.wow64_workaround  = paWasapi->useWOW64Workaround;

		// Create and activate audio client
		hr = ActivateAudioClientOutput(stream);
        if (hr != S_OK)
		{
			LogPaError(result = paInvalidDevice);
			goto error;
        }

		// Get closest format
        hostOutputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->out.wavex), outputSampleFormat );

        // Set user-side custom host processor
        if ((outputStreamInfo != NULL) &&
            (outputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
        {
            stream->hostProcessOverrideOutput.processor = outputStreamInfo->hostProcessorOutput;
            stream->hostProcessOverrideOutput.userData = userData;
        }

		// Only get IAudioCaptureClient output once here instead of getting it at multiple places based on the use
		hr = IAudioClient_GetService(stream->out.clientParent, &pa_IID_IAudioRenderClient, (void **)&stream->renderClientParent);
		if (hr != S_OK)
		{
			LogHostError(hr);
			LogPaError(result = paUnanticipatedHostError);
			goto error;
		}
	}
    else
    {
        outputChannelCount = 0;
        outputSampleFormat = hostOutputSampleFormat = paInt16; /* Surpress 'uninitialized var' warnings. */
    }

	// log full-duplex
	if (fullDuplex)
		PRINT(("WASAPI::OpenStream: full-duplex mode\n"));

	// paWinWasapiPolling must be on/or not on both streams
	if ((inputParameters != NULL) && (outputParameters != NULL))
	{
		if ((inputStreamInfo != NULL) && (outputStreamInfo != NULL))
		{
			if (((inputStreamInfo->flags & paWinWasapiPolling) &&
				!(outputStreamInfo->flags & paWinWasapiPolling))
				||
				(!(inputStreamInfo->flags & paWinWasapiPolling) &&
				 (outputStreamInfo->flags & paWinWasapiPolling)))
			{
				LogPaError(result = paInvalidFlag);
				goto error;
			}
		}
	}

	// Initialize stream representation
    if (streamCallback)
    {
		stream->bBlocking = FALSE;
        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
                                              &paWasapi->callbackStreamInterface,
											  streamCallback, userData);
    }
    else
    {
		stream->bBlocking = TRUE;
        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
                                              &paWasapi->blockingStreamInterface,
											  streamCallback, userData);
    }

	// Initialize CPU measurer
    PaUtil_InitializeCpuLoadMeasurer(&stream->cpuLoadMeasurer, sampleRate);

	if (outputParameters && inputParameters)
	{
		// serious problem #1 - No, Not a problem, especially concerning Exclusive mode.
		// Input device in exclusive mode somehow is getting large buffer always, thus we
		// adjust Output latency to reflect it, thus period will differ but playback will be
		// normal.
		/*if (stream->in.period != stream->out.period)
		{
			PRINT(("WASAPI: OpenStream: period discrepancy\n"));
			LogPaError(result = paBadIODeviceCombination);
			goto error;
		}*/

		// serious problem #2 - No, Not a problem, as framesPerHostCallback take into account
		// sample size while it is not a problem for PA full-duplex, we must care of
		// preriod only!
		/*if (stream->out.framesPerHostCallback != stream->in.framesPerHostCallback)
		{
			PRINT(("WASAPI: OpenStream: framesPerHostCallback discrepancy\n"));
			goto error;
		}*/
	}

	// Calculate frames per host for processor
	framesPerHostCallback = (outputParameters ? stream->out.framesPerBuffer : stream->in.framesPerBuffer);

	// Choose correct mode of buffer processing:
	// Exclusive/Shared non paWinWasapiPolling mode: paUtilFixedHostBufferSize - always fixed
	// Exclusive/Shared paWinWasapiPolling mode: paUtilBoundedHostBufferSize - may vary for Exclusive or Full-duplex
	bufferMode = paUtilFixedHostBufferSize;
	if (inputParameters) // !!! WASAPI IAudioCaptureClient::GetBuffer extracts not number of frames but 1 packet, thus we always must adapt
		bufferMode = paUtilBoundedHostBufferSize;
	else
	if (outputParameters)
	{
		if ((stream->out.buffers == 1) &&
			(!stream->out.streamFlags || ((stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
			bufferMode = paUtilBoundedHostBufferSize;
	}
	stream->bufferMode = bufferMode;

    // Initialize buffer processor
    result =  PaUtil_InitializeBufferProcessor(
		&stream->bufferProcessor,
        inputChannelCount,
		inputSampleFormat,
		hostInputSampleFormat,
        outputChannelCount,
		outputSampleFormat,
		hostOutputSampleFormat,
        sampleRate,
		streamFlags,
		framesPerBuffer,
        framesPerHostCallback,
		bufferMode,
        streamCallback,
		userData);
    if (result != paNoError)
	{
		LogPaError(result);
        goto error;
	}

	// Set Input latency
    stream->streamRepresentation.streamInfo.inputLatency =
            ((double)PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor) / sampleRate)
			+ ((inputParameters)?stream->in.latencySeconds : 0);

	// Set Output latency
    stream->streamRepresentation.streamInfo.outputLatency =
            ((double)PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor) / sampleRate)
			+ ((outputParameters)?stream->out.latencySeconds : 0);

	// Set SR
    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

    (*s) = (PaStream *)stream;
    return result;

error:

    if (stream != NULL)
		CloseStream(stream);

    return result;
}

// ------------------------------------------------------------------------------------------
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaWasapiStream *stream = (PaWasapiStream*)s;

	// abort active stream
	if (IsStreamActive(s))
	{
		result = AbortStream(s);
	}

    SAFE_RELEASE(stream->captureClientParent);
    SAFE_RELEASE(stream->renderClientParent);
    SAFE_RELEASE(stream->out.clientParent);
    SAFE_RELEASE(stream->in.clientParent);
	SAFE_RELEASE(stream->inVol);
	SAFE_RELEASE(stream->outVol);

	CloseHandle(stream->event[S_INPUT]);
	CloseHandle(stream->event[S_OUTPUT]);

	_StreamCleanup(stream);

	PaWasapi_FreeMemory(stream->in.monoBuffer);
	PaWasapi_FreeMemory(stream->out.monoBuffer);

	PaUtil_FreeMemory(stream->in.tailBuffer);
	PaUtil_FreeMemory(stream->in.tailBufferMemory);

	PaUtil_FreeMemory(stream->out.tailBuffer);
	PaUtil_FreeMemory(stream->out.tailBufferMemory);

    PaUtil_TerminateBufferProcessor(&stream->bufferProcessor);
    PaUtil_TerminateStreamRepresentation(&stream->streamRepresentation);
    PaUtil_FreeMemory(stream);

    return result;
}

// ------------------------------------------------------------------------------------------
HRESULT UnmarshalSubStreamComPointers(PaWasapiSubStream *substream) 
{
#ifndef PA_WINRT
	HRESULT hResult = S_OK;
	HRESULT hFirstBadResult = S_OK;
	substream->clientProc = NULL;

	// IAudioClient
	hResult = CoGetInterfaceAndReleaseStream(substream->clientStream, GetAudioClientIID(), (LPVOID*)&substream->clientProc);
	substream->clientStream = NULL;
	if (hResult != S_OK) 
	{
		hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
	}

	return hFirstBadResult;

#else
	(void)substream;
	return S_OK;
#endif
}

// ------------------------------------------------------------------------------------------
HRESULT UnmarshalStreamComPointers(PaWasapiStream *stream) 
{
#ifndef PA_WINRT
	HRESULT hResult = S_OK;
	HRESULT hFirstBadResult = S_OK;
	stream->captureClient = NULL;
	stream->renderClient = NULL;
	stream->in.clientProc = NULL;
	stream->out.clientProc = NULL;

	if (NULL != stream->in.clientParent) 
	{
		// SubStream pointers
		hResult = UnmarshalSubStreamComPointers(&stream->in);
		if (hResult != S_OK) 
		{
			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
		}

		// IAudioCaptureClient
		hResult = CoGetInterfaceAndReleaseStream(stream->captureClientStream, &pa_IID_IAudioCaptureClient, (LPVOID*)&stream->captureClient);
		stream->captureClientStream = NULL;
		if (hResult != S_OK) 
		{
			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
		}
	}

	if (NULL != stream->out.clientParent) 
	{
		// SubStream pointers
		hResult = UnmarshalSubStreamComPointers(&stream->out);
		if (hResult != S_OK) 
		{
			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
		}

		// IAudioRenderClient
		hResult = CoGetInterfaceAndReleaseStream(stream->renderClientStream, &pa_IID_IAudioRenderClient, (LPVOID*)&stream->renderClient);
		stream->renderClientStream = NULL;
		if (hResult != S_OK) 
		{
			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
		}
	}

	return hFirstBadResult;
#else
	if (stream->in.clientParent != NULL)
	{
		stream->in.clientProc = stream->in.clientParent;
		IAudioClient_AddRef(stream->in.clientParent);
	}

	if (stream->out.clientParent != NULL)
	{
		stream->out.clientProc = stream->out.clientParent;
		IAudioClient_AddRef(stream->out.clientParent);
	}

	if (stream->renderClientParent != NULL)
	{
		stream->renderClient = stream->renderClientParent;
		IAudioRenderClient_AddRef(stream->renderClientParent);
	}

	if (stream->captureClientParent != NULL)
	{
		stream->captureClient = stream->captureClientParent;
		IAudioCaptureClient_AddRef(stream->captureClientParent);
	}

	return S_OK;
#endif
}

// -----------------------------------------------------------------------------------------
void ReleaseUnmarshaledSubComPointers(PaWasapiSubStream *substream) 
{
	SAFE_RELEASE(substream->clientProc);
}

// -----------------------------------------------------------------------------------------
void ReleaseUnmarshaledComPointers(PaWasapiStream *stream) 
{
	// Release AudioClient services first
	SAFE_RELEASE(stream->captureClient);
	SAFE_RELEASE(stream->renderClient);

	// Release AudioClients
	ReleaseUnmarshaledSubComPointers(&stream->in);
	ReleaseUnmarshaledSubComPointers(&stream->out);
}

// ------------------------------------------------------------------------------------------
HRESULT MarshalSubStreamComPointers(PaWasapiSubStream *substream) 
{
#ifndef PA_WINRT
	HRESULT hResult;
	substream->clientStream = NULL;

	// IAudioClient
	hResult = CoMarshalInterThreadInterfaceInStream(GetAudioClientIID(), (LPUNKNOWN)substream->clientParent, &substream->clientStream);
	if (hResult != S_OK)
		goto marshal_sub_error;

	return hResult;

	// If marshaling error occurred, make sure to release everything.
marshal_sub_error:

	UnmarshalSubStreamComPointers(substream);
	ReleaseUnmarshaledSubComPointers(substream);
	return hResult;
#else
	(void)substream;
	return S_OK;
#endif
}

// ------------------------------------------------------------------------------------------
HRESULT MarshalStreamComPointers(PaWasapiStream *stream) 
{
#ifndef PA_WINRT
	HRESULT hResult = S_OK;
	stream->captureClientStream = NULL;
	stream->in.clientStream = NULL;
	stream->renderClientStream = NULL;
	stream->out.clientStream = NULL;

	if (NULL != stream->in.clientParent) 
	{
		// SubStream pointers
		hResult = MarshalSubStreamComPointers(&stream->in);
		if (hResult != S_OK) 
			goto marshal_error;

		// IAudioCaptureClient
		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioCaptureClient, (LPUNKNOWN)stream->captureClientParent, &stream->captureClientStream);
		if (hResult != S_OK) 
			goto marshal_error;
	}

	if (NULL != stream->out.clientParent) 
	{
		// SubStream pointers
		hResult = MarshalSubStreamComPointers(&stream->out);
		if (hResult != S_OK) 
			goto marshal_error;

		// IAudioRenderClient
		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioRenderClient, (LPUNKNOWN)stream->renderClientParent, &stream->renderClientStream);
		if (hResult != S_OK) 
			goto marshal_error;
	}

	return hResult;

	// If marshaling error occurred, make sure to release everything.
marshal_error:

	UnmarshalStreamComPointers(stream);
	ReleaseUnmarshaledComPointers(stream);
	return hResult;
#else
	(void)stream;
	return S_OK;
#endif
}

// ------------------------------------------------------------------------------------------
static PaError StartStream( PaStream *s )
{
	HRESULT hr;
    PaWasapiStream *stream = (PaWasapiStream*)s;
	PaError result = paNoError;

	// check if stream is active already
	if (IsStreamActive(s))
		return paStreamIsNotStopped;

    PaUtil_ResetBufferProcessor(&stream->bufferProcessor);

	// Cleanup handles (may be necessary if stream was stopped by itself due to error)
	_StreamCleanup(stream);

	// Create close event
	if ((stream->hCloseRequest = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) 
	{
		result = paInsufficientMemory;
		goto start_error;
	}

	// Create thread
	if (!stream->bBlocking)
	{
		// Create thread events
		stream->hThreadStart = CreateEvent(NULL, TRUE, FALSE, NULL);
		stream->hThreadExit  = CreateEvent(NULL, TRUE, FALSE, NULL);
		if ((stream->hThreadStart == NULL) || (stream->hThreadExit == NULL))
		{
			result = paInsufficientMemory;
			goto start_error;
		}

		// Marshal WASAPI interface pointers for safe use in thread created below.
		if ((hr = MarshalStreamComPointers(stream)) != S_OK) 
		{
			PRINT(("Failed marshaling stream COM pointers."));
			result = paUnanticipatedHostError;
			goto nonblocking_start_error;
		}

		if ((stream->in.clientParent  && (stream->in.streamFlags  & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)) ||
			(stream->out.clientParent && (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)))
		{
			if ((stream->hThread = CREATE_THREAD(ProcThreadEvent)) == NULL) 
			{
				PRINT(("Failed creating thread: ProcThreadEvent."));
				result = paUnanticipatedHostError;
				goto nonblocking_start_error;
			}
		}
		else
		{
			if ((stream->hThread = CREATE_THREAD(ProcThreadPoll)) == NULL) 
			{
				PRINT(("Failed creating thread: ProcThreadPoll."));
				result = paUnanticipatedHostError;
				goto nonblocking_start_error;
			}
		}

		// Wait for thread to start
		if (WaitForSingleObject(stream->hThreadStart, 60*1000) == WAIT_TIMEOUT) 
		{
			PRINT(("Failed starting thread: timeout."));
			result = paUnanticipatedHostError;
			goto nonblocking_start_error;
		}
	}
	else
	{
		// Create blocking operation events (non-signaled event means - blocking operation is pending)
		if (stream->out.clientParent != NULL) 
		{
			if ((stream->hBlockingOpStreamWR = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
			{
				result = paInsufficientMemory;
				goto start_error;
			}
		}
		if (stream->in.clientParent != NULL) 
		{
			if ((stream->hBlockingOpStreamRD = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
			{
				result = paInsufficientMemory;
				goto start_error;
			}
		}

		// Initialize event & start INPUT stream
		if (stream->in.clientParent != NULL)
		{
			if ((hr = IAudioClient_Start(stream->in.clientParent)) != S_OK)
			{
				LogHostError(hr);
				result = paUnanticipatedHostError;
				goto start_error;
			}
		}

		// Initialize event & start OUTPUT stream
		if (stream->out.clientParent != NULL)
		{
			// Start
			if ((hr = IAudioClient_Start(stream->out.clientParent)) != S_OK)
			{
				LogHostError(hr);
				result = paUnanticipatedHostError;
				goto start_error;
			}
		}

		// Set parent to working pointers to use shared functions.
		stream->captureClient  = stream->captureClientParent;
		stream->renderClient   = stream->renderClientParent;
		stream->in.clientProc  = stream->in.clientParent;
		stream->out.clientProc = stream->out.clientParent;

		// Signal: stream running.
		stream->running = TRUE;
	}

    return result;

nonblocking_start_error:

	// Set hThreadExit event to prevent blocking during cleanup
	SetEvent(stream->hThreadExit);
	UnmarshalStreamComPointers(stream);
	ReleaseUnmarshaledComPointers(stream);

start_error:

	StopStream(s);
	return result;
}

// ------------------------------------------------------------------------------------------
void _StreamFinish(PaWasapiStream *stream)
{
	// Issue command to thread to stop processing and wait for thread exit
	if (!stream->bBlocking)
	{
		SignalObjectAndWait(stream->hCloseRequest, stream->hThreadExit, INFINITE, FALSE);
	}
	else
	// Blocking mode does not own thread
	{
		// Signal close event and wait for each of 2 blocking operations to complete
		if (stream->out.clientParent)
			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamWR, INFINITE, TRUE);
		if (stream->out.clientParent)
			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamRD, INFINITE, TRUE);

		// Process stop
		_StreamOnStop(stream);
	}

	// Cleanup handles
	_StreamCleanup(stream);

    stream->running = FALSE;
}

// ------------------------------------------------------------------------------------------
void _StreamCleanup(PaWasapiStream *stream)
{
	// Close thread handles to allow restart
	SAFE_CLOSE(stream->hThread);
	SAFE_CLOSE(stream->hThreadStart);
	SAFE_CLOSE(stream->hThreadExit);
	SAFE_CLOSE(stream->hCloseRequest);
	SAFE_CLOSE(stream->hBlockingOpStreamRD);
	SAFE_CLOSE(stream->hBlockingOpStreamWR);
}

// ------------------------------------------------------------------------------------------
static PaError StopStream( PaStream *s )
{
	// Finish stream
	_StreamFinish((PaWasapiStream *)s);
    return paNoError;
}

// ------------------------------------------------------------------------------------------
static PaError AbortStream( PaStream *s )
{
	// Finish stream
	_StreamFinish((PaWasapiStream *)s);
    return paNoError;
}

// ------------------------------------------------------------------------------------------
static PaError IsStreamStopped( PaStream *s )
{
	return !((PaWasapiStream *)s)->running;
}

// ------------------------------------------------------------------------------------------
static PaError IsStreamActive( PaStream *s )
{
    return ((PaWasapiStream *)s)->running;
}

// ------------------------------------------------------------------------------------------
static PaTime GetStreamTime( PaStream *s )
{
    PaWasapiStream *stream = (PaWasapiStream*)s;

    /* suppress unused variable warnings */
    (void) stream;

    return PaUtil_GetTime();
}

// ------------------------------------------------------------------------------------------
static double GetStreamCpuLoad( PaStream* s )
{
	return PaUtil_GetCpuLoad(&((PaWasapiStream *)s)->cpuLoadMeasurer);
}

// ------------------------------------------------------------------------------------------
static PaError ReadStream( PaStream* s, void *_buffer, unsigned long frames )
{
    PaWasapiStream *stream = (PaWasapiStream*)s;

	HRESULT hr = S_OK;
	BYTE *user_buffer = (BYTE *)_buffer;
	BYTE *wasapi_buffer = NULL;
	DWORD flags = 0;
	UINT32 i, available, sleep = 0;
	unsigned long processed;
	ThreadIdleScheduler sched;

	// validate
	if (!stream->running)
		return paStreamIsStopped;
	if (stream->captureClient == NULL)
		return paBadStreamPtr;

	// Notify blocking op has begun
	ResetEvent(stream->hBlockingOpStreamRD);

	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
	ThreadIdleScheduler_Setup(&sched, 1, 250/* microseconds */);

    // Make a local copy of the user buffer pointer(s), this is necessary
	// because PaUtil_CopyOutput() advances these pointers every time it is called
    if (!stream->bufferProcessor.userInputIsInterleaved)
    {
		user_buffer = (BYTE *)alloca(sizeof(BYTE *) * stream->bufferProcessor.inputChannelCount);
        if (user_buffer == NULL)
            return paInsufficientMemory;

        for (i = 0; i < stream->bufferProcessor.inputChannelCount; ++i)
            ((BYTE **)user_buffer)[i] = ((BYTE **)_buffer)[i];
    }

	// Findout if there are tail frames, flush them all before reading hardware
	if ((available = PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer)) != 0)
	{
		ring_buffer_size_t buf1_size = 0, buf2_size = 0, read, desired;
		void *buf1 = NULL, *buf2 = NULL;

		// Limit desired to amount of requested frames
		desired = available;
		if ((UINT32)desired > frames)
			desired = frames;
		
		// Get pointers to read regions
		read = PaUtil_GetRingBufferReadRegions(stream->in.tailBuffer, desired, &buf1, &buf1_size, &buf2, &buf2_size);

		if (buf1 != NULL)
		{
			// Register available frames to processor
			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf1_size);

			// Register host buffer pointer to processor
			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf1, stream->bufferProcessor.inputChannelCount);

			// Copy user data to host buffer (with conversion if applicable)
			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf1_size);
			frames -= processed;
		}

		if (buf2 != NULL)
		{
			// Register available frames to processor
			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf2_size);

			// Register host buffer pointer to processor
			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf2, stream->bufferProcessor.inputChannelCount);

			// Copy user data to host buffer (with conversion if applicable)
			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf2_size);
			frames -= processed;
		}

		// Advance
		PaUtil_AdvanceRingBufferReadIndex(stream->in.tailBuffer, read);
	}

	// Read hardware
	while (frames != 0)
	{
		// Check if blocking call must be interrupted
		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
			break;

		// Get available frames (must be finding out available frames before call to IAudioCaptureClient_GetBuffer
		// othervise audio glitches will occur inExclusive mode as it seems that WASAPI has some scheduling/
		// processing problems when such busy polling with IAudioCaptureClient_GetBuffer occurs)
		if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
		{
			LogHostError(hr);
			return paUnanticipatedHostError;
		}

		// Wait for more frames to become available
		if (available == 0)
		{
			// Exclusive mode may require latency of 1 millisecond, thus we shall sleep
			// around 500 microseconds (emulated) to collect packets in time
			if (stream->in.shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE)
			{
				UINT32 sleep_frames = (frames < stream->in.framesPerHostCallback ? frames : stream->in.framesPerHostCallback);

				sleep  = GetFramesSleepTime(sleep_frames, stream->in.wavex.Format.nSamplesPerSec);
				sleep /= 4; // wait only for 1/4 of the buffer

				// WASAPI input provides packets, thus expiring packet will result in bad audio
				// limit waiting time to 2 seconds (will always work for smallest buffer in Shared)
				if (sleep > 2)
					sleep = 2;

				// Avoid busy waiting, schedule next 1 millesecond wait
				if (sleep == 0)
					sleep = ThreadIdleScheduler_NextSleep(&sched);
			}
			else
			{
				if ((sleep = ThreadIdleScheduler_NextSleep(&sched)) != 0)
				{
					Sleep(sleep);
					sleep = 0;
				}
			}

			continue;
		}

		// Get the available data in the shared buffer.
		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &wasapi_buffer, &available, &flags, NULL, NULL)) != S_OK)
		{
			// Buffer size is too small, waiting
			if (hr != AUDCLNT_S_BUFFER_EMPTY)
			{
				LogHostError(hr);
				goto end;
			}

			continue;
		}

		// Register available frames to processor
        PaUtil_SetInputFrameCount(&stream->bufferProcessor, available);

		// Register host buffer pointer to processor
        PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, wasapi_buffer, stream->bufferProcessor.inputChannelCount);

		// Copy user data to host buffer (with conversion if applicable)
		processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, frames);
		frames -= processed;

		// Save tail into buffer
		if ((frames == 0) && (available > processed))
		{
			UINT32 bytes_processed = processed * stream->in.wavex.Format.nBlockAlign;
			UINT32 frames_to_save  = available - processed;

			PaUtil_WriteRingBuffer(stream->in.tailBuffer, wasapi_buffer + bytes_processed, frames_to_save);
		}

		// Release host buffer
		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, available)) != S_OK)
		{
			LogHostError(hr);
			goto end;
		}
	}

end:

	// Notify blocking op has ended
	SetEvent(stream->hBlockingOpStreamRD);

	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
}

// ------------------------------------------------------------------------------------------
static PaError WriteStream( PaStream* s, const void *_buffer, unsigned long frames )
{
    PaWasapiStream *stream = (PaWasapiStream*)s;

	//UINT32 frames;
	const BYTE *user_buffer = (const BYTE *)_buffer;
	BYTE *wasapi_buffer;
	HRESULT hr = S_OK;
	UINT32 i, available, sleep = 0;
	unsigned long processed;
	ThreadIdleScheduler sched;

	// validate
	if (!stream->running)
		return paStreamIsStopped;
	if (stream->renderClient == NULL)
		return paBadStreamPtr;

	// Notify blocking op has begun
	ResetEvent(stream->hBlockingOpStreamWR);

	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
	ThreadIdleScheduler_Setup(&sched, 1, 500/* microseconds */);

    // Make a local copy of the user buffer pointer(s), this is necessary
	// because PaUtil_CopyOutput() advances these pointers every time it is called
    if (!stream->bufferProcessor.userOutputIsInterleaved)
    {
        user_buffer = (const BYTE *)alloca(sizeof(const BYTE *) * stream->bufferProcessor.outputChannelCount);
        if (user_buffer == NULL)
            return paInsufficientMemory;

        for (i = 0; i < stream->bufferProcessor.outputChannelCount; ++i)
            ((const BYTE **)user_buffer)[i] = ((const BYTE **)_buffer)[i];
    }

	// Blocking (potentially, untill 'frames' are consumed) loop
	while (frames != 0)
	{
		// Check if blocking call must be interrupted
		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
			break;

		// Get frames available
		if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
		{
			LogHostError(hr);
			goto end;
		}

		// Wait for more frames to become available
		if (available == 0)
		{
			UINT32 sleep_frames = (frames < stream->out.framesPerHostCallback ? frames : stream->out.framesPerHostCallback);

			sleep  = GetFramesSleepTime(sleep_frames, stream->out.wavex.Format.nSamplesPerSec);
			sleep /= 2; // wait only for half of the buffer

			// Avoid busy waiting, schedule next 1 millesecond wait
			if (sleep == 0)
				sleep = ThreadIdleScheduler_NextSleep(&sched);

			continue;
		}

		// Keep in 'frmaes' range
		if (available > frames)
			available = frames;

		// Get pointer to host buffer
		if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, available, &wasapi_buffer)) != S_OK)
		{
			// Buffer size is too big, waiting
			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
				continue;

			LogHostError(hr);
			goto end;
		}

		// Keep waiting again (on Vista it was noticed that WASAPI could SOMETIMES return NULL pointer 
		// to buffer without returning AUDCLNT_E_BUFFER_TOO_LARGE instead)
		if (wasapi_buffer == NULL)
			continue;

		// Register available frames to processor
        PaUtil_SetOutputFrameCount(&stream->bufferProcessor, available);

		// Register host buffer pointer to processor
        PaUtil_SetInterleavedOutputChannels(&stream->bufferProcessor, 0, wasapi_buffer,	stream->bufferProcessor.outputChannelCount);

		// Copy user data to host buffer (with conversion if applicable), this call will advance
		// pointer 'user_buffer' to consumed portion of data
		processed = PaUtil_CopyOutput(&stream->bufferProcessor, (const void **)&user_buffer, frames);
		frames -= processed;

		// Release host buffer
		if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, available, 0)) != S_OK)
		{
			LogHostError(hr);
			goto end;
		}
	}

end:

	// Notify blocking op has ended
	SetEvent(stream->hBlockingOpStreamWR);

	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
}

unsigned long PaUtil_GetOutputFrameCount( PaUtilBufferProcessor* bp )
{
	return bp->hostOutputFrameCount[0];
}

// ------------------------------------------------------------------------------------------
static signed long GetStreamReadAvailable( PaStream* s )
{
    PaWasapiStream *stream = (PaWasapiStream*)s;

	HRESULT hr;
	UINT32  available = 0;

	// validate
	if (!stream->running)
		return paStreamIsStopped;
	if (stream->captureClient == NULL)
		return paBadStreamPtr;

	// available in hardware buffer
	if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
	{
		LogHostError(hr);
		return paUnanticipatedHostError;
	}

	// available in software tail buffer
	available += PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer);

    return available;
}

// ------------------------------------------------------------------------------------------
static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaWasapiStream *stream = (PaWasapiStream*)s;
	HRESULT hr;
	UINT32  available = 0;

	// validate
	if (!stream->running)
		return paStreamIsStopped;
	if (stream->renderClient == NULL)
		return paBadStreamPtr;

	if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
	{
		LogHostError(hr);
		return paUnanticipatedHostError;
	}

	return (signed long)available;
}


// ------------------------------------------------------------------------------------------
static void WaspiHostProcessingLoop( void *inputBuffer,  long inputFrames,
                                     void *outputBuffer, long outputFrames,
                                     void *userData )
{
    PaWasapiStream *stream = (PaWasapiStream*)userData;
    PaStreamCallbackTimeInfo timeInfo = {0,0,0};
	PaStreamCallbackFlags flags = 0;
    int callbackResult;
    unsigned long framesProcessed;
	HRESULT hr;
	UINT32 pending;

    PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

    /*
		Pa_GetStreamTime:
            - generate timing information
            - handle buffer slips
    */
	timeInfo.currentTime = PaUtil_GetTime();
	// Query input latency
	if (stream->in.clientProc != NULL)
	{
		PaTime pending_time;
		if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, &pending)) == S_OK)
			pending_time = (PaTime)pending / (PaTime)stream->in.wavex.Format.nSamplesPerSec;
		else
			pending_time = (PaTime)stream->in.latencySeconds;

		timeInfo.inputBufferAdcTime = timeInfo.currentTime + pending_time;
	}
	// Query output current latency
	if (stream->out.clientProc != NULL)
	{
		PaTime pending_time;
		if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &pending)) == S_OK)
			pending_time = (PaTime)pending / (PaTime)stream->out.wavex.Format.nSamplesPerSec;
		else
			pending_time = (PaTime)stream->out.latencySeconds;

		timeInfo.outputBufferDacTime = timeInfo.currentTime + pending_time;
	}

    /*
        If you need to byte swap or shift inputBuffer to convert it into a
        portaudio format, do it here.
    */

    PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, flags );

    /*
        depending on whether the host buffers are interleaved, non-interleaved
        or a mixture, you will want to call PaUtil_SetInterleaved*Channels(),
        PaUtil_SetNonInterleaved*Channel() or PaUtil_Set*Channel() here.
    */

    if (stream->bufferProcessor.inputChannelCount > 0)
    {
        PaUtil_SetInputFrameCount( &stream->bufferProcessor, inputFrames );
        PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor,
            0, /* first channel of inputBuffer is channel 0 */
            inputBuffer,
            0 ); /* 0 - use inputChannelCount passed to init buffer processor */
    }

    if (stream->bufferProcessor.outputChannelCount > 0)
    {
        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, outputFrames);
        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor,
            0, /* first channel of outputBuffer is channel 0 */
            outputBuffer,
            0 ); /* 0 - use outputChannelCount passed to init buffer processor */
    }

    /* you must pass a valid value of callback result to PaUtil_EndBufferProcessing()
        in general you would pass paContinue for normal operation, and
        paComplete to drain the buffer processor's internal output buffer.
        You can check whether the buffer processor's output buffer is empty
        using PaUtil_IsBufferProcessorOuputEmpty( bufferProcessor )
    */
    callbackResult = paContinue;
    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );

    /*
        If you need to byte swap or shift outputBuffer to convert it to
        host format, do it here.
    */

	PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );

    if (callbackResult == paContinue)
    {
        /* nothing special to do */
    }
    else
	if (callbackResult == paAbort)
    {
		// stop stream
        SetEvent(stream->hCloseRequest);
    }
    else
    {
		// stop stream
        SetEvent(stream->hCloseRequest);
    }
}

// ------------------------------------------------------------------------------------------
HANDLE MMCSS_activate(const char *name)
{
#ifndef PA_WINRT
    DWORD task_idx = 0;
    HANDLE hTask = pAvSetMmThreadCharacteristics(name, &task_idx);
    if (hTask == NULL)
	{
        PRINT(("WASAPI: AvSetMmThreadCharacteristics failed!\n"));
    }

    /*BOOL priority_ok = pAvSetMmThreadPriority(hTask, AVRT_PRIORITY_NORMAL);
    if (priority_ok == FALSE)
	{
        PRINT(("WASAPI: AvSetMmThreadPriority failed!\n"));
    }*/

	// debug
    {
        int    cur_priority		  = GetThreadPriority(GetCurrentThread());
        DWORD  cur_priority_class = GetPriorityClass(GetCurrentProcess());
		PRINT(("WASAPI: thread[ priority-0x%X class-0x%X ]\n", cur_priority, cur_priority_class));
    }

	return hTask;
#else
	(void)name;
	return NULL;
#endif
}

// ------------------------------------------------------------------------------------------
void MMCSS_deactivate(HANDLE hTask)
{
	if (!hTask)
		return;

#ifndef PA_WINRT
	if (pAvRevertMmThreadCharacteristics(hTask) == FALSE)
	{
        PRINT(("WASAPI: AvRevertMmThreadCharacteristics failed!\n"));
    }
#endif
}

// ------------------------------------------------------------------------------------------
PaError PaWasapi_ThreadPriorityBoost(void **hTask, PaWasapiThreadPriority nPriorityClass)
{
	static const char *mmcs_name[] =
	{
		NULL,
		"Audio",
		"Capture",
		"Distribution",
		"Games",
		"Playback",
		"Pro Audio",
		"Window Manager"
	};
	HANDLE task;

	if (hTask == NULL)
		return paUnanticipatedHostError;

	if ((UINT32)nPriorityClass >= STATIC_ARRAY_SIZE(mmcs_name))
		return paUnanticipatedHostError;

	task = MMCSS_activate(mmcs_name[nPriorityClass]);
	if (task == NULL)
		return paUnanticipatedHostError;

	(*hTask) = task;
	return paNoError;
}

// ------------------------------------------------------------------------------------------
PaError PaWasapi_ThreadPriorityRevert(void *hTask)
{
	if (hTask == NULL)
		return paUnanticipatedHostError;

	MMCSS_deactivate((HANDLE)hTask);

	return paNoError;
}

// ------------------------------------------------------------------------------------------
// Described at:
// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx

PaError PaWasapi_GetJackCount(PaDeviceIndex nDevice, int *jcount)
{
#ifndef PA_WINRT
	PaError ret;
	HRESULT hr = S_OK;
	PaDeviceIndex index;
    IDeviceTopology *pDeviceTopology = NULL;
    IConnector *pConnFrom = NULL;
    IConnector *pConnTo = NULL;
    IPart *pPart = NULL;
    IKsJackDescription *pJackDesc = NULL;
	UINT jackCount = 0;

	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
	if (paWasapi == NULL)
		return paNotInitialized;

	// Get device index.
	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
    if (ret != paNoError)
        return ret;

	// Validate index.
	if ((UINT32)index >= paWasapi->deviceCount)
		return paInvalidDevice;

	// Get the endpoint device's IDeviceTopology interface.
	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
	IF_FAILED_JUMP(hr, error);

    // The device topology for an endpoint device always contains just one connector (connector number 0).
	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
	IF_FAILED_JUMP(hr, error);

    // Step across the connection to the jack on the adapter.
	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        // The adapter device is not currently active.
        hr = E_NOINTERFACE;
    }
	IF_FAILED_JUMP(hr, error);

	// Get the connector's IPart interface.
	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
	IF_FAILED_JUMP(hr, error);

	// Activate the connector's IKsJackDescription interface.
	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
	IF_FAILED_JUMP(hr, error);

	// Return jack count for this device.
	hr = IKsJackDescription_GetJackCount(pJackDesc, &jackCount);
	IF_FAILED_JUMP(hr, error);

	// Set.
	(*jcount) = jackCount;

	// Ok.
	ret = paNoError;

error:

	SAFE_RELEASE(pDeviceTopology);
	SAFE_RELEASE(pConnFrom);
	SAFE_RELEASE(pConnTo);
	SAFE_RELEASE(pPart);
	SAFE_RELEASE(pJackDesc);

	LogHostError(hr);
	return paNoError;
#else
	(void)nDevice;
	(void)jcount;
	return paUnanticipatedHostError;
#endif
}

// ------------------------------------------------------------------------------------------
#ifndef PA_WINRT
static PaWasapiJackConnectionType ConvertJackConnectionTypeWASAPIToPA(int connType)
{
	switch (connType)
	{
		case eConnTypeUnknown:			return eJackConnTypeUnknown;
#ifdef _KS_
		case eConnType3Point5mm:		return eJackConnType3Point5mm;
#else
		case eConnTypeEighth:		    return eJackConnType3Point5mm;
#endif
		case eConnTypeQuarter:			return eJackConnTypeQuarter;
		case eConnTypeAtapiInternal:	return eJackConnTypeAtapiInternal;
		case eConnTypeRCA:				return eJackConnTypeRCA;
		case eConnTypeOptical:			return eJackConnTypeOptical;
		case eConnTypeOtherDigital:		return eJackConnTypeOtherDigital;
		case eConnTypeOtherAnalog:		return eJackConnTypeOtherAnalog;
		case eConnTypeMultichannelAnalogDIN: return eJackConnTypeMultichannelAnalogDIN;
		case eConnTypeXlrProfessional:	return eJackConnTypeXlrProfessional;
		case eConnTypeRJ11Modem:		return eJackConnTypeRJ11Modem;
		case eConnTypeCombination:		return eJackConnTypeCombination;
	}
	return eJackConnTypeUnknown;
}
#endif

// ------------------------------------------------------------------------------------------
#ifndef PA_WINRT
static PaWasapiJackGeoLocation ConvertJackGeoLocationWASAPIToPA(int geoLoc)
{
	switch (geoLoc)
	{
	case eGeoLocRear:				return eJackGeoLocRear;
	case eGeoLocFront:				return eJackGeoLocFront;
	case eGeoLocLeft:				return eJackGeoLocLeft;
	case eGeoLocRight:				return eJackGeoLocRight;
	case eGeoLocTop:				return eJackGeoLocTop;
	case eGeoLocBottom:				return eJackGeoLocBottom;
#ifdef _KS_
	case eGeoLocRearPanel:			return eJackGeoLocRearPanel;
#else
	case eGeoLocRearOPanel:         return eJackGeoLocRearPanel;
#endif
	case eGeoLocRiser:				return eJackGeoLocRiser;
	case eGeoLocInsideMobileLid:	return eJackGeoLocInsideMobileLid;
	case eGeoLocDrivebay:			return eJackGeoLocDrivebay;
	case eGeoLocHDMI:				return eJackGeoLocHDMI;
	case eGeoLocOutsideMobileLid:	return eJackGeoLocOutsideMobileLid;
	case eGeoLocATAPI:				return eJackGeoLocATAPI;
	}
	return eJackGeoLocUnk;
}
#endif

// ------------------------------------------------------------------------------------------
#ifndef PA_WINRT
static PaWasapiJackGenLocation ConvertJackGenLocationWASAPIToPA(int genLoc)
{
	switch (genLoc)
	{
	case eGenLocPrimaryBox:	return eJackGenLocPrimaryBox;
	case eGenLocInternal:	return eJackGenLocInternal;
#ifdef _KS_
	case eGenLocSeparate:	return eJackGenLocSeparate;
#else
	case eGenLocSeperate:	return eJackGenLocSeparate;
#endif
	case eGenLocOther:		return eJackGenLocOther;
	}
	return eJackGenLocPrimaryBox;
}
#endif

// ------------------------------------------------------------------------------------------
#ifndef PA_WINRT
static PaWasapiJackPortConnection ConvertJackPortConnectionWASAPIToPA(int portConn)
{
	switch (portConn)
	{
	case ePortConnJack:					return eJackPortConnJack;
	case ePortConnIntegratedDevice:		return eJackPortConnIntegratedDevice;
	case ePortConnBothIntegratedAndJack:return eJackPortConnBothIntegratedAndJack;
	case ePortConnUnknown:				return eJackPortConnUnknown;
	}
	return eJackPortConnJack;
}
#endif

// ------------------------------------------------------------------------------------------
// Described at:
// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx

PaError PaWasapi_GetJackDescription(PaDeviceIndex nDevice, int jindex, PaWasapiJackDescription *pJackDescription)
{
#ifndef PA_WINRT
	PaError ret;
	HRESULT hr = S_OK;
	PaDeviceIndex index;
    IDeviceTopology *pDeviceTopology = NULL;
    IConnector *pConnFrom = NULL;
    IConnector *pConnTo = NULL;
    IPart *pPart = NULL;
    IKsJackDescription *pJackDesc = NULL;
	KSJACK_DESCRIPTION jack = { 0 };

	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
	if (paWasapi == NULL)
		return paNotInitialized;

	// Get device index.
	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
    if (ret != paNoError)
        return ret;

	// Validate index.
	if ((UINT32)index >= paWasapi->deviceCount)
		return paInvalidDevice;

	// Get the endpoint device's IDeviceTopology interface.
	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
	IF_FAILED_JUMP(hr, error);

    // The device topology for an endpoint device always contains just one connector (connector number 0).
	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
	IF_FAILED_JUMP(hr, error);

    // Step across the connection to the jack on the adapter.
	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        // The adapter device is not currently active.
        hr = E_NOINTERFACE;
    }
	IF_FAILED_JUMP(hr, error);

	// Get the connector's IPart interface.
	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
	IF_FAILED_JUMP(hr, error);

	// Activate the connector's IKsJackDescription interface.
	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
	IF_FAILED_JUMP(hr, error);

	// Test to return jack description struct for index 0.
	hr = IKsJackDescription_GetJackDescription(pJackDesc, jindex, &jack);
	IF_FAILED_JUMP(hr, error);

	// Convert WASAPI values to PA format.
	pJackDescription->channelMapping = jack.ChannelMapping;
	pJackDescription->color          = jack.Color;
	pJackDescription->connectionType = ConvertJackConnectionTypeWASAPIToPA(jack.ConnectionType);
	pJackDescription->genLocation    = ConvertJackGenLocationWASAPIToPA(jack.GenLocation);
	pJackDescription->geoLocation    = ConvertJackGeoLocationWASAPIToPA(jack.GeoLocation);
	pJackDescription->isConnected    = jack.IsConnected;
	pJackDescription->portConnection = ConvertJackPortConnectionWASAPIToPA(jack.PortConnection);

	// Ok.
	ret = paNoError;

error:

	SAFE_RELEASE(pDeviceTopology);
	SAFE_RELEASE(pConnFrom);
	SAFE_RELEASE(pConnTo);
	SAFE_RELEASE(pPart);
	SAFE_RELEASE(pJackDesc);

	LogHostError(hr);
	return ret;

#else
	(void)nDevice;
	(void)jindex;
	(void)pJackDescription;
	return paUnanticipatedHostError;
#endif
}

// ------------------------------------------------------------------------------------------
HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
{
	HRESULT hr;
	UINT32 frames  = stream->out.framesPerHostCallback,
		   padding = 0;

	(*available) = 0;

	// get read position
	if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding)) != S_OK)
		return LogHostError(hr);

	// get available
	frames -= padding;

	// set
	(*available) = frames;
	return hr;
}

// ------------------------------------------------------------------------------------------
HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
{
	HRESULT hr;

	(*available) = 0;

	// GetCurrentPadding() has opposite meaning to Output stream 
	if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, available)) != S_OK)
		return LogHostError(hr);

	return hr;
}

// ------------------------------------------------------------------------------------------
HRESULT ProcessOutputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor, UINT32 frames)
{
	HRESULT hr;
	BYTE *data = NULL;

	// Get buffer
	if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
	{
		if (stream->out.shareMode == AUDCLNT_SHAREMODE_SHARED)
		{
			// Using GetCurrentPadding to overcome AUDCLNT_E_BUFFER_TOO_LARGE in
			// shared mode results in no sound in Event-driven mode (MSDN does not
			// document this, or is it WASAPI bug?), thus we better
			// try to acquire buffer next time when GetBuffer allows to do so.
#if 0
			// Get Read position
			UINT32 padding = 0;
			hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding);
			if (hr != S_OK)
				return LogHostError(hr);

			// Get frames to write
			frames -= padding;
			if (frames == 0)
				return S_OK;

			if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
				return LogHostError(hr);
#else
			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
				return S_OK; // be silent in shared mode, try again next time
#endif
		}
		else
			return LogHostError(hr);
	}

	// Process data
	if (stream->out.monoMixer != NULL)
	{
		// expand buffer
		UINT32 mono_frames_size = frames * (stream->out.wavex.Format.wBitsPerSample / 8);
		if (mono_frames_size > stream->out.monoBufferSize)
			stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));

		// process
		processor[S_OUTPUT].processor(NULL, 0, (BYTE *)stream->out.monoBuffer, frames, processor[S_OUTPUT].userData);

		// mix 1 to 2 channels
		stream->out.monoMixer(data, stream->out.monoBuffer, frames);
	}
	else
	{
		processor[S_OUTPUT].processor(NULL, 0, data, frames, processor[S_OUTPUT].userData);
	}

	// Release buffer
	if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, frames, 0)) != S_OK)
		LogHostError(hr);

	return hr;
}

// ------------------------------------------------------------------------------------------
HRESULT ProcessInputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor)
{
	HRESULT hr = S_OK;
	UINT32 frames;
	BYTE *data = NULL;
	DWORD flags = 0;

	for (;;)
	{
		// Check if blocking call must be interrupted
		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
			break;

		// Findout if any frames available
		frames = 0;
		if ((hr = _PollGetInputFramesAvailable(stream, &frames)) != S_OK)
			return hr;

		// Empty/consumed buffer
		if (frames == 0)
			break;

		// Get the available data in the shared buffer.
		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &data, &frames, &flags, NULL, NULL)) != S_OK)
		{
			if (hr == AUDCLNT_S_BUFFER_EMPTY)
			{
				hr = S_OK;
				break; // Empty/consumed buffer
			}

			return LogHostError(hr);
			break;
		}

		// Detect silence
		// if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
		//	data = NULL;

		// Process data
		if (stream->in.monoMixer != NULL)
		{
			// expand buffer
			UINT32 mono_frames_size = frames * (stream->in.wavex.Format.wBitsPerSample / 8);
			if (mono_frames_size > stream->in.monoBufferSize)
				stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));

			// mix 1 to 2 channels
			stream->in.monoMixer(stream->in.monoBuffer, data, frames);

			// process
			processor[S_INPUT].processor((BYTE *)stream->in.monoBuffer, frames, NULL, 0, processor[S_INPUT].userData);
		}
		else
		{
			processor[S_INPUT].processor(data, frames, NULL, 0, processor[S_INPUT].userData);
		}

		// Release buffer
		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, frames)) != S_OK)
			return LogHostError(hr);

		//break;
	}

	return hr;
}

// ------------------------------------------------------------------------------------------
void _StreamOnStop(PaWasapiStream *stream)
{
	// Stop INPUT/OUTPUT clients
	if (!stream->bBlocking) 
	{
		if (stream->in.clientProc != NULL)
			IAudioClient_Stop(stream->in.clientProc);
		if (stream->out.clientProc != NULL)
			IAudioClient_Stop(stream->out.clientProc);
	} 
	else 
	{
		if (stream->in.clientParent != NULL)
			IAudioClient_Stop(stream->in.clientParent);
		if (stream->out.clientParent != NULL)
			IAudioClient_Stop(stream->out.clientParent);
	}

	// Restore thread priority
	if (stream->hAvTask != NULL)
	{
		PaWasapi_ThreadPriorityRevert(stream->hAvTask);
		stream->hAvTask = NULL;
	}

    // Notify
    if (stream->streamRepresentation.streamFinishedCallback != NULL)
        stream->streamRepresentation.streamFinishedCallback(stream->streamRepresentation.userData);
}

// ------------------------------------------------------------------------------------------
PA_THREAD_FUNC ProcThreadEvent(void *param)
{
    PaWasapiHostProcessor processor[S_COUNT];
	HRESULT hr;
	DWORD dwResult;
    PaWasapiStream *stream = (PaWasapiStream *)param;
	PaWasapiHostProcessor defaultProcessor;
	BOOL set_event[S_COUNT] = { FALSE, FALSE };
	BOOL bWaitAllEvents = FALSE;
	BOOL bThreadComInitialized = FALSE;

	/*
	If COM is already initialized CoInitialize will either return
	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
	threading mode. In either case we shouldn't consider it an error
	but we need to be careful to not call CoUninitialize() if 
	RPC_E_CHANGED_MODE was returned.
	*/
	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
	{
		PRINT(("WASAPI: failed ProcThreadEvent CoInitialize"));
		return (UINT32)paUnanticipatedHostError;
	}
	if (hr != RPC_E_CHANGED_MODE)
		bThreadComInitialized = TRUE;

	// Unmarshal stream pointers for safe COM operation
	hr = UnmarshalStreamComPointers(stream);
	if (hr != S_OK) {
		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
		goto thread_end;
	}

	// Waiting on all events in case of Full-Duplex/Exclusive mode.
	if ((stream->in.clientProc != NULL) && (stream->out.clientProc != NULL))
	{
		bWaitAllEvents = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) &&
			(stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE);
	}

    // Setup data processors
    defaultProcessor.processor = WaspiHostProcessingLoop;
    defaultProcessor.userData  = stream;
    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);

	// Boost thread priority
	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);

	// Create events
	if (stream->event[S_OUTPUT] == NULL)
	{
		stream->event[S_OUTPUT] = CreateEvent(NULL, FALSE, FALSE, NULL);
		set_event[S_OUTPUT] = TRUE;
	}
	if (stream->event[S_INPUT] == NULL)
	{
		stream->event[S_INPUT]  = CreateEvent(NULL, FALSE, FALSE, NULL);
		set_event[S_INPUT] = TRUE;
	}
	if ((stream->event[S_OUTPUT] == NULL) || (stream->event[S_INPUT] == NULL))
	{
		PRINT(("WASAPI Thread: failed creating Input/Output event handle\n"));
		goto thread_error;
	}

	// Initialize event & start INPUT stream
	if (stream->in.clientProc)
	{
		// Create & set handle
		if (set_event[S_INPUT])
		{
			if ((hr = IAudioClient_SetEventHandle(stream->in.clientProc, stream->event[S_INPUT])) != S_OK)
			{
				LogHostError(hr);
				goto thread_error;
			}
		}

		// Start
		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
		{
			LogHostError(hr);
			goto thread_error;
		}
	}

	// Initialize event & start OUTPUT stream
	if (stream->out.clientProc)
	{
		// Create & set handle
		if (set_event[S_OUTPUT])
		{
			if ((hr = IAudioClient_SetEventHandle(stream->out.clientProc, stream->event[S_OUTPUT])) != S_OK)
			{
				LogHostError(hr);
				goto thread_error;
			}
		}

		// Preload buffer before start
		if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
		{
			LogHostError(hr);
			goto thread_error;
		}

		// Start
		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
		{
			LogHostError(hr);
			goto thread_error;
		}

	}

	// Signal: stream running
	stream->running = TRUE;

	// Notify: thread started
	SetEvent(stream->hThreadStart);

	// Processing Loop
	for (;;)
    {
	    // 10 sec timeout (on timeout stream will auto-stop when processed by WAIT_TIMEOUT case)
        dwResult = WaitForMultipleObjects(S_COUNT, stream->event, bWaitAllEvents, 10*1000);

		// Check for close event (after wait for buffers to avoid any calls to user
		// callback when hCloseRequest was set)
		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
			break;

		// Process S_INPUT/S_OUTPUT
		switch (dwResult)
		{
		case WAIT_TIMEOUT: {
			PRINT(("WASAPI Thread: WAIT_TIMEOUT - probably bad audio driver or Vista x64 bug: use paWinWasapiPolling instead\n"));
			goto thread_end;
			break; }

		// Input stream
		case WAIT_OBJECT_0 + S_INPUT: {

            if (stream->captureClient == NULL)
                break;

			if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
			{
				LogHostError(hr);
				goto thread_error;
			}

			break; }

		// Output stream
		case WAIT_OBJECT_0 + S_OUTPUT: {

            if (stream->renderClient == NULL)
                break;

			if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
			{
				LogHostError(hr);
				goto thread_error;
			}

			break; }
		}
	}

thread_end:

	// Process stop
	_StreamOnStop(stream);

	// Release unmarshaled COM pointers
	ReleaseUnmarshaledComPointers(stream);

	// Cleanup COM for this thread
	if (bThreadComInitialized == TRUE)
		CoUninitialize();

	// Notify: not running
	stream->running = FALSE;

	// Notify: thread exited
	SetEvent(stream->hThreadExit);

	return 0;

thread_error:

	// Prevent deadlocking in Pa_StreamStart
	SetEvent(stream->hThreadStart);

	// Exit
	goto thread_end;
}

// ------------------------------------------------------------------------------------------
PA_THREAD_FUNC ProcThreadPoll(void *param)
{
    PaWasapiHostProcessor processor[S_COUNT];
	HRESULT hr;
    PaWasapiStream *stream = (PaWasapiStream *)param;
	PaWasapiHostProcessor defaultProcessor;
	INT32 i;
	ThreadIdleScheduler scheduler;

	// Calculate the actual duration of the allocated buffer.
	DWORD sleep_ms     = 0;
	DWORD sleep_ms_in;
	DWORD sleep_ms_out;

	BOOL bThreadComInitialized = FALSE;

	/*
	If COM is already initialized CoInitialize will either return
	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
	threading mode. In either case we shouldn't consider it an error
	but we need to be careful to not call CoUninitialize() if 
	RPC_E_CHANGED_MODE was returned.
	*/
	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
	{
		PRINT(("WASAPI: failed ProcThreadPoll CoInitialize"));
		return (UINT32)paUnanticipatedHostError;
	}
	if (hr != RPC_E_CHANGED_MODE)
		bThreadComInitialized = TRUE;

	// Unmarshal stream pointers for safe COM operation
	hr = UnmarshalStreamComPointers(stream);
	if (hr != S_OK) 
	{
		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
		return 0;
	}

	// Calculate timeout for next polling attempt.
	sleep_ms_in  = GetFramesSleepTime(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
	sleep_ms_out = GetFramesSleepTime(stream->out.framesPerBuffer, stream->out.wavex.Format.nSamplesPerSec);

	// WASAPI Input packets tend to expire very easily, let's limit sleep time to 2 milliseconds
	// for all cases. Please propose better solution if any.
	if (sleep_ms_in > 2)
		sleep_ms_in = 2;

	// Adjust polling time for non-paUtilFixedHostBufferSize. Input stream is not adjustable as it is being
	// polled according its packet length.
	if (stream->bufferMode != paUtilFixedHostBufferSize)
	{
		//sleep_ms_in = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->in.wavex.Format.nSamplesPerSec);
		sleep_ms_out = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);
	}

	// Choose smallest
	if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
		sleep_ms = min(sleep_ms_in, sleep_ms_out);
	else
	{
		sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
	}
	// Make sure not 0, othervise use ThreadIdleScheduler
	if (sleep_ms == 0)
	{
		sleep_ms_in  = GetFramesSleepTimeMicroseconds(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
		sleep_ms_out = GetFramesSleepTimeMicroseconds(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);

		// Choose smallest
		if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
			sleep_ms = min(sleep_ms_in, sleep_ms_out);
		else
		{
			sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
		}

		// Setup thread sleep scheduler
		ThreadIdleScheduler_Setup(&scheduler, 1, sleep_ms/* microseconds here */);
		sleep_ms = 0;
	}

    // Setup data processors
    defaultProcessor.processor = WaspiHostProcessingLoop;
    defaultProcessor.userData  = stream;
    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);

	// Boost thread priority
	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);

	// Initialize event & start INPUT stream
	if (stream->in.clientProc)
	{
		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
		{
			LogHostError(hr);
			goto thread_error;
		}
	}

	// Initialize event & start OUTPUT stream
	if (stream->out.clientProc)
	{
		// Preload buffer (obligatory, othervise ->Start() will fail), avoid processing
		// when in full-duplex mode as it requires input processing as well
		if (!PA_WASAPI__IS_FULLDUPLEX(stream))
		{
			UINT32 frames = 0;
			if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) == S_OK)
            {
				if (stream->bufferMode == paUtilFixedHostBufferSize)
				{
					if (frames >= stream->out.framesPerBuffer)
					{
						frames = stream->out.framesPerBuffer;

						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
						{
							LogHostError(hr); // not fatal, just log
						}
					}
				}
				else
				{
					if (frames != 0)
					{
						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
						{
							LogHostError(hr); // not fatal, just log
						}
					}
				}
            }
            else
			{
				LogHostError(hr); // not fatal, just log
			}
		}

		// Start
		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
		{
			LogHostError(hr);
			goto thread_error;
		}
	}

	// Signal: stream running
	stream->running = TRUE;

	// Notify: thread started
	SetEvent(stream->hThreadStart);

	if (!PA_WASAPI__IS_FULLDUPLEX(stream))
	{
		// Processing Loop
		UINT32 next_sleep = sleep_ms;
		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
		{
			// Get next sleep time
			if (sleep_ms == 0)
			{
				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
			}

			for (i = 0; i < S_COUNT; ++i)
			{
				// Process S_INPUT/S_OUTPUT
				switch (i)
				{
				// Input stream
				case S_INPUT: {

					if (stream->captureClient == NULL)
						break;

					if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
					{
						LogHostError(hr);
						goto thread_error;
					}

					break; }

				// Output stream
				case S_OUTPUT: {

					UINT32 frames;
					if (stream->renderClient == NULL)
						break;

					// get available frames
					if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) != S_OK)
					{
						LogHostError(hr);
						goto thread_error;
					}

					// output
					if (stream->bufferMode == paUtilFixedHostBufferSize)
					{
						while (frames >= stream->out.framesPerBuffer)
						{
							if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
							{
								LogHostError(hr);
								goto thread_error;
							}

							frames -= stream->out.framesPerBuffer;
						}
					}
					else
					{
						if (frames != 0)
						{
							if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
							{
								LogHostError(hr);
								goto thread_error;
							}
						}
					}

					break; }
				}
			}
		}
	}
	else
	{
#if 0
		// Processing Loop
		while (WaitForSingleObject(stream->hCloseRequest, 1) == WAIT_TIMEOUT)
		{
			UINT32 i_frames = 0, i_processed = 0;
			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
			DWORD i_flags = 0;
			UINT32 o_frames = 0;

			// get host input buffer
			if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
			{
				if (hr == AUDCLNT_S_BUFFER_EMPTY)
					continue; // no data in capture buffer

				LogHostError(hr);
				break;
			}

			// get available frames
			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
			{
				// release input buffer
				IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);

				LogHostError(hr);
				break;
			}

			// process equal ammount of frames
			if (o_frames >= i_frames)
			{
				// process input ammount of frames
				UINT32 o_processed = i_frames;

				// get host output buffer
				if ((hr = IAudioRenderClient_GetBuffer(stream->procRCClient, o_processed, &o_data)) == S_OK)
				{
					// processed amount of i_frames
					i_processed = i_frames;
					o_data_host = o_data;

					// convert output mono
					if (stream->out.monoMixer)
					{
						UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
						// expand buffer
						if (mono_frames_size > stream->out.monoBufferSize)
						{
							stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
							if (stream->out.monoBuffer == NULL)
							{
								// release input buffer
								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
								// release output buffer
								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);

								LogPaError(paInsufficientMemory);
								break;
							}
						}

						// replace buffer pointer
						o_data = (BYTE *)stream->out.monoBuffer;
					}

					// convert input mono
					if (stream->in.monoMixer)
					{
						UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
						// expand buffer
						if (mono_frames_size > stream->in.monoBufferSize)
						{
							stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
							if (stream->in.monoBuffer == NULL)
							{
								// release input buffer
								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
								// release output buffer
								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);

								LogPaError(paInsufficientMemory);
								break;
							}
						}

						// mix 2 to 1 input channels
						stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);

						// replace buffer pointer
						i_data = (BYTE *)stream->in.monoBuffer;
					}

					// process
					processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);

					// mix 1 to 2 output channels
					if (stream->out.monoBuffer)
						stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);

					// release host output buffer
					if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
						LogHostError(hr);
				}
				else
				{
					if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
						LogHostError(hr); // be silent in shared mode, try again next time
				}
			}

			// release host input buffer
			if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
			{
				LogHostError(hr);
				break;
			}
		}
#else
		// Processing Loop
		UINT32 next_sleep = sleep_ms;
		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
		{
			UINT32 i_frames = 0, i_processed = 0;
			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
			DWORD i_flags = 0;
			UINT32 o_frames = 0;

			// Get next sleep time
			if (sleep_ms == 0)
			{
				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
			}

			// get available frames
			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
			{
				LogHostError(hr);
				break;
			}

			while (o_frames != 0)
			{
				// get host input buffer
				if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
				{
					if (hr == AUDCLNT_S_BUFFER_EMPTY)
						break; // no data in capture buffer

					LogHostError(hr);
					break;
				}

				// process equal ammount of frames
				if (o_frames >= i_frames)
				{
					// process input ammount of frames
					UINT32 o_processed = i_frames;

					// get host output buffer
					if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, o_processed, &o_data)) == S_OK)
					{
						// processed amount of i_frames
						i_processed = i_frames;
						o_data_host = o_data;

						// convert output mono
						if (stream->out.monoMixer)
						{
							UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
							// expand buffer
							if (mono_frames_size > stream->out.monoBufferSize)
							{
								stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
								if (stream->out.monoBuffer == NULL)
								{
									// release input buffer
									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
									// release output buffer
									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);

									LogPaError(paInsufficientMemory);
									goto thread_error;
								}
							}

							// replace buffer pointer
							o_data = (BYTE *)stream->out.monoBuffer;
						}

						// convert input mono
						if (stream->in.monoMixer)
						{
							UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
							// expand buffer
							if (mono_frames_size > stream->in.monoBufferSize)
							{
								stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
								if (stream->in.monoBuffer == NULL)
								{
									// release input buffer
									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
									// release output buffer
									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);

									LogPaError(paInsufficientMemory);
									goto thread_error;
								}
							}

							// mix 2 to 1 input channels
							stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);

							// replace buffer pointer
							i_data = (BYTE *)stream->in.monoBuffer;
						}

						// process
						processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);

						// mix 1 to 2 output channels
						if (stream->out.monoBuffer)
							stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);

						// release host output buffer
						if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
							LogHostError(hr);

						o_frames -= o_processed;
					}
					else
					{
						if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
							LogHostError(hr); // be silent in shared mode, try again next time
					}
				}
				else
				{
					i_processed = 0;
					goto fd_release_buffer_in;
				}

fd_release_buffer_in:

				// release host input buffer
				if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
				{
					LogHostError(hr);
					break;
				}

				// break processing, input hasn't been accumulated yet
				if (i_processed == 0)
					break;
			}
		}
#endif
	}

thread_end:

	// Process stop
	_StreamOnStop(stream);

	// Release unmarshaled COM pointers
	ReleaseUnmarshaledComPointers(stream);

	// Cleanup COM for this thread
	if (bThreadComInitialized == TRUE)
		CoUninitialize();

	// Notify: not running
	stream->running = FALSE;

	// Notify: thread exited
	SetEvent(stream->hThreadExit);

	return 0;

thread_error:

	// Prevent deadlocking in Pa_StreamStart
	SetEvent(stream->hThreadStart);

	// Exit
	goto thread_end;
}

// ------------------------------------------------------------------------------------------
void *PaWasapi_ReallocateMemory(void *ptr, size_t size)
{
	return realloc(ptr, size);
}

// ------------------------------------------------------------------------------------------
void PaWasapi_FreeMemory(void *ptr)
{
	free(ptr);
}

//#endif //VC 2005




#if 0
			if(bFirst) {
				float masteur;
				hr = stream->outVol->GetMasterVolumeLevelScalar(&masteur);
				if (hr != S_OK)
					LogHostError(hr);
				float chan1, chan2;
				hr = stream->outVol->GetChannelVolumeLevelScalar(0, &chan1);
				if (hr != S_OK)
					LogHostError(hr);
				hr = stream->outVol->GetChannelVolumeLevelScalar(1, &chan2);
				if (hr != S_OK)
					LogHostError(hr);

				BOOL bMute;
				hr = stream->outVol->GetMute(&bMute);
				if (hr != S_OK)
					LogHostError(hr);

				stream->outVol->SetMasterVolumeLevelScalar(0.5, NULL);
				stream->outVol->SetChannelVolumeLevelScalar(0, 0.5, NULL);
				stream->outVol->SetChannelVolumeLevelScalar(1, 0.5, NULL);
				stream->outVol->SetMute(FALSE, NULL);
				bFirst = FALSE;
			}
#endif
#endif

#if PA_USE_WDMKS
/*
* $Id$
* PortAudio Windows WDM-KS interface
*
* Author: Andrew Baldwin, Robert Bielik (WaveRT)
* Based on the Open Source API proposed by Ross Bencina
* Copyright (c) 1999-2004 Andrew Baldwin, Ross Bencina, Phil Burk
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files
* (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge,
* publish, distribute, sublicense, and/or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
* ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
* CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*
* The text above constitutes the entire PortAudio license; however, 
* the PortAudio community also makes the following non-binding requests:
*
* Any person wishing to distribute modifications to the Software is
* requested to send the modifications to the original developer so that
* they can be incorporated into the canonical version. It is also 
* requested that these non-binding requests be included along with the 
* license above.
*/

/** @file
@ingroup hostapi_src
@brief Portaudio WDM-KS host API.

@note This is the implementation of the Portaudio host API using the
Windows WDM/Kernel Streaming API in order to enable very low latency
playback and recording on all modern Windows platforms (e.g. 2K, XP, Vista, Win7)
Note: This API accesses the device drivers below the usual KMIXER
component which is normally used to enable multi-client mixing and
format conversion. That means that it will lock out all other users
of a device for the duration of active stream using those devices
*/

#include <stdio.h>

#if (defined(_WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
#pragma comment( lib, "setupapi.lib" )
#endif

/* Debugging/tracing support */

#define PA_LOGE_
#define PA_LOGL_

#ifdef __GNUC__
#include <initguid.h>
#define _WIN32_WINNT 0x0501
#define WINVER 0x0501
#endif

#include <string.h> /* strlen() */
#include <assert.h>
#include <wchar.h>  /* iswspace() */

// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "portaudio.h"
// (amalg) #include "pa_debugprint.h"
// (amalg) #include "pa_memorybarrier.h"
// (amalg) #include "pa_ringbuffer.h"
// (amalg) #include "pa_trace.h"
// (amalg) #include "pa_win_waveformat.h"

// (amalg) #include "pa_win_wdmks.h"

#ifndef DRV_QUERYDEVICEINTERFACE
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#endif
#ifndef DRV_QUERYDEVICEINTERFACESIZE
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#endif

#include <windows.h>
#ifndef __GNUC__ /* Fix for ticket #257: MinGW-w64: Inclusion of <winioctl.h> triggers multiple redefinition errors. */
#include <winioctl.h>
#endif
#include <process.h>

#include <math.h>

#ifdef _MSC_VER
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

/* The PA_HP_TRACE macro is used in RT parts, so it can be switched off without affecting
the rest of the debug tracing */
#if 1
#define PA_HP_TRACE(x)  PaUtil_AddHighSpeedLogMessage x ;
#else
#define PA_HP_TRACE(x)
#endif

/* A define that selects whether the resulting pin names are chosen from pin category
instead of the available pin names, who sometimes can be quite cheesy, like "Volume control".
Default is to use the pin category.
*/
#ifndef PA_WDMKS_USE_CATEGORY_FOR_PIN_NAMES
#define PA_WDMKS_USE_CATEGORY_FOR_PIN_NAMES  1
#endif

#ifdef __GNUC__
#undef PA_LOGE_
#define PA_LOGE_ PA_DEBUG(("%s {\n",__FUNCTION__))
#undef PA_LOGL_
#define PA_LOGL_ PA_DEBUG(("} %s\n",__FUNCTION__))
/* These defines are set in order to allow the WIndows DirectX
* headers to compile with a GCC compiler such as MinGW
* NOTE: The headers may generate a few warning in GCC, but
* they should compile */
#define _INC_MMSYSTEM
#define _INC_MMREG
#define _NTRTL_ /* Turn off default definition of DEFINE_GUIDEX */
#define DEFINE_GUID_THUNK(name,guid) DEFINE_GUID(name,guid)
#define DEFINE_GUIDEX(n) DEFINE_GUID_THUNK( n, STATIC_##n )
#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif
#define  WAVE_FORMAT_ADPCM      0x0002
#define  WAVE_FORMAT_IEEE_FLOAT 0x0003
#define  WAVE_FORMAT_ALAW       0x0006
#define  WAVE_FORMAT_MULAW      0x0007
#define  WAVE_FORMAT_MPEG       0x0050
#define  WAVE_FORMAT_DRM        0x0009
#define DYNAMIC_GUID_THUNK(l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
#define DYNAMIC_GUID(data) DYNAMIC_GUID_THUNK(data)
#endif

/* use CreateThread for CYGWIN/Windows Mobile, _beginthreadex for all others */
#if !defined(__CYGWIN__) && !defined(_WIN32_WCE)
#define CREATE_THREAD_FUNCTION (HANDLE)_beginthreadex
#define PA_THREAD_FUNC static unsigned WINAPI
#else
#define CREATE_THREAD_FUNCTION CreateThread
#define PA_THREAD_FUNC static DWORD WINAPI
#endif

#ifdef _MSC_VER
#define NOMMIDS
#define DYNAMIC_GUID(data) {data}
#define _NTRTL_ /* Turn off default definition of DEFINE_GUIDEX */
#undef DEFINE_GUID
#define DEFINE_GUID(n,data) EXTERN_C const GUID n = {data}
#define DEFINE_GUID_THUNK(n,data) DEFINE_GUID(n,data)
#define DEFINE_GUIDEX(n) DEFINE_GUID_THUNK(n, STATIC_##n)
#endif

#include <setupapi.h>

#ifndef EXTERN_C
#define EXTERN_C extern
#endif

#if defined(__GNUC__)

/* For MinGW we reference mingw-include files supplied with WASAPI */
#define WINBOOL BOOL

// (amalg) #include "../wasapi/mingw-include/ks.h"
// (amalg) #include "../wasapi/mingw-include/ksmedia.h"

#else

#include <mmreg.h>
#include <ks.h>

/* Note that Windows SDK V6.0A or later is needed for WaveRT specific structs to be present in
   ksmedia.h. Also make sure that the SDK include path is before other include paths (that may contain
   an "old" ksmedia.h), so the proper ksmedia.h is used */
#include <ksmedia.h>

#endif

#include <assert.h>
#include <stdio.h>

/* These next definitions allow the use of the KSUSER DLL */
typedef /*KSDDKAPI*/ DWORD WINAPI KSCREATEPIN(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE);
extern HMODULE      DllKsUser;
extern KSCREATEPIN* FunctionKsCreatePin;

/* These definitions allows the use of AVRT.DLL on Vista and later OSs */
typedef enum _PA_AVRT_PRIORITY
{
    PA_AVRT_PRIORITY_LOW = -1,
    PA_AVRT_PRIORITY_NORMAL,
    PA_AVRT_PRIORITY_HIGH,
    PA_AVRT_PRIORITY_CRITICAL
} PA_AVRT_PRIORITY, *PPA_AVRT_PRIORITY;

typedef struct
{
    HINSTANCE hInstance;

    HANDLE  (WINAPI *AvSetMmThreadCharacteristics) (LPCSTR, LPDWORD);
    BOOL    (WINAPI *AvRevertMmThreadCharacteristics) (HANDLE);
    BOOL    (WINAPI *AvSetMmThreadPriority) (HANDLE, PA_AVRT_PRIORITY);
} PaWinWDMKSAvRtEntryPoints;

static PaWinWDMKSAvRtEntryPoints paWinWDMKSAvRtEntryPoints = {0};

/* An unspecified channel count (-1) is not treated correctly, so we replace it with
* an arbitrarily large number */ 
#define MAXIMUM_NUMBER_OF_CHANNELS 256

/* Forward definition to break circular type reference between pin and filter */
struct __PaWinWdmFilter;
typedef struct __PaWinWdmFilter PaWinWdmFilter;

struct __PaWinWdmPin;
typedef struct __PaWinWdmPin PaWinWdmPin;

struct __PaWinWdmStream;
typedef struct __PaWinWdmStream PaWinWdmStream;

/* Function prototype for getting audio position */
typedef PaError (*FunctionGetPinAudioPosition)(PaWinWdmPin*, unsigned long*);

/* Function prototype for memory barrier */
typedef void (*FunctionMemoryBarrier)(void);

struct __PaProcessThreadInfo;
typedef struct __PaProcessThreadInfo PaProcessThreadInfo;

typedef PaError (*FunctionPinHandler)(PaProcessThreadInfo* pInfo, unsigned eventIndex);

typedef enum __PaStreamStartEnum
{
    StreamStart_kOk,
    StreamStart_kFailed,
    StreamStart_kCnt
} PaStreamStartEnum;

/* Multiplexed input structure.
*  Very often several physical inputs are multiplexed through a MUX node (represented in the topology filter) */
typedef struct __PaWinWdmMuxedInput
{
    wchar_t                     friendlyName[MAX_PATH];
    ULONG                       muxPinId;
    ULONG                       muxNodeId;
    ULONG                       endpointPinId;
} PaWinWdmMuxedInput;

/* The Pin structure
* A pin is an input or output node, e.g. for audio flow */
struct __PaWinWdmPin
{
    HANDLE                      handle;
    PaWinWdmMuxedInput**        inputs;
    unsigned                    inputCount;
    wchar_t                     friendlyName[MAX_PATH];

    PaWinWdmFilter*             parentFilter;
    PaWDMKSSubType              pinKsSubType;
    unsigned long               pinId;
    unsigned long               endpointPinId;  /* For output pins */
    KSPIN_CONNECT*              pinConnect;
    unsigned long               pinConnectSize;
    KSDATAFORMAT_WAVEFORMATEX*  ksDataFormatWfx;
    KSPIN_COMMUNICATION         communication;
    KSDATARANGE*                dataRanges;
    KSMULTIPLE_ITEM*            dataRangesItem;
    KSPIN_DATAFLOW              dataFlow;
    KSPIN_CINSTANCES            instances;
    unsigned long               frameSize;
    int                         maxChannels;
    unsigned long               formats;
    int                         defaultSampleRate;
    ULONG                       *positionRegister;  /* WaveRT */
    ULONG                       hwLatency;          /* WaveRT */
    FunctionMemoryBarrier       fnMemBarrier;       /* WaveRT */
    FunctionGetPinAudioPosition fnAudioPosition;    /* WaveRT */
    FunctionPinHandler          fnEventHandler;
    FunctionPinHandler          fnSubmitHandler;
};

/* The Filter structure
* A filter has a number of pins and a "friendly name" */
struct __PaWinWdmFilter
{
    HANDLE         handle;
    PaWinWDMKSDeviceInfo    devInfo;  /* This will hold information that is exposed in PaDeviceInfo */

    DWORD            deviceNode;
    int            pinCount;
    PaWinWdmPin**  pins;
    PaWinWdmFilter*  topologyFilter;
    wchar_t          friendlyName[MAX_PATH];
    int              validPinCount;
    int            usageCount;
    KSMULTIPLE_ITEM* connections;
    KSMULTIPLE_ITEM* nodes;
    int              filterRefCount;
};


typedef struct __PaWinWdmDeviceInfo
{
    PaDeviceInfo    inheritedDeviceInfo;
    char            compositeName[MAX_PATH];   /* Composite name consists of pin name + device name in utf8 */
    PaWinWdmFilter* filter;
    unsigned long   pin;
    int             muxPosition;    /* Used only for input devices */
    int             endpointPinId;
}
PaWinWdmDeviceInfo;

/* PaWinWdmHostApiRepresentation - host api datastructure specific to this implementation */
typedef struct __PaWinWdmHostApiRepresentation
{
    PaUtilHostApiRepresentation  inheritedHostApiRep;
    PaUtilStreamInterface        callbackStreamInterface;
    PaUtilStreamInterface        blockingStreamInterface;

    PaUtilAllocationGroup*       allocations;
    int                          deviceCount;
}
PaWinWdmHostApiRepresentation;

typedef struct __DATAPACKET
{
    KSSTREAM_HEADER  Header;
    OVERLAPPED       Signal;
} DATAPACKET;

typedef struct __PaIOPacket
{
    DATAPACKET*     packet;
    unsigned        startByte;
    unsigned        lengthBytes;
} PaIOPacket;

typedef struct __PaWinWdmIOInfo
{
    PaWinWdmPin*        pPin;
    char*               hostBuffer;
    unsigned            hostBufferSize;
    unsigned            framesPerBuffer;
    unsigned            bytesPerFrame;
    unsigned            bytesPerSample;
    unsigned            noOfPackets;    /* Only used in WaveCyclic */
    HANDLE              *events;        /* noOfPackets handles (WaveCyclic) 1 (WaveRT) */
    DATAPACKET          *packets;       /* noOfPackets packets (WaveCyclic) 2 (WaveRT) */
    /* WaveRT polled mode */
    unsigned            lastPosition; 
    unsigned            pollCntr;
} PaWinWdmIOInfo;

/* PaWinWdmStream - a stream data structure specifically for this implementation */
struct __PaWinWdmStream
{
    PaUtilStreamRepresentation  streamRepresentation;
    PaWDMKSSpecificStreamInfo   hostApiStreamInfo;    /* This holds info that is exposed through PaStreamInfo */
    PaUtilCpuLoadMeasurer       cpuLoadMeasurer;
    PaUtilBufferProcessor       bufferProcessor;

#if PA_TRACE_REALTIME_EVENTS
    LogHandle                   hLog;
#endif

    PaUtilAllocationGroup*      allocGroup;
    PaWinWdmIOInfo              capture;
    PaWinWdmIOInfo              render;
    int                         streamStarted;
    int                         streamActive;
    int                         streamStop;
    int                         streamAbort;
    int                         oldProcessPriority;
    HANDLE                      streamThread;
    HANDLE                      eventAbort;
    HANDLE                      eventStreamStart[StreamStart_kCnt];        /* 0 = OK, 1 = Failed */
    PaError                     threadResult;
    PaStreamFlags               streamFlags;

    /* Capture ring buffer */
    PaUtilRingBuffer            ringBuffer;
    char*                       ringBufferData;

    /* These values handle the case where the user wants to use fewer
    * channels than the device has */
    int                         userInputChannels;
    int                         deviceInputChannels;
    int                         userOutputChannels;
    int                         deviceOutputChannels;
};

/* Gather all processing variables in a struct */
struct __PaProcessThreadInfo 
{
    PaWinWdmStream              *stream;
    PaStreamCallbackTimeInfo    ti;
    PaStreamCallbackFlags       underover;
    int                         cbResult;
    volatile int                pending;
    volatile int                priming;
    volatile int                pinsStarted;
    unsigned long               timeout;
    unsigned                    captureHead;
    unsigned                    captureTail;
    unsigned                    renderHead;
    unsigned                    renderTail;
    PaIOPacket                  capturePackets[4];
    PaIOPacket                  renderPackets[4];
};

/* Used for transferring device infos during scanning / rescanning */
typedef struct __PaWinWDMScanDeviceInfosResults
{ 
    PaDeviceInfo **deviceInfos;
    PaDeviceIndex defaultInputDevice;
    PaDeviceIndex defaultOutputDevice;
} PaWinWDMScanDeviceInfosResults;

static const unsigned cPacketsArrayMask = 3;

HMODULE      DllKsUser = NULL;
KSCREATEPIN* FunctionKsCreatePin = NULL;

/* prototypes for functions declared in this file */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

    PaError PaWinWdm_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */

/* Low level I/O functions */
static PaError WdmSyncIoctl(HANDLE handle,
                            unsigned long ioctlNumber,
                            void* inBuffer,
                            unsigned long inBufferCount,
                            void* outBuffer,
                            unsigned long outBufferCount,
                            unsigned long* bytesReturned);

static PaError WdmGetPropertySimple(HANDLE handle,
                                    const GUID* const guidPropertySet,
                                    unsigned long property,
                                    void* value,
                                    unsigned long valueCount);

static PaError WdmSetPropertySimple(HANDLE handle,
                                    const GUID* const guidPropertySet,
                                    unsigned long property,
                                    void* value,
                                    unsigned long valueCount,
                                    void* instance,
                                    unsigned long instanceCount);

static PaError WdmGetPinPropertySimple(HANDLE  handle,
                                       unsigned long pinId,
                                       const GUID* const guidPropertySet,
                                       unsigned long property,
                                       void* value,
                                       unsigned long valueCount,
                                       unsigned long* byteCount);

static PaError WdmGetPinPropertyMulti(HANDLE  handle,
                                      unsigned long pinId,
                                      const GUID* const guidPropertySet,
                                      unsigned long property,
                                      KSMULTIPLE_ITEM** ksMultipleItem);

static PaError WdmGetPropertyMulti(HANDLE handle,
                                   const GUID* const guidPropertySet,
                                   unsigned long property,
                                   KSMULTIPLE_ITEM** ksMultipleItem);

static PaError WdmSetMuxNodeProperty(HANDLE handle,
                                     ULONG nodeId,
                                     ULONG pinId);


/** Pin management functions */
static PaWinWdmPin* PinNew(PaWinWdmFilter* parentFilter, unsigned long pinId, PaError* error);
static void PinFree(PaWinWdmPin* pin);
static void PinClose(PaWinWdmPin* pin);
static PaError PinInstantiate(PaWinWdmPin* pin);
/*static PaError PinGetState(PaWinWdmPin* pin, KSSTATE* state); NOT USED */
static PaError PinSetState(PaWinWdmPin* pin, KSSTATE state);
static PaError PinSetFormat(PaWinWdmPin* pin, const WAVEFORMATEX* format);
static PaError PinIsFormatSupported(PaWinWdmPin* pin, const WAVEFORMATEX* format);
/* WaveRT support */
static PaError PinQueryNotificationSupport(PaWinWdmPin* pPin, BOOL* pbResult);
static PaError PinGetBuffer(PaWinWdmPin* pPin, void** pBuffer, DWORD* pRequestedBufSize, BOOL* pbCallMemBarrier);
static PaError PinRegisterPositionRegister(PaWinWdmPin* pPin);
static PaError PinRegisterNotificationHandle(PaWinWdmPin* pPin, HANDLE handle);
static PaError PinUnregisterNotificationHandle(PaWinWdmPin* pPin, HANDLE handle);
static PaError PinGetHwLatency(PaWinWdmPin* pPin, ULONG* pFifoSize, ULONG* pChipsetDelay, ULONG* pCodecDelay);
static PaError PinGetAudioPositionMemoryMapped(PaWinWdmPin* pPin, ULONG* pPosition);
static PaError PinGetAudioPositionViaIOCTLRead(PaWinWdmPin* pPin, ULONG* pPosition);
static PaError PinGetAudioPositionViaIOCTLWrite(PaWinWdmPin* pPin, ULONG* pPosition);

/* Filter management functions */
static PaWinWdmFilter* FilterNew(PaWDMKSType type, DWORD devNode, const wchar_t* filterName, const wchar_t* friendlyName, PaError* error);
static PaError FilterInitializePins(PaWinWdmFilter* filter);
static void FilterFree(PaWinWdmFilter* filter);
static void FilterAddRef(PaWinWdmFilter* filter);
static PaWinWdmPin* FilterCreatePin(
                                    PaWinWdmFilter* filter,
                                    int pinId,
                                    const WAVEFORMATEX* wfex,
                                    PaError* error);
static PaError FilterUse(PaWinWdmFilter* filter);
static void FilterRelease(PaWinWdmFilter* filter);

/* Hot plug functions */
static BOOL IsDeviceTheSame(const PaWinWdmDeviceInfo* pDev1,
                            const PaWinWdmDeviceInfo* pDev2);

/* Interface functions */
static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError IsFormatSupported(
struct PaUtilHostApiRepresentation *hostApi,
    const PaStreamParameters *inputParameters,
    const PaStreamParameters *outputParameters,
    double sampleRate );

static PaError ScanDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, PaHostApiIndex index, void **newDeviceInfos, int *newDeviceCount );
static PaError CommitDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, PaHostApiIndex index, void *deviceInfos, int deviceCount );
static PaError DisposeDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, void *deviceInfos, int deviceCount );

static PaError OpenStream(
struct PaUtilHostApiRepresentation *hostApi,
    PaStream** s,
    const PaStreamParameters *inputParameters,
    const PaStreamParameters *outputParameters,
    double sampleRate,
    unsigned long framesPerBuffer,
    PaStreamFlags streamFlags,
    PaStreamCallback *streamCallback,
    void *userData );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream(
                          PaStream* stream,
                          void *buffer,
                          unsigned long frames );
static PaError WriteStream(
                           PaStream* stream,
                           const void *buffer,
                           unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );

/* Utility functions */
static unsigned long GetWfexSize(const WAVEFORMATEX* wfex);
static PaWinWdmFilter** BuildFilterList(int* filterCount, int* noOfPaDevices, PaError* result);
static BOOL PinWrite(HANDLE h, DATAPACKET* p);
static BOOL PinRead(HANDLE h, DATAPACKET* p);
static void DuplicateFirstChannelInt16(void* buffer, int channels, int samples);
static void DuplicateFirstChannelInt24(void* buffer, int channels, int samples);
PA_THREAD_FUNC ProcessingThread(void*);

/* Pin handler functions */
static PaError PaPinCaptureEventHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinCaptureSubmitHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex);

static PaError PaPinRenderEventHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinRenderSubmitHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex);

static PaError PaPinCaptureEventHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinCaptureEventHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinCaptureSubmitHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinCaptureSubmitHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex);

static PaError PaPinRenderEventHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinRenderEventHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinRenderSubmitHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex);
static PaError PaPinRenderSubmitHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex);

/* Function bodies */

#if defined(_DEBUG) && defined(PA_ENABLE_DEBUG_OUTPUT)
#define PA_WDMKS_SET_TREF
static PaTime tRef = 0;

static void PaWinWdmDebugPrintf(const char* fmt, ...)
{
    va_list list;
    char buffer[1024];
    PaTime t = PaUtil_GetTime() - tRef;
    va_start(list, fmt);
    _vsnprintf(buffer, 1023, fmt, list);
    va_end(list);
    PaUtil_DebugPrint("%6.3lf: %s", t, buffer);
}

#ifdef PA_DEBUG
#undef PA_DEBUG
#define PA_DEBUG(x)    PaWinWdmDebugPrintf x ;
#endif
#endif

static BOOL IsDeviceTheSame(const PaWinWdmDeviceInfo* pDev1,
                            const PaWinWdmDeviceInfo* pDev2)
{
    if (pDev1 == NULL || pDev2 == NULL)
        return FALSE;

    if (pDev1 == pDev2)
        return TRUE;

    if (strcmp(pDev1->compositeName, pDev2->compositeName) == 0)
        return TRUE;

    return FALSE;
}

static BOOL IsEarlierThanVista()
{
/*
NOTE: GetVersionEx() is deprecated as of Windows 8.1 and can not be used to reliably detect
versions of Windows higher than Windows 8 (due to manifest requirements for reporting higher versions).
Microsoft recommends switching to VerifyVersionInfo (available on Win 2k and later), however GetVersionEx
is is faster, for now we just disable the deprecation warning.
See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724451(v=vs.85).aspx
See: http://www.codeproject.com/Articles/678606/Part-Overcoming-Windows-s-deprecation-of-GetVe
*/
#pragma warning (disable : 4996) /* use of GetVersionEx */

    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (GetVersionEx(&osvi) && osvi.dwMajorVersion<6)
    {
        return TRUE;
    }
    return FALSE;

#pragma warning (default : 4996)
}



static void MemoryBarrierDummy(void)
{
    /* Do nothing */
}

static void MemoryBarrierRead(void)
{
    PaUtil_ReadMemoryBarrier();
}

static void MemoryBarrierWrite(void)
{
    PaUtil_WriteMemoryBarrier();
}

static unsigned long GetWfexSize(const WAVEFORMATEX* wfex)
{
    if( wfex->wFormatTag == WAVE_FORMAT_PCM )
    {
        return sizeof( WAVEFORMATEX );
    }
    else
    {
        return (sizeof( WAVEFORMATEX ) + wfex->cbSize);
    }
}

static void PaWinWDM_SetLastErrorInfo(long errCode, const char* fmt, ...)
{
    va_list list;
    char buffer[1024];
    va_start(list, fmt);
    _vsnprintf(buffer, 1023, fmt, list);
    va_end(list);
    PaUtil_SetLastHostErrorInfo(paWDMKS, errCode, buffer);
}

/*
Low level pin/filter access functions
*/
static PaError WdmSyncIoctl(
                            HANDLE handle,
                            unsigned long ioctlNumber,
                            void* inBuffer,
                            unsigned long inBufferCount,
                            void* outBuffer,
                            unsigned long outBufferCount,
                            unsigned long* bytesReturned)
{
    PaError result = paNoError;
    unsigned long dummyBytesReturned = 0;
    BOOL bRes;

    if( !bytesReturned )
    {
        /* Use a dummy as the caller hasn't supplied one */
        bytesReturned = &dummyBytesReturned;
    }

    bRes = DeviceIoControl(handle, ioctlNumber, inBuffer, inBufferCount, outBuffer, outBufferCount, bytesReturned, NULL);
    if (!bRes)
    {
        unsigned long error = GetLastError();
        if ( !(((error == ERROR_INSUFFICIENT_BUFFER ) || ( error == ERROR_MORE_DATA )) && 
            ( ioctlNumber == IOCTL_KS_PROPERTY ) &&
            ( outBufferCount == 0 ) ) ) 
        {
            KSPROPERTY* ksProperty = (KSPROPERTY*)inBuffer;

            PaWinWDM_SetLastErrorInfo(result, "WdmSyncIoctl: DeviceIoControl GLE = 0x%08X (prop_set = {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}, prop_id = %u)",
                error,
                ksProperty->Set.Data1, ksProperty->Set.Data2, ksProperty->Set.Data3,
                ksProperty->Set.Data4[0], ksProperty->Set.Data4[1],
                ksProperty->Set.Data4[2], ksProperty->Set.Data4[3],
                ksProperty->Set.Data4[4], ksProperty->Set.Data4[5],
                ksProperty->Set.Data4[6], ksProperty->Set.Data4[7],
                ksProperty->Id
                );
            result = paUnanticipatedHostError;
        }
    }
    return result;
}

static PaError WdmGetPropertySimple(HANDLE handle,
                                    const GUID* const guidPropertySet,
                                    unsigned long property,
                                    void* value,
                                    unsigned long valueCount)
{
    PaError result;
    KSPROPERTY ksProperty;

    ksProperty.Set = *guidPropertySet;
    ksProperty.Id = property;
    ksProperty.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksProperty,
        sizeof(KSPROPERTY),
        value,
        valueCount,
        NULL);

    return result;
}

static PaError WdmSetPropertySimple(
                                    HANDLE handle,
                                    const GUID* const guidPropertySet,
                                    unsigned long property,
                                    void* value,
                                    unsigned long valueCount,
                                    void* instance,
                                    unsigned long instanceCount)
{
    PaError result;
    KSPROPERTY* ksProperty;
    unsigned long propertyCount  = 0;

    propertyCount = sizeof(KSPROPERTY) + instanceCount;
    ksProperty = (KSPROPERTY*)_alloca( propertyCount );
    if( !ksProperty )
    {
        return paInsufficientMemory;
    }

    ksProperty->Set = *guidPropertySet;
    ksProperty->Id = property;
    ksProperty->Flags = KSPROPERTY_TYPE_SET;

    if( instance )
    {
        memcpy((void*)((char*)ksProperty + sizeof(KSPROPERTY)), instance, instanceCount);
    }

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        ksProperty,
        propertyCount,
        value,
        valueCount,
        NULL);

    return result;
}

static PaError WdmGetPinPropertySimple(
                                       HANDLE  handle,
                                       unsigned long pinId,
                                       const GUID* const guidPropertySet,
                                       unsigned long property,
                                       void* value,
                                       unsigned long valueCount,
                                       unsigned long *byteCount)
{
    PaError result;

    KSP_PIN ksPProp;
    ksPProp.Property.Set = *guidPropertySet;
    ksPProp.Property.Id = property;
    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksPProp.PinId = pinId;
    ksPProp.Reserved = 0;

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksPProp,
        sizeof(KSP_PIN),
        value,
        valueCount,
        byteCount);

    return result;
}

static PaError WdmGetPinPropertyMulti(
                                      HANDLE handle,
                                      unsigned long pinId,
                                      const GUID* const guidPropertySet,
                                      unsigned long property,
                                      KSMULTIPLE_ITEM** ksMultipleItem)
{
    PaError result;
    unsigned long multipleItemSize = 0;
    KSP_PIN ksPProp;

    ksPProp.Property.Set = *guidPropertySet;
    ksPProp.Property.Id = property;
    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksPProp.PinId = pinId;
    ksPProp.Reserved = 0;

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksPProp.Property,
        sizeof(KSP_PIN),
        NULL,
        0,
        &multipleItemSize);
    if( result != paNoError )
    {
        return result;
    }

    *ksMultipleItem = (KSMULTIPLE_ITEM*)PaUtil_AllocateMemory( multipleItemSize );
    if( !*ksMultipleItem )
    {
        return paInsufficientMemory;
    }

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksPProp,
        sizeof(KSP_PIN),
        (void*)*ksMultipleItem,
        multipleItemSize,
        NULL);

    if( result != paNoError )
    {
        PaUtil_FreeMemory( ksMultipleItem );
    }

    return result;
}

static PaError WdmGetPropertyMulti(HANDLE handle,
                                   const GUID* const guidPropertySet,
                                   unsigned long property,
                                   KSMULTIPLE_ITEM** ksMultipleItem)
{
    PaError result;
    unsigned long multipleItemSize = 0;
    KSPROPERTY ksProp;

    ksProp.Set = *guidPropertySet;
    ksProp.Id = property;
    ksProp.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksProp,
        sizeof(KSPROPERTY),
        NULL,
        0,
        &multipleItemSize);
    if( result != paNoError )
    {
        return result;
    }

    *ksMultipleItem = (KSMULTIPLE_ITEM*)PaUtil_AllocateMemory( multipleItemSize );
    if( !*ksMultipleItem )
    {
        return paInsufficientMemory;
    }

    result = WdmSyncIoctl(
        handle,
        IOCTL_KS_PROPERTY,
        &ksProp,
        sizeof(KSPROPERTY),
        (void*)*ksMultipleItem,
        multipleItemSize,
        NULL);

    if( result != paNoError )
    {
        PaUtil_FreeMemory( ksMultipleItem );
    }

    return result;
}

static PaError WdmSetMuxNodeProperty(HANDLE handle,
                                     ULONG nodeId,
                                     ULONG pinId)
{
    PaError result = paNoError;
    KSNODEPROPERTY prop;
    prop.Property.Set = KSPROPSETID_Audio;
    prop.Property.Id = KSPROPERTY_AUDIO_MUX_SOURCE;
    prop.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    prop.NodeId = nodeId;
    prop.Reserved = 0;

    result = WdmSyncIoctl(handle, IOCTL_KS_PROPERTY, &prop, sizeof(KSNODEPROPERTY), &pinId, sizeof(ULONG), NULL);

    return result;
}

/* Used when traversing topology for outputs */
static const KSTOPOLOGY_CONNECTION* GetConnectionTo(const KSTOPOLOGY_CONNECTION* pFrom, PaWinWdmFilter* filter, int muxIdx)
{
    unsigned i;
    const KSTOPOLOGY_CONNECTION* retval = NULL;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    (void)muxIdx;
    PA_DEBUG(("GetConnectionTo: Checking %u connections... (pFrom = %p)", filter->connections->Count, pFrom));
    for (i = 0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        if (pConn == pFrom)
            continue;

        if (pConn->FromNode == pFrom->ToNode)
        {
            retval = pConn;
            break;
        }
    }
    PA_DEBUG(("GetConnectionTo: Returning %p\n", retval));
    return retval;
}

/* Used when traversing topology for inputs */
static const KSTOPOLOGY_CONNECTION* GetConnectionFrom(const KSTOPOLOGY_CONNECTION* pTo, PaWinWdmFilter* filter, int muxIdx)
{
    unsigned i;
    const KSTOPOLOGY_CONNECTION* retval = NULL;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    int muxCntr = 0;
    PA_DEBUG(("GetConnectionFrom: Checking %u connections... (pTo = %p)\n", filter->connections->Count, pTo));
    for (i = 0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        if (pConn == pTo)
            continue;

        if (pConn->ToNode == pTo->FromNode)
        {
            if (muxIdx >= 0)
            {
                if (muxCntr < muxIdx)
                {
                    ++muxCntr;
                    continue;
                }
            }
            retval = pConn;
            break;
        }
    }
    PA_DEBUG(("GetConnectionFrom: Returning %p\n", retval));
    return retval;
}

static ULONG GetNumberOfConnectionsTo(const KSTOPOLOGY_CONNECTION* pTo, PaWinWdmFilter* filter)
{
    ULONG retval = 0;
    unsigned i;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    PA_DEBUG(("GetNumberOfConnectionsTo: Checking %u connections...\n", filter->connections->Count));
    for (i = 0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        if (pConn->ToNode == pTo->FromNode &&
            (pTo->FromNode != KSFILTER_NODE || pConn->ToNodePin == pTo->FromNodePin))
        {
            ++retval;
        }
    }
    PA_DEBUG(("GetNumberOfConnectionsTo: Returning %d\n", retval));
    return retval;
}

typedef const KSTOPOLOGY_CONNECTION *(*TFnGetConnection)(const KSTOPOLOGY_CONNECTION*, PaWinWdmFilter*, int);

static const KSTOPOLOGY_CONNECTION* FindStartConnectionFrom(ULONG startPin, PaWinWdmFilter* filter)
{
    unsigned i;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    PA_DEBUG(("FindStartConnectionFrom: Startpin %u, Checking %u connections...\n", startPin, filter->connections->Count));
    for (i = 0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        if (pConn->ToNode == KSFILTER_NODE && pConn->ToNodePin == startPin)
        {
            PA_DEBUG(("FindStartConnectionFrom: returning %p\n", pConn));
            return pConn;
        }
    }

    PA_DEBUG(("FindStartConnectionFrom: returning NULL\n"));
    assert(FALSE);
    return 0;
}

static const KSTOPOLOGY_CONNECTION* FindStartConnectionTo(ULONG startPin, PaWinWdmFilter* filter)
{
    unsigned i;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    PA_DEBUG(("FindStartConnectionTo: Startpin %u, Checking %u connections...\n", startPin, filter->connections->Count));
    for (i = 0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        if (pConn->FromNode == KSFILTER_NODE && pConn->FromNodePin == startPin)
        {
            PA_DEBUG(("FindStartConnectionTo: returning %p\n", pConn));
            return pConn;
        }
    }

    PA_DEBUG(("FindStartConnectionTo: returning NULL\n"));
    assert(FALSE);
    return 0;
}

static ULONG GetConnectedPin(ULONG startPin, BOOL forward, PaWinWdmFilter* filter, int muxPosition, ULONG *muxInputPinId, ULONG *muxNodeId)
{
    int limit=1000;
    const KSTOPOLOGY_CONNECTION *conn = NULL; 
    TFnGetConnection fnGetConnection = forward ? GetConnectionTo : GetConnectionFrom ;
    PA_LOGE_;
    while (1)
    {
        limit--;
        if (limit == 0) {
           PA_DEBUG(("GetConnectedPin: LOOP LIMIT REACHED\n"));
           break;
        }

        if (conn == NULL)
        {
            conn = forward ? FindStartConnectionTo(startPin, filter) : FindStartConnectionFrom(startPin, filter);
        }
        else
        {
            conn = fnGetConnection(conn, filter, -1);
        }

        /* Handling case of erroneous connection list */
        if (conn == NULL)
        {
            break;
        }

        if (forward ? conn->ToNode == KSFILTER_NODE : conn->FromNode == KSFILTER_NODE)
        {
            return forward ? conn->ToNodePin : conn->FromNodePin;
        }
        else
        {
            PA_DEBUG(("GetConnectedPin: count=%d, forward=%d, muxPosition=%d\n", filter->nodes->Count, forward, muxPosition));
            if (filter->nodes->Count > 0 && !forward && muxPosition >= 0)
            {
                const GUID* nodes = (const GUID*)(filter->nodes + 1);
                if (IsEqualGUID(&nodes[conn->FromNode], &KSNODETYPE_MUX))
                {
                    ULONG nConn = GetNumberOfConnectionsTo(conn, filter);
                    conn = fnGetConnection(conn, filter, muxPosition);
                    if (conn == NULL)
                    {
                        break;
                    }
                    if (muxInputPinId != 0)
                    {
                        *muxInputPinId = conn->ToNodePin;
                    }
                    if (muxNodeId != 0)
                    {
                        *muxNodeId = conn->ToNode;
                    }
                }
            }
        }
    }
    PA_LOGL_;
    return KSFILTER_NODE;
}

static void DumpConnectionsAndNodes(PaWinWdmFilter* filter)
{
    unsigned i;
    const KSTOPOLOGY_CONNECTION* connections = (const KSTOPOLOGY_CONNECTION*)(filter->connections + 1);
    const GUID* nodes = (const GUID*)(filter->nodes + 1);

    PA_LOGE_;
    PA_DEBUG(("DumpConnectionsAndNodes: connections=%d, nodes=%d\n", filter->connections->Count, filter->nodes->Count));

    for (i=0; i < filter->connections->Count; ++i)
    {
        const KSTOPOLOGY_CONNECTION* pConn = connections + i;
        PA_DEBUG(("  Connection: %u - FromNode=%u,FromPin=%u -> ToNode=%u,ToPin=%u\n", 
            i,
            pConn->FromNode, pConn->FromNodePin,
            pConn->ToNode, pConn->ToNodePin
            ));
    }

    for (i=0; i < filter->nodes->Count; ++i)
    {
        const GUID* pConn = nodes + i;
        PA_DEBUG(("  Node: %d - {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
            i,
            pConn->Data1, pConn->Data2, pConn->Data3,
            pConn->Data4[0], pConn->Data4[1],
            pConn->Data4[2], pConn->Data4[3],
            pConn->Data4[4], pConn->Data4[5],
            pConn->Data4[6], pConn->Data4[7]
        ));
    }
    PA_LOGL_;

}

typedef struct __PaUsbTerminalGUIDToName 
{
    USHORT     usbGUID;
    wchar_t    name[64];
} PaUsbTerminalGUIDToName;

static const PaUsbTerminalGUIDToName kNames[] =
{
    /* Types copied from: http://msdn.microsoft.com/en-us/library/ff537742(v=vs.85).aspx */
    /* Input terminal types */
    { 0x0201, L"Microphone" },
    { 0x0202, L"Desktop Microphone" },
    { 0x0203, L"Personal Microphone" },
    { 0x0204, L"Omni Directional Microphone" },
    { 0x0205, L"Microphone Array" },
    { 0x0206, L"Processing Microphone Array" },
    /* Output terminal types */
    { 0x0301, L"Speakers" },
    { 0x0302, L"Headphones" },
    { 0x0303, L"Head Mounted Display Audio" },
    { 0x0304, L"Desktop Speaker" },
    { 0x0305, L"Room Speaker" },
    { 0x0306, L"Communication Speaker" },
    { 0x0307, L"LFE Speakers" },
    /* External terminal types */
    { 0x0601, L"Analog" },
    { 0x0602, L"Digital" },
    { 0x0603, L"Line" },
    { 0x0604, L"Audio" },
    { 0x0605, L"SPDIF" },
};

static const unsigned kNamesCnt = sizeof(kNames)/sizeof(PaUsbTerminalGUIDToName);

static int PaUsbTerminalGUIDToNameCmp(const void* lhs, const void* rhs)
{
    const PaUsbTerminalGUIDToName* pL = (const PaUsbTerminalGUIDToName*)lhs;
    const PaUsbTerminalGUIDToName* pR = (const PaUsbTerminalGUIDToName*)rhs;
    return ((int)(pL->usbGUID) - (int)(pR->usbGUID));
}

static PaError GetNameFromCategory(const GUID* pGUID, BOOL input, wchar_t* name, unsigned length)
{
    PaError result = paUnanticipatedHostError;
    USHORT usbTerminalGUID = (USHORT)(pGUID->Data1 - 0xDFF219E0);

    PA_LOGE_;
    if (input && usbTerminalGUID >= 0x301 && usbTerminalGUID < 0x400)
    {
        /* Output terminal name for an input !? Set it to Line! */
        usbTerminalGUID = 0x603;
    }
    if (!input && usbTerminalGUID >= 0x201 && usbTerminalGUID < 0x300)
    {
        /* Input terminal name for an output !? Set it to Line! */
        usbTerminalGUID = 0x603;
    }
    if (usbTerminalGUID >= 0x201 && usbTerminalGUID < 0x713)
    {
        PaUsbTerminalGUIDToName s = { usbTerminalGUID };
        const PaUsbTerminalGUIDToName* ptr = bsearch(
            &s,
            kNames,
            kNamesCnt,
            sizeof(PaUsbTerminalGUIDToName),
            PaUsbTerminalGUIDToNameCmp
            );
        if (ptr != 0)
        {
            PA_DEBUG(("GetNameFromCategory: USB GUID %04X -> '%S'\n", usbTerminalGUID, ptr->name));

            if (name != NULL && length > 0)
            {
                int n = _snwprintf(name, length, L"%s", ptr->name);
                if (usbTerminalGUID >= 0x601 && usbTerminalGUID < 0x700)
                {
                    _snwprintf(name + n, length - n, L" %s", (input ? L"In":L"Out"));
                }
            }
            result = paNoError;
        }
    }
    else
    {
        PaWinWDM_SetLastErrorInfo(result, "GetNameFromCategory: usbTerminalGUID = %04X ", usbTerminalGUID);
    }
    PA_LOGL_;
    return result;
}

static BOOL IsFrequencyWithinRange(const KSDATARANGE_AUDIO* range, int frequency)
{
    if (frequency < (int)range->MinimumSampleFrequency)
        return FALSE;
    if (frequency > (int)range->MaximumSampleFrequency)
        return FALSE;
    return TRUE;
}

static BOOL IsBitsWithinRange(const KSDATARANGE_AUDIO* range, int noOfBits)
{
    if (noOfBits < (int)range->MinimumBitsPerSample)
        return FALSE;
    if (noOfBits > (int)range->MaximumBitsPerSample)
        return FALSE;
    return TRUE;
}

/* Note: Somewhat different order compared to WMME implementation, as we want to focus on fidelity first */
static const int defaultSampleRateSearchOrder[] =
{ 44100, 48000, 88200, 96000, 192000, 32000, 24000, 22050, 16000, 12000, 11025, 9600, 8000 };
static const int defaultSampleRateSearchOrderCount = sizeof(defaultSampleRateSearchOrder)/sizeof(defaultSampleRateSearchOrder[0]);

static int DefaultSampleFrequencyIndex(const KSDATARANGE_AUDIO* range)
{
    int i;

    for(i=0; i < defaultSampleRateSearchOrderCount; ++i)
    {
        int currentFrequency = defaultSampleRateSearchOrder[i];

        if (IsFrequencyWithinRange(range, currentFrequency))
        {
            return i;
        }
    }

    return -1;
}

/*
Create a new pin object belonging to a filter
The pin object holds all the configuration information about the pin
before it is opened, and then the handle of the pin after is opened
*/
static PaWinWdmPin* PinNew(PaWinWdmFilter* parentFilter, unsigned long pinId, PaError* error)
{
    PaWinWdmPin* pin;
    PaError result;
    unsigned long i;
    KSMULTIPLE_ITEM* item = NULL;
    KSIDENTIFIER* identifier;
    KSDATARANGE* dataRange;
    const ULONG streamingId = (parentFilter->devInfo.streamingType == Type_kWaveRT) ? KSINTERFACE_STANDARD_LOOPED_STREAMING : KSINTERFACE_STANDARD_STREAMING;
    int defaultSampleRateIndex = defaultSampleRateSearchOrderCount;

    PA_LOGE_;
    PA_DEBUG(("PinNew: Creating pin %d:\n",pinId));

    /* Allocate the new PIN object */
    pin = (PaWinWdmPin*)PaUtil_AllocateMemory( sizeof(PaWinWdmPin) );
    if( !pin )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Zero the pin object */
    /* memset( (void*)pin, 0, sizeof(PaWinWdmPin) ); */

    pin->parentFilter = parentFilter;
    pin->pinId = pinId;

    /* Allocate a connect structure */
    pin->pinConnectSize = sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX);
    pin->pinConnect = (KSPIN_CONNECT*)PaUtil_AllocateMemory( pin->pinConnectSize );
    if( !pin->pinConnect )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Configure the connect structure with default values */
    pin->pinConnect->Interface.Set               = KSINTERFACESETID_Standard;
    pin->pinConnect->Interface.Id                = streamingId;
    pin->pinConnect->Interface.Flags             = 0;
    pin->pinConnect->Medium.Set                  = KSMEDIUMSETID_Standard;
    pin->pinConnect->Medium.Id                   = KSMEDIUM_TYPE_ANYINSTANCE;
    pin->pinConnect->Medium.Flags                = 0;
    pin->pinConnect->PinId                       = pinId;
    pin->pinConnect->PinToHandle                 = NULL;
    pin->pinConnect->Priority.PriorityClass      = KSPRIORITY_NORMAL;
    pin->pinConnect->Priority.PrioritySubClass   = 1;
    pin->ksDataFormatWfx = (KSDATAFORMAT_WAVEFORMATEX*)(pin->pinConnect + 1);
    pin->ksDataFormatWfx->DataFormat.FormatSize  = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    pin->ksDataFormatWfx->DataFormat.Flags       = 0;
    pin->ksDataFormatWfx->DataFormat.Reserved    = 0;
    pin->ksDataFormatWfx->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    pin->ksDataFormatWfx->DataFormat.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
    pin->ksDataFormatWfx->DataFormat.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    pin->frameSize = 0; /* Unknown until we instantiate pin */

    /* Get the COMMUNICATION property */
    result = WdmGetPinPropertySimple(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_COMMUNICATION,
        &pin->communication,
        sizeof(KSPIN_COMMUNICATION),
        NULL);
    if( result != paNoError )
        goto error;

    if( /*(pin->communication != KSPIN_COMMUNICATION_SOURCE) &&*/
        (pin->communication != KSPIN_COMMUNICATION_SINK) &&
        (pin->communication != KSPIN_COMMUNICATION_BOTH) )
    {
        PA_DEBUG(("PinNew: Not source/sink\n"));
        result = paInvalidDevice;
        goto error;
    }

    /* Get dataflow information */
    result = WdmGetPinPropertySimple(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_DATAFLOW,
        &pin->dataFlow,
        sizeof(KSPIN_DATAFLOW),
        NULL);

    if( result != paNoError )
        goto error;

    /* Get the INTERFACE property list */
    result = WdmGetPinPropertyMulti(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_INTERFACES,
        &item);

    if( result != paNoError )
        goto error;

    identifier = (KSIDENTIFIER*)(item+1);

    /* Check that at least one interface is STANDARD_STREAMING */
    result = paUnanticipatedHostError;
    for( i = 0; i < item->Count; i++ )
    {
        if( IsEqualGUID(&identifier[i].Set, &KSINTERFACESETID_Standard) && ( identifier[i].Id == streamingId ) )
        {
            result = paNoError;
            break;
        }
    }

    if( result != paNoError )
    {
        PA_DEBUG(("PinNew: No %s streaming\n", streamingId==KSINTERFACE_STANDARD_LOOPED_STREAMING?"looped":"standard"));
        goto error;
    }

    /* Don't need interfaces any more */
    PaUtil_FreeMemory( item );
    item = NULL;

    /* Get the MEDIUM properties list */
    result = WdmGetPinPropertyMulti(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_MEDIUMS,
        &item);

    if( result != paNoError )
        goto error;

    identifier = (KSIDENTIFIER*)(item+1); /* Not actually necessary... */

    /* Check that at least one medium is STANDARD_DEVIO */
    result = paUnanticipatedHostError;
    for( i = 0; i < item->Count; i++ )
    {
        if( IsEqualGUID(&identifier[i].Set, &KSMEDIUMSETID_Standard) && ( identifier[i].Id == KSMEDIUM_STANDARD_DEVIO ) )
        {
            result = paNoError;
            break;
        }
    }

    if( result != paNoError )
    {
        PA_DEBUG(("No standard devio\n"));
        goto error;
    }
    /* Don't need mediums any more */
    PaUtil_FreeMemory( item );
    item = NULL;

    /* Get DATARANGES */
    result = WdmGetPinPropertyMulti(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_DATARANGES,
        &pin->dataRangesItem);

    if( result != paNoError )
        goto error;

    pin->dataRanges = (KSDATARANGE*)(pin->dataRangesItem +1);

    /* Check that at least one datarange supports audio */
    result = paUnanticipatedHostError;
    dataRange = pin->dataRanges;
    pin->maxChannels = 0;
    pin->defaultSampleRate = 0;
    pin->formats = 0;
    PA_DEBUG(("PinNew: Checking %u no of dataranges...\n", pin->dataRangesItem->Count));
    for( i = 0; i < pin->dataRangesItem->Count; i++)
    {
        PA_DEBUG(("PinNew: DR major format %x\n",*(unsigned long*)(&(dataRange->MajorFormat))));
        /* Check that subformat is WAVEFORMATEX, PCM or WILDCARD */
        if( IS_VALID_WAVEFORMATEX_GUID(&dataRange->SubFormat) ||
            IsEqualGUID(&dataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM) ||
            IsEqualGUID(&dataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) ||
            IsEqualGUID(&dataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
            IsEqualGUID(&dataRange->MajorFormat, &KSDATAFORMAT_TYPE_AUDIO) )
        {
            int defaultIndex;
            result = paNoError;
            /* Record the maximum possible channels with this pin */
            if( ((KSDATARANGE_AUDIO*)dataRange)->MaximumChannels == (ULONG) -1 )
            {
                pin->maxChannels = MAXIMUM_NUMBER_OF_CHANNELS;
            }
            else if( (int) ((KSDATARANGE_AUDIO*)dataRange)->MaximumChannels > pin->maxChannels )
            {
                pin->maxChannels = (int) ((KSDATARANGE_AUDIO*)dataRange)->MaximumChannels;
            }
            PA_DEBUG(("PinNew: MaxChannel: %d\n",pin->maxChannels));

            /* Record the formats (bit depths) that are supported */
            if( IsBitsWithinRange((KSDATARANGE_AUDIO*)dataRange, 8) )
            {
                pin->formats |= paInt8;
                PA_DEBUG(("PinNew: Format PCM 8 bit supported\n"));
            }
            if( IsBitsWithinRange((KSDATARANGE_AUDIO*)dataRange, 16) )
            {
                pin->formats |= paInt16;
                PA_DEBUG(("PinNew: Format PCM 16 bit supported\n"));
            }
            if( IsBitsWithinRange((KSDATARANGE_AUDIO*)dataRange, 24) )
            {
                pin->formats |= paInt24;
                PA_DEBUG(("PinNew: Format PCM 24 bit supported\n"));
            }
            if( IsBitsWithinRange((KSDATARANGE_AUDIO*)dataRange, 32) )
            {
                if (IsEqualGUID(&dataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
                {
                    pin->formats |= paFloat32;
                    PA_DEBUG(("PinNew: Format IEEE float 32 bit supported\n"));
                }
                else
                {
                    pin->formats |= paInt32;
                    PA_DEBUG(("PinNew: Format PCM 32 bit supported\n"));
                }
            }

            defaultIndex = DefaultSampleFrequencyIndex((KSDATARANGE_AUDIO*)dataRange);
            if (defaultIndex >= 0 && defaultIndex < defaultSampleRateIndex)
            {
                defaultSampleRateIndex = defaultIndex;
            }
        }
        dataRange = (KSDATARANGE*)( ((char*)dataRange) + dataRange->FormatSize);
    }

    if( result != paNoError )
        goto error;

    /* If none of the frequencies searched for are present, there's something seriously wrong */
    if (defaultSampleRateIndex == defaultSampleRateSearchOrderCount)
    {
        PA_DEBUG(("PinNew: No default sample rate found, skipping pin!\n"));
        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "PinNew: No default sample rate found");
        result = paUnanticipatedHostError;
        goto error;
    }

    /* Set the default sample rate */
    pin->defaultSampleRate = defaultSampleRateSearchOrder[defaultSampleRateIndex];
    PA_DEBUG(("PinNew: Default sample rate = %d Hz\n", pin->defaultSampleRate));

    /* Get instance information */
    result = WdmGetPinPropertySimple(
        parentFilter->handle,
        pinId,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_CINSTANCES,
        &pin->instances,
        sizeof(KSPIN_CINSTANCES),
        NULL);

    if( result != paNoError )
        goto error;

    /* If WaveRT, check if pin supports notification mode */
    if (parentFilter->devInfo.streamingType == Type_kWaveRT)
    {
        BOOL bSupportsNotification = FALSE;
        if (PinQueryNotificationSupport(pin, &bSupportsNotification) == paNoError)
        {
            pin->pinKsSubType = bSupportsNotification ? SubType_kNotification : SubType_kPolled;
        }
    }

    /* Query pin name (which means we need to traverse to non IRP pin, via physical connection to topology filter pin, through
    its nodes to the endpoint pin, and get that ones name... phew...) */
    PA_DEBUG(("PinNew: Finding topology pin...\n"));

    {
        ULONG topoPinId = GetConnectedPin(pinId, (pin->dataFlow == KSPIN_DATAFLOW_IN), parentFilter, -1, NULL, NULL);
        const wchar_t kInputName[] = L"Input";
        const wchar_t kOutputName[] = L"Output";

        if (topoPinId != KSFILTER_NODE)
        {
            /* Get physical connection for topo pin */
            unsigned long cbBytes = 0;
            PA_DEBUG(("PinNew: Getting physical connection...\n"));
            result = WdmGetPinPropertySimple(parentFilter->handle,
                topoPinId,
                &KSPROPSETID_Pin,
                KSPROPERTY_PIN_PHYSICALCONNECTION,
                0,
                0,
                &cbBytes
                );

            if (result != paNoError)
            {
                /* No physical connection -> there is no topology filter! So we get the name of the pin! */
                PA_DEBUG(("PinNew: No physical connection! Getting the pin name\n"));
                result = WdmGetPinPropertySimple(parentFilter->handle,
                    topoPinId,
                    &KSPROPSETID_Pin,
                    KSPROPERTY_PIN_NAME,
                    pin->friendlyName,
                    MAX_PATH,
                    NULL);
                if (result != paNoError)
                {
                    GUID category = {0};

                    /* Get pin category information */
                    result = WdmGetPinPropertySimple(parentFilter->handle,
                        topoPinId,
                        &KSPROPSETID_Pin,
                        KSPROPERTY_PIN_CATEGORY,
                        &category,
                        sizeof(GUID),
                        NULL);

                    if (result == paNoError)
                    {
                        result = GetNameFromCategory(&category, (pin->dataFlow == KSPIN_DATAFLOW_OUT), pin->friendlyName, MAX_PATH);
                    }
                }

                /* Make sure pin gets a name here... */
                if (wcslen(pin->friendlyName) == 0)
                {
                    wcscpy(pin->friendlyName, (pin->dataFlow == KSPIN_DATAFLOW_IN) ? kOutputName : kInputName);
#ifdef UNICODE
                    PA_DEBUG(("PinNew: Setting pin friendly name to '%s'\n", pin->friendlyName));
#else
                    PA_DEBUG(("PinNew: Setting pin friendly name to '%S'\n", pin->friendlyName));
#endif
                }

                /* This is then == the endpoint pin */
                pin->endpointPinId = (pin->dataFlow == KSPIN_DATAFLOW_IN) ? pinId : topoPinId;
            }
            else
            {
                KSPIN_PHYSICALCONNECTION* pc = (KSPIN_PHYSICALCONNECTION*)PaUtil_AllocateMemory(cbBytes + 2);
                ULONG pcPin;
                wchar_t symbLinkName[MAX_PATH];
                PA_DEBUG(("PinNew: Physical connection found!\n"));
                if (pc == NULL)
                {
                    result = paInsufficientMemory;
                    goto error;
                }
                result = WdmGetPinPropertySimple(parentFilter->handle,
                    topoPinId,
                    &KSPROPSETID_Pin,
                    KSPROPERTY_PIN_PHYSICALCONNECTION,
                    pc,
                    cbBytes,
                    NULL
                    );

                pcPin = pc->Pin;
                wcsncpy(symbLinkName, pc->SymbolicLinkName, MAX_PATH);
                PaUtil_FreeMemory( pc );

                if (result != paNoError)
                {
                    /* Shouldn't happen, but fail if it does */
                    PA_DEBUG(("PinNew: failed to retrieve physical connection!\n"));
                    goto error;
                }

                if (symbLinkName[1] == TEXT('?'))
                {
                    symbLinkName[1] = TEXT('\\');
                }

                if (pin->parentFilter->topologyFilter == NULL)
                {
                    PA_DEBUG(("PinNew: Creating topology filter '%S'\n", symbLinkName));

                    pin->parentFilter->topologyFilter = FilterNew(Type_kNotUsed, 0, symbLinkName, L"", &result);
                    if (pin->parentFilter->topologyFilter == NULL)
                    {
                        PA_DEBUG(("PinNew: Failed creating topology filter\n"));
                        result = paUnanticipatedHostError;
                        PaWinWDM_SetLastErrorInfo(result, "Failed to create topology filter '%S'", symbLinkName);
                        goto error;
                    }

                    /* Copy info so we have it in device info */
                    wcsncpy(pin->parentFilter->devInfo.topologyPath, symbLinkName, MAX_PATH);
                }
                else
                {
                    /* Must be the same */
                    assert(wcscmp(symbLinkName, pin->parentFilter->topologyFilter->devInfo.filterPath) == 0);
                }

                PA_DEBUG(("PinNew: Opening topology filter..."));

                result = FilterUse(pin->parentFilter->topologyFilter);
                if (result == paNoError)
                {
                    unsigned long endpointPinId;

                    if (pin->dataFlow == KSPIN_DATAFLOW_IN)
                    {
                        /* The "endpointPinId" is what WASAPI looks at for pin names */
                        GUID category = {0};

                        PA_DEBUG(("PinNew: Checking for output endpoint pin id...\n"));

                        endpointPinId = GetConnectedPin(pcPin, TRUE, pin->parentFilter->topologyFilter, -1, NULL, NULL);

                        if (endpointPinId == KSFILTER_NODE)
                        {
                            result = paUnanticipatedHostError;
                            PaWinWDM_SetLastErrorInfo(result, "Failed to get endpoint pin ID on topology filter!");
                            goto error;
                        }

                        PA_DEBUG(("PinNew: Found endpoint pin id %u\n", endpointPinId));

                        /* Get pin category information */
                        result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                            endpointPinId,
                            &KSPROPSETID_Pin,
                            KSPROPERTY_PIN_CATEGORY,
                            &category,
                            sizeof(GUID),
                            NULL);

                        if (result == paNoError)
                        {
#if !PA_WDMKS_USE_CATEGORY_FOR_PIN_NAMES
                            wchar_t pinName[MAX_PATH];

                            PA_DEBUG(("PinNew: Getting pin name property..."));

                            /* Ok, try pin name also, and favor that if available */
                            result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                                endpointPinId,
                                &KSPROPSETID_Pin,
                                KSPROPERTY_PIN_NAME,
                                pinName,
                                MAX_PATH,
                                NULL);

                            if (result == paNoError && wcslen(pinName)>0)
                            {
                                wcsncpy(pin->friendlyName, pinName, MAX_PATH);
                            }
                            else
#endif
                            {
                                result = GetNameFromCategory(&category, (pin->dataFlow == KSPIN_DATAFLOW_OUT), pin->friendlyName, MAX_PATH);
                            }
                        }

                        /* Make sure we get a name for the pin */
                        if (wcslen(pin->friendlyName) == 0)
                        {
                            wcscpy(pin->friendlyName, kOutputName);
                        }
#ifdef UNICODE
                        PA_DEBUG(("PinNew: Pin name '%s'\n", pin->friendlyName));
#else
                        PA_DEBUG(("PinNew: Pin name '%S'\n", pin->friendlyName));
#endif                                

                        /* Set endpoint pin ID (this is the topology INPUT pin, since portmixer will always traverse the
                        filter in audio streaming direction, see http://msdn.microsoft.com/en-us/library/windows/hardware/ff536331(v=vs.85).aspx
                        for more information)
                        */
                        pin->endpointPinId = pcPin;
                    }
                    else
                    {
                        unsigned muxCount = 0;
                        int muxPos = 0;
                        /* Max 64 multiplexer inputs... sanity check :) */
                        for (i = 0; i < 64; ++i)
                        {
                            ULONG muxNodeIdTest = (unsigned)-1;
                            PA_DEBUG(("PinNew: Checking for input endpoint pin id (%d)...\n", i));

                            endpointPinId = GetConnectedPin(pcPin,
                                FALSE,
                                pin->parentFilter->topologyFilter,
                                (int)i,
                                NULL,
                                &muxNodeIdTest);

                            if (endpointPinId == KSFILTER_NODE)
                            {
                                /* We're done */
                                PA_DEBUG(("PinNew: Done with inputs.\n", endpointPinId));
                                break;
                            }
                            else
                            {
                                /* The "endpointPinId" is what WASAPI looks at for pin names */
                                GUID category = {0};

                                PA_DEBUG(("PinNew: Found endpoint pin id %u\n", endpointPinId));

                                /* Get pin category information */
                                result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                                    endpointPinId,
                                    &KSPROPSETID_Pin,
                                    KSPROPERTY_PIN_CATEGORY,
                                    &category,
                                    sizeof(GUID),
                                    NULL);

                                if (result == paNoError)
                                {
                                    if (muxNodeIdTest == (unsigned)-1)
                                    {
                                        /* Ok, try pin name, and favor that if available */
                                        result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                                            endpointPinId,
                                            &KSPROPSETID_Pin,
                                            KSPROPERTY_PIN_NAME,
                                            pin->friendlyName,
                                            MAX_PATH,
                                            NULL);

                                        if (result != paNoError)
                                        {
                                            result = GetNameFromCategory(&category, TRUE, pin->friendlyName, MAX_PATH);
                                        }
                                        break;
                                    }
                                    else
                                    {
                                        result = GetNameFromCategory(&category, TRUE, NULL, 0);

                                        if (result == paNoError)
                                        {
                                            ++muxCount;
                                        }
                                    }
                                }
                                else
                                {
                                    PA_DEBUG(("PinNew: Failed to get pin category"));
                                }
                            }
                        }

                        if (muxCount == 0)
                        {
                            pin->endpointPinId = endpointPinId;
                            /* Make sure we get a name for the pin */
                            if (wcslen(pin->friendlyName) == 0)
                            {
                                wcscpy(pin->friendlyName, kInputName);
                            }
#ifdef UNICODE
                            PA_DEBUG(("PinNew: Input friendly name '%s'\n", pin->friendlyName));
#else
                            PA_DEBUG(("PinNew: Input friendly name '%S'\n", pin->friendlyName));
#endif
                        }
                        else // muxCount > 0
                        {
                            PA_DEBUG(("PinNew: Setting up %u inputs\n", muxCount));

                            /* Now we redo the operation once known how many multiplexer positions there are */
                            pin->inputs = (PaWinWdmMuxedInput**)PaUtil_AllocateMemory(muxCount * sizeof(PaWinWdmMuxedInput*));
                            if (pin->inputs == NULL)
                            {
                                FilterRelease(pin->parentFilter->topologyFilter);
                                result = paInsufficientMemory;
                                goto error;
                            }
                            pin->inputCount = muxCount;

                            for (i = 0; i < muxCount; ++muxPos)
                            {
                                PA_DEBUG(("PinNew: Setting up input %u...\n", i));

                                if (pin->inputs[i] == NULL)
                                {
                                    pin->inputs[i] = (PaWinWdmMuxedInput*)PaUtil_AllocateMemory(sizeof(PaWinWdmMuxedInput));
                                    if (pin->inputs[i] == NULL)
                                    {
                                        FilterRelease(pin->parentFilter->topologyFilter);
                                        result = paInsufficientMemory;
                                        goto error;
                                    }
                                }

                                endpointPinId = GetConnectedPin(pcPin,
                                    FALSE,
                                    pin->parentFilter->topologyFilter,
                                    muxPos,
                                    &pin->inputs[i]->muxPinId, 
                                    &pin->inputs[i]->muxNodeId);

                                if (endpointPinId != KSFILTER_NODE)
                                {
                                    /* The "endpointPinId" is what WASAPI looks at for pin names */
                                    GUID category = {0};

                                    /* Set input endpoint ID */
                                    pin->inputs[i]->endpointPinId = endpointPinId;

                                    /* Get pin category information */
                                    result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                                        endpointPinId,
                                        &KSPROPSETID_Pin,
                                        KSPROPERTY_PIN_CATEGORY,
                                        &category,
                                        sizeof(GUID),
                                        NULL);

                                    if (result == paNoError)
                                    {
                                        /* Try pin name first, and if that is not defined, use category instead */
                                        result = WdmGetPinPropertySimple(pin->parentFilter->topologyFilter->handle,
                                            endpointPinId,
                                            &KSPROPSETID_Pin,
                                            KSPROPERTY_PIN_NAME,
                                            pin->inputs[i]->friendlyName,
                                            MAX_PATH,
                                            NULL);

                                        if (result != paNoError)
                                        {
                                            result = GetNameFromCategory(&category, TRUE, pin->inputs[i]->friendlyName, MAX_PATH);
                                            if (result != paNoError)
                                            {
                                                /* Only specify name, let name hash in ScanDeviceInfos fix postfix enumerators */
                                                wcscpy(pin->inputs[i]->friendlyName, kInputName);
                                            }
                                        }
#ifdef UNICODE
                                        PA_DEBUG(("PinNew: Input (%u) friendly name '%s'\n", i, pin->inputs[i]->friendlyName));
#else
                                        PA_DEBUG(("PinNew: Input (%u) friendly name '%S'\n", i, pin->inputs[i]->friendlyName));
#endif
                                        ++i;
                                    }
                                }
                                else
                                {
                                    /* Should never come here! */
                                    assert(FALSE);
                                }
                            }
                        }
                    }
                }
            }
        }
        else
        {
            PA_DEBUG(("PinNew: No topology pin id found. Bad...\n"));
            /* No TOPO pin id ??? This is bad. Ok, so we just say it is an input or output... */
            wcscpy(pin->friendlyName, (pin->dataFlow == KSPIN_DATAFLOW_IN) ? kOutputName : kInputName);
        }
    }

    /* Release topology filter if it has been used */
    if (pin->parentFilter->topologyFilter && pin->parentFilter->topologyFilter->handle != NULL)
    {
        PA_DEBUG(("PinNew: Releasing topology filter...\n"));
        FilterRelease(pin->parentFilter->topologyFilter);
    }

    /* Success */
    *error = paNoError;
    PA_DEBUG(("Pin created successfully\n"));
    PA_LOGL_;
    return pin;

error:
    PA_DEBUG(("PinNew: Error %d\n", result));
    /*
    Error cleanup
    */

    if (pin->parentFilter->topologyFilter && pin->parentFilter->topologyFilter->handle != NULL)
    {
        FilterRelease(pin->parentFilter->topologyFilter);
    }

    PaUtil_FreeMemory( item );
    PinFree(pin);

    *error = result;
    PA_LOGL_;
    return NULL;
}

/*
Safely free all resources associated with the pin
*/
static void PinFree(PaWinWdmPin* pin)
{
    unsigned i;
    PA_LOGE_;
    if( pin )
    {
        PinClose(pin);
        if( pin->pinConnect )
        {
            PaUtil_FreeMemory( pin->pinConnect );
        }
        if( pin->dataRangesItem )
        {
            PaUtil_FreeMemory( pin->dataRangesItem );
        }
        if( pin->inputs )
        {
            for (i = 0; i < pin->inputCount; ++i)
            {
                PaUtil_FreeMemory( pin->inputs[i] );
            }
            PaUtil_FreeMemory( pin->inputs );
        }
        PaUtil_FreeMemory( pin );
    }
    PA_LOGL_;
}

/*
If the pin handle is open, close it
*/
static void PinClose(PaWinWdmPin* pin)
{
    PA_LOGE_;
    if( pin == NULL )
    {
        PA_DEBUG(("Closing NULL pin!"));
        PA_LOGL_;
        return;
    }
    if( pin->handle != NULL )
    {
        PinSetState( pin, KSSTATE_PAUSE );
        PinSetState( pin, KSSTATE_STOP );
        CloseHandle( pin->handle );
        pin->handle = NULL;
        FilterRelease(pin->parentFilter);
    }
    PA_LOGL_;
}

/*
Set the state of this (instantiated) pin
*/
static PaError PinSetState(PaWinWdmPin* pin, KSSTATE state)
{
    PaError result = paNoError;
    KSPROPERTY prop;

    PA_LOGE_;
    prop.Set = KSPROPSETID_Connection;
    prop.Id  = KSPROPERTY_CONNECTION_STATE;
    prop.Flags = KSPROPERTY_TYPE_SET;

    if( pin == NULL )
        return paInternalError;
    if( pin->handle == NULL )
        return paInternalError;

    result = WdmSyncIoctl(pin->handle, IOCTL_KS_PROPERTY, &prop, sizeof(KSPROPERTY), &state, sizeof(KSSTATE), NULL);

    PA_LOGL_;
    return result;
}

static PaError PinInstantiate(PaWinWdmPin* pin)
{
    PaError result;
    unsigned long createResult;
    KSALLOCATOR_FRAMING ksaf;
    KSALLOCATOR_FRAMING_EX ksafex;

    PA_LOGE_;

    if( pin == NULL )
        return paInternalError;
    if(!pin->pinConnect)
        return paInternalError;

    FilterUse(pin->parentFilter);

    createResult = FunctionKsCreatePin(
        pin->parentFilter->handle,
        pin->pinConnect,
        GENERIC_WRITE | GENERIC_READ,
        &pin->handle
        );

    PA_DEBUG(("Pin create result = 0x%08x\n",createResult));
    if( createResult != ERROR_SUCCESS )
    {
        FilterRelease(pin->parentFilter);
        pin->handle = NULL;
        switch (createResult)
        {
        case ERROR_INVALID_PARAMETER:
            /* First case when pin actually don't support the format */
            return paSampleFormatNotSupported;
        case ERROR_BAD_COMMAND:
            /* Case when pin is occupied (by another application) */
            return paDeviceUnavailable;
        default:
            /* All other cases */
            return paInvalidDevice;
        }
    }

    if (pin->parentFilter->devInfo.streamingType == Type_kWaveCyclic)
    {
        /* Framing size query only valid for WaveCyclic devices */
        result = WdmGetPropertySimple(
            pin->handle,
            &KSPROPSETID_Connection,
            KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
            &ksaf,
            sizeof(ksaf));

        if( result != paNoError )
        {
            result = WdmGetPropertySimple(
                pin->handle,
                &KSPROPSETID_Connection,
                KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
                &ksafex,
                sizeof(ksafex));
            if( result == paNoError )
            {
                pin->frameSize = ksafex.FramingItem[0].FramingRange.Range.MinFrameSize;
            }
        }
        else
        {
            pin->frameSize = ksaf.FrameSize;
        }
    }

    PA_LOGL_;

    return paNoError;
}

static PaError PinSetFormat(PaWinWdmPin* pin, const WAVEFORMATEX* format)
{
    unsigned long size;
    void* newConnect;

    PA_LOGE_;

    if( pin == NULL )
        return paInternalError;
    if( format == NULL )
        return paInternalError;

    size = GetWfexSize(format) + sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX) - sizeof(WAVEFORMATEX);

    if( pin->pinConnectSize != size )
    {
        newConnect = PaUtil_AllocateMemory( size );
        if( newConnect == NULL )
            return paInsufficientMemory;
        memcpy( newConnect, (void*)pin->pinConnect, min(pin->pinConnectSize,size) );
        PaUtil_FreeMemory( pin->pinConnect );
        pin->pinConnect = (KSPIN_CONNECT*)newConnect;
        pin->pinConnectSize = size;
        pin->ksDataFormatWfx = (KSDATAFORMAT_WAVEFORMATEX*)((KSPIN_CONNECT*)newConnect + 1);
        pin->ksDataFormatWfx->DataFormat.FormatSize = size - sizeof(KSPIN_CONNECT);
    }

    memcpy( (void*)&(pin->ksDataFormatWfx->WaveFormatEx), format, GetWfexSize(format) );
    pin->ksDataFormatWfx->DataFormat.SampleSize = (unsigned short)(format->nChannels * (format->wBitsPerSample / 8));

    PA_LOGL_;

    return paNoError;
}

static PaError PinIsFormatSupported(PaWinWdmPin* pin, const WAVEFORMATEX* format)
{
    KSDATARANGE_AUDIO* dataRange;
    unsigned long count;
    GUID guid = DYNAMIC_GUID( DEFINE_WAVEFORMATEX_GUID(format->wFormatTag) );
    PaError result = paInvalidDevice;
    const WAVEFORMATEXTENSIBLE* pFormatExt = (format->wFormatTag == WAVE_FORMAT_EXTENSIBLE) ? (const WAVEFORMATEXTENSIBLE*)format : 0;

    PA_LOGE_;

    if( pFormatExt != 0 )
    {
        guid = pFormatExt->SubFormat;
    }
    dataRange = (KSDATARANGE_AUDIO*)pin->dataRanges;
    for(count = 0;
        count<pin->dataRangesItem->Count;
        count++, 
        dataRange = (KSDATARANGE_AUDIO*)( ((char*)dataRange) + dataRange->DataRange.FormatSize)) /* Need to update dataRange here, due to 'continue' !! */
    {
        /* Check major format*/
        if (!(IsEqualGUID(&(dataRange->DataRange.MajorFormat), &KSDATAFORMAT_TYPE_AUDIO) ||
            IsEqualGUID(&(dataRange->DataRange.MajorFormat), &KSDATAFORMAT_TYPE_WILDCARD)))
        {
            continue;
        }

        /* This is an audio or wildcard datarange... */
        if (! (IsEqualGUID(&(dataRange->DataRange.SubFormat), &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
            IsEqualGUID(&(dataRange->DataRange.SubFormat), &KSDATAFORMAT_SUBTYPE_PCM) ||
            IsEqualGUID(&(dataRange->DataRange.SubFormat), &guid) ))
        {
            continue;
        }

        /* Check specifier... */
        if (! (IsEqualGUID(&(dataRange->DataRange.Specifier), &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
            IsEqualGUID(&(dataRange->DataRange.Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) )
        {
            continue;
        }

        PA_DEBUG(("Pin:%x, DataRange:%d\n",(void*)pin,count));
        PA_DEBUG(("\tFormatSize:%d, SampleSize:%d\n",dataRange->DataRange.FormatSize,dataRange->DataRange.SampleSize));
        PA_DEBUG(("\tMaxChannels:%d\n",dataRange->MaximumChannels));
        PA_DEBUG(("\tBits:%d-%d\n",dataRange->MinimumBitsPerSample,dataRange->MaximumBitsPerSample));
        PA_DEBUG(("\tSampleRate:%d-%d\n",dataRange->MinimumSampleFrequency,dataRange->MaximumSampleFrequency));

        if( dataRange->MaximumChannels != (ULONG)-1 && 
            dataRange->MaximumChannels < format->nChannels )
        {
            result = paInvalidChannelCount;
            continue;
        }

        if (pFormatExt != 0)
        {
            if (!IsBitsWithinRange(dataRange, pFormatExt->Samples.wValidBitsPerSample))
            {
                result = paSampleFormatNotSupported;
                continue;
            }
        }
        else
        {
            if (!IsBitsWithinRange(dataRange, format->wBitsPerSample))
            {
                result = paSampleFormatNotSupported;
                continue;
            }
        }

        if (!IsFrequencyWithinRange(dataRange, format->nSamplesPerSec))
        {
            result = paInvalidSampleRate;
            continue;
        }

        /* Success! */
        result = paNoError;
        break;
    }

    PA_LOGL_;
    return result;
}

static PaError PinQueryNotificationSupport(PaWinWdmPin* pPin, BOOL* pbResult)
{
    PaError result = paNoError;
    KSPROPERTY propIn;

    PA_LOGE_;

    propIn.Set = KSPROPSETID_RtAudio;
    propIn.Id = 8; /* = KSPROPERTY_RTAUDIO_QUERY_NOTIFICATION_SUPPORT */
    propIn.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle, IOCTL_KS_PROPERTY,
        &propIn,
        sizeof(KSPROPERTY),
        pbResult,
        sizeof(BOOL),
        NULL);

    if (result != paNoError) 
    {
        PA_DEBUG(("Failed PinQueryNotificationSupport\n"));
    }

    PA_LOGL_;
    return result;
}

static PaError PinGetBufferWithNotification(PaWinWdmPin* pPin, void** pBuffer, DWORD* pRequestedBufSize, BOOL* pbCallMemBarrier)
{
    PaError result = paNoError;
    KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION propIn;
    KSRTAUDIO_BUFFER propOut;

    PA_LOGE_;

    propIn.BaseAddress = 0;
    propIn.NotificationCount = 2;
    propIn.RequestedBufferSize = *pRequestedBufSize;
    propIn.Property.Set = KSPROPSETID_RtAudio;
    propIn.Property.Id = KSPROPERTY_RTAUDIO_BUFFER_WITH_NOTIFICATION;
    propIn.Property.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle, IOCTL_KS_PROPERTY,
        &propIn,
        sizeof(KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION),
        &propOut,
        sizeof(KSRTAUDIO_BUFFER),
        NULL);

    if (result == paNoError) 
    {
        *pBuffer = propOut.BufferAddress;
        *pRequestedBufSize = propOut.ActualBufferSize;
        *pbCallMemBarrier = propOut.CallMemoryBarrier;
    }
    else 
    {
        PA_DEBUG(("Failed to get buffer with notification\n"));
    }

    PA_LOGL_;
    return result;
}

static PaError PinGetBufferWithoutNotification(PaWinWdmPin* pPin, void** pBuffer, DWORD* pRequestedBufSize, BOOL* pbCallMemBarrier)
{
    PaError result = paNoError;
    KSRTAUDIO_BUFFER_PROPERTY propIn;
    KSRTAUDIO_BUFFER propOut;

    PA_LOGE_;

    propIn.BaseAddress = NULL;
    propIn.RequestedBufferSize = *pRequestedBufSize;
    propIn.Property.Set = KSPROPSETID_RtAudio;
    propIn.Property.Id = KSPROPERTY_RTAUDIO_BUFFER;
    propIn.Property.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle, IOCTL_KS_PROPERTY,
        &propIn,
        sizeof(KSRTAUDIO_BUFFER_PROPERTY),
        &propOut,
        sizeof(KSRTAUDIO_BUFFER),
        NULL);

    if (result == paNoError)
    {
        *pBuffer = propOut.BufferAddress;
        *pRequestedBufSize = propOut.ActualBufferSize;
        *pbCallMemBarrier = propOut.CallMemoryBarrier;
    }
    else 
    {
        PA_DEBUG(("Failed to get buffer without notification\n"));
    }

    PA_LOGL_;
    return result;
}

/* greatest common divisor - PGCD in French */
static unsigned long PaWinWDMGCD( unsigned long a, unsigned long b )
{
    return (b==0) ? a : PaWinWDMGCD( b, a%b);
}


/* This function will handle getting the cyclic buffer from a WaveRT driver. Certain WaveRT drivers needs to have
requested buffer size on multiples of 128 bytes:

*/
static PaError PinGetBuffer(PaWinWdmPin* pPin, void** pBuffer, DWORD* pRequestedBufSize, BOOL* pbCallMemBarrier)
{
    PaError result = paNoError;
    int limit = 1000;
    PA_LOGE_;

    while (1)
    {
        limit--;
        if (limit == 0) {
           PA_DEBUG(("PinGetBuffer: LOOP LIMIT REACHED\n"));
           break;
        }

        if (pPin->pinKsSubType != SubType_kPolled)
        {
            /* In case of unknown (or notification), we try both modes */
            result = PinGetBufferWithNotification(pPin, pBuffer, pRequestedBufSize, pbCallMemBarrier);
            if (result == paNoError)
            {
                PA_DEBUG(("PinGetBuffer: SubType_kNotification\n"));
                pPin->pinKsSubType = SubType_kNotification;
                break;
            }
        }

        result = PinGetBufferWithoutNotification(pPin, pBuffer, pRequestedBufSize, pbCallMemBarrier);
        if (result == paNoError)
        {
            PA_DEBUG(("PinGetBuffer: SubType_kPolled\n"));
            pPin->pinKsSubType = SubType_kPolled;
            break;
        }

        /* Check if requested size is on a 128 byte boundary */
        if (((*pRequestedBufSize) % 128UL) == 0)
        {
            PA_DEBUG(("Buffer size on 128 byte boundary, still fails :(\n"));
            /* Ok, can't do much more */
            break;
        }
        else
        {
            /* Compute LCM so we know which sizes are on a 128 byte boundary */
            const unsigned gcd = PaWinWDMGCD(128UL, pPin->ksDataFormatWfx->WaveFormatEx.nBlockAlign);
            const unsigned lcm = (128UL * pPin->ksDataFormatWfx->WaveFormatEx.nBlockAlign) / gcd;
            DWORD dwOldSize = *pRequestedBufSize;

            /* Align size to (next larger) LCM byte boundary, and then we try again. Note that LCM is not necessarily a
            power of 2. */
            *pRequestedBufSize = ((*pRequestedBufSize + lcm - 1) / lcm) * lcm;

            PA_DEBUG(("Adjusting buffer size from %u to %u bytes (128 byte boundary, LCM=%u)\n", dwOldSize, *pRequestedBufSize, lcm));
        }
    }

    PA_LOGL_;

    return result;
}

static PaError PinRegisterPositionRegister(PaWinWdmPin* pPin) 
{
    PaError result = paNoError;
    KSRTAUDIO_HWREGISTER_PROPERTY propIn;
    KSRTAUDIO_HWREGISTER propOut;

    PA_LOGE_;

    propIn.BaseAddress = NULL;
    propIn.Property.Set = KSPROPSETID_RtAudio;
    propIn.Property.Id = KSPROPERTY_RTAUDIO_POSITIONREGISTER;
    propIn.Property.Flags = KSPROPERTY_TYPE_SET;

    result = WdmSyncIoctl(pPin->handle, IOCTL_KS_PROPERTY,
        &propIn,
        sizeof(KSRTAUDIO_HWREGISTER_PROPERTY),
        &propOut,
        sizeof(KSRTAUDIO_HWREGISTER),
        NULL);

    if (result == paNoError) 
    {
        pPin->positionRegister = (ULONG*)propOut.Register;
    }
    else
    {
        PA_DEBUG(("Failed to register position register\n"));
    }

    PA_LOGL_;

    return result;
}

static PaError PinRegisterNotificationHandle(PaWinWdmPin* pPin, HANDLE handle) 
{
    PaError result = paNoError;
    KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY prop;

    PA_LOGE_;

    prop.NotificationEvent = handle;
    prop.Property.Set = KSPROPSETID_RtAudio;
    prop.Property.Id = KSPROPERTY_RTAUDIO_REGISTER_NOTIFICATION_EVENT;
    prop.Property.Flags = KSPROPERTY_TYPE_SET;

    result = WdmSyncIoctl(pPin->handle,
        IOCTL_KS_PROPERTY,
        &prop,
        sizeof(KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY),
        &prop,
        sizeof(KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY),
        NULL);

    if (result != paNoError) {
        PA_DEBUG(("Failed to register notification handle 0x%08X\n", handle));
    }

    PA_LOGL_;

    return result;
}

static PaError PinUnregisterNotificationHandle(PaWinWdmPin* pPin, HANDLE handle) 
{
    PaError result = paNoError;
    KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY prop;

    PA_LOGE_;

    if (handle != NULL)
    {
        prop.NotificationEvent = handle;
        prop.Property.Set = KSPROPSETID_RtAudio;
        prop.Property.Id = KSPROPERTY_RTAUDIO_UNREGISTER_NOTIFICATION_EVENT;
        prop.Property.Flags = KSPROPERTY_TYPE_SET;

        result = WdmSyncIoctl(pPin->handle,
            IOCTL_KS_PROPERTY,
            &prop,
            sizeof(KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY),
            &prop,
            sizeof(KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY),
            NULL);

        if (result != paNoError) {
            PA_DEBUG(("Failed to unregister notification handle 0x%08X\n", handle));
        }
    }
    PA_LOGL_;

    return result;
}

static PaError PinGetHwLatency(PaWinWdmPin* pPin, ULONG* pFifoSize, ULONG* pChipsetDelay, ULONG* pCodecDelay)
{
    PaError result = paNoError;
    KSPROPERTY propIn;
    KSRTAUDIO_HWLATENCY propOut;

    PA_LOGE_;

    propIn.Set = KSPROPSETID_RtAudio;
    propIn.Id = KSPROPERTY_RTAUDIO_HWLATENCY;
    propIn.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle, IOCTL_KS_PROPERTY,
        &propIn,
        sizeof(KSPROPERTY),
        &propOut,
        sizeof(KSRTAUDIO_HWLATENCY),
        NULL);

    if (result == paNoError)
    {
        *pFifoSize = propOut.FifoSize;
        *pChipsetDelay = propOut.ChipsetDelay;
        *pCodecDelay = propOut.CodecDelay;
    }
    else
    {
        PA_DEBUG(("Failed to retrieve hardware FIFO size!\n"));
    }

    PA_LOGL_;

    return result;
}

/* This one is used for WaveRT */
static PaError PinGetAudioPositionMemoryMapped(PaWinWdmPin* pPin, ULONG* pPosition)
{
    *pPosition = (*pPin->positionRegister);
    return paNoError;
}

/* This one also, but in case the driver hasn't implemented memory mapped access to the position register */
static PaError PinGetAudioPositionViaIOCTLRead(PaWinWdmPin* pPin, ULONG* pPosition)
{
    PaError result = paNoError;
    KSPROPERTY propIn;
    KSAUDIO_POSITION propOut;

    PA_LOGE_;

    propIn.Set = KSPROPSETID_Audio;
    propIn.Id = KSPROPERTY_AUDIO_POSITION;
    propIn.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle,
        IOCTL_KS_PROPERTY,
        &propIn, sizeof(KSPROPERTY),
        &propOut, sizeof(KSAUDIO_POSITION),
        NULL);

    if (result == paNoError)
    {
        *pPosition = (ULONG)(propOut.PlayOffset);
    }
    else
    {
        PA_DEBUG(("Failed to get audio play position!\n"));
    }

    PA_LOGL_;

    return result;

}

/* This one also, but in case the driver hasn't implemented memory mapped access to the position register */
static PaError PinGetAudioPositionViaIOCTLWrite(PaWinWdmPin* pPin, ULONG* pPosition)
{
    PaError result = paNoError;
    KSPROPERTY propIn;
    KSAUDIO_POSITION propOut;

    PA_LOGE_;

    propIn.Set = KSPROPSETID_Audio;
    propIn.Id = KSPROPERTY_AUDIO_POSITION;
    propIn.Flags = KSPROPERTY_TYPE_GET;

    result = WdmSyncIoctl(pPin->handle,
        IOCTL_KS_PROPERTY,
        &propIn, sizeof(KSPROPERTY),
        &propOut, sizeof(KSAUDIO_POSITION),
        NULL);

    if (result == paNoError)
    {
        *pPosition = (ULONG)(propOut.WriteOffset);
    }
    else
    {
        PA_DEBUG(("Failed to get audio write position!\n"));
    }

    PA_LOGL_;

    return result;

}

/***********************************************************************************************/

/**
* Create a new filter object. 
*/
static PaWinWdmFilter* FilterNew( PaWDMKSType type, DWORD devNode, const wchar_t* filterName, const wchar_t* friendlyName, PaError* error )
{
    PaWinWdmFilter* filter = 0;
    PaError result;

    /* Allocate the new filter object */
    filter = (PaWinWdmFilter*)PaUtil_AllocateMemory( sizeof(PaWinWdmFilter) );
    if( !filter )
    {
        result = paInsufficientMemory;
        goto error;
    }

    PA_DEBUG(("FilterNew: Creating filter '%S'\n", friendlyName));

    /* Set type flag */
    filter->devInfo.streamingType = type;

    /* Store device node */
    filter->deviceNode = devNode;

    /* Zero the filter object - done by AllocateMemory */
    /* memset( (void*)filter, 0, sizeof(PaWinWdmFilter) ); */

    /* Copy the filter name */
    wcsncpy(filter->devInfo.filterPath, filterName, MAX_PATH);

    /* Copy the friendly name */
    wcsncpy(filter->friendlyName, friendlyName, MAX_PATH);

    PA_DEBUG(("FilterNew: Opening filter...\n", friendlyName));

    /* Open the filter handle */
    result = FilterUse(filter);
    if( result != paNoError )
    {
        goto error;
    }

    /* Get pin count */
    result = WdmGetPinPropertySimple
        (
        filter->handle,
        0,
        &KSPROPSETID_Pin,
        KSPROPERTY_PIN_CTYPES,
        &filter->pinCount,
        sizeof(filter->pinCount),
        NULL);

    if( result != paNoError)
    {
        goto error;
    }

    /* Get connections & nodes for filter */
    result = WdmGetPropertyMulti(
        filter->handle,
        &KSPROPSETID_Topology,
        KSPROPERTY_TOPOLOGY_CONNECTIONS,
        &filter->connections);

    if( result != paNoError)
    {
        goto error;
    }

    result = WdmGetPropertyMulti(
        filter->handle,
        &KSPROPSETID_Topology,
        KSPROPERTY_TOPOLOGY_NODES,
        &filter->nodes);

    if( result != paNoError)
    {
        goto error;
    }

    /* For debugging purposes */
    DumpConnectionsAndNodes(filter);

    /* Get product GUID (it might not be supported) */
    {
        KSCOMPONENTID compId;
        if (WdmGetPropertySimple(filter->handle, &KSPROPSETID_General, KSPROPERTY_GENERAL_COMPONENTID, &compId, sizeof(KSCOMPONENTID)) == paNoError)
        {
            filter->devInfo.deviceProductGuid = compId.Product;
        }
    }

    /* This section is not executed for topology filters */
    if (type != Type_kNotUsed)
    {
        /* Initialize the pins */
        result = FilterInitializePins(filter);

        if( result != paNoError)
        {
            goto error;
        }
    }

    /* Close the filter handle for now
    * It will be opened later when needed */
    FilterRelease(filter);

    *error = paNoError;
    return filter;

error:
    PA_DEBUG(("FilterNew: Error %d\n", result));
    /*
    Error cleanup
    */
    FilterFree(filter);

    *error = result;
    return NULL;
}

/**
* Add reference to filter
*/
static void FilterAddRef( PaWinWdmFilter* filter )
{
    if (filter != 0)
    {
        filter->filterRefCount++;
    }
}


/**
* Initialize the pins of the filter. This is separated from FilterNew because this might fail if there is another
* process using the pin(s).
*/
PaError FilterInitializePins( PaWinWdmFilter* filter )
{
    PaError result = paNoError;
    int pinId;

    if (filter->devInfo.streamingType == Type_kNotUsed)
        return paNoError;

    if (filter->pins != NULL)
        return paNoError;   

    /* Allocate pointer array to hold the pins */
    filter->pins = (PaWinWdmPin**)PaUtil_AllocateMemory( sizeof(PaWinWdmPin*) * filter->pinCount );
    if( !filter->pins )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Create all the pins we can */
    for(pinId = 0; pinId < filter->pinCount; pinId++)
    {
        /* Create the pin with this Id */
        PaWinWdmPin* newPin;
        newPin = PinNew(filter, pinId, &result);
        if( result == paInsufficientMemory )
            goto error;
        if( newPin != NULL )
        {
            filter->pins[pinId] = newPin;
            ++filter->validPinCount;
        }
    }

    if (filter->validPinCount == 0)
    {
        result = paDeviceUnavailable;
        goto error;
    }

    return paNoError;

error:

    if (filter->pins)
    {
        for (pinId = 0; pinId < filter->pinCount; ++pinId)
        {
            if (filter->pins[pinId])
            {
                PinFree(filter->pins[pinId]);
                filter->pins[pinId] = 0;
            }
        }
        PaUtil_FreeMemory( filter->pins );
        filter->pins = 0;
    }

    return result;
}


/**
* Free a previously created filter
*/
static void FilterFree(PaWinWdmFilter* filter)
{
    PA_LOGL_;
    if( filter )
    {
        if (--filter->filterRefCount > 0)
        {
            /* Ok, a stream has a ref count to this filter */
            return;
        }

        if ( filter->topologyFilter )
        {
            FilterFree(filter->topologyFilter);
            filter->topologyFilter = 0;
        }
        if ( filter->pins )
        {
            int pinId;
            for( pinId = 0; pinId < filter->pinCount; pinId++ )
                PinFree(filter->pins[pinId]);
            PaUtil_FreeMemory( filter->pins );
            filter->pins = 0;
        }
        if( filter->connections )
        {
            PaUtil_FreeMemory(filter->connections);
            filter->connections = 0;
        }
        if( filter->nodes )
        {
            PaUtil_FreeMemory(filter->nodes);
            filter->nodes = 0;
        }
        if( filter->handle )
            CloseHandle( filter->handle );
        PaUtil_FreeMemory( filter );
    }
    PA_LOGE_;
}

/**
* Reopen the filter handle if necessary so it can be used
**/
static PaError FilterUse(PaWinWdmFilter* filter)
{
    assert( filter );

    PA_LOGE_;
    if( filter->handle == NULL )
    {
        /* Open the filter */
        filter->handle = CreateFileW(
            filter->devInfo.filterPath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL);

        if( filter->handle == NULL )
        {
            return paDeviceUnavailable;
        }
    }
    filter->usageCount++;
    PA_LOGL_;
    return paNoError;
}

/**
* Release the filter handle if nobody is using it
**/
static void FilterRelease(PaWinWdmFilter* filter)
{
    assert( filter );
    assert( filter->usageCount > 0 );

    PA_LOGE_;
    /* Check first topology filter, if used */
    if (filter->topologyFilter != NULL && filter->topologyFilter->handle != NULL)
    {
        FilterRelease(filter->topologyFilter);
    }

    filter->usageCount--;
    if( filter->usageCount == 0 )
    {
        if( filter->handle != NULL )
        {
            CloseHandle( filter->handle );
            filter->handle = NULL;
        }
    }
    PA_LOGL_;
}

/**
* Create a render or playback pin using the supplied format
**/
static PaWinWdmPin* FilterCreatePin(PaWinWdmFilter* filter,
                                    int pinId,
                                    const WAVEFORMATEX* wfex,
                                    PaError* error)
{
    PaError result = paNoError;
    PaWinWdmPin* pin = NULL;
    assert( filter );
    assert( pinId < filter->pinCount );
    pin = filter->pins[pinId];
    assert( pin );
    result = PinSetFormat(pin,wfex);
    if( result == paNoError )
    {
        result = PinInstantiate(pin);
    }
    *error = result;
    return result == paNoError ? pin : 0;
}

static const wchar_t kUsbPrefix[] = L"\\\\?\\USB";

static BOOL IsUSBDevice(const wchar_t* devicePath)
{
    /* Alex Lessard pointed out that different devices might present the device path with
       lower case letters. */
    return (_wcsnicmp(devicePath, kUsbPrefix, sizeof(kUsbPrefix)/sizeof(kUsbPrefix[0]) ) == 0);
}

/* This should make it more language tolerant, I hope... */
static const wchar_t kUsbNamePrefix[] = L"USB Audio";

static BOOL IsNameUSBAudioDevice(const wchar_t* friendlyName)
{
    return (_wcsnicmp(friendlyName, kUsbNamePrefix, sizeof(kUsbNamePrefix)/sizeof(kUsbNamePrefix[0])) == 0);
}

typedef enum _tag_EAlias
{
    Alias_kRender   = (1<<0),
    Alias_kCapture  = (1<<1),
    Alias_kRealtime = (1<<2),
} EAlias;

/* Trim whitespace from string */
static void TrimString(wchar_t* str, size_t length)
{
    wchar_t* s = str;
    wchar_t* e = 0;

    /* Find start of string */
    while (iswspace(*s)) ++s;
    e=s+min(length,wcslen(s))-1;

    /* Find end of string */
    while(e>s && iswspace(*e)) --e;
    ++e;

    length = e - s;
    memmove(str, s, length * sizeof(wchar_t));
    str[length] = 0;
}

/**
* Build the list of available filters
* Use the SetupDi API to enumerate all devices in the KSCATEGORY_AUDIO which 
* have a KSCATEGORY_RENDER or KSCATEGORY_CAPTURE alias. For each of these 
* devices initialise a PaWinWdmFilter structure by calling our NewFilter() 
* function. We enumerate devices twice, once to count how many there are, 
* and once to initialize the PaWinWdmFilter structures.
*
* Vista and later: Also check KSCATEGORY_REALTIME for WaveRT devices.
*/
//PaError BuildFilterList( PaWinWdmHostApiRepresentation* wdmHostApi, int* noOfPaDevices )
PaWinWdmFilter** BuildFilterList( int* pFilterCount, int* pNoOfPaDevices, PaError* pResult )
{
    PaWinWdmFilter** ppFilters = NULL;
    HDEVINFO handle = NULL;
    int device;
    int invalidDevices;
    int slot;
    SP_DEVICE_INTERFACE_DATA interfaceData;
    SP_DEVICE_INTERFACE_DATA aliasData;
    SP_DEVINFO_DATA devInfoData;
    int noError;
    const int sizeInterface = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR));
    unsigned char interfaceDetailsArray[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR))];
    SP_DEVICE_INTERFACE_DETAIL_DATA_W* devInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA_W*)interfaceDetailsArray;
    const GUID* category = (const GUID*)&KSCATEGORY_AUDIO;
    const GUID* alias_render = (const GUID*)&KSCATEGORY_RENDER;
    const GUID* alias_capture = (const GUID*)&KSCATEGORY_CAPTURE;
    const GUID* category_realtime = (const GUID*)&KSCATEGORY_REALTIME;
    DWORD aliasFlags;
    PaWDMKSType streamingType;
    int filterCount = 0;
    int noOfPaDevices = 0;

    PA_LOGE_;

    assert(pFilterCount != NULL);
    assert(pNoOfPaDevices != NULL);
    assert(pResult != NULL);

    devInterfaceDetails->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
    *pFilterCount = 0;
    *pNoOfPaDevices = 0;

    /* Open a handle to search for devices (filters) */
    handle = SetupDiGetClassDevs(category,NULL,NULL,DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if( handle == INVALID_HANDLE_VALUE )
    {
        *pResult = paUnanticipatedHostError;
        return NULL;
    }
    PA_DEBUG(("Setup called\n"));

    /* First let's count the number of devices so we can allocate a list */
    invalidDevices = 0;
    for( device = 0;;device++ )
    {
        interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        interfaceData.Reserved = 0;
        aliasData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        aliasData.Reserved = 0;
        noError = SetupDiEnumDeviceInterfaces(handle,NULL,category,device,&interfaceData);
        PA_DEBUG(("Enum called\n"));
        if( !noError )
            break; /* No more devices */

        /* Check this one has the render or capture alias */
        aliasFlags = 0;
        noError = SetupDiGetDeviceInterfaceAlias(handle,&interfaceData,alias_render,&aliasData);
        PA_DEBUG(("noError = %d\n",noError));
        if(noError)
        {
            if(aliasData.Flags && (!(aliasData.Flags & SPINT_REMOVED)))
            {
                PA_DEBUG(("Device %d has render alias\n",device));
                aliasFlags |= Alias_kRender; /* Has render alias */
            }
            else
            {
                PA_DEBUG(("Device %d has no render alias\n",device));
            }
        }
        noError = SetupDiGetDeviceInterfaceAlias(handle,&interfaceData,alias_capture,&aliasData);
        if(noError)
        {
            if(aliasData.Flags && (!(aliasData.Flags & SPINT_REMOVED)))
            {
                PA_DEBUG(("Device %d has capture alias\n",device));
                aliasFlags |= Alias_kCapture; /* Has capture alias */
            }
            else
            {
                PA_DEBUG(("Device %d has no capture alias\n",device));
            }
        }
        if(!aliasFlags)
            invalidDevices++; /* This was not a valid capture or render audio device */
    }
    /* Remember how many there are */
    filterCount = device-invalidDevices;

    PA_DEBUG(("Interfaces found: %d\n",device-invalidDevices));

    /* Now allocate the list of pointers to devices */
    ppFilters  = (PaWinWdmFilter**)PaUtil_AllocateMemory( sizeof(PaWinWdmFilter*) * filterCount);
    if( ppFilters == 0 )
    {
        if(handle != NULL)
            SetupDiDestroyDeviceInfoList(handle);
        *pResult = paInsufficientMemory;
        return NULL;
    }

    /* Now create filter objects for each interface found */
    slot = 0;
    for( device = 0;;device++ )
    {
        interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        interfaceData.Reserved = 0;
        aliasData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        aliasData.Reserved = 0;
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        devInfoData.Reserved = 0;
        streamingType = Type_kWaveCyclic;

        noError = SetupDiEnumDeviceInterfaces(handle,NULL,category,device,&interfaceData);
        if( !noError )
            break; /* No more devices */

        /* Check this one has the render or capture alias */
        aliasFlags = 0;
        noError = SetupDiGetDeviceInterfaceAlias(handle,&interfaceData,alias_render,&aliasData);
        if(noError)
        {
            if(aliasData.Flags && (!(aliasData.Flags & SPINT_REMOVED)))
            {
                PA_DEBUG(("Device %d has render alias\n",device));
                aliasFlags |= Alias_kRender; /* Has render alias */
            }
        }
        noError = SetupDiGetDeviceInterfaceAlias(handle,&interfaceData,alias_capture,&aliasData);
        if(noError)
        {
            if(aliasData.Flags && (!(aliasData.Flags & SPINT_REMOVED)))
            {
                PA_DEBUG(("Device %d has capture alias\n",device));
                aliasFlags |= Alias_kCapture; /* Has capture alias */
            }
        }
        if(!aliasFlags)
        {
            continue; /* This was not a valid capture or render audio device */
        }
        else
        {
            /* Check if filter is WaveRT, if not it is a WaveCyclic */
            noError = SetupDiGetDeviceInterfaceAlias(handle,&interfaceData,category_realtime,&aliasData);
            if (noError)
            {
                PA_DEBUG(("Device %d has realtime alias\n",device));
                aliasFlags |= Alias_kRealtime;
                streamingType = Type_kWaveRT;
            }
        }

        noError = SetupDiGetDeviceInterfaceDetailW(handle,&interfaceData,devInterfaceDetails,sizeInterface,NULL,&devInfoData);
        if( noError )
        {
            DWORD type;
            WCHAR friendlyName[MAX_PATH] = {0};
            DWORD sizeFriendlyName;
            PaWinWdmFilter* newFilter = 0;

            PaError result = paNoError;
            /* Try to get the "friendly name" for this interface */
            sizeFriendlyName = sizeof(friendlyName);

            if (IsEarlierThanVista() && IsUSBDevice(devInterfaceDetails->DevicePath))
            {
                /* XP and USB audio device needs to look elsewhere, otherwise it'll only be a "USB Audio Device". Not
                very literate. */
                if (!SetupDiGetDeviceRegistryPropertyW(handle,
                    &devInfoData,
                    SPDRP_LOCATION_INFORMATION, 
                    &type,
                    (BYTE*)friendlyName,
                    sizeof(friendlyName),
                    NULL))
                {
                    friendlyName[0] = 0;
                }
            }

            if (friendlyName[0] == 0 || IsNameUSBAudioDevice(friendlyName))
            {
                /* Fix contributed by Ben Allison
                * Removed KEY_SET_VALUE from flags on following call
                * as its causes failure when running without admin rights
                * and it was not required */
                HKEY hkey=SetupDiOpenDeviceInterfaceRegKey(handle,&interfaceData,0,KEY_QUERY_VALUE);
                if(hkey!=INVALID_HANDLE_VALUE)
                {
                    noError = RegQueryValueExW(hkey,L"FriendlyName",0,&type,(BYTE*)friendlyName,&sizeFriendlyName);
                    if( noError == ERROR_SUCCESS )
                    {
                        PA_DEBUG(("Interface %d, Name: %s\n",device,friendlyName));
                        RegCloseKey(hkey);
                    }
                    else
                    {
                        friendlyName[0] = 0;
                    }
                }
            }

            TrimString(friendlyName, sizeFriendlyName);

            newFilter = FilterNew(streamingType, 
                devInfoData.DevInst,
                devInterfaceDetails->DevicePath,
                friendlyName,
                &result);

            if( result == paNoError )
            {
                int pin;
                unsigned filterIOs = 0;

                /* Increment number of "devices" */
                for (pin = 0; pin < newFilter->pinCount; ++pin)
                {
                    PaWinWdmPin* pPin = newFilter->pins[pin];
                    if (pPin == NULL)
                        continue;

                    filterIOs += max(1, pPin->inputCount);
                }

                noOfPaDevices += filterIOs;

                PA_DEBUG(("Filter (%s) created with %d valid pins (total I/Os: %u)\n", ((newFilter->devInfo.streamingType==Type_kWaveRT)?"WaveRT":"WaveCyclic"), newFilter->validPinCount, filterIOs));

                assert(slot < filterCount);

                ppFilters[slot] = newFilter;

                slot++;
            }
            else
            {
                PA_DEBUG(("Filter NOT created\n"));
                /* As there are now less filters than we initially thought
                * we must reduce the count by one */
                filterCount--;
            }
        }
    }

    /* Clean up */
    if(handle != NULL)
        SetupDiDestroyDeviceInfoList(handle);

    *pFilterCount = filterCount;
    *pNoOfPaDevices = noOfPaDevices;

    return ppFilters;
}

typedef struct PaNameHashIndex
{
    unsigned index;
    unsigned count;
    ULONG    hash;
    struct PaNameHashIndex *next;
} PaNameHashIndex;

typedef struct PaNameHashObject
{
    PaNameHashIndex* list;
    PaUtilAllocationGroup* allocGroup;
} PaNameHashObject;

static ULONG GetNameHash(const wchar_t* str, const BOOL input)
{
    /* This is to make sure that a name that exists as both input & output won't get the same hash value */
    const ULONG fnv_prime = (input ? 0x811C9DD7 : 0x811FEB0B);
    ULONG hash = 0;
    for(; *str != 0; str++)
    {
        hash *= fnv_prime;
        hash ^= (*str);
    }
    assert(hash != 0);
    return hash;
}

static PaError CreateHashEntry(PaNameHashObject* obj, const wchar_t* name, const BOOL input)
{
    ULONG hash = GetNameHash(name, input); 
    PaNameHashIndex * pLast = NULL;
    PaNameHashIndex * p = obj->list;
    while (p != 0)
    {
        if (p->hash == hash)
        {
            break;
        }
        pLast = p;
        p = p->next;
    }
    if (p == NULL)
    {
        p = (PaNameHashIndex*)PaUtil_GroupAllocateMemory(obj->allocGroup, sizeof(PaNameHashIndex));
        if (p == NULL)
        {
            return paInsufficientMemory;
        }
        p->hash = hash;
        p->count = 1;
        if (pLast != 0)
        {
            assert(pLast->next == 0);
            pLast->next = p;
        }
        if (obj->list == 0)
        {
            obj->list = p;
        }
    }
    else
    {
        ++p->count;
    }
    return paNoError;
}

static PaError InitNameHashObject(PaNameHashObject* obj, PaWinWdmFilter* pFilter)
{
    int i;

    obj->allocGroup = PaUtil_CreateAllocationGroup();
    if (obj->allocGroup == NULL)
    {
        return paInsufficientMemory;
    }

    for (i = 0; i < pFilter->pinCount; ++i)
    {
        unsigned m;
        PaWinWdmPin* pin = pFilter->pins[i];

        if (pin == NULL)
            continue;

        for (m = 0; m < max(1, pin->inputCount); ++m)
        {
            const BOOL isInput = (pin->dataFlow == KSPIN_DATAFLOW_OUT);
            const wchar_t* name = (pin->inputs == NULL) ? pin->friendlyName : pin->inputs[m]->friendlyName;

            PaError result = CreateHashEntry(obj, name, isInput);

            if (result != paNoError)
            {
                return result;
            }
        }
    }
    return paNoError;
}

static void DeinitNameHashObject(PaNameHashObject* obj)
{
    assert(obj != 0);
    PaUtil_FreeAllAllocations(obj->allocGroup);
    PaUtil_DestroyAllocationGroup(obj->allocGroup);
    memset(obj, 0, sizeof(PaNameHashObject));
}

static unsigned GetNameIndex(PaNameHashObject* obj, const wchar_t* name, const BOOL input)
{
    ULONG hash = GetNameHash(name, input); 
    PaNameHashIndex* p = obj->list;
    while (p != NULL)
    {
        if (p->hash == hash)
        {
            if (p->count > 1)
            {
                return (++p->index);
            }
            else
            {
                return 0;
            }
        }

        p = p->next;
    }
    // Should never get here!!
    assert(FALSE);
    return 0;
}

static PaError ScanDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, PaHostApiIndex hostApiIndex, void **scanResults, int *newDeviceCount )
{
    PaWinWdmHostApiRepresentation *wdmHostApi = (PaWinWdmHostApiRepresentation*)hostApi;
    PaError result = paNoError;
    PaWinWdmFilter** ppFilters = 0;
    PaWinWDMScanDeviceInfosResults *outArgument = 0;
    int filterCount = 0;
    int totalDeviceCount = 0;
    int idxDevice = 0;
    DWORD defaultInDevPathSize = 0;
    DWORD defaultOutDevPathSize = 0;
    wchar_t* defaultInDevPath = 0;
    wchar_t* defaultOutDevPath = 0;

    ppFilters = BuildFilterList( &filterCount, &totalDeviceCount, &result );
    if( result != paNoError )
    {
        goto error;
    }

    // Get hold of default device paths for capture & playback
    if( waveInMessage(0, DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&defaultInDevPathSize, 0 ) == MMSYSERR_NOERROR )
    {
        defaultInDevPath = (wchar_t *)PaUtil_AllocateMemory((defaultInDevPathSize + 1) * sizeof(wchar_t));
        waveInMessage(0, DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)defaultInDevPath, defaultInDevPathSize);
    }
    if( waveOutMessage(0, DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&defaultOutDevPathSize, 0 ) == MMSYSERR_NOERROR )
    {
        defaultOutDevPath = (wchar_t *)PaUtil_AllocateMemory((defaultOutDevPathSize + 1) * sizeof(wchar_t));
        waveOutMessage(0, DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)defaultOutDevPath, defaultOutDevPathSize);
    }

    if( totalDeviceCount > 0 )
    {
        PaWinWdmDeviceInfo *deviceInfoArray = 0;
        int idxFilter;
        int i;
        unsigned devIsDefaultIn = 0, devIsDefaultOut = 0;

        /* Allocate the out param for all the info we need */
        outArgument = (PaWinWDMScanDeviceInfosResults *) PaUtil_GroupAllocateMemory(
            wdmHostApi->allocations, sizeof(PaWinWDMScanDeviceInfosResults) );
        if( !outArgument )
        {
            result = paInsufficientMemory;
            goto error;
        }

        outArgument->defaultInputDevice  = paNoDevice;
        outArgument->defaultOutputDevice = paNoDevice;

        outArgument->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
            wdmHostApi->allocations, sizeof(PaDeviceInfo*) * totalDeviceCount );
        if( !outArgument->deviceInfos )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all device info structs in a contiguous block */
        deviceInfoArray = (PaWinWdmDeviceInfo*)PaUtil_GroupAllocateMemory(
            wdmHostApi->allocations, sizeof(PaWinWdmDeviceInfo) * totalDeviceCount );
        if( !deviceInfoArray )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* Make sure all items in array */
        for( i = 0 ; i < totalDeviceCount; ++i )
        {
            PaDeviceInfo *deviceInfo  = &deviceInfoArray[i].inheritedDeviceInfo;
            deviceInfo->structVersion = 2;
            deviceInfo->hostApi       = hostApiIndex;
            deviceInfo->name          = 0;
            outArgument->deviceInfos[ i ] = deviceInfo;
        }

        idxDevice = 0;
        for (idxFilter = 0; idxFilter < filterCount; ++idxFilter)
        {
            PaNameHashObject nameHash = {0};
            PaWinWdmFilter* pFilter = ppFilters[idxFilter];
            if( pFilter == NULL )
                continue;

            if (InitNameHashObject(&nameHash, pFilter) != paNoError)
            {
                DeinitNameHashObject(&nameHash);
                continue;
            }

            devIsDefaultIn = (defaultInDevPath && (_wcsicmp(pFilter->devInfo.filterPath, defaultInDevPath) == 0));
            devIsDefaultOut = (defaultOutDevPath && (_wcsicmp(pFilter->devInfo.filterPath, defaultOutDevPath) == 0));

            for (i = 0; i < pFilter->pinCount; ++i)
            {
                unsigned m;
                ULONG nameIndex = 0;
                ULONG nameIndexHash = 0;
                PaWinWdmPin* pin = pFilter->pins[i];

                if (pin == NULL)
                    continue;

                for (m = 0; m < max(1, pin->inputCount); ++m)
                {
                    PaWinWdmDeviceInfo *wdmDeviceInfo = (PaWinWdmDeviceInfo *)outArgument->deviceInfos[idxDevice];
                    PaDeviceInfo *deviceInfo = &wdmDeviceInfo->inheritedDeviceInfo;
                    wchar_t localCompositeName[MAX_PATH];
                    unsigned nameIndex = 0;
                    const BOOL isInput = (pin->dataFlow == KSPIN_DATAFLOW_OUT);

                    wdmDeviceInfo->filter = pFilter;

                    deviceInfo->structVersion = 2;
                    deviceInfo->hostApi = hostApiIndex;
                    deviceInfo->name = wdmDeviceInfo->compositeName;
                    /* deviceInfo->hostApiSpecificDeviceInfo = &pFilter->devInfo; */

                    wdmDeviceInfo->pin = pin->pinId;

                    /* Get the name of the "device" */
                    if (pin->inputs == NULL)
                    {
                        wcsncpy(localCompositeName, pin->friendlyName, MAX_PATH);
                        wdmDeviceInfo->muxPosition = -1;
                        wdmDeviceInfo->endpointPinId = pin->endpointPinId;
                    }
                    else
                    {
                        PaWinWdmMuxedInput* input = pin->inputs[m];
                        wcsncpy(localCompositeName, input->friendlyName, MAX_PATH);
                        wdmDeviceInfo->muxPosition = (int)m;
                        wdmDeviceInfo->endpointPinId = input->endpointPinId;
                    }

                    {
                        /* Get base length */
                        size_t n = wcslen(localCompositeName);

                        /* Check if there are more entries with same name (which might very well be the case), if there
                        are, the name will be postfixed with an index. */
                        nameIndex = GetNameIndex(&nameHash, localCompositeName, isInput);
                        if (nameIndex > 0)
                        {
                            /* This name has multiple instances, so we post fix with a number */
                            n += _snwprintf(localCompositeName + n, MAX_PATH - n, L" %u", nameIndex);
                        }
                        /* Postfix with filter name */
                        _snwprintf(localCompositeName + n, MAX_PATH - n, L" (%s)", pFilter->friendlyName);
                    }

                    /* Convert wide char string to utf-8 */
                    WideCharToMultiByte(CP_UTF8, 0, localCompositeName, -1, wdmDeviceInfo->compositeName, MAX_PATH, NULL, NULL);

                    /* NB! WDM/KS has no concept of a full-duplex device, each pin is either an input or an output */
                    if (isInput)
                    {
                        /* INPUT ! */
                        deviceInfo->maxInputChannels  = pin->maxChannels;
                        deviceInfo->maxOutputChannels = 0;

                        /* RoBi NB: Due to the fact that input audio endpoints in Vista (& later OSs) can be the same device, but with
                           different input mux settings, there might be a discrepancy between the default input device chosen, and
                           that which will be used by Portaudio. Not much to do about that unfortunately.
                        */
                        if ((defaultInDevPath == 0 || devIsDefaultIn) &&
                             outArgument->defaultInputDevice == paNoDevice)
                        {
                            outArgument->defaultInputDevice = idxDevice;
                        }
                    }
                    else
                    {
                        /* OUTPUT ! */
                        deviceInfo->maxInputChannels  = 0;
                        deviceInfo->maxOutputChannels = pin->maxChannels;

                        if ((defaultOutDevPath == 0 || devIsDefaultOut) &&
                            outArgument->defaultOutputDevice == paNoDevice)
                        {
                            outArgument->defaultOutputDevice = idxDevice;
                        }
                    }

                    /* These low values are not very useful because
                    * a) The lowest latency we end up with can depend on many factors such
                    *    as the device buffer sizes/granularities, sample rate, channels and format
                    * b) We cannot know the device buffer sizes until we try to open/use it at
                    *    a particular setting
                    * So: we give 512x48000Hz frames as the default low input latency
                    **/
                    switch (pFilter->devInfo.streamingType)
                    {
                    case Type_kWaveCyclic:
                        if (IsEarlierThanVista())
                        {
                            /* XP doesn't tolerate low latency, unless the Process Priority Class is set to REALTIME_PRIORITY_CLASS 
                            through SetPriorityClass, then 10 ms is quite feasible. However, one should then bear in mind that ALL of
                            the process is running in REALTIME_PRIORITY_CLASS, which might not be appropriate for an application with
                            a GUI . In this case it is advisable to separate the audio engine in another process and use IPC to communicate
                            with it. */
                            deviceInfo->defaultLowInputLatency = 0.02;
                            deviceInfo->defaultLowOutputLatency = 0.02;
                        }
                        else
                        {
                            /* This is a conservative estimate. Most WaveCyclic drivers will limit the available latency, but f.i. my Edirol
                            PCR-A30 can reach 3 ms latency easily... */
                            deviceInfo->defaultLowInputLatency = 0.01;
                            deviceInfo->defaultLowOutputLatency = 0.01;
                        }
                        deviceInfo->defaultHighInputLatency = (4096.0/48000.0);
                        deviceInfo->defaultHighOutputLatency = (4096.0/48000.0);
                        deviceInfo->defaultSampleRate = (double)(pin->defaultSampleRate);
                        break;
                    case Type_kWaveRT:
                        /* This is also a conservative estimate, based on WaveRT polled mode. In polled mode, the latency will be dictated
                        by the buffer size given by the driver. */
                        deviceInfo->defaultLowInputLatency = 0.01;
                        deviceInfo->defaultLowOutputLatency = 0.01;
                        deviceInfo->defaultHighInputLatency = 0.04;
                        deviceInfo->defaultHighOutputLatency = 0.04;
                        deviceInfo->defaultSampleRate = (double)(pin->defaultSampleRate);
                        break;
                    default:
                        assert(0);
                        break;
                    }

                    /* Add reference to filter */
                    FilterAddRef(wdmDeviceInfo->filter);

                    assert(idxDevice < totalDeviceCount);
                    ++idxDevice;
                }
            }

            /* If no one has add ref'd the filter, drop it */
            if (pFilter->filterRefCount == 0)
            {
                FilterFree(pFilter);
            }

            /* Deinitialize name hash object */
            DeinitNameHashObject(&nameHash);
        }
    }

    *scanResults = outArgument;
    *newDeviceCount = idxDevice;
    return result;

error:
    result = DisposeDeviceInfos(hostApi, outArgument, totalDeviceCount);

    return result;
}

static PaError CommitDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, PaHostApiIndex index, void *scanResults, int deviceCount )
{
    PaWinWdmHostApiRepresentation *wdmHostApi = (PaWinWdmHostApiRepresentation*)hostApi;

    hostApi->info.deviceCount = 0;
    hostApi->info.defaultInputDevice = paNoDevice;
    hostApi->info.defaultOutputDevice = paNoDevice;

    /* Free any old memory which might be in the device info */
    if( hostApi->deviceInfos )
    {
        PaWinWDMScanDeviceInfosResults* localScanResults = (PaWinWDMScanDeviceInfosResults*)PaUtil_GroupAllocateMemory(
            wdmHostApi->allocations, sizeof(PaWinWDMScanDeviceInfosResults));
        localScanResults->deviceInfos = hostApi->deviceInfos;

        DisposeDeviceInfos(hostApi, &localScanResults, hostApi->info.deviceCount);

        hostApi->deviceInfos = NULL;
    }

    if( scanResults != NULL )
    {
        PaWinWDMScanDeviceInfosResults *scanDeviceInfosResults = ( PaWinWDMScanDeviceInfosResults * ) scanResults;

        if( deviceCount > 0 )
        {
            /* use the array allocated in ScanDeviceInfos() as our deviceInfos */
            hostApi->deviceInfos = scanDeviceInfosResults->deviceInfos;

            hostApi->info.defaultInputDevice = scanDeviceInfosResults->defaultInputDevice;
            hostApi->info.defaultOutputDevice = scanDeviceInfosResults->defaultOutputDevice;

            hostApi->info.deviceCount = deviceCount;
        }

        PaUtil_GroupFreeMemory( wdmHostApi->allocations, scanDeviceInfosResults );
    }

    return paNoError;

}

static PaError DisposeDeviceInfos( struct PaUtilHostApiRepresentation *hostApi, void *scanResults, int deviceCount )
{
    PaWinWdmHostApiRepresentation *winDsHostApi = (PaWinWdmHostApiRepresentation*)hostApi;

    if( scanResults != NULL )
    {
        PaWinWDMScanDeviceInfosResults *scanDeviceInfosResults = ( PaWinWDMScanDeviceInfosResults * ) scanResults;

        if( scanDeviceInfosResults->deviceInfos )
        {
            int i;
            for (i = 0; i < deviceCount; ++i)
            {
                PaWinWdmDeviceInfo* pDevice = (PaWinWdmDeviceInfo*)scanDeviceInfosResults->deviceInfos[i];
                if (pDevice->filter != 0)
                {
                    FilterFree(pDevice->filter);
                }
            }

            PaUtil_GroupFreeMemory( winDsHostApi->allocations, scanDeviceInfosResults->deviceInfos[0] ); /* all device info structs are allocated in a block so we can destroy them here */
            PaUtil_GroupFreeMemory( winDsHostApi->allocations, scanDeviceInfosResults->deviceInfos );
        }

        PaUtil_GroupFreeMemory( winDsHostApi->allocations, scanDeviceInfosResults );
    }

    return paNoError;

}

PaError PaWinWdm_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    int deviceCount = 0;
    void *scanResults = 0;
    PaWinWdmHostApiRepresentation *wdmHostApi = NULL;

    PA_LOGE_;

#ifdef PA_WDMKS_SET_TREF
    tRef = PaUtil_GetTime();
#endif

    /*
    Attempt to load the KSUSER.DLL without which we cannot create pins
    We will unload this on termination
    */
    if(DllKsUser == NULL)
    {
        DllKsUser = LoadLibrary(TEXT("ksuser.dll"));
        if(DllKsUser == NULL)
            goto error;
    }
    FunctionKsCreatePin = (KSCREATEPIN*)GetProcAddress(DllKsUser, "KsCreatePin");
    if(FunctionKsCreatePin == NULL)
        goto error;

    /* Attempt to load AVRT.DLL, if we can't, then we'll just use time critical prio instead... */
    if(paWinWDMKSAvRtEntryPoints.hInstance == NULL)
    {
        paWinWDMKSAvRtEntryPoints.hInstance = LoadLibrary(TEXT("avrt.dll"));
        if (paWinWDMKSAvRtEntryPoints.hInstance != NULL)
        {
            paWinWDMKSAvRtEntryPoints.AvSetMmThreadCharacteristics =
                (HANDLE(WINAPI*)(LPCSTR,LPDWORD))GetProcAddress(paWinWDMKSAvRtEntryPoints.hInstance,"AvSetMmThreadCharacteristicsA");
            paWinWDMKSAvRtEntryPoints.AvRevertMmThreadCharacteristics =
                (BOOL(WINAPI*)(HANDLE))GetProcAddress(paWinWDMKSAvRtEntryPoints.hInstance, "AvRevertMmThreadCharacteristics");
            paWinWDMKSAvRtEntryPoints.AvSetMmThreadPriority =
                (BOOL(WINAPI*)(HANDLE,PA_AVRT_PRIORITY))GetProcAddress(paWinWDMKSAvRtEntryPoints.hInstance, "AvSetMmThreadPriority");
        }
    }

    wdmHostApi = (PaWinWdmHostApiRepresentation*)PaUtil_AllocateMemory( sizeof(PaWinWdmHostApiRepresentation) );
    if( !wdmHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }

    wdmHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !wdmHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }

    *hostApi = &wdmHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paWDMKS;
    (*hostApi)->info.name = "Windows WDM-KS";

    /* these are all updated by CommitDeviceInfos() */
    (*hostApi)->info.deviceCount = 0;
    (*hostApi)->info.defaultInputDevice = paNoDevice;
    (*hostApi)->info.defaultOutputDevice = paNoDevice;
    (*hostApi)->deviceInfos = 0;

    result = ScanDeviceInfos(&wdmHostApi->inheritedHostApiRep, hostApiIndex, &scanResults, &deviceCount);
    if (result != paNoError)
    {
        goto error;
    }

    CommitDeviceInfos(&wdmHostApi->inheritedHostApiRep, hostApiIndex, scanResults, deviceCount);

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;
    /* In preparation for hotplug
    (*hostApi)->ScanDeviceInfos = ScanDeviceInfos;
    (*hostApi)->CommitDeviceInfos = CommitDeviceInfos;
    (*hostApi)->DisposeDeviceInfos = DisposeDeviceInfos;
    */
    PaUtil_InitializeStreamInterface( &wdmHostApi->callbackStreamInterface, CloseStream, StartStream,
        StopStream, AbortStream, IsStreamStopped, IsStreamActive,
        GetStreamTime, GetStreamCpuLoad,
        PaUtil_DummyRead, PaUtil_DummyWrite,
        PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &wdmHostApi->blockingStreamInterface, CloseStream, StartStream,
        StopStream, AbortStream, IsStreamStopped, IsStreamActive,
        GetStreamTime, PaUtil_DummyGetCpuLoad,
        ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    PA_LOGL_;
    return result;

error:
    Terminate( (PaUtilHostApiRepresentation*)wdmHostApi );

    PA_LOGL_;
    return result;
}


static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaWinWdmHostApiRepresentation *wdmHostApi = (PaWinWdmHostApiRepresentation*)hostApi;
    PA_LOGE_;

    /* Do not unload the libraries */
    if( DllKsUser != NULL )
    {
        FreeLibrary( DllKsUser );
        DllKsUser = NULL;
    }

    if( paWinWDMKSAvRtEntryPoints.hInstance != NULL )
    {
        FreeLibrary( paWinWDMKSAvRtEntryPoints.hInstance );
        paWinWDMKSAvRtEntryPoints.hInstance = NULL;
    }

    if( wdmHostApi)
    {
        PaWinWDMScanDeviceInfosResults* localScanResults = (PaWinWDMScanDeviceInfosResults*)PaUtil_GroupAllocateMemory(
            wdmHostApi->allocations, sizeof(PaWinWDMScanDeviceInfosResults));
        localScanResults->deviceInfos = hostApi->deviceInfos;
        DisposeDeviceInfos(hostApi, localScanResults, hostApi->info.deviceCount);

        if( wdmHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( wdmHostApi->allocations );
            PaUtil_DestroyAllocationGroup( wdmHostApi->allocations );
        }
        PaUtil_FreeMemory( wdmHostApi );
    }
    PA_LOGL_;
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                 const PaStreamParameters *inputParameters,
                                 const PaStreamParameters *outputParameters,
                                 double sampleRate )
{
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaWinWdmHostApiRepresentation *wdmHostApi = (PaWinWdmHostApiRepresentation*)hostApi;
    PaWinWdmFilter* pFilter;
    int result = paFormatIsSupported;
    WAVEFORMATEXTENSIBLE wfx;
    PaWinWaveFormatChannelMask channelMask;

    PA_LOGE_;

    if( inputParameters )
    {
        PaWinWdmDeviceInfo* pDeviceInfo = (PaWinWdmDeviceInfo*)wdmHostApi->inheritedHostApiRep.deviceInfos[inputParameters->device];
        PaWinWdmPin* pin;
        unsigned fmt;
        unsigned long testFormat = 0;
        unsigned validBits = 0;

        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
        this implementation doesn't support any custom sample formats */
        if( inputSampleFormat & paCustomFormat )
        {
            PaWinWDM_SetLastErrorInfo(paSampleFormatNotSupported, "IsFormatSupported: Custom input format not supported");
            return paSampleFormatNotSupported;
        }

        /* unless alternate device specification is supported, reject the use of
        paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidDevice, "IsFormatSupported: paUseHostApiSpecificDeviceSpecification not supported");
            return paInvalidDevice;
        }

        /* check that input device can support inputChannelCount */
        if( inputChannelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidChannelCount, "IsFormatSupported: Invalid input channel count");
            return paInvalidChannelCount;
        }

        /* validate inputStreamInfo */
        if( inputParameters->hostApiSpecificStreamInfo )
        {
            PaWinWDM_SetLastErrorInfo(paIncompatibleHostApiSpecificStreamInfo, "Host API stream info not supported");
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
        }

        pFilter = pDeviceInfo->filter;
        pin = pFilter->pins[pDeviceInfo->pin];

        /* Find out the testing format */
        for (fmt = paFloat32; fmt <= paUInt8; fmt <<= 1)
        {
            if ((fmt & pin->formats) != 0)
            {
                /* Found a matching format! */
                testFormat = fmt;
                break;
            }
        }
        if (testFormat == 0)
        {
            PaWinWDM_SetLastErrorInfo(result, "IsFormatSupported(capture) failed: no testformat found!");
            return paUnanticipatedHostError;
        }

        /* Due to special considerations, WaveRT devices with paInt24 should be tested with paInt32 and
        valid bits = 24 (instead of 24 bit samples) */
        if (pFilter->devInfo.streamingType == Type_kWaveRT && testFormat == paInt24)
        {
            PA_DEBUG(("IsFormatSupported (capture): WaveRT overriding testFormat paInt24 with paInt32 (24 valid bits)"));
            testFormat = paInt32;
            validBits = 24;
        }

        /* Check that the input format is supported */
        channelMask = PaWin_DefaultChannelMask(inputChannelCount);
        PaWin_InitializeWaveFormatExtensible((PaWinWaveFormat*)&wfx,
            inputChannelCount, 
            testFormat,
            PaWin_SampleFormatToLinearWaveFormatTag(testFormat),
            sampleRate,
            channelMask );
        if (validBits != 0)
        {
            wfx.Samples.wValidBitsPerSample = validBits;
        }

        result = PinIsFormatSupported(pin, (const WAVEFORMATEX*)&wfx);
        if( result != paNoError )
        {
            /* Try a WAVE_FORMAT_PCM instead */
            PaWin_InitializeWaveFormatEx((PaWinWaveFormat*)&wfx,
                inputChannelCount, 
                testFormat,
                PaWin_SampleFormatToLinearWaveFormatTag(testFormat),
                sampleRate);

            if (validBits != 0)
            {
                wfx.Samples.wValidBitsPerSample = validBits;
            }

            result = PinIsFormatSupported(pin, (const WAVEFORMATEX*)&wfx);
            if( result != paNoError )
            {
                PaWinWDM_SetLastErrorInfo(result, "IsFormatSupported(capture) failed: sr=%u,ch=%u,bits=%u", wfx.Format.nSamplesPerSec, wfx.Format.nChannels, wfx.Format.wBitsPerSample);
                return result;
            }
        }
    }
    else
    {
        inputChannelCount = 0;
    }

    if( outputParameters )
    {
        PaWinWdmDeviceInfo* pDeviceInfo = (PaWinWdmDeviceInfo*)wdmHostApi->inheritedHostApiRep.deviceInfos[outputParameters->device];
        PaWinWdmPin* pin;
        unsigned fmt;
        unsigned long testFormat = 0;
        unsigned validBits = 0;

        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* all standard sample formats are supported by the buffer adapter,
        this implementation doesn't support any custom sample formats */
        if( outputSampleFormat & paCustomFormat )
        {
            PaWinWDM_SetLastErrorInfo(paSampleFormatNotSupported, "IsFormatSupported: Custom output format not supported");
            return paSampleFormatNotSupported;
        }

        /* unless alternate device specification is supported, reject the use of
        paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidDevice, "IsFormatSupported: paUseHostApiSpecificDeviceSpecification not supported");
            return paInvalidDevice;
        }

        /* check that output device can support outputChannelCount */
        if( outputChannelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidChannelCount, "Invalid output channel count");
            return paInvalidChannelCount;
        }

        /* validate outputStreamInfo */
        if( outputParameters->hostApiSpecificStreamInfo )
        {
            PaWinWDM_SetLastErrorInfo(paIncompatibleHostApiSpecificStreamInfo, "Host API stream info not supported");
            return paIncompatibleHostApiSpecificStreamInfo; /* this implementation doesn't use custom stream info */
        }

        pFilter = pDeviceInfo->filter;
        pin = pFilter->pins[pDeviceInfo->pin];

        /* Find out the testing format */
        for (fmt = paFloat32; fmt <= paUInt8; fmt <<= 1)
        {
            if ((fmt & pin->formats) != 0)
            {
                /* Found a matching format! */
                testFormat = fmt;
                break;
            }
        }
        if (testFormat == 0)
        {
            PaWinWDM_SetLastErrorInfo(result, "IsFormatSupported(render) failed: no testformat found!");
            return paUnanticipatedHostError;
        }

        /* Due to special considerations, WaveRT devices with paInt24 should be tested with paInt32 and
        valid bits = 24 (instead of 24 bit samples) */
        if (pFilter->devInfo.streamingType == Type_kWaveRT && testFormat == paInt24)
        {
            PA_DEBUG(("IsFormatSupported (render): WaveRT overriding testFormat paInt24 with paInt32 (24 valid bits)"));
            testFormat = paInt32;
            validBits = 24;
        }

        /* Check that the output format is supported */
        channelMask = PaWin_DefaultChannelMask(outputChannelCount);
        PaWin_InitializeWaveFormatExtensible((PaWinWaveFormat*)&wfx,
            outputChannelCount, 
            testFormat,
            PaWin_SampleFormatToLinearWaveFormatTag(testFormat),
            sampleRate,
            channelMask );

        if (validBits != 0)
        {
            wfx.Samples.wValidBitsPerSample = validBits;
        }

        result = PinIsFormatSupported(pin, (const WAVEFORMATEX*)&wfx);
        if( result != paNoError )
        {
            /* Try a WAVE_FORMAT_PCM instead */
            PaWin_InitializeWaveFormatEx((PaWinWaveFormat*)&wfx,
                outputChannelCount, 
                testFormat,
                PaWin_SampleFormatToLinearWaveFormatTag(testFormat),
                sampleRate);

            if (validBits != 0)
            {
                wfx.Samples.wValidBitsPerSample = validBits;
            }

            result = PinIsFormatSupported(pin, (const WAVEFORMATEX*)&wfx);
            if( result != paNoError )
            {
                PaWinWDM_SetLastErrorInfo(result, "IsFormatSupported(render) failed: %u,%u,%u", wfx.Format.nSamplesPerSec, wfx.Format.nChannels, wfx.Format.wBitsPerSample);
                return result;
            }
        }

    }
    else
    {
        outputChannelCount = 0;
    }

    /*
    IMPLEMENT ME:

    - if a full duplex stream is requested, check that the combination
    of input and output parameters is supported if necessary

    - check that the device supports sampleRate

    Because the buffer adapter handles conversion between all standard
    sample formats, the following checks are only required if paCustomFormat
    is implemented, or under some other unusual conditions.

    - check that input device can support inputSampleFormat, or that
    we have the capability to convert from inputSampleFormat to
    a native format

    - check that output device can support outputSampleFormat, or that
    we have the capability to convert from outputSampleFormat to
    a native format
    */
    if((inputChannelCount == 0)&&(outputChannelCount == 0))
    {
        PaWinWDM_SetLastErrorInfo(paSampleFormatNotSupported, "No input or output channels defined");
        result = paSampleFormatNotSupported; /* Not right error */
    }

    PA_LOGL_;
    return result;
}

static void ResetStreamEvents(PaWinWdmStream* stream) 
{
    unsigned i;
    ResetEvent(stream->eventAbort);
    ResetEvent(stream->eventStreamStart[StreamStart_kOk]);
    ResetEvent(stream->eventStreamStart[StreamStart_kFailed]);

    for (i=0; i<stream->capture.noOfPackets; ++i)
    {
        if (stream->capture.events && stream->capture.events[i])
        {
            ResetEvent(stream->capture.events[i]);
        }
    }

    for (i=0; i<stream->render.noOfPackets; ++i)
    {
        if (stream->render.events && stream->render.events[i])
        {
            ResetEvent(stream->render.events[i]);
        }
    }
}

static void CloseStreamEvents(PaWinWdmStream* stream) 
{
    unsigned i;
    PaWinWdmIOInfo* ios[2] = { &stream->capture, &stream->render };

    if (stream->eventAbort)
    {
        CloseHandle(stream->eventAbort);
        stream->eventAbort = 0;
    }
    if (stream->eventStreamStart[StreamStart_kOk])
    {
        CloseHandle(stream->eventStreamStart[StreamStart_kOk]);
    }
    if (stream->eventStreamStart[StreamStart_kFailed])
    {
        CloseHandle(stream->eventStreamStart[StreamStart_kFailed]);
    }

    for (i = 0; i < 2; ++i)
    {
        unsigned j;
        /* Unregister notification handles for WaveRT */
        if (ios[i]->pPin && ios[i]->pPin->parentFilter->devInfo.streamingType == Type_kWaveRT &&
            ios[i]->pPin->pinKsSubType == SubType_kNotification &&
            ios[i]->events != 0)
        {
            PinUnregisterNotificationHandle(ios[i]->pPin, ios[i]->events[0]);
        }

        for (j=0; j < ios[i]->noOfPackets; ++j)
        {
            if (ios[i]->events && ios[i]->events[j])
            {
                CloseHandle(ios[i]->events[j]);
                ios[i]->events[j] = 0;
            }
        }
    }
}

static unsigned NextPowerOf2(unsigned val)
{
    val--;
    val = (val >> 1) | val;
    val = (val >> 2) | val;
    val = (val >> 4) | val;
    val = (val >> 8) | val;
    val = (val >> 16) | val;
    return ++val;
}

static PaError ValidateSpecificStreamParameters(
    const PaStreamParameters *streamParameters,
    const PaWinWDMKSInfo *streamInfo,
    unsigned isInput)
{
    if( streamInfo )
    {
        if( streamInfo->size != sizeof( PaWinWDMKSInfo )
            || streamInfo->version != 1 )
        {
            PA_DEBUG(("Stream parameters: size or version not correct"));
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        if (!!(streamInfo->flags & ~(paWinWDMKSOverrideFramesize | paWinWDMKSUseGivenChannelMask)))
        {
            PA_DEBUG(("Stream parameters: non supported flags set"));
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        if (streamInfo->noOfPackets != 0 &&
            (streamInfo->noOfPackets < 2 || streamInfo->noOfPackets > 8))
        {
            PA_DEBUG(("Stream parameters: noOfPackets %u out of range [2,8]", streamInfo->noOfPackets));
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        if (streamInfo->flags & paWinWDMKSUseGivenChannelMask)
        {
            if (isInput)
            {
                PA_DEBUG(("Stream parameters: Channels mask setting not supported for input stream"));
                return paIncompatibleHostApiSpecificStreamInfo;
            }

            if (streamInfo->channelMask & PAWIN_SPEAKER_RESERVED)
            {
                PA_DEBUG(("Stream parameters: Given channels mask 0x%08X not supported", streamInfo->channelMask));
                return paIncompatibleHostApiSpecificStreamInfo;
            }
        }

    }

    return paNoError;
}




/* see pa_hostapi.h for a list of validity guarantees made about OpenStream parameters */

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                          PaStream** s,
                          const PaStreamParameters *inputParameters,
                          const PaStreamParameters *outputParameters,
                          double sampleRate,
                          unsigned long framesPerUserBuffer,
                          PaStreamFlags streamFlags,
                          PaStreamCallback *streamCallback,
                          void *userData )
{
    PaError result = paNoError;
    PaWinWdmHostApiRepresentation *wdmHostApi = (PaWinWdmHostApiRepresentation*)hostApi;
    PaWinWdmStream *stream = 0;
    /* unsigned long framesPerHostBuffer; these may not be equivalent for all implementations */
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
    int userInputChannels,userOutputChannels;
    WAVEFORMATEXTENSIBLE wfx;

    PA_LOGE_;
    PA_DEBUG(("OpenStream:sampleRate = %f\n",sampleRate));
    PA_DEBUG(("OpenStream:framesPerBuffer = %lu\n",framesPerUserBuffer));

    if( inputParameters )
    {
        userInputChannels = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
        paUseHostApiSpecificDeviceSpecification */

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidDevice, "paUseHostApiSpecificDeviceSpecification(in) not supported");
            return paInvalidDevice;
        }

        /* check that input device can support stream->userInputChannels */
        if( userInputChannels > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidChannelCount, "Invalid input channel count");
            return paInvalidChannelCount;
        }

        /* validate inputStreamInfo */
        result = ValidateSpecificStreamParameters(inputParameters, inputParameters->hostApiSpecificStreamInfo, 1 );
        if(result != paNoError)
        {
            PaWinWDM_SetLastErrorInfo(result, "Host API stream info not supported (in)");
            return result; /* this implementation doesn't use custom stream info */
        }
    }
    else
    {
        userInputChannels = 0;
        inputSampleFormat = hostInputSampleFormat = paInt16; /* Supress 'uninitialised var' warnings. */
    }

    if( outputParameters )
    {
        userOutputChannels = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;

        /* unless alternate device specification is supported, reject the use of
        paUseHostApiSpecificDeviceSpecification */

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidDevice, "paUseHostApiSpecificDeviceSpecification(out) not supported");
            return paInvalidDevice;
        }

        /* check that output device can support stream->userInputChannels */
        if( userOutputChannels > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels )
        {
            PaWinWDM_SetLastErrorInfo(paInvalidChannelCount, "Invalid output channel count");
            return paInvalidChannelCount;
        }

        /* validate outputStreamInfo */
        result = ValidateSpecificStreamParameters( outputParameters, outputParameters->hostApiSpecificStreamInfo, 0 );
        if (result != paNoError)
        {
            PaWinWDM_SetLastErrorInfo(result, "Host API stream info not supported (out)");
            return result; /* this implementation doesn't use custom stream info */
        }
    }
    else
    {
        userOutputChannels = 0;
        outputSampleFormat = hostOutputSampleFormat = paInt16; /* Supress 'uninitialized var' warnings. */
    }

    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
    {
        PaWinWDM_SetLastErrorInfo(paInvalidFlag, "Invalid flag supplied");
        return paInvalidFlag; /* unexpected platform specific flag */
    }

    stream = (PaWinWdmStream*)PaUtil_AllocateMemory( sizeof(PaWinWdmStream) );
    if( !stream )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Create allocation group */
    stream->allocGroup = PaUtil_CreateAllocationGroup();
    if( !stream->allocGroup )
    {
        result = paInsufficientMemory;
        goto error;
    }

    /* Zero the stream object */
    /* memset((void*)stream,0,sizeof(PaWinWdmStream)); */

    if( streamCallback )
    {
        PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
            &wdmHostApi->callbackStreamInterface, streamCallback, userData );
    }
    else
    {
        /* PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
        &wdmHostApi->blockingStreamInterface, streamCallback, userData ); */

        /* We don't support the blocking API yet */
        PA_DEBUG(("Blocking API not supported yet!\n"));
        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Blocking API not supported yet");
        result = paUnanticipatedHostError;
        goto error;
    }

    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );

    /* Instantiate the input pin if necessary */
    if(userInputChannels > 0)
    {
        PaWinWdmFilter* pFilter;
        PaWinWdmDeviceInfo* pDeviceInfo;
        PaWinWdmPin* pPin;
        unsigned validBitsPerSample = 0;
        PaWinWaveFormatChannelMask channelMask = PaWin_DefaultChannelMask( userInputChannels );

        result = paSampleFormatNotSupported;
        pDeviceInfo = (PaWinWdmDeviceInfo*)wdmHostApi->inheritedHostApiRep.deviceInfos[inputParameters->device];
        pFilter = pDeviceInfo->filter;
        pPin = pFilter->pins[pDeviceInfo->pin];

        stream->userInputChannels = userInputChannels;

        hostInputSampleFormat = PaUtil_SelectClosestAvailableFormat( pPin->formats, inputSampleFormat );
        if (hostInputSampleFormat == paSampleFormatNotSupported)
        {
            result = paUnanticipatedHostError;
            PaWinWDM_SetLastErrorInfo(result, "PU_SCAF(%X,%X) failed (input)", pPin->formats, inputSampleFormat);
            goto error;
        }
        else if (pFilter->devInfo.streamingType == Type_kWaveRT && hostInputSampleFormat == paInt24)
        {
            /* For WaveRT, we choose 32 bit format instead of paInt24, since we MIGHT need to align buffer on a
            128 byte boundary (see PinGetBuffer) */
            hostInputSampleFormat = paInt32;
            /* But we'll tell the driver that it's 24 bit in 32 bit container */
            validBitsPerSample = 24;
        }

        while (hostInputSampleFormat <= paUInt8)
        {
            unsigned channelsToProbe = stream->userInputChannels;
            /* Some or all KS devices can only handle the exact number of channels
            * they specify. But PortAudio clients expect to be able to
            * at least specify mono I/O on a multi-channel device
            * If this is the case, then we will do the channel mapping internally
            * The following loop tests this case
            **/
            while (1)
            {
                PaWin_InitializeWaveFormatExtensible((PaWinWaveFormat*)&wfx,
                    channelsToProbe, 
                    hostInputSampleFormat,
                    PaWin_SampleFormatToLinearWaveFormatTag(hostInputSampleFormat),
                    sampleRate,
                    channelMask );
                stream->capture.bytesPerFrame = wfx.Format.nBlockAlign;
                if (validBitsPerSample != 0)
                {
                    wfx.Samples.wValidBitsPerSample = validBitsPerSample;
                }
                stream->capture.pPin = FilterCreatePin(pFilter, pPin->pinId, (WAVEFORMATEX*)&wfx, &result);
                stream->deviceInputChannels = channelsToProbe;

                if( result != paNoError && result != paDeviceUnavailable )
                {
                    /* Try a WAVE_FORMAT_PCM instead */
                    PaWin_InitializeWaveFormatEx((PaWinWaveFormat*)&wfx,
                        channelsToProbe, 
                        hostInputSampleFormat,
                        PaWin_SampleFormatToLinearWaveFormatTag(hostInputSampleFormat),
                        sampleRate);
                    if (validBitsPerSample != 0)
                    {
                        wfx.Samples.wValidBitsPerSample = validBitsPerSample;
                    }
                    stream->capture.pPin = FilterCreatePin(pFilter, pPin->pinId, (const WAVEFORMATEX*)&wfx, &result);
                }

                if (result == paDeviceUnavailable) goto occupied;

                if (result == paNoError)
                {
                    /* We're done */
                    break;
                }

                if (channelsToProbe < (unsigned)pPin->maxChannels)
                {
                    /* Go to next multiple of 2 */
                    channelsToProbe = min((((channelsToProbe>>1)+1)<<1), (unsigned)pPin->maxChannels);
                    continue;
                }

                break;
            }

            if (result == paNoError)
            {
                /* We're done */
                break;
            }

            /* Go to next format in line with lower resolution */
            hostInputSampleFormat <<= 1;
        }

        if(stream->capture.pPin == NULL)
        {
            PaWinWDM_SetLastErrorInfo(result, "Failed to create capture pin: sr=%u,ch=%u,bits=%u,align=%u",
                wfx.Format.nSamplesPerSec, wfx.Format.nChannels, wfx.Format.wBitsPerSample, wfx.Format.nBlockAlign);
            goto error;
        }

        /* Select correct mux input on MUX node of topology filter */
        if (pDeviceInfo->muxPosition >= 0)
        {
            assert(pPin->parentFilter->topologyFilter != NULL);

            result = FilterUse(pPin->parentFilter->topologyFilter);
            if (result != paNoError)
            {
                PaWinWDM_SetLastErrorInfo(result, "Failed to open topology filter");
                goto error;
            }

            result = WdmSetMuxNodeProperty(pPin->parentFilter->topologyFilter->handle,
                pPin->inputs[pDeviceInfo->muxPosition]->muxNodeId,
                pPin->inputs[pDeviceInfo->muxPosition]->muxPinId);

            FilterRelease(pPin->parentFilter->topologyFilter);

            if(result != paNoError)
            {
                PaWinWDM_SetLastErrorInfo(result, "Failed to set topology mux node");
                goto error;
            }
        }

        stream->capture.bytesPerSample = stream->capture.bytesPerFrame / stream->deviceInputChannels;
        stream->capture.pPin->frameSize /= stream->capture.bytesPerFrame;
        PA_DEBUG(("Capture pin frames: %d\n",stream->capture.pPin->frameSize));
    }
    else
    {
        stream->capture.pPin = NULL;
        stream->capture.bytesPerFrame = 0;
    }

    /* Instantiate the output pin if necessary */
    if(userOutputChannels > 0)
    {
        PaWinWdmFilter* pFilter;
        PaWinWdmDeviceInfo* pDeviceInfo;
        PaWinWdmPin* pPin;
        PaWinWDMKSInfo* pInfo = (PaWinWDMKSInfo*)(outputParameters->hostApiSpecificStreamInfo);
        unsigned validBitsPerSample = 0;
        PaWinWaveFormatChannelMask channelMask = PaWin_DefaultChannelMask( userOutputChannels );
        if (pInfo && (pInfo->flags & paWinWDMKSUseGivenChannelMask))
        {
            PA_DEBUG(("Using channelMask 0x%08X instead of default 0x%08X\n",
                pInfo->channelMask,
                channelMask));
            channelMask = pInfo->channelMask;
        }

        result = paSampleFormatNotSupported;
        pDeviceInfo = (PaWinWdmDeviceInfo*)wdmHostApi->inheritedHostApiRep.deviceInfos[outputParameters->device];
        pFilter = pDeviceInfo->filter;
        pPin = pFilter->pins[pDeviceInfo->pin];

        stream->userOutputChannels = userOutputChannels;

        hostOutputSampleFormat = PaUtil_SelectClosestAvailableFormat( pPin->formats, outputSampleFormat );
        if (hostOutputSampleFormat == paSampleFormatNotSupported)
        {
            result = paUnanticipatedHostError;
            PaWinWDM_SetLastErrorInfo(result, "PU_SCAF(%X,%X) failed (output)", pPin->formats, hostOutputSampleFormat);
            goto error;
        }
        else if (pFilter->devInfo.streamingType == Type_kWaveRT && hostOutputSampleFormat == paInt24)
        {
            /* For WaveRT, we choose 32 bit format instead of paInt24, since we MIGHT need to align buffer on a
            128 byte boundary (see PinGetBuffer) */
            hostOutputSampleFormat = paInt32;
            /* But we'll tell the driver that it's 24 bit in 32 bit container */
            validBitsPerSample = 24;
        }

        while (hostOutputSampleFormat <= paUInt8)
        {
            unsigned channelsToProbe = stream->userOutputChannels;
            /* Some or all KS devices can only handle the exact number of channels
            * they specify. But PortAudio clients expect to be able to
            * at least specify mono I/O on a multi-channel device
            * If this is the case, then we will do the channel mapping internally
            * The following loop tests this case
            **/
            while (1)
            {
                PaWin_InitializeWaveFormatExtensible((PaWinWaveFormat*)&wfx,
                    channelsToProbe, 
                    hostOutputSampleFormat,
                    PaWin_SampleFormatToLinearWaveFormatTag(hostOutputSampleFormat),
                    sampleRate,
                    channelMask );
                stream->render.bytesPerFrame = wfx.Format.nBlockAlign;
                if (validBitsPerSample != 0)
                {
                    wfx.Samples.wValidBitsPerSample = validBitsPerSample;
                }
                stream->render.pPin = FilterCreatePin(pFilter, pPin->pinId, (WAVEFORMATEX*)&wfx, &result);
                stream->deviceOutputChannels = channelsToProbe;

                if( result != paNoError && result != paDeviceUnavailable )
                {
                    PaWin_InitializeWaveFormatEx((PaWinWaveFormat*)&wfx,
                        channelsToProbe, 
                        hostOutputSampleFormat,
                        PaWin_SampleFormatToLinearWaveFormatTag(hostOutputSampleFormat),
                        sampleRate);
                    if (validBitsPerSample != 0)
                    {
                        wfx.Samples.wValidBitsPerSample = validBitsPerSample;
                    }
                    stream->render.pPin = FilterCreatePin(pFilter, pPin->pinId, (const WAVEFORMATEX*)&wfx, &result);
                }

                if (result == paDeviceUnavailable) goto occupied;

                if (result == paNoError)
                {
                    /* We're done */
                    break;
                }

                if (channelsToProbe < (unsigned)pPin->maxChannels)
                {
                    /* Go to next multiple of 2 */
                    channelsToProbe = min((((channelsToProbe>>1)+1)<<1), (unsigned)pPin->maxChannels);
                    continue;
                }

                break;
            };

            if (result == paNoError)
            {
                /* We're done */
                break;
            }

            /* Go to next format in line with lower resolution */
            hostOutputSampleFormat <<= 1;
        }

        if(stream->render.pPin == NULL)
        {
            PaWinWDM_SetLastErrorInfo(result, "Failed to create render pin: sr=%u,ch=%u,bits=%u,align=%u",
                wfx.Format.nSamplesPerSec, wfx.Format.nChannels, wfx.Format.wBitsPerSample, wfx.Format.nBlockAlign);
            goto error;
        }

        stream->render.bytesPerSample = stream->render.bytesPerFrame / stream->deviceOutputChannels;
        stream->render.pPin->frameSize /= stream->render.bytesPerFrame;
        PA_DEBUG(("Render pin frames: %d\n",stream->render.pPin->frameSize));
    }
    else
    {
        stream->render.pPin = NULL;
        stream->render.bytesPerFrame = 0;
    }

    /* Calculate the framesPerHostXxxxBuffer size based upon the suggested latency values */
    /* Record the buffer length */
    if(inputParameters)
    {
        /* Calculate the frames from the user's value - add a bit to round up */
        stream->capture.framesPerBuffer = (unsigned long)((inputParameters->suggestedLatency*sampleRate)+0.0001);
        if(stream->capture.framesPerBuffer > (unsigned long)sampleRate)
        { /* Upper limit is 1 second */
            stream->capture.framesPerBuffer = (unsigned long)sampleRate;
        }
        else if(stream->capture.framesPerBuffer < stream->capture.pPin->frameSize)
        {
            stream->capture.framesPerBuffer = stream->capture.pPin->frameSize;
        }
        PA_DEBUG(("Input frames chosen:%ld\n",stream->capture.framesPerBuffer));

        /* Setup number of packets to use */
        stream->capture.noOfPackets = 2;

        if (inputParameters->hostApiSpecificStreamInfo)
        {
            PaWinWDMKSInfo* pInfo = (PaWinWDMKSInfo*)inputParameters->hostApiSpecificStreamInfo;

            if (stream->capture.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic &&
                pInfo->noOfPackets != 0)
            {
                stream->capture.noOfPackets = pInfo->noOfPackets;
            }
        }
    }

    if(outputParameters)
    {
        /* Calculate the frames from the user's value - add a bit to round up */
        stream->render.framesPerBuffer = (unsigned long)((outputParameters->suggestedLatency*sampleRate)+0.0001);
        if(stream->render.framesPerBuffer > (unsigned long)sampleRate)
        { /* Upper limit is 1 second */
            stream->render.framesPerBuffer = (unsigned long)sampleRate;
        }
        else if(stream->render.framesPerBuffer < stream->render.pPin->frameSize)
        {
            stream->render.framesPerBuffer = stream->render.pPin->frameSize;
        }
        PA_DEBUG(("Output frames chosen:%ld\n",stream->render.framesPerBuffer));

        /* Setup number of packets to use */
        stream->render.noOfPackets = 2;

        if (outputParameters->hostApiSpecificStreamInfo)
        {
            PaWinWDMKSInfo* pInfo = (PaWinWDMKSInfo*)outputParameters->hostApiSpecificStreamInfo;

            if (stream->render.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic &&
                pInfo->noOfPackets != 0)
            {
                stream->render.noOfPackets = pInfo->noOfPackets;
            }
        }
    }

    /* Host buffer size is bound to the largest of the input and output frame sizes */
    result =  PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
        stream->userInputChannels, inputSampleFormat, hostInputSampleFormat,
        stream->userOutputChannels, outputSampleFormat, hostOutputSampleFormat,
        sampleRate, streamFlags, framesPerUserBuffer,
        max(stream->capture.framesPerBuffer, stream->render.framesPerBuffer), 
        paUtilBoundedHostBufferSize,
        streamCallback, userData );
    if( result != paNoError )
    {
        PaWinWDM_SetLastErrorInfo(result, "PaUtil_InitializeBufferProcessor failed: ich=%u, isf=%u, hisf=%u, och=%u, osf=%u, hosf=%u, sr=%lf, flags=0x%X, fpub=%u, fphb=%u",
            stream->userInputChannels, inputSampleFormat, hostInputSampleFormat,
            stream->userOutputChannels, outputSampleFormat, hostOutputSampleFormat,
            sampleRate, streamFlags, framesPerUserBuffer,
            max(stream->capture.framesPerBuffer, stream->render.framesPerBuffer));
        goto error;
    }

    /* Allocate/get all the buffers for host I/O */
    if (stream->userInputChannels > 0)
    {
        stream->streamRepresentation.streamInfo.inputLatency = stream->capture.framesPerBuffer / sampleRate;

        switch (stream->capture.pPin->parentFilter->devInfo.streamingType)
        {
        case Type_kWaveCyclic:
            {
                unsigned size = stream->capture.noOfPackets * stream->capture.framesPerBuffer * stream->capture.bytesPerFrame;
                /* Allocate input host buffer */
                stream->capture.hostBuffer = (char*)PaUtil_GroupAllocateMemory(stream->allocGroup, size);
                PA_DEBUG(("Input buffer allocated (size = %u)\n", size));
                if( !stream->capture.hostBuffer )
                {
                    PA_DEBUG(("Cannot allocate host input buffer!\n"));
                    PaWinWDM_SetLastErrorInfo(paInsufficientMemory, "Failed to allocate input buffer");
                    result = paInsufficientMemory;
                    goto error;
                }
                stream->capture.hostBufferSize = size;
                PA_DEBUG(("Input buffer start = %p (size=%u)\n",stream->capture.hostBuffer, stream->capture.hostBufferSize));
                stream->capture.pPin->fnEventHandler = PaPinCaptureEventHandler_WaveCyclic;
                stream->capture.pPin->fnSubmitHandler = PaPinCaptureSubmitHandler_WaveCyclic;
            }
            break;
        case Type_kWaveRT:
            {
                const DWORD dwTotalSize = 2 * stream->capture.framesPerBuffer * stream->capture.bytesPerFrame;
                DWORD dwRequestedSize = dwTotalSize;
                BOOL bCallMemoryBarrier = FALSE;
                ULONG hwFifoLatency = 0;
                ULONG dummy;
                result = PinGetBuffer(stream->capture.pPin, (void**)&stream->capture.hostBuffer, &dwRequestedSize, &bCallMemoryBarrier);
                if (!result) 
                {
                    PA_DEBUG(("Input buffer start = %p, size = %u\n", stream->capture.hostBuffer, dwRequestedSize));
                    if (dwRequestedSize != dwTotalSize)
                    {
                        PA_DEBUG(("Buffer length changed by driver from %u to %u !\n", dwTotalSize, dwRequestedSize));
                        /* Recalculate to what the driver has given us */
                        stream->capture.framesPerBuffer = dwRequestedSize / (2 * stream->capture.bytesPerFrame);
                    }
                    stream->capture.hostBufferSize = dwRequestedSize;

                    if (stream->capture.pPin->pinKsSubType == SubType_kPolled)
                    {
                        stream->capture.pPin->fnEventHandler = PaPinCaptureEventHandler_WaveRTPolled;
                        stream->capture.pPin->fnSubmitHandler = PaPinCaptureSubmitHandler_WaveRTPolled;
                    }
                    else
                    {
                        stream->capture.pPin->fnEventHandler = PaPinCaptureEventHandler_WaveRTEvent;
                        stream->capture.pPin->fnSubmitHandler = PaPinCaptureSubmitHandler_WaveRTEvent;
                    }

                    stream->capture.pPin->fnMemBarrier = bCallMemoryBarrier ? MemoryBarrierRead : MemoryBarrierDummy;
                }
                else 
                {
                    PA_DEBUG(("Failed to get input buffer (WaveRT)\n"));
                    PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to get input buffer (WaveRT)");
                    result = paUnanticipatedHostError;
                    goto error;
                }

                /* Get latency */
                result = PinGetHwLatency(stream->capture.pPin, &hwFifoLatency, &dummy, &dummy);
                if (result == paNoError)
                {
                    stream->capture.pPin->hwLatency = hwFifoLatency;

                    /* Add HW latency into total input latency */
                    stream->streamRepresentation.streamInfo.inputLatency += ((hwFifoLatency / stream->capture.bytesPerFrame) / sampleRate);
                }
                else
                {
                    PA_DEBUG(("Failed to get size of FIFO hardware buffer (is set to zero)\n"));
                    stream->capture.pPin->hwLatency = 0;
                }
            }
            break;
        default:
            /* Undefined wave type!! */
            assert(0);
            result = paInternalError;
            PaWinWDM_SetLastErrorInfo(result, "Wave type %u ??", stream->capture.pPin->parentFilter->devInfo.streamingType);
            goto error;
        }
    }
    else 
    {
        stream->capture.hostBuffer = 0;
    }

    if (stream->userOutputChannels > 0)
    {
        stream->streamRepresentation.streamInfo.outputLatency = stream->render.framesPerBuffer / sampleRate;

        switch (stream->render.pPin->parentFilter->devInfo.streamingType)
        {
        case Type_kWaveCyclic:
            {
                unsigned size = stream->render.noOfPackets * stream->render.framesPerBuffer * stream->render.bytesPerFrame;
                /* Allocate output device buffer */
                stream->render.hostBuffer = (char*)PaUtil_GroupAllocateMemory(stream->allocGroup, size);
                PA_DEBUG(("Output buffer allocated (size = %u)\n", size));
                if( !stream->render.hostBuffer )
                {
                    PA_DEBUG(("Cannot allocate host output buffer!\n"));
                    PaWinWDM_SetLastErrorInfo(paInsufficientMemory, "Failed to allocate output buffer");
                    result = paInsufficientMemory;
                    goto error;
                }
                stream->render.hostBufferSize = size;
                PA_DEBUG(("Output buffer start = %p (size=%u)\n",stream->render.hostBuffer, stream->render.hostBufferSize));

                stream->render.pPin->fnEventHandler = PaPinRenderEventHandler_WaveCyclic;
                stream->render.pPin->fnSubmitHandler = PaPinRenderSubmitHandler_WaveCyclic;
            }
            break;
        case Type_kWaveRT:
            {
                const DWORD dwTotalSize = 2 * stream->render.framesPerBuffer * stream->render.bytesPerFrame;
                DWORD dwRequestedSize = dwTotalSize;
                BOOL bCallMemoryBarrier = FALSE;
                ULONG hwFifoLatency = 0;
                ULONG dummy;
                result = PinGetBuffer(stream->render.pPin, (void**)&stream->render.hostBuffer, &dwRequestedSize, &bCallMemoryBarrier);
                if (!result) 
                {
                    PA_DEBUG(("Output buffer start = %p, size = %u, membarrier = %u\n", stream->render.hostBuffer, dwRequestedSize, bCallMemoryBarrier));
                    if (dwRequestedSize != dwTotalSize)
                    {
                        PA_DEBUG(("Buffer length changed by driver from %u to %u !\n", dwTotalSize, dwRequestedSize));
                        /* Recalculate to what the driver has given us */
                        stream->render.framesPerBuffer = dwRequestedSize / (2 * stream->render.bytesPerFrame);
                    }
                    stream->render.hostBufferSize = dwRequestedSize;

                    if (stream->render.pPin->pinKsSubType == SubType_kPolled)
                    {
                        stream->render.pPin->fnEventHandler = PaPinRenderEventHandler_WaveRTPolled;
                        stream->render.pPin->fnSubmitHandler = PaPinRenderSubmitHandler_WaveRTPolled;
                    }
                    else
                    {
                        stream->render.pPin->fnEventHandler = PaPinRenderEventHandler_WaveRTEvent;
                        stream->render.pPin->fnSubmitHandler = PaPinRenderSubmitHandler_WaveRTEvent;
                    }

                    stream->render.pPin->fnMemBarrier = bCallMemoryBarrier ? MemoryBarrierWrite : MemoryBarrierDummy;
                }
                else 
                {
                    PA_DEBUG(("Failed to get output buffer (with notification)\n"));
                    PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to get output buffer (with notification)");
                    result = paUnanticipatedHostError;
                    goto error;
                }

                /* Get latency */
                result = PinGetHwLatency(stream->render.pPin, &hwFifoLatency, &dummy, &dummy);
                if (result == paNoError)
                {
                    stream->render.pPin->hwLatency = hwFifoLatency;

                    /* Add HW latency into total output latency */
                    stream->streamRepresentation.streamInfo.outputLatency += ((hwFifoLatency / stream->render.bytesPerFrame) / sampleRate);
                }
                else
                {
                    PA_DEBUG(("Failed to get size of FIFO hardware buffer (is set to zero)\n"));
                    stream->render.pPin->hwLatency = 0;
                }
            }
            break;
        default:
            /* Undefined wave type!! */
            assert(0);
            result = paInternalError;
            PaWinWDM_SetLastErrorInfo(result, "Wave type %u ??", stream->capture.pPin->parentFilter->devInfo.streamingType);
            goto error;
        }
    }
    else 
    {
        stream->render.hostBuffer = 0;
    }

    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

    PA_DEBUG(("BytesPerInputFrame = %d\n",stream->capture.bytesPerFrame));
    PA_DEBUG(("BytesPerOutputFrame = %d\n",stream->render.bytesPerFrame));

    /* memset(stream->hostBuffer,0,size); */

    /* Abort */
    stream->eventAbort          = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (stream->eventAbort == 0)
    {
        result = paInsufficientMemory;
        goto error;
    }
    stream->eventStreamStart[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (stream->eventStreamStart[0] == 0)
    {
        result = paInsufficientMemory;
        goto error;
    }
    stream->eventStreamStart[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (stream->eventStreamStart[1] == 0)
    {
        result = paInsufficientMemory;
        goto error;
    }

    if(stream->userInputChannels > 0)
    {
        const unsigned bufferSizeInBytes = stream->capture.framesPerBuffer * stream->capture.bytesPerFrame;
        const unsigned ringBufferFrameSize = NextPowerOf2( 1024 + 2 * max(stream->capture.framesPerBuffer, stream->render.framesPerBuffer) );

        stream->capture.events = (HANDLE*)PaUtil_GroupAllocateMemory(stream->allocGroup, stream->capture.noOfPackets * sizeof(HANDLE));
        if (stream->capture.events == NULL)
        {
            result = paInsufficientMemory;
            goto error;
        }

        stream->capture.packets = (DATAPACKET*)PaUtil_GroupAllocateMemory(stream->allocGroup, stream->capture.noOfPackets * sizeof(DATAPACKET));
        if (stream->capture.packets == NULL)
        {
            result = paInsufficientMemory;
            goto error;
        }

        switch(stream->capture.pPin->parentFilter->devInfo.streamingType)
        {
        case Type_kWaveCyclic:
            {
                /* WaveCyclic case */
                unsigned i;
                for (i = 0; i < stream->capture.noOfPackets; ++i)
                {
                    /* Set up the packets */
                    DATAPACKET *p = stream->capture.packets + i;

                    /* Record event */
                    stream->capture.events[i] = CreateEvent(NULL, TRUE, FALSE, NULL);

                    p->Signal.hEvent = stream->capture.events[i];
                    p->Header.Data = stream->capture.hostBuffer + (i*bufferSizeInBytes);
                    p->Header.FrameExtent = bufferSizeInBytes;
                    p->Header.DataUsed = 0;
                    p->Header.Size = sizeof(p->Header);
                    p->Header.PresentationTime.Numerator = 1;
                    p->Header.PresentationTime.Denominator = 1;
                }
            }
            break;
        case Type_kWaveRT:
            {
                /* Set up the "packets" */
                DATAPACKET *p = stream->capture.packets + 0;

                /* Record event: WaveRT has a single event for 2 notification per buffer */
                stream->capture.events[0] = CreateEvent(NULL, FALSE, FALSE, NULL);

                p->Header.Data = stream->capture.hostBuffer;
                p->Header.FrameExtent = bufferSizeInBytes;
                p->Header.DataUsed = 0;
                p->Header.Size = sizeof(p->Header);
                p->Header.PresentationTime.Numerator = 1;
                p->Header.PresentationTime.Denominator = 1;

                ++p;
                p->Header.Data = stream->capture.hostBuffer + bufferSizeInBytes;
                p->Header.FrameExtent = bufferSizeInBytes;
                p->Header.DataUsed = 0;
                p->Header.Size = sizeof(p->Header);
                p->Header.PresentationTime.Numerator = 1;
                p->Header.PresentationTime.Denominator = 1;

                if (stream->capture.pPin->pinKsSubType == SubType_kNotification)
                {
                    result = PinRegisterNotificationHandle(stream->capture.pPin, stream->capture.events[0]);

                    if (result != paNoError)
                    {
                        PA_DEBUG(("Failed to register capture notification handle\n"));
                        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to register capture notification handle");
                        result = paUnanticipatedHostError;
                        goto error;
                    }
                }

                result = PinRegisterPositionRegister(stream->capture.pPin);

                if (result != paNoError)
                {
                    unsigned long pos = 0xdeadc0de;
                    PA_DEBUG(("Failed to register capture position register, using PinGetAudioPositionViaIOCTLWrite\n"));
                    stream->capture.pPin->fnAudioPosition = PinGetAudioPositionViaIOCTLWrite;
                    /* Test position function */
                    result = (stream->capture.pPin->fnAudioPosition)(stream->capture.pPin, &pos);
                    if (result != paNoError || pos != 0x0)
                    {
                        PA_DEBUG(("Failed to read capture position register (IOCTL)\n"));
                        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to read capture position register (IOCTL)");
                        result = paUnanticipatedHostError;
                        goto error;
                    }                
                }
                else
                {
                    stream->capture.pPin->fnAudioPosition = PinGetAudioPositionMemoryMapped;
                }
            }
            break;
        default:
            /* Undefined wave type!! */
            assert(0);
            result = paInternalError;
            PaWinWDM_SetLastErrorInfo(result, "Wave type %u ??", stream->capture.pPin->parentFilter->devInfo.streamingType);
            goto error;
        }

        /* Setup the input ring buffer here */
        stream->ringBufferData = (char*)PaUtil_GroupAllocateMemory(stream->allocGroup, ringBufferFrameSize * stream->capture.bytesPerFrame);
        if (stream->ringBufferData == NULL)
        {
            result = paInsufficientMemory;
            goto error;
        }
        PaUtil_InitializeRingBuffer(&stream->ringBuffer, stream->capture.bytesPerFrame, ringBufferFrameSize, stream->ringBufferData);
    }
    if(stream->userOutputChannels > 0)
    {
        const unsigned bufferSizeInBytes = stream->render.framesPerBuffer * stream->render.bytesPerFrame;

        stream->render.events = (HANDLE*)PaUtil_GroupAllocateMemory(stream->allocGroup, stream->render.noOfPackets * sizeof(HANDLE));
        if (stream->render.events == NULL)
        {
            result = paInsufficientMemory;
            goto error;
        }

        stream->render.packets = (DATAPACKET*)PaUtil_GroupAllocateMemory(stream->allocGroup, stream->render.noOfPackets * sizeof(DATAPACKET));
        if (stream->render.packets == NULL)
        {
            result = paInsufficientMemory;
            goto error;
        }

        switch(stream->render.pPin->parentFilter->devInfo.streamingType)
        {
        case Type_kWaveCyclic:
            {
                /* WaveCyclic case */
                unsigned i;
                for (i = 0; i < stream->render.noOfPackets; ++i)
                {
                    /* Set up the packets */
                    DATAPACKET *p = stream->render.packets + i;

                    /* Playback event */
                    stream->render.events[i] = CreateEvent(NULL, TRUE, FALSE, NULL);

                    /* In this case, we just use the packets as ptr to the device buffer */
                    p->Signal.hEvent = stream->render.events[i];
                    p->Header.Data = stream->render.hostBuffer + (i*bufferSizeInBytes);
                    p->Header.FrameExtent = bufferSizeInBytes;
                    p->Header.DataUsed = bufferSizeInBytes;
                    p->Header.Size = sizeof(p->Header);
                    p->Header.PresentationTime.Numerator = 1;
                    p->Header.PresentationTime.Denominator = 1;
                }
            }
            break;
        case Type_kWaveRT:
            {
                /* WaveRT case */

                /* Set up the "packets" */
                DATAPACKET *p = stream->render.packets;

                /* The only playback event */
                stream->render.events[0] = CreateEvent(NULL, FALSE, FALSE, NULL);

                /* In this case, we just use the packets as ptr to the device buffer */
                p->Header.Data = stream->render.hostBuffer;
                p->Header.FrameExtent = stream->render.framesPerBuffer*stream->render.bytesPerFrame;
                p->Header.DataUsed = stream->render.framesPerBuffer*stream->render.bytesPerFrame;
                p->Header.Size = sizeof(p->Header);
                p->Header.PresentationTime.Numerator = 1;
                p->Header.PresentationTime.Denominator = 1;

                ++p;
                p->Header.Data = stream->render.hostBuffer + stream->render.framesPerBuffer*stream->render.bytesPerFrame;
                p->Header.FrameExtent = stream->render.framesPerBuffer*stream->render.bytesPerFrame;
                p->Header.DataUsed = stream->render.framesPerBuffer*stream->render.bytesPerFrame;
                p->Header.Size = sizeof(p->Header);
                p->Header.PresentationTime.Numerator = 1;
                p->Header.PresentationTime.Denominator = 1;

                if (stream->render.pPin->pinKsSubType == SubType_kNotification)
                {
                    result = PinRegisterNotificationHandle(stream->render.pPin, stream->render.events[0]);

                    if (result != paNoError)
                    {
                        PA_DEBUG(("Failed to register rendering notification handle\n"));
                        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to register rendering notification handle");
                        result = paUnanticipatedHostError;
                        goto error;
                    }
                }

                result = PinRegisterPositionRegister(stream->render.pPin);

                if (result != paNoError)
                {
                    unsigned long pos = 0xdeadc0de;
                    PA_DEBUG(("Failed to register rendering position register, using PinGetAudioPositionViaIOCTLRead\n"));
                    stream->render.pPin->fnAudioPosition = PinGetAudioPositionViaIOCTLRead;
                    /* Test position function */
                    result = (stream->render.pPin->fnAudioPosition)(stream->render.pPin, &pos);
                    if (result != paNoError || pos != 0x0)
                    {
                        PA_DEBUG(("Failed to read render position register (IOCTL)\n"));
                        PaWinWDM_SetLastErrorInfo(paUnanticipatedHostError, "Failed to read render position register (IOCTL)");
                        result = paUnanticipatedHostError;
                        goto error;
                    }
                }
                else
                {
                    stream->render.pPin->fnAudioPosition = PinGetAudioPositionMemoryMapped;
                }
            }
            break;
        default:
            /* Undefined wave type!! */
            assert(0);
            result = paInternalError;
            PaWinWDM_SetLastErrorInfo(result, "Wave type %u ??", stream->capture.pPin->parentFilter->devInfo.streamingType);
            goto error;
        }
    }

    stream->streamStarted = 0;
    stream->streamActive = 0;
    stream->streamStop = 0;
    stream->streamAbort = 0;
    stream->streamFlags = streamFlags;
    stream->oldProcessPriority = REALTIME_PRIORITY_CLASS;

    /* Increase ref count on filters in use, so that a CommitDeviceInfos won't delete them */
    if (stream->capture.pPin != 0)
    {
        FilterAddRef(stream->capture.pPin->parentFilter);
    }
    if (stream->render.pPin != 0)
    {
        FilterAddRef(stream->render.pPin->parentFilter);
    }

    /* Ok, now update our host API specific stream info */
    if (stream->userInputChannels)
    {
        PaWinWdmDeviceInfo *pDeviceInfo = (PaWinWdmDeviceInfo*)wdmHostApi->inheritedHostApiRep.deviceInfos[inputParameters->device];

        stream->hostApiStreamInfo.input.device = Pa_HostApiDeviceIndexToDeviceIndex(Pa_HostApiTypeIdToHostApiIndex(paWDMKS), inputParameters->device);
        stream->hostApiStreamInfo.input.channels = stream->deviceInputChannels;
        stream->hostApiStreamInfo.input.muxNodeId = -1;
        if (stream->capture.pPin->inputs)
        {
            stream->hostApiStreamInfo.input.muxNodeId = stream->capture.pPin->inputs[pDeviceInfo->muxPosition]->muxNodeId;
        }
        stream->hostApiStreamInfo.input.endpointPinId = pDeviceInfo->endpointPinId;
        stream->hostApiStreamInfo.input.framesPerHostBuffer = stream->capture.framesPerBuffer;
        stream->hostApiStreamInfo.input.streamingSubType = stream->capture.pPin->pinKsSubType;
    }
    else
    {
        stream->hostApiStreamInfo.input.device = paNoDevice;
    }
    if (stream->userOutputChannels)
    {
        stream->hostApiStreamInfo.output.device = Pa_HostApiDeviceIndexToDeviceIndex(Pa_HostApiTypeIdToHostApiIndex(paWDMKS), outputParameters->device);
        stream->hostApiStreamInfo.output.channels = stream->deviceOutputChannels;
        stream->hostApiStreamInfo.output.framesPerHostBuffer = stream->render.framesPerBuffer;
        stream->hostApiStreamInfo.output.endpointPinId = stream->render.pPin->endpointPinId;
        stream->hostApiStreamInfo.output.streamingSubType = stream->render.pPin->pinKsSubType;
    }
    else
    {
        stream->hostApiStreamInfo.output.device = paNoDevice;
    }
    /*stream->streamRepresentation.streamInfo.hostApiTypeId = paWDMKS;
    stream->streamRepresentation.streamInfo.hostApiSpecificStreamInfo = &stream->hostApiStreamInfo;*/
    stream->streamRepresentation.streamInfo.structVersion = 2;

    *s = (PaStream*)stream;

    PA_LOGL_;
    return result;

occupied:
    /* Ok, someone else is hogging the pin, bail out */
    assert (result == paDeviceUnavailable);
    PaWinWDM_SetLastErrorInfo(result, "Device is occupied");

error:
    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );

    CloseStreamEvents(stream);

    if (stream->allocGroup)
    {
        PaUtil_FreeAllAllocations(stream->allocGroup);
        PaUtil_DestroyAllocationGroup(stream->allocGroup);
        stream->allocGroup = 0;
    }

    if(stream->render.pPin)
        PinClose(stream->render.pPin);
    if(stream->capture.pPin)
        PinClose(stream->capture.pPin);

    PaUtil_FreeMemory( stream );

    PA_LOGL_;
    return result;
}

/*
When CloseStream() is called, the multi-api layer ensures that
the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;

    assert(!stream->streamStarted);
    assert(!stream->streamActive);

    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );

    CloseStreamEvents(stream);

    if (stream->allocGroup)
    {
        PaUtil_FreeAllAllocations(stream->allocGroup);
        PaUtil_DestroyAllocationGroup(stream->allocGroup);
        stream->allocGroup = 0;
    }

    if(stream->render.pPin)
    {
        PinClose(stream->render.pPin);
    }
    if(stream->capture.pPin)
    {
        PinClose(stream->capture.pPin);
    }

    if (stream->render.pPin)
    {
        FilterFree(stream->render.pPin->parentFilter);
    }
    if (stream->capture.pPin)
    {
        FilterFree(stream->capture.pPin->parentFilter);
    }

    PaUtil_FreeMemory( stream );

    PA_LOGL_;
    return result;
}

/*
Write the supplied packet to the pin
Asynchronous
Should return paNoError on success
*/
static PaError PinWrite(HANDLE h, DATAPACKET* p)
{
    PaError result = paNoError;
    unsigned long cbReturned = 0;
    BOOL fRes = DeviceIoControl(h,
        IOCTL_KS_WRITE_STREAM,
        NULL,
        0,
        &p->Header,
        p->Header.Size,
        &cbReturned,
        &p->Signal);
    if (!fRes)
    {
        unsigned long error = GetLastError();
        if (error != ERROR_IO_PENDING)
        {
            result = paInternalError;
        }
    }
    return result;
}

/*
Read to the supplied packet from the pin
Asynchronous
Should return paNoError on success
*/
static PaError PinRead(HANDLE h, DATAPACKET* p)
{
    PaError result = paNoError;
    unsigned long cbReturned = 0;
    BOOL fRes = DeviceIoControl(h,
        IOCTL_KS_READ_STREAM,
        NULL,
        0,
        &p->Header,
        p->Header.Size,
        &cbReturned,
        &p->Signal);
    if (!fRes)
    {
        unsigned long error = GetLastError();
        if (error != ERROR_IO_PENDING)
        {
            result = paInternalError;
        }
    }
    return result;
}

/*
Copy the first interleaved channel of 16 bit data to the other channels
*/
static void DuplicateFirstChannelInt16(void* buffer, int channels, int samples)
{
    unsigned short* data = (unsigned short*)buffer;
    int channel;
    unsigned short sourceSample;
    while( samples-- )
    {
        sourceSample = *data++;
        channel = channels-1;
        while( channel-- )
        {
            *data++ = sourceSample;
        }
    }
}

/*
Copy the first interleaved channel of 24 bit data to the other channels
*/
static void DuplicateFirstChannelInt24(void* buffer, int channels, int samples)
{
    unsigned char* data = (unsigned char*)buffer;
    int channel;
    unsigned char sourceSample[3];
    while( samples-- )
    {
        sourceSample[0] = data[0];
        sourceSample[1] = data[1];
        sourceSample[2] = data[2];
        data += 3;
        channel = channels-1;
        while( channel-- )
        {
            data[0] = sourceSample[0];
            data[1] = sourceSample[1];
            data[2] = sourceSample[2];
            data += 3;
        }
    }
}

/*
Copy the first interleaved channel of 32 bit data to the other channels
*/
static void DuplicateFirstChannelInt32(void* buffer, int channels, int samples)
{
    unsigned long* data = (unsigned long*)buffer;
    int channel;
    unsigned long sourceSample;
    while( samples-- )
    {
        sourceSample = *data++;
        channel = channels-1;
        while( channel-- )
        {
            *data++ = sourceSample;
        }
    }
}

/*
Increase the priority of the calling thread to RT 
*/
static HANDLE BumpThreadPriority() 
{
    HANDLE hThread = GetCurrentThread();
    DWORD dwTask = 0;
    HANDLE hAVRT = NULL;

    /* If we have access to AVRT.DLL (Vista and later), use it */
    if (paWinWDMKSAvRtEntryPoints.AvSetMmThreadCharacteristics != NULL) 
    {
        hAVRT = paWinWDMKSAvRtEntryPoints.AvSetMmThreadCharacteristics("Pro Audio", &dwTask);
        if (hAVRT != NULL && hAVRT != INVALID_HANDLE_VALUE) 
        {
            BOOL bret = paWinWDMKSAvRtEntryPoints.AvSetMmThreadPriority(hAVRT, PA_AVRT_PRIORITY_CRITICAL);
            if (!bret)
            {
                PA_DEBUG(("Set mm thread prio to critical failed!\n"));
            }
            else
            {
                return hAVRT;
            }
        }
        else
        {
            PA_DEBUG(("Set mm thread characteristic to 'Pro Audio' failed, reverting to SetThreadPriority\n"));
        }
    }

    /* For XP and earlier, or if AvSetMmThreadCharacteristics fails (MMCSS disabled ?) */
    if (timeBeginPeriod(1) != TIMERR_NOERROR) {
        PA_DEBUG(("timeBeginPeriod(1) failed!\n"));
    }

    if (!SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL)) {
        PA_DEBUG(("SetThreadPriority failed!\n"));
    }

    return hAVRT;
}

/*
Decrease the priority of the calling thread to normal
*/
static void DropThreadPriority(HANDLE hAVRT)
{
    HANDLE hThread = GetCurrentThread();

    if (hAVRT != NULL) 
    {
        paWinWDMKSAvRtEntryPoints.AvSetMmThreadPriority(hAVRT, PA_AVRT_PRIORITY_NORMAL);
        paWinWDMKSAvRtEntryPoints.AvRevertMmThreadCharacteristics(hAVRT);
        return;
    }

    SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);
    timeEndPeriod(1);
}

static PaError PreparePinForStart(PaWinWdmPin* pin)
{
    PaError result;
    result = PinSetState(pin, KSSTATE_ACQUIRE);
    if (result != paNoError)
    {
        goto error;
    }
    result = PinSetState(pin, KSSTATE_PAUSE);
    if (result != paNoError)
    {
        goto error;
    }
    return result;

error:
    PinSetState(pin, KSSTATE_STOP);
    return result;
}

static PaError PreparePinsForStart(PaProcessThreadInfo* pInfo)
{
    PaError result = paNoError;
    /* Submit buffers */
    if (pInfo->stream->capture.pPin)
    {
        if ((result = PreparePinForStart(pInfo->stream->capture.pPin)) != paNoError)
        {
            goto error;
        }

        if (pInfo->stream->capture.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic)
        {
            unsigned i;
            for(i=0; i < pInfo->stream->capture.noOfPackets; ++i)
            {
                if ((result = PinRead(pInfo->stream->capture.pPin->handle, pInfo->stream->capture.packets + i)) != paNoError)
                {
                    goto error;
                }
                ++pInfo->pending;
            }
        }
        else
        {
            pInfo->pending = 2;
        }
    }

    if(pInfo->stream->render.pPin)
    {
        if ((result = PreparePinForStart(pInfo->stream->render.pPin)) != paNoError)
        {
            goto error;
        }

        pInfo->priming += pInfo->stream->render.noOfPackets;
        ++pInfo->pending;
        SetEvent(pInfo->stream->render.events[0]);
        if (pInfo->stream->render.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic) 
        {
            unsigned i;
            for(i=1; i < pInfo->stream->render.noOfPackets; ++i)
            {
                SetEvent(pInfo->stream->render.events[i]);
                ++pInfo->pending;
            }
        }
    }

error:
    PA_DEBUG(("PreparePinsForStart = %d\n", result));
    return result;
}

static PaError StartPin(PaWinWdmPin* pin)
{
    return PinSetState(pin, KSSTATE_RUN);
}

static PaError StartPins(PaProcessThreadInfo* pInfo)
{
    PaError result = paNoError;
    /* Start the pins as synced as possible */
    if (pInfo->stream->capture.pPin)
    {
        result = StartPin(pInfo->stream->capture.pPin);
    }
    if(pInfo->stream->render.pPin)
    {
        result = StartPin(pInfo->stream->render.pPin);
    }
    PA_DEBUG(("StartPins = %d\n", result));
    return result;
}


static PaError StopPin(PaWinWdmPin* pin)
{
    PinSetState(pin, KSSTATE_PAUSE);
    PinSetState(pin, KSSTATE_STOP);
    return paNoError;
}


static PaError StopPins(PaProcessThreadInfo* pInfo)
{
    PaError result = paNoError;
    if(pInfo->stream->render.pPin)
    {
        StopPin(pInfo->stream->render.pPin);
    }
    if(pInfo->stream->capture.pPin)
    {
        StopPin(pInfo->stream->capture.pPin);
    }
    return result;
}

typedef void (*TSetInputFrameCount)(PaUtilBufferProcessor*, unsigned long);
typedef void (*TSetInputChannel)(PaUtilBufferProcessor*, unsigned int, void *, unsigned int);
static const TSetInputFrameCount fnSetInputFrameCount[2] = { PaUtil_SetInputFrameCount, PaUtil_Set2ndInputFrameCount };
static const TSetInputChannel fnSetInputChannel[2] = { PaUtil_SetInputChannel, PaUtil_Set2ndInputChannel };

static PaError PaDoProcessing(PaProcessThreadInfo* pInfo)
{
    PaError result = paNoError;
    int i, framesProcessed = 0, doChannelCopy = 0;
    ring_buffer_size_t inputFramesAvailable = PaUtil_GetRingBufferReadAvailable(&pInfo->stream->ringBuffer);

    /* Do necessary buffer processing (which will invoke user callback if necessary) */
    if (pInfo->cbResult == paContinue &&
        (pInfo->renderHead != pInfo->renderTail || inputFramesAvailable))
    {
        unsigned processFullDuplex = pInfo->stream->capture.pPin && pInfo->stream->render.pPin && (!pInfo->priming);

        PA_HP_TRACE((pInfo->stream->hLog, "DoProcessing: InputFrames=%u", inputFramesAvailable));

        PaUtil_BeginCpuLoadMeasurement( &pInfo->stream->cpuLoadMeasurer );

        pInfo->ti.currentTime = PaUtil_GetTime();

        PaUtil_BeginBufferProcessing(&pInfo->stream->bufferProcessor, &pInfo->ti, pInfo->underover);
        pInfo->underover = 0; /* Reset the (under|over)flow status */

        if (pInfo->renderTail != pInfo->renderHead)
        {
            DATAPACKET* packet = pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet;

            assert(packet != 0);
            assert(packet->Header.Data != 0);

            PaUtil_SetOutputFrameCount(&pInfo->stream->bufferProcessor, pInfo->stream->render.framesPerBuffer);

            for(i=0;i<pInfo->stream->userOutputChannels;i++)
            {
                /* Only write the user output channels. Leave the rest blank */
                PaUtil_SetOutputChannel(&pInfo->stream->bufferProcessor,
                    i,
                    ((unsigned char*)(packet->Header.Data))+(i*pInfo->stream->render.bytesPerSample),
                    pInfo->stream->deviceOutputChannels);
            }

            /* We will do a copy to the other channels after the data has been written */
            doChannelCopy = ( pInfo->stream->userOutputChannels == 1 );
        }

        if (inputFramesAvailable && (!pInfo->stream->userOutputChannels || inputFramesAvailable >= (int)pInfo->stream->render.framesPerBuffer))
        {
            unsigned wrapCntr = 0;
            void* data[2] = {0};
            ring_buffer_size_t size[2] = {0};

            /* If full-duplex, we just extract output buffer number of frames */
            if (pInfo->stream->userOutputChannels)
            {
                inputFramesAvailable = min(inputFramesAvailable, (int)pInfo->stream->render.framesPerBuffer);
            }

            inputFramesAvailable = PaUtil_GetRingBufferReadRegions(&pInfo->stream->ringBuffer,
                inputFramesAvailable,
                &data[0],
                &size[0],
                &data[1],
                &size[1]);

            for (wrapCntr = 0; wrapCntr < 2; ++wrapCntr)
            {
                if (size[wrapCntr] == 0)
                    break;

                fnSetInputFrameCount[wrapCntr](&pInfo->stream->bufferProcessor, size[wrapCntr]);
                for(i=0;i<pInfo->stream->userInputChannels;i++)
                {
                    /* Only read as many channels as the user wants */
                    fnSetInputChannel[wrapCntr](&pInfo->stream->bufferProcessor,
                        i,
                        ((unsigned char*)(data[wrapCntr]))+(i*pInfo->stream->capture.bytesPerSample),
                        pInfo->stream->deviceInputChannels);
                }
            }
        }
        else
        {
            /* We haven't consumed anything from the ring buffer... */
            inputFramesAvailable = 0;
            /* If we have full-duplex, this is at startup, so mark no-input! */
            if (pInfo->stream->userOutputChannels>0 && pInfo->stream->userInputChannels>0)
            {
                PA_HP_TRACE((pInfo->stream->hLog, "Input startup, marking no input."));
                PaUtil_SetNoInput(&pInfo->stream->bufferProcessor);
            }
        }

        if (processFullDuplex) /* full duplex */
        {
            /* Only call the EndBufferProcessing function when the total input frames == total output frames */
            const unsigned long totalInputFrameCount = pInfo->stream->bufferProcessor.hostInputFrameCount[0] + pInfo->stream->bufferProcessor.hostInputFrameCount[1];
            const unsigned long totalOutputFrameCount = pInfo->stream->bufferProcessor.hostOutputFrameCount[0] + pInfo->stream->bufferProcessor.hostOutputFrameCount[1];

            if(totalInputFrameCount == totalOutputFrameCount && totalOutputFrameCount != 0)
            {
                framesProcessed = PaUtil_EndBufferProcessing(&pInfo->stream->bufferProcessor, &pInfo->cbResult);
            }
            else
            {
                framesProcessed = 0;
            }
        }
        else 
        {
            framesProcessed = PaUtil_EndBufferProcessing(&pInfo->stream->bufferProcessor, &pInfo->cbResult);
        }

        PA_HP_TRACE((pInfo->stream->hLog, "Frames processed: %u %s", framesProcessed, (pInfo->priming ? "(priming)":"")));

        if( doChannelCopy )
        {
            DATAPACKET* packet = pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet;
            /* Copy the first output channel to the other channels */
            switch (pInfo->stream->render.bytesPerSample)
            {
            case 2:
                DuplicateFirstChannelInt16(packet->Header.Data, pInfo->stream->deviceOutputChannels, pInfo->stream->render.framesPerBuffer);
                break;
            case 3:
                DuplicateFirstChannelInt24(packet->Header.Data, pInfo->stream->deviceOutputChannels, pInfo->stream->render.framesPerBuffer);
                break;
            case 4:
                DuplicateFirstChannelInt32(packet->Header.Data, pInfo->stream->deviceOutputChannels, pInfo->stream->render.framesPerBuffer);
                break;
            default:
                assert(0); /* Unsupported format! */
                break;
            }
        }
        PaUtil_EndCpuLoadMeasurement( &pInfo->stream->cpuLoadMeasurer, framesProcessed );

        if (inputFramesAvailable)
        {
            PaUtil_AdvanceRingBufferReadIndex(&pInfo->stream->ringBuffer, inputFramesAvailable);
        }

        if (pInfo->renderTail != pInfo->renderHead)
        {
            if (!pInfo->stream->streamStop)
            {
                result = pInfo->stream->render.pPin->fnSubmitHandler(pInfo, pInfo->renderTail);
                if (result != paNoError)
                {
                    PA_HP_TRACE((pInfo->stream->hLog, "Capture submit handler failed with result %d", result));
                    return result;
                }
            }
            pInfo->renderTail++;
            if (!pInfo->pinsStarted && pInfo->priming == 0)
            {
                /* We start the pins here to allow "prime time" */
                if ((result = StartPins(pInfo)) == paNoError)
                {
                    PA_HP_TRACE((pInfo->stream->hLog, "Starting pins!"));
                    pInfo->pinsStarted = 1;
                }
            }
        }
    }

    return result;
}

static VOID CALLBACK TimerAPCWaveRTPolledMode(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue)
{
    HANDLE* pHandles = (HANDLE*)lpArgToCompletionRoutine;
    if (pHandles[0]) SetEvent(pHandles[0]);
    if (pHandles[1]) SetEvent(pHandles[1]);
}

static DWORD GetCurrentTimeInMillisecs()
{
    return timeGetTime();
}

PA_THREAD_FUNC ProcessingThread(void* pParam)
{
    PaError result = paNoError;
    HANDLE hAVRT = NULL;
    HANDLE hTimer = NULL;
    HANDLE *handleArray = NULL;
    HANDLE timerEventHandles[2] = {0};
    unsigned noOfHandles = 0;
    unsigned captureEvents = 0;
    unsigned renderEvents = 0;
    unsigned timerPeriod = 0;
    DWORD timeStamp[2] = {0};

    PaProcessThreadInfo info;
    memset(&info, 0, sizeof(PaProcessThreadInfo));
    info.stream = (PaWinWdmStream*)pParam;

    info.stream->threadResult = paNoError;

    PA_LOGE_;

    info.ti.inputBufferAdcTime = 0.0;
    info.ti.currentTime = 0.0;
    info.ti.outputBufferDacTime = 0.0;

    PA_DEBUG(("In  buffer len: %.3f ms\n",(2000*info.stream->capture.framesPerBuffer) / info.stream->streamRepresentation.streamInfo.sampleRate));
    PA_DEBUG(("Out buffer len: %.3f ms\n",(2000*info.stream->render.framesPerBuffer) / info.stream->streamRepresentation.streamInfo.sampleRate));
    info.timeout = (DWORD)max(
        (2000*info.stream->render.framesPerBuffer/info.stream->streamRepresentation.streamInfo.sampleRate + 0.5),
        (2000*info.stream->capture.framesPerBuffer/info.stream->streamRepresentation.streamInfo.sampleRate + 0.5));
    info.timeout = max(info.timeout*8, 100);
    timerPeriod = info.timeout;
    PA_DEBUG(("Timeout = %ld ms\n",info.timeout));

    /* Allocate handle array */
    handleArray = (HANDLE*)PaUtil_AllocateMemory((info.stream->capture.noOfPackets + info.stream->render.noOfPackets + 1) * sizeof(HANDLE));

    /* Setup handle array for WFMO */
    if (info.stream->capture.pPin != 0)
    {
        handleArray[noOfHandles++] = info.stream->capture.events[0];
        if (info.stream->capture.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic)
        {
            unsigned i;
            for(i=1; i < info.stream->capture.noOfPackets; ++i)
            {
                handleArray[noOfHandles++] = info.stream->capture.events[i];
            }
        }
        captureEvents = noOfHandles;
        renderEvents = noOfHandles;
    }

    if (info.stream->render.pPin != 0)
    {
        handleArray[noOfHandles++] = info.stream->render.events[0];
        if (info.stream->render.pPin->parentFilter->devInfo.streamingType == Type_kWaveCyclic)
        {
            unsigned i;
            for(i=1; i < info.stream->render.noOfPackets; ++i)
            {
                handleArray[noOfHandles++] = info.stream->render.events[i];
            }
        }
        renderEvents = noOfHandles;
    }
    handleArray[noOfHandles++] = info.stream->eventAbort;
    assert(noOfHandles <= (info.stream->capture.noOfPackets + info.stream->render.noOfPackets + 1));

    /* Prepare render and capture pins */
    if ((result = PreparePinsForStart(&info)) != paNoError) 
    {
        PA_DEBUG(("Failed to prepare device(s)!\n"));
        goto error;
    }

    /* Init high speed logger */
    if (PaUtil_InitializeHighSpeedLog(&info.stream->hLog, 1000000) != paNoError)
    {
        PA_DEBUG(("Failed to init high speed logger!\n"));
        goto error;
    }

    /* Heighten priority here */
    hAVRT = BumpThreadPriority();

    /* If input only, we start the pins immediately */
    if (info.stream->render.pPin == 0)
    {
        if ((result = StartPins(&info)) != paNoError)
        {
            PA_DEBUG(("Failed to start device(s)!\n"));
            goto error;
        }
        info.pinsStarted = 1;
    }

    /* Handle WaveRT polled mode */
    {
        const unsigned fs = (unsigned)info.stream->streamRepresentation.streamInfo.sampleRate;
        if (info.stream->capture.pPin != 0 && info.stream->capture.pPin->pinKsSubType == SubType_kPolled)
        {
            timerEventHandles[0] = info.stream->capture.events[0];
            timerPeriod = min(timerPeriod, (1000*info.stream->capture.framesPerBuffer)/fs);
        }

        if (info.stream->render.pPin != 0 && info.stream->render.pPin->pinKsSubType == SubType_kPolled)
        {
            timerEventHandles[1] = info.stream->render.events[0];
            timerPeriod = min(timerPeriod, (1000*info.stream->render.framesPerBuffer)/fs);
        }

        if (timerEventHandles[0] || timerEventHandles[1])
        {
            LARGE_INTEGER dueTime = {0};

            timerPeriod=max(timerPeriod/5,1);
            PA_DEBUG(("Timer event handles=0x%04X,0x%04X period=%u ms", timerEventHandles[0], timerEventHandles[1], timerPeriod));
            hTimer = CreateWaitableTimer(0, FALSE, NULL);
            if (hTimer == NULL)
            {
                result = paUnanticipatedHostError;
                goto error;
            }
            /* invoke first timeout immediately */
            if (!SetWaitableTimer(hTimer, &dueTime, timerPeriod, TimerAPCWaveRTPolledMode, timerEventHandles, FALSE))
            {
                result = paUnanticipatedHostError;
                goto error;
            }
            PA_DEBUG(("Waitable timer started, period = %u ms\n", timerPeriod));
        }
    }

    /* Mark stream as active */
    info.stream->streamActive = 1;
    info.stream->threadResult = paNoError;

    /* Up and running... */
    SetEvent(info.stream->eventStreamStart[StreamStart_kOk]);

    /* Take timestamp here */
    timeStamp[0] = timeStamp[1] = GetCurrentTimeInMillisecs();

    while(!info.stream->streamAbort)
    {
        unsigned doProcessing = 1;
        unsigned wait = WaitForMultipleObjects(noOfHandles, handleArray, FALSE, 0);
        unsigned eventSignalled = wait - WAIT_OBJECT_0;
        DWORD dwCurrentTime = 0;

        if (wait == WAIT_FAILED) 
        {
            PA_DEBUG(("Wait failed = %ld! \n",wait));
            break;
        }
        if (wait == WAIT_TIMEOUT)
        {
            wait = WaitForMultipleObjectsEx(noOfHandles, handleArray, FALSE, 50, TRUE);
            eventSignalled = wait - WAIT_OBJECT_0;
        }
        else
        {
            if (eventSignalled < captureEvents)
            {
                if (PaUtil_GetRingBufferWriteAvailable(&info.stream->ringBuffer) == 0)
                {
                    PA_HP_TRACE((info.stream->hLog, "!!!!! Input overflow !!!!!"));
                    info.underover |= paInputOverflow;
                }
            }
            else if (eventSignalled < renderEvents)
            {
                if (!info.priming && info.renderHead - info.renderTail > 1)
                {
                    PA_HP_TRACE((info.stream->hLog, "!!!!! Output underflow !!!!!"));
                    info.underover |= paOutputUnderflow;
                }
            }
        }

        /* Get event time */
        dwCurrentTime = GetCurrentTimeInMillisecs();

        /* Since we can mix capture/render devices between WaveCyclic, WaveRT polled and WaveRT notification (3x3 combinations), 
        we can't rely on the timeout of WFMO to check for device timeouts, we need to keep tally. */
        if (info.stream->capture.pPin && (dwCurrentTime - timeStamp[0]) >= info.timeout)
        {
            PA_DEBUG(("Timeout for capture device (%u ms)!", info.timeout, (dwCurrentTime - timeStamp[0])));
            result = paTimedOut;
            break;
        }
        if (info.stream->render.pPin && (dwCurrentTime - timeStamp[1]) >= info.timeout)
        {
            PA_DEBUG(("Timeout for render device (%u ms)!", info.timeout, (dwCurrentTime - timeStamp[1])));
            result = paTimedOut;
            break;
        }

        if (wait == WAIT_IO_COMPLETION)
        {
            /* Waitable timer has fired! */
            PA_HP_TRACE((info.stream->hLog, "WAIT_IO_COMPLETION"));
            continue;
        }

        if (wait == WAIT_TIMEOUT)
        {
            continue;
        }
        else
        {
            if (eventSignalled < captureEvents)
            {
                if (info.stream->capture.pPin->fnEventHandler(&info, eventSignalled) == paNoError)
                {
                    timeStamp[0] = dwCurrentTime;

                    /* Since we use the ring buffer, we can submit the buffers directly */
                    if (!info.stream->streamStop)
                    {
                        result = info.stream->capture.pPin->fnSubmitHandler(&info, info.captureTail);
                        if (result != paNoError)
                        {
                            PA_HP_TRACE((info.stream->hLog, "Capture submit handler failed with result %d", result));
                            break;
                        }
                    }
                    ++info.captureTail;
                    /* If full-duplex, let _only_ render event trigger processing. We still need the stream stop
                    handling working, so let that be processed anyways... */
                    if (info.stream->userOutputChannels > 0)
                    {
                        doProcessing = 0;
                    }
                }
            }
            else if (eventSignalled < renderEvents)
            {
                timeStamp[1] = dwCurrentTime;
                eventSignalled -= captureEvents;
                info.stream->render.pPin->fnEventHandler(&info, eventSignalled);
            }
            else
            {
                assert(info.stream->streamAbort);
                PA_HP_TRACE((info.stream->hLog, "Stream abort!"));
                continue;
            }
        }

        /* Handle processing */
        if (doProcessing)
        {
            result = PaDoProcessing(&info);
            if (result != paNoError)
            {
                PA_HP_TRACE((info.stream->hLog, "PaDoProcessing failed!"));
                break;
            }
        }

        if(info.stream->streamStop && info.cbResult != paComplete)
        {
            PA_HP_TRACE((info.stream->hLog, "Stream stop! pending=%d",info.pending));
            info.cbResult = paComplete; /* Stop, but play remaining buffers */
        }

        if(info.pending<=0)
        {
            PA_HP_TRACE((info.stream->hLog, "pending==0 finished..."));
            break;
        }
        if((!info.stream->render.pPin)&&(info.cbResult!=paContinue))
        {
            PA_HP_TRACE((info.stream->hLog, "record only cbResult=%d...",info.cbResult));
            break;
        }
    }

    PA_DEBUG(("Finished processing loop\n"));

    info.stream->threadResult = result;
    goto bailout;

error:
    PA_DEBUG(("Error starting processing thread\n"));
    /* Set the "error" event together with result */
    info.stream->threadResult = result;
    SetEvent(info.stream->eventStreamStart[StreamStart_kFailed]);

bailout:
    if (hTimer)
    {
        PA_DEBUG(("Waitable timer stopped\n", timerPeriod));
        CancelWaitableTimer(hTimer);
        CloseHandle(hTimer);
        hTimer = 0;
    }

    if (info.pinsStarted)
    {
        StopPins(&info);
    }

    /* Lower prio here */
    DropThreadPriority(hAVRT);

    if (handleArray != NULL)
    {
        PaUtil_FreeMemory(handleArray);
    }

#if PA_TRACE_REALTIME_EVENTS
    if (info.stream->hLog)
    {
        PA_DEBUG(("Dumping highspeed trace...\n"));
        PaUtil_DumpHighSpeedLog(info.stream->hLog, "hp_trace.log");
        PaUtil_DiscardHighSpeedLog(info.stream->hLog);
        info.stream->hLog = 0;
    }
#endif
    info.stream->streamActive = 0;

    if((!info.stream->streamStop)&&(!info.stream->streamAbort))
    {
        /* Invoke the user stream finished callback */
        /* Only do it from here if not being stopped/aborted by user */
        if( info.stream->streamRepresentation.streamFinishedCallback != 0 )
            info.stream->streamRepresentation.streamFinishedCallback( info.stream->streamRepresentation.userData );
    }
    info.stream->streamStop = 0;
    info.stream->streamAbort = 0;

    PA_LOGL_;
    return 0;
}


static PaError StartStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;

    if (stream->streamThread != NULL)
    {
        return paStreamIsNotStopped;
    }

    stream->streamStop = 0;
    stream->streamAbort = 0;

    ResetStreamEvents(stream);

    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );

    stream->oldProcessPriority = GetPriorityClass(GetCurrentProcess());
    /* Uncomment the following line to enable dynamic boosting of the process
    * priority to real time for best low latency support
    * Disabled by default because RT processes can easily block the OS */
    /*ret = SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    PA_DEBUG(("Class ret = %d;",ret));*/

    stream->streamThread = CREATE_THREAD_FUNCTION (NULL, 0, ProcessingThread, stream, CREATE_SUSPENDED, NULL);
    if(stream->streamThread == NULL)
    {
        result = paInsufficientMemory;
        goto end;
    }
    ResumeThread(stream->streamThread);

    switch (WaitForMultipleObjects(2, stream->eventStreamStart, FALSE, 5000))
    {
    case WAIT_OBJECT_0 + StreamStart_kOk:
        PA_DEBUG(("Processing thread started!\n"));
        result = paNoError;
        /* streamActive is set in processing thread */
        stream->streamStarted = 1;
        break;
    case WAIT_OBJECT_0 + StreamStart_kFailed:
        PA_DEBUG(("Processing thread start failed! (result=%d)\n", stream->threadResult));
        result = stream->threadResult;
        /* Wait for the stream to really exit */
        WaitForSingleObject(stream->streamThread, 200);
        CloseHandle(stream->streamThread);
        stream->streamThread = 0;
        break;
    case WAIT_TIMEOUT:
    default:
        result = paTimedOut;
        PaWinWDM_SetLastErrorInfo(result, "Failed to start processing thread (timeout)!");
        break;
    }

end:
    PA_LOGL_;
    return result;
}


static PaError StopStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinWdmStream *stream = (PaWinWdmStream*)s;
    BOOL doCb = FALSE;

    PA_LOGE_;

    if(stream->streamActive)
    {
        DWORD dwExitCode;
        doCb = TRUE;
        stream->streamStop = 1;
        if (GetExitCodeThread(stream->streamThread, &dwExitCode) && dwExitCode == STILL_ACTIVE)
        {
            if (WaitForSingleObject(stream->streamThread, INFINITE) != WAIT_OBJECT_0)
            {
                PA_DEBUG(("StopStream: stream thread terminated\n"));
                TerminateThread(stream->streamThread, -1);
                result = paTimedOut;
            }
        }
        else
        {
            PA_DEBUG(("StopStream: GECT says not active, but streamActive is not false ??"));
            result = paUnanticipatedHostError;
            PaWinWDM_SetLastErrorInfo(result, "StopStream: GECT says not active, but streamActive = %d", stream->streamActive);
        }
    }
    else
    {
        if (stream->threadResult != paNoError)
        {
            PA_DEBUG(("StopStream: Stream not active (%d)\n", stream->threadResult));
            result = stream->threadResult;
            stream->threadResult = paNoError;
        }
    }

    if (stream->streamThread != NULL)
    {
        CloseHandle(stream->streamThread);
        stream->streamThread = 0;
    }
    stream->streamStarted = 0;
    stream->streamActive = 0;

    if(doCb)
    {
        /* Do user callback now after all state has been reset */
        /* This means it should be safe for the called function */
        /* to invoke e.g. StartStream */
        if( stream->streamRepresentation.streamFinishedCallback != 0 )
            stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
    }

    PA_LOGL_;
    return result;
}

static PaError AbortStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinWdmStream *stream = (PaWinWdmStream*)s;
    int doCb = 0;

    PA_LOGE_;

    if(stream->streamActive)
    {
        doCb = 1;
        stream->streamAbort = 1;
        SetEvent(stream->eventAbort); /* Signal immediately */
        if (WaitForSingleObject(stream->streamThread, 10000) != WAIT_OBJECT_0)
        {
            TerminateThread(stream->streamThread, -1);
            result = paTimedOut;

            PA_DEBUG(("AbortStream: stream thread terminated\n"));
        }
        assert(!stream->streamActive);
    }
    CloseHandle(stream->streamThread);
    stream->streamThread = NULL;
    stream->streamStarted = 0;

    if(doCb)
    {
        /* Do user callback now after all state has been reset */
        /* This means it should be safe for the called function */
        /* to invoke e.g. StartStream */
        if( stream->streamRepresentation.streamFinishedCallback != 0 )
            stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );
    }

    stream->streamActive = 0;
    stream->streamStarted = 0;

    PA_LOGL_;
    return result;
}


static PaError IsStreamStopped( PaStream *s )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;
    int result = 0;

    PA_LOGE_;

    if(!stream->streamStarted)
        result = 1;

    PA_LOGL_;
    return result;
}


static PaError IsStreamActive( PaStream *s )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;
    int result = 0;

    PA_LOGE_;

    if(stream->streamActive)
        result = 1;

    PA_LOGL_;
    return result;
}


static PaTime GetStreamTime( PaStream* s )
{
    PA_LOGE_;
    PA_LOGL_;
    (void)s;
    return PaUtil_GetTime();
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;
    double result;
    PA_LOGE_;
    result = PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
    PA_LOGL_;
    return result;
}


/*
As separate stream interfaces are used for blocking and callback
streams, the following functions can be guaranteed to only be called
for blocking streams.
*/

static PaError ReadStream( PaStream* s,
                          void *buffer,
                          unsigned long frames )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;

    /* suppress unused variable warnings */
    (void) buffer;
    (void) frames;
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/
    PA_LOGL_;
    return paInternalError;
}


static PaError WriteStream( PaStream* s,
                           const void *buffer,
                           unsigned long frames )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;

    /* suppress unused variable warnings */
    (void) buffer;
    (void) frames;
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/
    PA_LOGL_;
    return paInternalError;
}


static signed long GetStreamReadAvailable( PaStream* s )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;

    /* suppress unused variable warnings */
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/
    PA_LOGL_;
    return 0;
}


static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaWinWdmStream *stream = (PaWinWdmStream*)s;

    PA_LOGE_;
    /* suppress unused variable warnings */
    (void) stream;

    /* IMPLEMENT ME, see portaudio.h for required behavior*/
    PA_LOGL_;
    return 0;
}

/***************************************************************************************/
/* Event and submit handlers for WaveCyclic                                            */
/***************************************************************************************/

static PaError PaPinCaptureEventHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    PaError result = paNoError;
    ring_buffer_size_t frameCount;
    DATAPACKET* packet = pInfo->stream->capture.packets + eventIndex;

    assert( eventIndex < pInfo->stream->capture.noOfPackets );

    if (packet->Header.DataUsed == 0)
    {
        PA_HP_TRACE((pInfo->stream->hLog, ">>> Capture bogus event (no data): idx=%u", eventIndex));

        /* Bogus event, reset! This is to handle the behavior of this USB mic: http://shop.xtz.se/measurement-system/microphone-to-dirac-live-room-correction-suite 
           on startup of streaming, where it erroneously sets the event without the corresponding buffer being filled (DataUsed == 0) */
        ResetEvent(packet->Signal.hEvent);

        result = -1;    /* Only need this to be NOT paNoError */
    }
    else
    {
        pInfo->capturePackets[pInfo->captureHead & cPacketsArrayMask].packet = packet;

        frameCount = PaUtil_WriteRingBuffer(&pInfo->stream->ringBuffer, packet->Header.Data, pInfo->stream->capture.framesPerBuffer);

        PA_HP_TRACE((pInfo->stream->hLog, ">>> Capture event: idx=%u (frames=%u)", eventIndex, frameCount));
        ++pInfo->captureHead;
    }

    --pInfo->pending; /* This needs to be done in either case */
    return result;
}

static PaError PaPinCaptureSubmitHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    PaError result = paNoError;
    DATAPACKET* packet = pInfo->capturePackets[pInfo->captureTail & cPacketsArrayMask].packet;
    pInfo->capturePackets[pInfo->captureTail & cPacketsArrayMask].packet = 0;
    assert(packet != 0);
    PA_HP_TRACE((pInfo->stream->hLog, "Capture submit: %u", eventIndex));
    packet->Header.DataUsed = 0; /* Reset for reuse */
    ResetEvent(packet->Signal.hEvent);
    result = PinRead(pInfo->stream->capture.pPin->handle, packet);
    ++pInfo->pending;
    return result;
}

static PaError PaPinRenderEventHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    assert( eventIndex < pInfo->stream->render.noOfPackets );

    pInfo->renderPackets[pInfo->renderHead & cPacketsArrayMask].packet = pInfo->stream->render.packets + eventIndex;
    PA_HP_TRACE((pInfo->stream->hLog, "<<< Render event : idx=%u head=%u", eventIndex, pInfo->renderHead));
    ++pInfo->renderHead;
    --pInfo->pending;
    return paNoError;
}

static PaError PaPinRenderSubmitHandler_WaveCyclic(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    PaError result = paNoError;
    DATAPACKET* packet = pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet;
    pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet = 0;
    assert(packet != 0);

    PA_HP_TRACE((pInfo->stream->hLog, "Render submit : %u idx=%u", pInfo->renderTail, (unsigned)(packet - pInfo->stream->render.packets)));
    ResetEvent(packet->Signal.hEvent);
    result = PinWrite(pInfo->stream->render.pPin->handle, packet);
    /* Reset event, just in case we have an analogous situation to capture (see PaPinCaptureSubmitHandler_WaveCyclic) */
    ++pInfo->pending;
    if (pInfo->priming)
    {
        --pInfo->priming;
    }
    return result;
}

/***************************************************************************************/
/* Event and submit handlers for WaveRT                                                */
/***************************************************************************************/

static PaError PaPinCaptureEventHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    unsigned long pos;
    unsigned realInBuf;
    unsigned frameCount;
    PaWinWdmIOInfo* pCapture = &pInfo->stream->capture;
    const unsigned halfInputBuffer = pCapture->hostBufferSize >> 1;
    PaWinWdmPin* pin = pCapture->pPin;
    DATAPACKET* packet = 0;

    /* Get hold of current ADC position */
    pin->fnAudioPosition(pin, &pos);
    /* Wrap it (robi: why not use hw latency compensation here ?? because pos then gets _way_ off from
    where it should be, i.e. at beginning or half buffer position. Why? No idea.)  */

    pos %= pCapture->hostBufferSize;
    /* Then realInBuf will point to "other" half of double buffer */
    realInBuf = pos < halfInputBuffer ? 1U : 0U;

    packet = pInfo->stream->capture.packets + realInBuf;

    /* Call barrier (or dummy) */
    pin->fnMemBarrier();

    /* Put it in queue */
    frameCount = PaUtil_WriteRingBuffer(&pInfo->stream->ringBuffer, packet->Header.Data, pCapture->framesPerBuffer);

    pInfo->capturePackets[pInfo->captureHead & cPacketsArrayMask].packet = packet;

    PA_HP_TRACE((pInfo->stream->hLog, "Capture event (WaveRT): idx=%u head=%u (pos = %4.1lf%%, frames=%u)", realInBuf, pInfo->captureHead, (pos * 100.0 / pCapture->hostBufferSize), frameCount));

    ++pInfo->captureHead;
    --pInfo->pending;

    return paNoError;
}

static PaError PaPinCaptureEventHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    unsigned long pos;
    unsigned bytesToRead;
    PaWinWdmIOInfo* pCapture = &pInfo->stream->capture;
    const unsigned halfInputBuffer = pCapture->hostBufferSize>>1;
    PaWinWdmPin* pin = pInfo->stream->capture.pPin;

    /* Get hold of current ADC position */
    pin->fnAudioPosition(pin, &pos);
    /* Wrap it (robi: why not use hw latency compensation here ?? because pos then gets _way_ off from
    where it should be, i.e. at beginning or half buffer position. Why? No idea.)  */
    /* Compensate for HW FIFO to get to last read buffer position */
    pos += pin->hwLatency;
    pos %= pCapture->hostBufferSize;
    /* Need to align position on frame boundary */
    pos &= ~(pCapture->bytesPerFrame - 1);

    /* Call barrier (or dummy) */
    pin->fnMemBarrier();

    /* Put it in "queue" */
    bytesToRead = (pCapture->hostBufferSize + pos - pCapture->lastPosition) % pCapture->hostBufferSize;
    if (bytesToRead > 0)
    {
        unsigned frameCount = PaUtil_WriteRingBuffer(&pInfo->stream->ringBuffer,
            pCapture->hostBuffer + pCapture->lastPosition,
            bytesToRead / pCapture->bytesPerFrame);

        pCapture->lastPosition = (pCapture->lastPosition + frameCount * pCapture->bytesPerFrame) % pCapture->hostBufferSize;

        PA_HP_TRACE((pInfo->stream->hLog, "Capture event (WaveRTPolled): pos = %4.1lf%%, framesRead=%u", (pos * 100.0 / pCapture->hostBufferSize), frameCount));
        ++pInfo->captureHead;
        --pInfo->pending;
    }
    return paNoError;
}

static PaError PaPinCaptureSubmitHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    pInfo->capturePackets[pInfo->captureTail & cPacketsArrayMask].packet = 0;
    ++pInfo->pending;
    return paNoError;
}

static PaError PaPinCaptureSubmitHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    pInfo->capturePackets[pInfo->captureTail & cPacketsArrayMask].packet = 0;
    ++pInfo->pending;
    return paNoError;
}

static PaError PaPinRenderEventHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    unsigned long pos;
    unsigned realOutBuf;
    PaWinWdmIOInfo* pRender = &pInfo->stream->render;
    const unsigned halfOutputBuffer = pRender->hostBufferSize >> 1;
    PaWinWdmPin* pin = pInfo->stream->render.pPin;
    PaIOPacket* ioPacket = &pInfo->renderPackets[pInfo->renderHead & cPacketsArrayMask];

    /* Get hold of current DAC position */
    pin->fnAudioPosition(pin, &pos);
    /* Compensate for HW FIFO to get to last read buffer position */
    pos += pin->hwLatency;
    /* Wrap it */
    pos %= pRender->hostBufferSize;
    /* And align it, not sure its really needed though */
    pos &= ~(pRender->bytesPerFrame - 1);
    /* Then realOutBuf will point to "other" half of double buffer */
    realOutBuf = pos < halfOutputBuffer ? 1U : 0U;

    if (pInfo->priming)
    {
        realOutBuf = pInfo->renderHead & 0x1;
    }
    ioPacket->packet = pInfo->stream->render.packets + realOutBuf;
    ioPacket->startByte = realOutBuf * halfOutputBuffer;
    ioPacket->lengthBytes = halfOutputBuffer;

    PA_HP_TRACE((pInfo->stream->hLog, "Render event (WaveRT) : idx=%u head=%u (pos = %4.1lf%%)", realOutBuf, pInfo->renderHead, (pos * 100.0 / pRender->hostBufferSize) ));

    ++pInfo->renderHead;
    --pInfo->pending;
    return paNoError;
}

static PaError PaPinRenderEventHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    unsigned long pos;
    unsigned realOutBuf;
    unsigned bytesToWrite;

    PaWinWdmIOInfo* pRender = &pInfo->stream->render;
    const unsigned halfOutputBuffer = pRender->hostBufferSize >> 1;
    PaWinWdmPin* pin = pInfo->stream->render.pPin;
    PaIOPacket* ioPacket = &pInfo->renderPackets[pInfo->renderHead & cPacketsArrayMask];

    /* Get hold of current DAC position */
    pin->fnAudioPosition(pin, &pos);
    /* Compensate for HW FIFO to get to last read buffer position */
    pos += pin->hwLatency;
    /* Wrap it */
    pos %= pRender->hostBufferSize;
    /* And align it, not sure its really needed though */
    pos &= ~(pRender->bytesPerFrame - 1);

    if (pInfo->priming)
    {
        realOutBuf = pInfo->renderHead & 0x1;
        ioPacket->packet = pInfo->stream->render.packets + realOutBuf;
        ioPacket->startByte = realOutBuf * halfOutputBuffer;
        ioPacket->lengthBytes = halfOutputBuffer;
        ++pInfo->renderHead;
        --pInfo->pending;
    }
    else
    {
        bytesToWrite = (pRender->hostBufferSize + pos - pRender->lastPosition) % pRender->hostBufferSize;
        ++pRender->pollCntr;
        if (bytesToWrite >= halfOutputBuffer)
        {
            realOutBuf = (pos < halfOutputBuffer) ? 1U : 0U;
            ioPacket->packet = pInfo->stream->render.packets + realOutBuf;
            pRender->lastPosition = realOutBuf ? 0U : halfOutputBuffer;
            ioPacket->startByte = realOutBuf * halfOutputBuffer;
            ioPacket->lengthBytes = halfOutputBuffer;
            ++pInfo->renderHead;
            --pInfo->pending;
            PA_HP_TRACE((pInfo->stream->hLog, "Render event (WaveRTPolled) : idx=%u head=%u (pos = %4.1lf%%, cnt=%u)", realOutBuf, pInfo->renderHead, (pos * 100.0 / pRender->hostBufferSize), pRender->pollCntr));
            pRender->pollCntr = 0;
        }
    }
    return paNoError;
}

static PaError PaPinRenderSubmitHandler_WaveRTEvent(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    PaWinWdmPin* pin = pInfo->stream->render.pPin;
    pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet = 0;
    /* Call barrier (if needed) */
    pin->fnMemBarrier();
    PA_HP_TRACE((pInfo->stream->hLog, "Render submit (WaveRT) : submit=%u", pInfo->renderTail));
    ++pInfo->pending;
    if (pInfo->priming)
    {
        --pInfo->priming;
        if (pInfo->priming)
        {
            PA_HP_TRACE((pInfo->stream->hLog, "Setting WaveRT event for priming (2)"));
            SetEvent(pInfo->stream->render.events[0]);
        }
    }
    return paNoError;
}

static PaError PaPinRenderSubmitHandler_WaveRTPolled(PaProcessThreadInfo* pInfo, unsigned eventIndex)
{
    PaWinWdmPin* pin = pInfo->stream->render.pPin;
    pInfo->renderPackets[pInfo->renderTail & cPacketsArrayMask].packet = 0;
    /* Call barrier (if needed) */
    pin->fnMemBarrier();
    PA_HP_TRACE((pInfo->stream->hLog, "Render submit (WaveRTPolled) : submit=%u", pInfo->renderTail));
    ++pInfo->pending;
    if (pInfo->priming)
    {
        --pInfo->priming;
        if (pInfo->priming)
        {
            PA_HP_TRACE((pInfo->stream->hLog, "Setting WaveRT event for priming (2)"));
            SetEvent(pInfo->stream->render.events[0]);
        }
    }
    return paNoError;
} 
#endif

#if PA_USE_WMME
/*
 * $Id$
 * pa_win_wmme.c
 * Implementation of PortAudio for Windows MultiMedia Extensions (WMME)       
 *                                                                                         
 * PortAudio Portable Real-Time Audio Library
 * Latest Version at: http://www.portaudio.com
 *
 * Authors: Ross Bencina and Phil Burk
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

/* Modification History:
 PLB = Phil Burk
 JM = Julien Maillard
 RDB = Ross Bencina
 PLB20010402 - sDevicePtrs now allocates based on sizeof(pointer)
 PLB20010413 - check for excessive numbers of channels
 PLB20010422 - apply Mike Berry's changes for CodeWarrior on PC
               including conditional inclusion of memory.h,
               and explicit typecasting on memory allocation
 PLB20010802 - use GlobalAlloc for sDevicesPtr instead of PaHost_AllocFastMemory
 PLB20010816 - pass process instead of thread to SetPriorityClass()
 PLB20010927 - use number of frames instead of real-time for CPULoad calculation.
 JM20020118 - prevent hung thread when buffers underflow.
 PLB20020321 - detect Win XP versus NT, 9x; fix DBUG typo; removed init of CurrentCount
 RDB20020411 - various renaming cleanups, factored streamData alloc and cpu usage init
 RDB20020417 - stopped counting WAVE_MAPPER when there were no real devices
               refactoring, renaming and fixed a few edge case bugs
 RDB20020531 - converted to V19 framework
 ** NOTE  maintanance history is now stored in CVS **
*/

/** @file
    @ingroup hostapi_src

    @brief Win32 host API implementation for the Windows MultiMedia Extensions (WMME) audio API.
*/

/*
    How it works:

    For both callback and blocking read/write streams we open the MME devices
    in CALLBACK_EVENT mode. In this mode, MME signals an Event object whenever
    it has finished with a buffer (either filled it for input, or played it
    for output). Where necessary, we block waiting for Event objects using
    WaitMultipleObjects().

    When implementing a PA callback stream, we set up a high priority thread
    which waits on the MME buffer Events and drains/fills the buffers when
    they are ready.

    When implementing a PA blocking read/write stream, we simply wait on these
    Events (when necessary) inside the ReadStream() and WriteStream() functions.
*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include <windows.h>
#include <mmsystem.h>
#ifndef UNDER_CE
#include <process.h>
#endif
#include <assert.h>
/* PLB20010422 - "memory.h" doesn't work on CodeWarrior for PC. Thanks Mike Berry for the mod. */
#ifndef __MWERKS__
#include <malloc.h>
#include <memory.h>
#endif /* __MWERKS__ */

// (amalg) #include "portaudio.h"
// (amalg) #include "pa_trace.h"
// (amalg) #include "pa_util.h"
// (amalg) #include "pa_allocation.h"
// (amalg) #include "pa_hostapi.h"
// (amalg) #include "pa_stream.h"
// (amalg) #include "pa_cpuload.h"
// (amalg) #include "pa_process.h"
// (amalg) #include "pa_debugprint.h"

// (amalg) #include "pa_win_wmme.h"
// (amalg) #include "pa_win_waveformat.h"

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
// (amalg) #include "pa_win_wdmks_utils.h"
#ifndef DRV_QUERYDEVICEINTERFACE
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#endif
#ifndef DRV_QUERYDEVICEINTERFACESIZE
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#endif
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

/* use CreateThread for CYGWIN, _beginthreadex for all others */
#if !defined(__CYGWIN__) && !defined(_WIN32_WCE)
#define CREATE_THREAD (HANDLE)_beginthreadex( 0, 0, ProcessingThreadProc, stream, 0, &stream->processingThreadId )
#define PA_THREAD_FUNC static unsigned WINAPI
#define PA_THREAD_ID unsigned
#else
#define CREATE_THREAD CreateThread( 0, 0, ProcessingThreadProc, stream, 0, &stream->processingThreadId )
#define PA_THREAD_FUNC static DWORD WINAPI
#define PA_THREAD_ID DWORD
#endif
#if (defined(_WIN32_WCE))
#pragma comment(lib, "Coredll.lib")
#elif (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
#pragma comment(lib, "winmm.lib")
#endif

/*
 provided in newer platform sdks
 */
#ifndef DWORD_PTR
    #if defined(_WIN64)
        #define DWORD_PTR unsigned __int64
    #else
        #define DWORD_PTR unsigned long
    #endif
#endif

/************************************************* Constants ********/

#define PA_MME_USE_HIGH_DEFAULT_LATENCY_    (0)  /* For debugging glitches. */

#if PA_MME_USE_HIGH_DEFAULT_LATENCY_
 #define PA_MME_WIN_9X_DEFAULT_LATENCY_                             (0.4)
 #define PA_MME_MIN_HOST_OUTPUT_BUFFER_COUNT_                       (4)
 #define PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_FULL_DUPLEX_	        (4)
 #define PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_HALF_DUPLEX_	        (4)
 #define PA_MME_HOST_BUFFER_GRANULARITY_FRAMES_WHEN_UNSPECIFIED_	(16)
 #define PA_MME_MAX_HOST_BUFFER_SECS_				                (0.3)       /* Do not exceed unless user buffer exceeds */
 #define PA_MME_MAX_HOST_BUFFER_BYTES_				                (32 * 1024) /* Has precedence over PA_MME_MAX_HOST_BUFFER_SECS_, some drivers are known to crash with buffer sizes > 32k */
#else
 #define PA_MME_WIN_9X_DEFAULT_LATENCY_                             (0.2)
 #define PA_MME_MIN_HOST_OUTPUT_BUFFER_COUNT_                       (2)
 #define PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_FULL_DUPLEX_	        (3)         /* always use at least 3 input buffers for full duplex */
 #define PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_HALF_DUPLEX_	        (2)
 #define PA_MME_HOST_BUFFER_GRANULARITY_FRAMES_WHEN_UNSPECIFIED_	(16)
 #define PA_MME_MAX_HOST_BUFFER_SECS_				                (0.1)       /* Do not exceed unless user buffer exceeds */
 #define PA_MME_MAX_HOST_BUFFER_BYTES_				                (32 * 1024) /* Has precedence over PA_MME_MAX_HOST_BUFFER_SECS_, some drivers are known to crash with buffer sizes > 32k */
#endif

/* Use higher latency for NT because it is even worse at real-time
   operation than Win9x.
*/
#define PA_MME_WIN_NT_DEFAULT_LATENCY_                              (0.4)

/* Default low latency for WDM based systems. This is based on a rough
   survey of workable latency settings using patest_wmme_find_best_latency_params.c.
   See pdf attached to ticket 185 for a graph of the survey results:
   http://www.portaudio.com/trac/ticket/185
   
   Workable latencies varied between 40ms and ~80ms on different systems (different
   combinations of hardware, 32 and 64 bit, WinXP, Vista and Win7. We didn't
   get enough Vista results to know if Vista has systemically worse latency.
   For now we choose a safe value across all Windows versions here.
*/
#define PA_MME_WIN_WDM_DEFAULT_LATENCY_                             (0.090)


/* When client suggestedLatency could result in many host buffers, we aim to have around 8, 
   based off Windows documentation that suggests that the kmixer uses 8 buffers. This choice
   is somewhat arbitrary here, since we havn't observed significant stability degredation 
   with using either more, or less buffers.     
*/
#define PA_MME_TARGET_HOST_BUFFER_COUNT_    8

#define PA_MME_MIN_TIMEOUT_MSEC_        (1000)

static const char constInputMapperSuffix_[] = " - Input";
static const char constOutputMapperSuffix_[] = " - Output";

/********************************************************************/

/* Copy null-terminated TCHAR string to explicit char string using UTF8 encoding */
static char *CopyTCharStringToUtf8CString(char *destination, size_t destLengthBytes, const TCHAR *source)
{
#if !defined(_UNICODE) && !defined(UNICODE)
    return strcpy(destination, source);
#else
    /* The cbMultiByte parameter ["destLengthBytes" below] is:
    """
    Size, in bytes, of the buffer indicated by lpMultiByteStr ["destination" below]. 
    If this parameter is set to 0, the function returns the required buffer 
    size for lpMultiByteStr and makes no use of the output parameter itself.
    """
    Source: WideCharToMultiByte at MSDN:
    http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130(v=vs.85).aspx
    */
    int intDestLengthBytes; /* cbMultiByte */
    /* intDestLengthBytes is an int, destLengthBytes is a size_t. Ensure that we don't overflow
    intDestLengthBytes by only using at most INT_MAX bytes of destination buffer.
    */
    if (destLengthBytes < INT_MAX)
    {
#pragma warning (disable : 4267) /* "conversion from 'size_t' to 'int', possible loss of data" */
        intDestLengthBytes = (int)destLengthBytes; /* destLengthBytes is guaranteed < INT_MAX here */
#pragma warning (default : 4267)
    }
    else
    {
        intDestLengthBytes = INT_MAX;
    }
    
    if (WideCharToMultiByte(CP_UTF8, 0, source, -1, destination, /*cbMultiByte=*/intDestLengthBytes, NULL, NULL) == 0)
        return NULL;
    return destination;
#endif
}

/* returns required length (in bytes) of destination buffer when 
   converting TCHAR string to UTF8 bytes, not including the terminating null. */
static size_t TCharStringLen(const TCHAR *str)
{
#if !defined(_UNICODE) && !defined(UNICODE)
    return strlen(str);
#else
    return WideCharToMultiByte(CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL);	
#endif
}

/********************************************************************/

typedef struct PaWinMmeStream PaWinMmeStream;     /* forward declaration */

/* prototypes for functions declared in this file */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

PaError PaWinMme_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );

#ifdef __cplusplus
}
#endif /* __cplusplus */

static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** stream,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData );
static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate );
static PaError CloseStream( PaStream* stream );
static PaError StartStream( PaStream *stream );
static PaError StopStream( PaStream *stream );
static PaError AbortStream( PaStream *stream );
static PaError IsStreamStopped( PaStream *s );
static PaError IsStreamActive( PaStream *stream );
static PaTime GetStreamTime( PaStream *stream );
static double GetStreamCpuLoad( PaStream* stream );
static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
static signed long GetStreamReadAvailable( PaStream* stream );
static signed long GetStreamWriteAvailable( PaStream* stream );


/* macros for setting last host error information */

#ifdef UNICODE

#define PA_MME_SET_LAST_WAVEIN_ERROR( mmresult ) \
    {                                                                   \
        wchar_t mmeErrorTextWide[ MAXERRORLENGTH ];                     \
        char mmeErrorText[ MAXERRORLENGTH ];                            \
        waveInGetErrorText( mmresult, mmeErrorTextWide, MAXERRORLENGTH );   \
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK | WC_DEFAULTCHAR,\
            mmeErrorTextWide, -1, mmeErrorText, MAXERRORLENGTH, NULL, NULL );  \
        PaUtil_SetLastHostErrorInfo( paMME, mmresult, mmeErrorText );   \
    }

#define PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult ) \
    {                                                                   \
        wchar_t mmeErrorTextWide[ MAXERRORLENGTH ];                     \
        char mmeErrorText[ MAXERRORLENGTH ];                            \
        waveOutGetErrorText( mmresult, mmeErrorTextWide, MAXERRORLENGTH );  \
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK | WC_DEFAULTCHAR,\
            mmeErrorTextWide, -1, mmeErrorText, MAXERRORLENGTH, NULL, NULL );  \
        PaUtil_SetLastHostErrorInfo( paMME, mmresult, mmeErrorText );   \
    }
    
#else /* !UNICODE */

#define PA_MME_SET_LAST_WAVEIN_ERROR( mmresult ) \
    {                                                                   \
        char mmeErrorText[ MAXERRORLENGTH ];                            \
        waveInGetErrorText( mmresult, mmeErrorText, MAXERRORLENGTH );   \
        PaUtil_SetLastHostErrorInfo( paMME, mmresult, mmeErrorText );   \
    }

#define PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult ) \
    {                                                                   \
        char mmeErrorText[ MAXERRORLENGTH ];                            \
        waveOutGetErrorText( mmresult, mmeErrorText, MAXERRORLENGTH );  \
        PaUtil_SetLastHostErrorInfo( paMME, mmresult, mmeErrorText );   \
    }

#endif /* UNICODE */


static void PaMme_SetLastSystemError( DWORD errorCode )
{
    char *lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
    );
    PaUtil_SetLastHostErrorInfo( paMME, errorCode, lpMsgBuf );
    LocalFree( lpMsgBuf );
}

#define PA_MME_SET_LAST_SYSTEM_ERROR( errorCode ) \
    PaMme_SetLastSystemError( errorCode )


/* PaError returning wrappers for some commonly used win32 functions
    note that we allow passing a null ptr to have no effect.
*/

static PaError CreateEventWithPaError( HANDLE *handle,
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        BOOL bManualReset,
        BOOL bInitialState,
        LPCTSTR lpName )
{
    PaError result = paNoError;

    *handle = NULL;
    
    *handle = CreateEvent( lpEventAttributes, bManualReset, bInitialState, lpName );
    if( *handle == NULL )
    {
        result = paUnanticipatedHostError;
        PA_MME_SET_LAST_SYSTEM_ERROR( GetLastError() );
    }

    return result;
}


static PaError ResetEventWithPaError( HANDLE handle )
{
    PaError result = paNoError;

    if( handle )
    {
        if( ResetEvent( handle ) == 0 )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_SYSTEM_ERROR( GetLastError() );
        }
    }

    return result;
}


static PaError CloseHandleWithPaError( HANDLE handle )
{
    PaError result = paNoError;
    
    if( handle )
    {
        if( CloseHandle( handle ) == 0 )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_SYSTEM_ERROR( GetLastError() );
        }
    }
    
    return result;
}


/* PaWinMmeHostApiRepresentation - host api datastructure specific to this implementation */

typedef struct
{
    PaUtilHostApiRepresentation inheritedHostApiRep;
    PaUtilStreamInterface callbackStreamInterface;
    PaUtilStreamInterface blockingStreamInterface;

    PaUtilAllocationGroup *allocations;
    
    int inputDeviceCount, outputDeviceCount;

    /** winMmeDeviceIds is an array of WinMme device ids.
        fields in the range [0, inputDeviceCount) are input device ids,
        and [inputDeviceCount, inputDeviceCount + outputDeviceCount) are output
        device ids.
     */ 
    UINT *winMmeDeviceIds;
}
PaWinMmeHostApiRepresentation;


typedef struct
{
    PaDeviceInfo inheritedDeviceInfo;
    DWORD dwFormats; /**<< standard formats bitmask from the WAVEINCAPS and WAVEOUTCAPS structures */
    char deviceInputChannelCountIsKnown; /**<< if the system returns 0xFFFF then we don't really know the number of supported channels (1=>known, 0=>unknown)*/
    char deviceOutputChannelCountIsKnown; /**<< if the system returns 0xFFFF then we don't really know the number of supported channels (1=>known, 0=>unknown)*/
}
PaWinMmeDeviceInfo;


/*************************************************************************
 * Returns recommended device ID.
 * On the PC, the recommended device can be specified by the user by
 * setting an environment variable. For example, to use device #1.
 *
 *    set PA_RECOMMENDED_OUTPUT_DEVICE=1
 *
 * The user should first determine the available device ID by using
 * the supplied application "pa_devs".
 */
#define PA_ENV_BUF_SIZE_  (32)
#define PA_REC_IN_DEV_ENV_NAME_  ("PA_RECOMMENDED_INPUT_DEVICE")
#define PA_REC_OUT_DEV_ENV_NAME_  ("PA_RECOMMENDED_OUTPUT_DEVICE")
static PaDeviceIndex GetEnvDefaultDeviceID( char *envName )
{
    PaDeviceIndex recommendedIndex = paNoDevice;
    DWORD   hresult;
    char    envbuf[PA_ENV_BUF_SIZE_];

#ifndef WIN32_PLATFORM_PSPC /* no GetEnvironmentVariable on PocketPC */

    /* Let user determine default device by setting environment variable. */
    hresult = GetEnvironmentVariableA( envName, envbuf, PA_ENV_BUF_SIZE_ );
    if( (hresult > 0) && (hresult < PA_ENV_BUF_SIZE_) )
    {
        recommendedIndex = atoi( envbuf );
    }
#endif

    return recommendedIndex;
}


static void InitializeDefaultDeviceIdsFromEnv( PaWinMmeHostApiRepresentation *hostApi )
{
    PaDeviceIndex device;

    /* input */
    device = GetEnvDefaultDeviceID( PA_REC_IN_DEV_ENV_NAME_ );
    if( device != paNoDevice &&
            ( device >= 0 && device < hostApi->inheritedHostApiRep.info.deviceCount ) &&
            hostApi->inheritedHostApiRep.deviceInfos[ device ]->maxInputChannels > 0 )
    {
        hostApi->inheritedHostApiRep.info.defaultInputDevice = device;
    }

    /* output */
    device = GetEnvDefaultDeviceID( PA_REC_OUT_DEV_ENV_NAME_ );
    if( device != paNoDevice &&
            ( device >= 0 && device < hostApi->inheritedHostApiRep.info.deviceCount ) &&
            hostApi->inheritedHostApiRep.deviceInfos[ device ]->maxOutputChannels > 0 )
    {
        hostApi->inheritedHostApiRep.info.defaultOutputDevice = device;
    }
}


/** Convert external PA ID to a windows multimedia device ID
*/
static UINT LocalDeviceIndexToWinMmeDeviceId( PaWinMmeHostApiRepresentation *hostApi, PaDeviceIndex device )
{
    assert( device >= 0 && device < hostApi->inputDeviceCount + hostApi->outputDeviceCount );

    return hostApi->winMmeDeviceIds[ device ];
}


static int SampleFormatAndWinWmmeSpecificFlagsToLinearWaveFormatTag( PaSampleFormat sampleFormat, unsigned long winMmeSpecificFlags )
{
    int waveFormatTag = 0;

    if( winMmeSpecificFlags & paWinMmeWaveFormatDolbyAc3Spdif )
        waveFormatTag = PAWIN_WAVE_FORMAT_DOLBY_AC3_SPDIF;
    else if( winMmeSpecificFlags & paWinMmeWaveFormatWmaSpdif )
        waveFormatTag = PAWIN_WAVE_FORMAT_WMA_SPDIF;
    else
        waveFormatTag = PaWin_SampleFormatToLinearWaveFormatTag( sampleFormat );

    return waveFormatTag;
}


static PaError QueryInputWaveFormatEx( int deviceId, WAVEFORMATEX *waveFormatEx )
{
    MMRESULT mmresult;
    
    switch( mmresult = waveInOpen( NULL, deviceId, waveFormatEx, 0, 0, WAVE_FORMAT_QUERY ) )
    {
        case MMSYSERR_NOERROR:
            return paNoError;
        case MMSYSERR_ALLOCATED:    /* Specified resource is already allocated. */
            return paDeviceUnavailable;
        case MMSYSERR_NODRIVER:	    /* No device driver is present. */
            return paDeviceUnavailable;
        case MMSYSERR_NOMEM:	    /* Unable to allocate or lock memory. */
            return paInsufficientMemory;
        case WAVERR_BADFORMAT:      /* Attempted to open with an unsupported waveform-audio format. */
            return paSampleFormatNotSupported;
                    
        case MMSYSERR_BADDEVICEID:	/* Specified device identifier is out of range. */
            /* falls through */
        default:
            PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
            return paUnanticipatedHostError;
    }
}


static PaError QueryOutputWaveFormatEx( int deviceId, WAVEFORMATEX *waveFormatEx )
{
    MMRESULT mmresult;
    
    switch( mmresult = waveOutOpen( NULL, deviceId, waveFormatEx, 0, 0, WAVE_FORMAT_QUERY ) )
    {
        case MMSYSERR_NOERROR:
            return paNoError;
        case MMSYSERR_ALLOCATED:    /* Specified resource is already allocated. */
            return paDeviceUnavailable;
        case MMSYSERR_NODRIVER:	    /* No device driver is present. */
            return paDeviceUnavailable;
        case MMSYSERR_NOMEM:	    /* Unable to allocate or lock memory. */
            return paInsufficientMemory;
        case WAVERR_BADFORMAT:      /* Attempted to open with an unsupported waveform-audio format. */
            return paSampleFormatNotSupported;
                    
        case MMSYSERR_BADDEVICEID:	/* Specified device identifier is out of range. */
            /* falls through */
        default:
            PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
            return paUnanticipatedHostError;
    }
}


static PaError QueryFormatSupported( PaDeviceInfo *deviceInfo,
        PaError (*waveFormatExQueryFunction)(int, WAVEFORMATEX*),
        int winMmeDeviceId, int channels, double sampleRate, unsigned long winMmeSpecificFlags )
{
    PaWinMmeDeviceInfo *winMmeDeviceInfo = (PaWinMmeDeviceInfo*)deviceInfo;
    PaWinWaveFormat waveFormat;
    PaSampleFormat sampleFormat;
    int waveFormatTag;
    
    /* @todo at the moment we only query with 16 bit sample format and directout speaker config*/

    sampleFormat = paInt16;
    waveFormatTag = SampleFormatAndWinWmmeSpecificFlagsToLinearWaveFormatTag( sampleFormat, winMmeSpecificFlags );

    if( waveFormatTag == PaWin_SampleFormatToLinearWaveFormatTag( paInt16 ) ){
    
        /* attempt bypass querying the device for linear formats */

        if( sampleRate == 11025.0
            && ( (channels == 1 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_1M16))
                || (channels == 2 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_1S16)) ) ){

            return paNoError;
        }

        if( sampleRate == 22050.0
            && ( (channels == 1 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_2M16))
                || (channels == 2 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_2S16)) ) ){

            return paNoError;
        }

        if( sampleRate == 44100.0
            && ( (channels == 1 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_4M16))
                || (channels == 2 && (winMmeDeviceInfo->dwFormats & WAVE_FORMAT_4S16)) ) ){

            return paNoError;
        }
    }


    /* first, attempt to query the device using WAVEFORMATEXTENSIBLE, 
       if this fails we fall back to WAVEFORMATEX */

    PaWin_InitializeWaveFormatExtensible( &waveFormat, channels, sampleFormat, waveFormatTag,
            sampleRate, PAWIN_SPEAKER_DIRECTOUT );

    if( waveFormatExQueryFunction( winMmeDeviceId, (WAVEFORMATEX*)&waveFormat ) == paNoError )
        return paNoError;

    PaWin_InitializeWaveFormatEx( &waveFormat, channels, sampleFormat, waveFormatTag, sampleRate );

    return waveFormatExQueryFunction( winMmeDeviceId, (WAVEFORMATEX*)&waveFormat );
}


#define PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_  (13) /* must match array length below */
static double defaultSampleRateSearchOrder_[] =
    { 44100.0, 48000.0, 32000.0, 24000.0, 22050.0, 88200.0, 96000.0, 192000.0,
        16000.0, 12000.0, 11025.0, 9600.0, 8000.0 };

static void DetectDefaultSampleRate( PaWinMmeDeviceInfo *winMmeDeviceInfo, int winMmeDeviceId,
        PaError (*waveFormatExQueryFunction)(int, WAVEFORMATEX*), int maxChannels )
{
    PaDeviceInfo *deviceInfo = &winMmeDeviceInfo->inheritedDeviceInfo;
    int i;
    
    deviceInfo->defaultSampleRate = 0.;

    for( i=0; i < PA_DEFAULTSAMPLERATESEARCHORDER_COUNT_; ++i )
    {
        double sampleRate = defaultSampleRateSearchOrder_[ i ]; 
        PaError paerror = QueryFormatSupported( deviceInfo, waveFormatExQueryFunction, winMmeDeviceId, maxChannels, sampleRate, 0 );
        if( paerror == paNoError )
        {
            deviceInfo->defaultSampleRate = sampleRate;
            break;
        }
    }
}


#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
static int QueryWaveInKSFilterMaxChannels( int waveInDeviceId, int *maxChannels )
{
    void *devicePath;
    DWORD devicePathSize;
    int result = 0;

    if( waveInMessage((HWAVEIN)waveInDeviceId, DRV_QUERYDEVICEINTERFACESIZE,
            (DWORD_PTR)&devicePathSize, 0 ) != MMSYSERR_NOERROR )
        return 0;

    devicePath = PaUtil_AllocateMemory( devicePathSize );
    if( !devicePath )
        return 0;

    /* apparently DRV_QUERYDEVICEINTERFACE returns a unicode interface path, although this is undocumented */
    if( waveInMessage((HWAVEIN)waveInDeviceId, DRV_QUERYDEVICEINTERFACE,
            (DWORD_PTR)devicePath, devicePathSize ) == MMSYSERR_NOERROR )
    {
        int count = PaWin_WDMKS_QueryFilterMaximumChannelCount( devicePath, /* isInput= */ 1  );
        if( count > 0 )
        {
            *maxChannels = count;
            result = 1;
        }
    }

    PaUtil_FreeMemory( devicePath );

    return result;
}
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */


static PaError InitializeInputDeviceInfo( PaWinMmeHostApiRepresentation *winMmeHostApi,
        PaWinMmeDeviceInfo *winMmeDeviceInfo, UINT winMmeInputDeviceId, int *success )
{
    PaError result = paNoError;
    char *deviceName; /* non-const ptr */
    MMRESULT mmresult;
    WAVEINCAPS wic;
    PaDeviceInfo *deviceInfo = &winMmeDeviceInfo->inheritedDeviceInfo;
    size_t len;
    
    *success = 0;

    mmresult = waveInGetDevCaps( winMmeInputDeviceId, &wic, sizeof( WAVEINCAPS ) );
    if( mmresult == MMSYSERR_NOMEM )
    {
        result = paInsufficientMemory;
        goto error;
    }
    else if( mmresult != MMSYSERR_NOERROR )
    {
        /* instead of returning paUnanticipatedHostError we return
            paNoError, but leave success set as 0. This allows
            Pa_Initialize to just ignore this device, without failing
            the entire initialisation process.
        */
        return paNoError;
    }           

    /* NOTE: the WAVEOUTCAPS.szPname is a null-terminated array of 32 characters,
        so we are limited to displaying only the first 31 characters of the device name. */
    if( winMmeInputDeviceId == WAVE_MAPPER )
    {
        len = TCharStringLen( wic.szPname ) + 1 + sizeof(constInputMapperSuffix_);
        /* Append I/O suffix to WAVE_MAPPER device. */
        deviceName = (char*)PaUtil_GroupAllocateMemory(
                    winMmeHostApi->allocations,
                    (long)len );
        if( !deviceName )
        {
            result = paInsufficientMemory;
            goto error;
        }
        CopyTCharStringToUtf8CString( deviceName, len, wic.szPname );
        strcat( deviceName, constInputMapperSuffix_ );
    }
    else
    {
        len = TCharStringLen( wic.szPname ) + 1;
        deviceName = (char*)PaUtil_GroupAllocateMemory(
                    winMmeHostApi->allocations,
                    (long)len );
        if( !deviceName )
        {
            result = paInsufficientMemory;
            goto error;
        }
        CopyTCharStringToUtf8CString( deviceName, len, wic.szPname  );
    }
    deviceInfo->name = deviceName;

    if( wic.wChannels == 0xFFFF || wic.wChannels < 1 || wic.wChannels > 255 ){
        /* For Windows versions using WDM (possibly Windows 98 ME and later)
         * the kernel mixer sits between the application and the driver. As a result,
         * wave*GetDevCaps often kernel mixer channel counts, which are unlimited.
         * When this happens we assume the device is stereo and set a flag
         * so that other channel counts can be tried with OpenStream -- i.e. when
         * device*ChannelCountIsKnown is false, OpenStream will try whatever
         * channel count you supply.
         * see also InitializeOutputDeviceInfo() below.
     */

        PA_DEBUG(("Pa_GetDeviceInfo: Num input channels reported as %d! Changed to 2.\n", wic.wChannels ));
        deviceInfo->maxInputChannels = 2;
        winMmeDeviceInfo->deviceInputChannelCountIsKnown = 0;
    }else{
        deviceInfo->maxInputChannels = wic.wChannels;
        winMmeDeviceInfo->deviceInputChannelCountIsKnown = 1;
    }

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
    winMmeDeviceInfo->deviceInputChannelCountIsKnown = 
            QueryWaveInKSFilterMaxChannels( winMmeInputDeviceId, &deviceInfo->maxInputChannels );
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

    winMmeDeviceInfo->dwFormats = wic.dwFormats;

    DetectDefaultSampleRate( winMmeDeviceInfo, winMmeInputDeviceId,
            QueryInputWaveFormatEx, deviceInfo->maxInputChannels );

    *success = 1;
    
error:
    return result;
}


#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
static int QueryWaveOutKSFilterMaxChannels( int waveOutDeviceId, int *maxChannels )
{
    void *devicePath;
    DWORD devicePathSize;
    int result = 0;

    if( waveOutMessage((HWAVEOUT)waveOutDeviceId, DRV_QUERYDEVICEINTERFACESIZE,
            (DWORD_PTR)&devicePathSize, 0 ) != MMSYSERR_NOERROR )
        return 0;

    devicePath = PaUtil_AllocateMemory( devicePathSize );
    if( !devicePath )
        return 0;

    /* apparently DRV_QUERYDEVICEINTERFACE returns a unicode interface path, although this is undocumented */
    if( waveOutMessage((HWAVEOUT)waveOutDeviceId, DRV_QUERYDEVICEINTERFACE,
            (DWORD_PTR)devicePath, devicePathSize ) == MMSYSERR_NOERROR )
    {
        int count = PaWin_WDMKS_QueryFilterMaximumChannelCount( devicePath, /* isInput= */ 0  );
        if( count > 0 )
        {
            *maxChannels = count;
            result = 1;
        }
    }

    PaUtil_FreeMemory( devicePath );

    return result;
}
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */


static PaError InitializeOutputDeviceInfo( PaWinMmeHostApiRepresentation *winMmeHostApi,
        PaWinMmeDeviceInfo *winMmeDeviceInfo, UINT winMmeOutputDeviceId, int *success )
{
    PaError result = paNoError;
    char *deviceName; /* non-const ptr */
    MMRESULT mmresult;
    WAVEOUTCAPS woc;
    PaDeviceInfo *deviceInfo = &winMmeDeviceInfo->inheritedDeviceInfo;
    size_t len;
#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
    int wdmksDeviceOutputChannelCountIsKnown;
#endif

    *success = 0;

    mmresult = waveOutGetDevCaps( winMmeOutputDeviceId, &woc, sizeof( WAVEOUTCAPS ) );
    if( mmresult == MMSYSERR_NOMEM )
    {
        result = paInsufficientMemory;
        goto error;
    }
    else if( mmresult != MMSYSERR_NOERROR )
    {
        /* instead of returning paUnanticipatedHostError we return
            paNoError, but leave success set as 0. This allows
            Pa_Initialize to just ignore this device, without failing
            the entire initialisation process.
        */
        return paNoError;
    }

    /* NOTE: the WAVEOUTCAPS.szPname is a null-terminated array of 32 characters,
        so we are limited to displaying only the first 31 characters of the device name. */
    if( winMmeOutputDeviceId == WAVE_MAPPER )
    {
        /* Append I/O suffix to WAVE_MAPPER device. */
        len = TCharStringLen( woc.szPname ) + 1 + sizeof(constOutputMapperSuffix_);
        deviceName = (char*)PaUtil_GroupAllocateMemory(
                    winMmeHostApi->allocations, 
                    (long)len );
        if( !deviceName )
        {
            result = paInsufficientMemory;
            goto error;
        }
        CopyTCharStringToUtf8CString( deviceName, len, woc.szPname );
        strcat( deviceName, constOutputMapperSuffix_ );
    }
    else
    {
        len = TCharStringLen( woc.szPname ) + 1;
        deviceName = (char*)PaUtil_GroupAllocateMemory(
                    winMmeHostApi->allocations, 
                    (long)len );
        if( !deviceName )
        {
            result = paInsufficientMemory;
            goto error;
        }
        CopyTCharStringToUtf8CString( deviceName, len, woc.szPname );
    }
    deviceInfo->name = deviceName;

    if( woc.wChannels == 0xFFFF || woc.wChannels < 1 || woc.wChannels > 255 ){
        /* For Windows versions using WDM (possibly Windows 98 ME and later)
         * the kernel mixer sits between the application and the driver. As a result,
         * wave*GetDevCaps often kernel mixer channel counts, which are unlimited.
         * When this happens we assume the device is stereo and set a flag
         * so that other channel counts can be tried with OpenStream -- i.e. when
         * device*ChannelCountIsKnown is false, OpenStream will try whatever
         * channel count you supply.
         * see also InitializeInputDeviceInfo() above.
     */

        PA_DEBUG(("Pa_GetDeviceInfo: Num output channels reported as %d! Changed to 2.\n", woc.wChannels ));
        deviceInfo->maxOutputChannels = 2;
        winMmeDeviceInfo->deviceOutputChannelCountIsKnown = 0;
    }else{
        deviceInfo->maxOutputChannels = woc.wChannels;
        winMmeDeviceInfo->deviceOutputChannelCountIsKnown = 1;
    }

#ifdef PAWIN_USE_WDMKS_DEVICE_INFO
    wdmksDeviceOutputChannelCountIsKnown = QueryWaveOutKSFilterMaxChannels( 
            winMmeOutputDeviceId, &deviceInfo->maxOutputChannels );
    if( wdmksDeviceOutputChannelCountIsKnown && !winMmeDeviceInfo->deviceOutputChannelCountIsKnown )
        winMmeDeviceInfo->deviceOutputChannelCountIsKnown = 1;
#endif /* PAWIN_USE_WDMKS_DEVICE_INFO */

    winMmeDeviceInfo->dwFormats = woc.dwFormats;

    DetectDefaultSampleRate( winMmeDeviceInfo, winMmeOutputDeviceId,
            QueryOutputWaveFormatEx, deviceInfo->maxOutputChannels );

    *success = 1;
    
error:
    return result;
}


static void GetDefaultLatencies( PaTime *defaultLowLatency, PaTime *defaultHighLatency )
{
/*
NOTE: GetVersionEx() is deprecated as of Windows 8.1 and can not be used to reliably detect
versions of Windows higher than Windows 8 (due to manifest requirements for reporting higher versions).
Microsoft recommends switching to VerifyVersionInfo (available on Win 2k and later), however GetVersionEx
is is faster, for now we just disable the deprecation warning.
See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724451(v=vs.85).aspx
See: http://www.codeproject.com/Articles/678606/Part-Overcoming-Windows-s-deprecation-of-GetVe
*/
#pragma warning (disable : 4996) /* use of GetVersionEx */

    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof( osvi );
    GetVersionEx( &osvi );

    /* Check for NT */
    if( (osvi.dwMajorVersion == 4) && (osvi.dwPlatformId == 2) )
    {
        *defaultLowLatency = PA_MME_WIN_NT_DEFAULT_LATENCY_;
    }
    else if(osvi.dwMajorVersion >= 5)
    {
        *defaultLowLatency  = PA_MME_WIN_WDM_DEFAULT_LATENCY_;
    }
    else
    {
        *defaultLowLatency  = PA_MME_WIN_9X_DEFAULT_LATENCY_;
    }     

    *defaultHighLatency = *defaultLowLatency * 2;

#pragma warning (default : 4996)
}


PaError PaWinMme_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
{
    PaError result = paNoError;
    int i;
    PaWinMmeHostApiRepresentation *winMmeHostApi;
    int inputDeviceCount, outputDeviceCount, maximumPossibleDeviceCount;
    PaWinMmeDeviceInfo *deviceInfoArray;
    int deviceInfoInitializationSucceeded;
    PaTime defaultLowLatency, defaultHighLatency;
    DWORD waveInPreferredDevice, waveOutPreferredDevice;
    DWORD preferredDeviceStatusFlags;

    winMmeHostApi = (PaWinMmeHostApiRepresentation*)PaUtil_AllocateMemory( sizeof(PaWinMmeHostApiRepresentation) );
    if( !winMmeHostApi )
    {
        result = paInsufficientMemory;
        goto error;
    }

    winMmeHostApi->allocations = PaUtil_CreateAllocationGroup();
    if( !winMmeHostApi->allocations )
    {
        result = paInsufficientMemory;
        goto error;
    }

    *hostApi = &winMmeHostApi->inheritedHostApiRep;
    (*hostApi)->info.structVersion = 1;
    (*hostApi)->info.type = paMME;
    (*hostApi)->info.name = "MME";

    
    /* initialise device counts and default devices under the assumption that
        there are no devices. These values are incremented below if and when
        devices are successfully initialized.
    */
    (*hostApi)->info.deviceCount = 0;
    (*hostApi)->info.defaultInputDevice = paNoDevice;
    (*hostApi)->info.defaultOutputDevice = paNoDevice;
    winMmeHostApi->inputDeviceCount = 0;
    winMmeHostApi->outputDeviceCount = 0;

#if !defined(DRVM_MAPPER_PREFERRED_GET)
/* DRVM_MAPPER_PREFERRED_GET is defined in mmddk.h but we avoid a dependency on the DDK by defining it here */
#define DRVM_MAPPER_PREFERRED_GET    (0x2000+21)
#endif

    /* the following calls assume that if wave*Message fails the preferred device parameter won't be modified */
    preferredDeviceStatusFlags = 0;
    waveInPreferredDevice = -1;
    waveInMessage( (HWAVEIN)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&waveInPreferredDevice, (DWORD_PTR)&preferredDeviceStatusFlags );

    preferredDeviceStatusFlags = 0;
    waveOutPreferredDevice = -1;
    waveOutMessage( (HWAVEOUT)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&waveOutPreferredDevice, (DWORD_PTR)&preferredDeviceStatusFlags );

    maximumPossibleDeviceCount = 0;

    inputDeviceCount = waveInGetNumDevs();
    if( inputDeviceCount > 0 )
        maximumPossibleDeviceCount += inputDeviceCount + 1;	/* assume there is a WAVE_MAPPER */

    outputDeviceCount = waveOutGetNumDevs();
    if( outputDeviceCount > 0 )
        maximumPossibleDeviceCount += outputDeviceCount + 1;	/* assume there is a WAVE_MAPPER */


    if( maximumPossibleDeviceCount > 0 ){

        (*hostApi)->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory(
                winMmeHostApi->allocations, sizeof(PaDeviceInfo*) * maximumPossibleDeviceCount );
        if( !(*hostApi)->deviceInfos )
        {
            result = paInsufficientMemory;
            goto error;
        }

        /* allocate all device info structs in a contiguous block */
        deviceInfoArray = (PaWinMmeDeviceInfo*)PaUtil_GroupAllocateMemory(
                winMmeHostApi->allocations, sizeof(PaWinMmeDeviceInfo) * maximumPossibleDeviceCount );
        if( !deviceInfoArray )
        {
            result = paInsufficientMemory;
            goto error;
        }

        winMmeHostApi->winMmeDeviceIds = (UINT*)PaUtil_GroupAllocateMemory(
                winMmeHostApi->allocations, sizeof(int) * maximumPossibleDeviceCount );
        if( !winMmeHostApi->winMmeDeviceIds )
        {
            result = paInsufficientMemory;
            goto error;
        }

        GetDefaultLatencies( &defaultLowLatency, &defaultHighLatency );

        if( inputDeviceCount > 0 ){
            /* -1 is the WAVE_MAPPER */
            for( i = -1; i < inputDeviceCount; ++i ){
                UINT winMmeDeviceId = (UINT)((i==-1) ? WAVE_MAPPER : i);
                PaWinMmeDeviceInfo *wmmeDeviceInfo = &deviceInfoArray[ (*hostApi)->info.deviceCount ];
                PaDeviceInfo *deviceInfo = &wmmeDeviceInfo->inheritedDeviceInfo;
                deviceInfo->structVersion = 2;
                deviceInfo->hostApi = hostApiIndex;

                deviceInfo->maxInputChannels = 0;
                wmmeDeviceInfo->deviceInputChannelCountIsKnown = 1;
                deviceInfo->maxOutputChannels = 0;
                wmmeDeviceInfo->deviceOutputChannelCountIsKnown = 1;

                deviceInfo->defaultLowInputLatency = defaultLowLatency;
                deviceInfo->defaultLowOutputLatency = defaultLowLatency;
                deviceInfo->defaultHighInputLatency = defaultHighLatency;
                deviceInfo->defaultHighOutputLatency = defaultHighLatency;

                result = InitializeInputDeviceInfo( winMmeHostApi, wmmeDeviceInfo,
                        winMmeDeviceId, &deviceInfoInitializationSucceeded );
                if( result != paNoError )
                    goto error;

                if( deviceInfoInitializationSucceeded ){
                    if( (*hostApi)->info.defaultInputDevice == paNoDevice ){
                        /* if there is currently no default device, use the first one available */
                        (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
                    
                    }else if( winMmeDeviceId == waveInPreferredDevice ){
                        /* set the default device to the system preferred device */
                        (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
                    }

                    winMmeHostApi->winMmeDeviceIds[ (*hostApi)->info.deviceCount ] = winMmeDeviceId;
                    (*hostApi)->deviceInfos[ (*hostApi)->info.deviceCount ] = deviceInfo;

                    winMmeHostApi->inputDeviceCount++;
                    (*hostApi)->info.deviceCount++;
                }
            }
        }

        if( outputDeviceCount > 0 ){
            /* -1 is the WAVE_MAPPER */
            for( i = -1; i < outputDeviceCount; ++i ){
                UINT winMmeDeviceId = (UINT)((i==-1) ? WAVE_MAPPER : i);
                PaWinMmeDeviceInfo *wmmeDeviceInfo = &deviceInfoArray[ (*hostApi)->info.deviceCount ];
                PaDeviceInfo *deviceInfo = &wmmeDeviceInfo->inheritedDeviceInfo;
                deviceInfo->structVersion = 2;
                deviceInfo->hostApi = hostApiIndex;

                deviceInfo->maxInputChannels = 0;
                wmmeDeviceInfo->deviceInputChannelCountIsKnown = 1;
                deviceInfo->maxOutputChannels = 0;
                wmmeDeviceInfo->deviceOutputChannelCountIsKnown = 1;

                deviceInfo->defaultLowInputLatency = defaultLowLatency;
                deviceInfo->defaultLowOutputLatency = defaultLowLatency;
                deviceInfo->defaultHighInputLatency = defaultHighLatency;
                deviceInfo->defaultHighOutputLatency = defaultHighLatency; 

                result = InitializeOutputDeviceInfo( winMmeHostApi, wmmeDeviceInfo,
                        winMmeDeviceId, &deviceInfoInitializationSucceeded );
                if( result != paNoError )
                    goto error;

                if( deviceInfoInitializationSucceeded ){
                    if( (*hostApi)->info.defaultOutputDevice == paNoDevice ){
                        /* if there is currently no default device, use the first one available */
                        (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;

                    }else if( winMmeDeviceId == waveOutPreferredDevice ){
                        /* set the default device to the system preferred device */
                        (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
                    }

                    winMmeHostApi->winMmeDeviceIds[ (*hostApi)->info.deviceCount ] = winMmeDeviceId;
                    (*hostApi)->deviceInfos[ (*hostApi)->info.deviceCount ] = deviceInfo;

                    winMmeHostApi->outputDeviceCount++;
                    (*hostApi)->info.deviceCount++;
                }
            }
        }
    }
    
    InitializeDefaultDeviceIdsFromEnv( winMmeHostApi );

    (*hostApi)->Terminate = Terminate;
    (*hostApi)->OpenStream = OpenStream;
    (*hostApi)->IsFormatSupported = IsFormatSupported;

    PaUtil_InitializeStreamInterface( &winMmeHostApi->callbackStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, GetStreamCpuLoad,
                                      PaUtil_DummyRead, PaUtil_DummyWrite,
                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );

    PaUtil_InitializeStreamInterface( &winMmeHostApi->blockingStreamInterface, CloseStream, StartStream,
                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );

    return result;

error:
    if( winMmeHostApi )
    {
        if( winMmeHostApi->allocations )
        {
            PaUtil_FreeAllAllocations( winMmeHostApi->allocations );
            PaUtil_DestroyAllocationGroup( winMmeHostApi->allocations );
        }
        
        PaUtil_FreeMemory( winMmeHostApi );
    }

    return result;
}


static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
{
    PaWinMmeHostApiRepresentation *winMmeHostApi = (PaWinMmeHostApiRepresentation*)hostApi;

    if( winMmeHostApi->allocations )
    {
        PaUtil_FreeAllAllocations( winMmeHostApi->allocations );
        PaUtil_DestroyAllocationGroup( winMmeHostApi->allocations );
    }

    PaUtil_FreeMemory( winMmeHostApi );
}


static PaError IsInputChannelCountSupported( PaWinMmeDeviceInfo* deviceInfo, int channelCount )
{
    PaError result = paNoError;

    if( channelCount > 0
            && deviceInfo->deviceInputChannelCountIsKnown
            && channelCount > deviceInfo->inheritedDeviceInfo.maxInputChannels ){

        result = paInvalidChannelCount; 
    }

    return result;
}

static PaError IsOutputChannelCountSupported( PaWinMmeDeviceInfo* deviceInfo, int channelCount )
{
    PaError result = paNoError;

    if( channelCount > 0
            && deviceInfo->deviceOutputChannelCountIsKnown
            && channelCount > deviceInfo->inheritedDeviceInfo.maxOutputChannels ){

        result = paInvalidChannelCount; 
    }

    return result;
}

static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
                                  const PaStreamParameters *inputParameters,
                                  const PaStreamParameters *outputParameters,
                                  double sampleRate )
{
    PaWinMmeHostApiRepresentation *winMmeHostApi = (PaWinMmeHostApiRepresentation*)hostApi;
    PaDeviceInfo *inputDeviceInfo, *outputDeviceInfo;
    int inputChannelCount, outputChannelCount;
    int inputMultipleDeviceChannelCount, outputMultipleDeviceChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    PaWinMmeStreamInfo *inputStreamInfo, *outputStreamInfo;
    UINT winMmeInputDeviceId, winMmeOutputDeviceId;
    unsigned int i;
    PaError paerror;

    /* The calls to QueryFormatSupported below are intended to detect invalid
        sample rates. If we assume that the channel count and format are OK,
        then the only thing that could fail is the sample rate. This isn't
        strictly true, but I can't think of a better way to test that the
        sample rate is valid.
    */  
    
    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        inputStreamInfo = inputParameters->hostApiSpecificStreamInfo;
        
        /* all standard sample formats are supported by the buffer adapter,
             this implementation doesn't support any custom sample formats */
        if( inputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;

        if( inputParameters->device == paUseHostApiSpecificDeviceSpecification
                && inputStreamInfo && (inputStreamInfo->flags & paWinMmeUseMultipleDevices) )
        {
            inputMultipleDeviceChannelCount = 0;
            for( i=0; i< inputStreamInfo->deviceCount; ++i )
            {
                inputMultipleDeviceChannelCount += inputStreamInfo->devices[i].channelCount;
                    
                inputDeviceInfo = hostApi->deviceInfos[ inputStreamInfo->devices[i].device ];

                /* check that input device can support inputChannelCount */
                if( inputStreamInfo->devices[i].channelCount < 1 )
                    return paInvalidChannelCount;

                paerror = IsInputChannelCountSupported( (PaWinMmeDeviceInfo*)inputDeviceInfo, 
                        inputStreamInfo->devices[i].channelCount );
                if( paerror != paNoError )
                    return paerror;

                /* test for valid sample rate, see comment above */
                winMmeInputDeviceId = LocalDeviceIndexToWinMmeDeviceId( winMmeHostApi, inputStreamInfo->devices[i].device );
                paerror = QueryFormatSupported( inputDeviceInfo, QueryInputWaveFormatEx, 
                        winMmeInputDeviceId, inputStreamInfo->devices[i].channelCount, sampleRate, 
                        ((inputStreamInfo) ? inputStreamInfo->flags : 0) );
                if( paerror != paNoError )
                    return paInvalidSampleRate;
            }
                
            if( inputMultipleDeviceChannelCount != inputChannelCount )
                return paIncompatibleHostApiSpecificStreamInfo;                  
        }
        else
        {
            if( inputStreamInfo && (inputStreamInfo->flags & paWinMmeUseMultipleDevices) )
                return paIncompatibleHostApiSpecificStreamInfo; /* paUseHostApiSpecificDeviceSpecification was not supplied as the input device */

            inputDeviceInfo = hostApi->deviceInfos[ inputParameters->device ];

            /* check that input device can support inputChannelCount */
            paerror = IsInputChannelCountSupported( (PaWinMmeDeviceInfo*)inputDeviceInfo, inputChannelCount );
            if( paerror != paNoError )
                return paerror;

            /* test for valid sample rate, see comment above */
            winMmeInputDeviceId = LocalDeviceIndexToWinMmeDeviceId( winMmeHostApi, inputParameters->device );
            paerror = QueryFormatSupported( inputDeviceInfo, QueryInputWaveFormatEx, 
                    winMmeInputDeviceId, inputChannelCount, sampleRate,
                    ((inputStreamInfo) ? inputStreamInfo->flags : 0) );
            if( paerror != paNoError )
                return paInvalidSampleRate;
        }
    }

    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        outputStreamInfo = outputParameters->hostApiSpecificStreamInfo;

        /* all standard sample formats are supported by the buffer adapter,
            this implementation doesn't support any custom sample formats */
        if( outputSampleFormat & paCustomFormat )
            return paSampleFormatNotSupported;

        if( outputParameters->device == paUseHostApiSpecificDeviceSpecification
                && outputStreamInfo && (outputStreamInfo->flags & paWinMmeUseMultipleDevices) )
        {
            outputMultipleDeviceChannelCount = 0;
            for( i=0; i< outputStreamInfo->deviceCount; ++i )
            {
                outputMultipleDeviceChannelCount += outputStreamInfo->devices[i].channelCount;
                    
                outputDeviceInfo = hostApi->deviceInfos[ outputStreamInfo->devices[i].device ];

                /* check that output device can support outputChannelCount */
                if( outputStreamInfo->devices[i].channelCount < 1 )
                    return paInvalidChannelCount;

                paerror = IsOutputChannelCountSupported( (PaWinMmeDeviceInfo*)outputDeviceInfo, 
                        outputStreamInfo->devices[i].channelCount );
                if( paerror != paNoError )
                    return paerror;

                /* test for valid sample rate, see comment above */
                winMmeOutputDeviceId = LocalDeviceIndexToWinMmeDeviceId( winMmeHostApi, outputStreamInfo->devices[i].device );
                paerror = QueryFormatSupported( outputDeviceInfo, QueryOutputWaveFormatEx, 
                        winMmeOutputDeviceId, outputStreamInfo->devices[i].channelCount, sampleRate,
                        ((outputStreamInfo) ? outputStreamInfo->flags : 0) );
                if( paerror != paNoError )
                    return paInvalidSampleRate;
            }
                
            if( outputMultipleDeviceChannelCount != outputChannelCount )
                return paIncompatibleHostApiSpecificStreamInfo;            
        }
        else
        {
            if( outputStreamInfo && (outputStreamInfo->flags & paWinMmeUseMultipleDevices) )
                return paIncompatibleHostApiSpecificStreamInfo; /* paUseHostApiSpecificDeviceSpecification was not supplied as the output device */

            outputDeviceInfo = hostApi->deviceInfos[ outputParameters->device ];

            /* check that output device can support outputChannelCount */
            paerror = IsOutputChannelCountSupported( (PaWinMmeDeviceInfo*)outputDeviceInfo, outputChannelCount );
            if( paerror != paNoError )
                return paerror;

            /* test for valid sample rate, see comment above */
            winMmeOutputDeviceId = LocalDeviceIndexToWinMmeDeviceId( winMmeHostApi, outputParameters->device );
            paerror = QueryFormatSupported( outputDeviceInfo, QueryOutputWaveFormatEx, 
                    winMmeOutputDeviceId, outputChannelCount, sampleRate,
                    ((outputStreamInfo) ? outputStreamInfo->flags : 0) );
            if( paerror != paNoError )
                return paInvalidSampleRate;
        }
    }
    
    /*
            - if a full duplex stream is requested, check that the combination
                of input and output parameters is supported

            - check that the device supports sampleRate

            for mme all we can do is test that the input and output devices
            support the requested sample rate and number of channels. we
            cannot test for full duplex compatibility.
    */                                             

    return paFormatIsSupported;
}


static unsigned long ComputeHostBufferCountForFixedBufferSizeFrames(
        unsigned long suggestedLatencyFrames,
        unsigned long hostBufferSizeFrames,
        unsigned long minimumBufferCount )
{
    /* Calculate the number of buffers of length hostFramesPerBuffer 
       that fit in suggestedLatencyFrames, rounding up to the next integer.

       The value (hostBufferSizeFrames - 1) below is to ensure the buffer count is rounded up.
    */
    unsigned long resultBufferCount = ((suggestedLatencyFrames + (hostBufferSizeFrames - 1)) / hostBufferSizeFrames);

    /* We always need one extra buffer for processing while the rest are queued/playing.
       i.e. latency is framesPerBuffer * (bufferCount - 1)
    */
    resultBufferCount += 1;

    if( resultBufferCount < minimumBufferCount ) /* clamp to minimum buffer count */
        resultBufferCount = minimumBufferCount;

    return resultBufferCount;
}


static unsigned long ComputeHostBufferSizeGivenHardUpperLimit( 
        unsigned long userFramesPerBuffer,
        unsigned long absoluteMaximumBufferSizeFrames )
{
    static unsigned long primes_[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 
            29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 0 }; /* zero terminated */

    unsigned long result = userFramesPerBuffer;
    int i;

    assert( absoluteMaximumBufferSizeFrames > 67 ); /* assume maximum is large and we're only factoring by small primes */

    /* search for the largest integer factor of userFramesPerBuffer less 
       than or equal to absoluteMaximumBufferSizeFrames */

    /* repeatedly divide by smallest prime factors until a buffer size 
       smaller than absoluteMaximumBufferSizeFrames is found */
    while( result > absoluteMaximumBufferSizeFrames ){

        /* search for the smallest prime factor of result */
        for( i=0; primes_[i] != 0; ++i ) 
        {
            unsigned long p = primes_[i];
            unsigned long divided = result / p;
            if( divided*p == result )
            {
                result = divided;
                break; /* continue with outer while loop */
            }
        }
        if( primes_[i] == 0 )
        { /* loop failed to find a prime factor, return an approximate result */
            unsigned long d = (userFramesPerBuffer + (absoluteMaximumBufferSizeFrames-1))
                    / absoluteMaximumBufferSizeFrames;
            return userFramesPerBuffer / d;
        }
    }

    return result;
}


static PaError SelectHostBufferSizeFramesAndHostBufferCount(
        unsigned long suggestedLatencyFrames,
        unsigned long userFramesPerBuffer,
        unsigned long minimumBufferCount,
        unsigned long preferredMaximumBufferSizeFrames, /* try not to exceed this. for example, don't exceed when coalescing buffers */
        unsigned long absoluteMaximumBufferSizeFrames,  /* never exceed this, a hard limit */
        unsigned long *hostBufferSizeFrames,
        unsigned long *hostBufferCount )
{
    unsigned long effectiveUserFramesPerBuffer;
    unsigned long numberOfUserBuffersPerHostBuffer;


    if( userFramesPerBuffer == paFramesPerBufferUnspecified ){

        effectiveUserFramesPerBuffer = PA_MME_HOST_BUFFER_GRANULARITY_FRAMES_WHEN_UNSPECIFIED_;

    }else{

        if( userFramesPerBuffer > absoluteMaximumBufferSizeFrames ){

            /* user has requested a user buffer that's larger than absoluteMaximumBufferSizeFrames.
               try to choose a buffer size that is equal or smaller than absoluteMaximumBufferSizeFrames
               but is also an integer factor of userFramesPerBuffer, so as to distribute computation evenly.
               the buffer processor will handle the block adaption between host and user buffer sizes.
               see http://www.portaudio.com/trac/ticket/189 for discussion.
            */

            effectiveUserFramesPerBuffer = ComputeHostBufferSizeGivenHardUpperLimit( userFramesPerBuffer, absoluteMaximumBufferSizeFrames );
            assert( effectiveUserFramesPerBuffer <= absoluteMaximumBufferSizeFrames );

            /* try to ensure that duration of host buffering is at least as 
                large as duration of user buffer. */
            if( suggestedLatencyFrames < userFramesPerBuffer )
                suggestedLatencyFrames = userFramesPerBuffer; 

        }else{

            effectiveUserFramesPerBuffer = userFramesPerBuffer;
        }
    }
                        
    /* compute a host buffer count based on suggestedLatencyFrames and our granularity */

    *hostBufferSizeFrames = effectiveUserFramesPerBuffer;

    *hostBufferCount = ComputeHostBufferCountForFixedBufferSizeFrames(
            suggestedLatencyFrames, *hostBufferSizeFrames, minimumBufferCount );

    if( *hostBufferSizeFrames >= userFramesPerBuffer )
    {
        /*
            If there are too many host buffers we would like to coalesce 
            them by packing an integer number of user buffers into each host buffer.
            We try to coalesce such that hostBufferCount will lie between 
            PA_MME_TARGET_HOST_BUFFER_COUNT_ and (PA_MME_TARGET_HOST_BUFFER_COUNT_*2)-1.
            We limit coalescing to avoid exceeding either absoluteMaximumBufferSizeFrames and
            preferredMaximumBufferSizeFrames. 

            First, compute a coalescing factor: the number of user buffers per host buffer.
            The goal is to achieve PA_MME_TARGET_HOST_BUFFER_COUNT_ total buffer count.
            Since our latency is computed based on (*hostBufferCount - 1) we compute a
            coalescing factor based on (*hostBufferCount - 1) and (PA_MME_TARGET_HOST_BUFFER_COUNT_-1).

            The + (PA_MME_TARGET_HOST_BUFFER_COUNT_-2) term below is intended to round up.
        */
        numberOfUserBuffersPerHostBuffer = ((*hostBufferCount - 1) + (PA_MME_TARGET_HOST_BUFFER_COUNT_-2)) / (PA_MME_TARGET_HOST_BUFFER_COUNT_ - 1);
        
        if( numberOfUserBuffersPerHostBuffer > 1 )
        {
            unsigned long maxCoalescedBufferSizeFrames = (absoluteMaximumBufferSizeFrames < preferredMaximumBufferSizeFrames) /* minimum of our limits */
                            ? absoluteMaximumBufferSizeFrames
                            : preferredMaximumBufferSizeFrames;

            unsigned long maxUserBuffersPerHostBuffer = maxCoalescedBufferSizeFrames / effectiveUserFramesPerBuffer; /* don't coalesce more than this */

            if( numberOfUserBuffersPerHostBuffer > maxUserBuffersPerHostBuffer )
                numberOfUserBuffersPerHostBuffer = maxUserBuffersPerHostBuffer;

            *hostBufferSizeFrames = effectiveUserFramesPerBuffer * numberOfUserBuffersPerHostBuffer;

            /* recompute hostBufferCount to approximate suggestedLatencyFrames now that hostBufferSizeFrames is larger */
            *hostBufferCount = ComputeHostBufferCountForFixedBufferSizeFrames(
                    suggestedLatencyFrames, *hostBufferSizeFrames, minimumBufferCount );
        }
    }

    return paNoError;
}


static PaError CalculateMaxHostSampleFrameSizeBytes(
        int channelCount,
        PaSampleFormat hostSampleFormat,
        const PaWinMmeStreamInfo *streamInfo,
        int *hostSampleFrameSizeBytes )
{
    unsigned int i;
    /* PA WMME streams may aggregate multiple WMME devices. When the stream addresses 
       more than one device in a single direction, maxDeviceChannelCount is the maximum 
       number of channels used by a single device.
    */
    int maxDeviceChannelCount = channelCount;
    int hostSampleSizeBytes = Pa_GetSampleSize( hostSampleFormat );
    if( hostSampleSizeBytes < 0 )
    {
        return hostSampleSizeBytes; /* the value of hostSampleSize here is an error code, not a sample size */
    }

    if( streamInfo && ( streamInfo->flags & paWinMmeUseMultipleDevices ) )
    {
        maxDeviceChannelCount = streamInfo->devices[0].channelCount;
        for( i=1; i< streamInfo->deviceCount; ++i )
        {
            if( streamInfo->devices[i].channelCount > maxDeviceChannelCount )
                maxDeviceChannelCount = streamInfo->devices[i].channelCount;
        }
    }

    *hostSampleFrameSizeBytes = hostSampleSizeBytes * maxDeviceChannelCount;

    return paNoError;
}


/* CalculateBufferSettings() fills the framesPerHostInputBuffer, hostInputBufferCount,
   framesPerHostOutputBuffer and hostOutputBufferCount parameters based on the values
   of the other parameters.
*/

static PaError CalculateBufferSettings(
        unsigned long *hostFramesPerInputBuffer, unsigned long *hostInputBufferCount,
        unsigned long *hostFramesPerOutputBuffer, unsigned long *hostOutputBufferCount,
        int inputChannelCount, PaSampleFormat hostInputSampleFormat,
        PaTime suggestedInputLatency, const PaWinMmeStreamInfo *inputStreamInfo,
        int outputChannelCount, PaSampleFormat hostOutputSampleFormat,
        PaTime suggestedOutputLatency, const PaWinMmeStreamInfo *outputStreamInfo,
        double sampleRate, unsigned long userFramesPerBuffer )
{
    PaError result = paNoError;
    
    if( inputChannelCount > 0 ) /* stream has input */
    {
        int hostInputFrameSizeBytes;
        result = CalculateMaxHostSampleFrameSizeBytes( 
                inputChannelCount, hostInputSampleFormat, inputStreamInfo, &hostInputFrameSizeBytes );
        if( result != paNoError )
            goto error;

        if( inputStreamInfo
                && ( inputStreamInfo->flags & paWinMmeUseLowLevelLatencyParameters ) )
        {
            /* input - using low level latency parameters if provided */

            if( inputStreamInfo->bufferCount <= 0
                    || inputStreamInfo->framesPerBuffer <= 0 )
            {
                result = paIncompatibleHostApiSpecificStreamInfo;
                goto error;
            }

            *hostFramesPerInputBuffer = inputStreamInfo->framesPerBuffer;
            *hostInputBufferCount = inputStreamInfo->bufferCount;
        }
        else
        {
            /* input - not using low level latency parameters, so compute 
               hostFramesPerInputBuffer and hostInputBufferCount
               based on userFramesPerBuffer and suggestedInputLatency. */

            unsigned long minimumBufferCount = (outputChannelCount > 0)
                    ? PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_FULL_DUPLEX_
                    : PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_HALF_DUPLEX_;

            result = SelectHostBufferSizeFramesAndHostBufferCount(
                    (unsigned long)(suggestedInputLatency * sampleRate), /* (truncate) */
                    userFramesPerBuffer,
                    minimumBufferCount,
                    (unsigned long)(PA_MME_MAX_HOST_BUFFER_SECS_ * sampleRate), /* in frames. preferred maximum */
                    (PA_MME_MAX_HOST_BUFFER_BYTES_ / hostInputFrameSizeBytes),  /* in frames. a hard limit. note truncation due to 
                                                                                division is intentional here to limit max bytes */
                    hostFramesPerInputBuffer,
                    hostInputBufferCount );
            if( result != paNoError )
                goto error;
        }
    }
    else
    {
        *hostFramesPerInputBuffer = 0;
        *hostInputBufferCount = 0;
    }

    if( outputChannelCount > 0 ) /* stream has output */
    {
        if( outputStreamInfo
                && ( outputStreamInfo->flags & paWinMmeUseLowLevelLatencyParameters ) )
        {
            /* output - using low level latency parameters */

            if( outputStreamInfo->bufferCount <= 0
                    || outputStreamInfo->framesPerBuffer <= 0 )
            {
                result = paIncompatibleHostApiSpecificStreamInfo;
                goto error;
            }

            *hostFramesPerOutputBuffer = outputStreamInfo->framesPerBuffer;
            *hostOutputBufferCount = outputStreamInfo->bufferCount;

            if( inputChannelCount > 0 ) /* full duplex */
            {
                /* harmonize hostFramesPerInputBuffer and hostFramesPerOutputBuffer */

                if( *hostFramesPerInputBuffer != *hostFramesPerOutputBuffer )
                {
                    if( inputStreamInfo
                            && ( inputStreamInfo->flags & paWinMmeUseLowLevelLatencyParameters ) )
                    { 
                        /* a custom StreamInfo was used for specifying both input
                            and output buffer sizes. We require that the larger buffer size
                            must be a multiple of the smaller buffer size */

                        if( *hostFramesPerInputBuffer < *hostFramesPerOutputBuffer )
                        {
                            if( *hostFramesPerOutputBuffer % *hostFramesPerInputBuffer != 0 )
                            {
                                result = paIncompatibleHostApiSpecificStreamInfo;
                                goto error;
                            }
                        }
                        else
                        {
                            assert( *hostFramesPerInputBuffer > *hostFramesPerOutputBuffer );
                            if( *hostFramesPerInputBuffer % *hostFramesPerOutputBuffer != 0 )
                            {
                                result = paIncompatibleHostApiSpecificStreamInfo;
                                goto error;
                            }
                        }                        
                    }
                    else
                    {
                        /* a custom StreamInfo was not used for specifying the input buffer size,
                            so use the output buffer size, and approximately the suggested input latency. */

                        *hostFramesPerInputBuffer = *hostFramesPerOutputBuffer;

                        *hostInputBufferCount = ComputeHostBufferCountForFixedBufferSizeFrames(
                                (unsigned long)(suggestedInputLatency * sampleRate), 
                                *hostFramesPerInputBuffer, 
                                PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_FULL_DUPLEX_ );
                    }
                }
            }
        }
        else
        {
            /* output - no low level latency parameters, so compute hostFramesPerOutputBuffer and hostOutputBufferCount
                based on userFramesPerBuffer and suggestedOutputLatency. */

            int hostOutputFrameSizeBytes;
            result = CalculateMaxHostSampleFrameSizeBytes( 
                    outputChannelCount, hostOutputSampleFormat, outputStreamInfo, &hostOutputFrameSizeBytes );
            if( result != paNoError )
                goto error;

            /* compute the output buffer size and count */

            result = SelectHostBufferSizeFramesAndHostBufferCount(
                    (unsigned long)(suggestedOutputLatency * sampleRate), /* (truncate) */
                    userFramesPerBuffer,
                    PA_MME_MIN_HOST_OUTPUT_BUFFER_COUNT_,
                    (unsigned long)(PA_MME_MAX_HOST_BUFFER_SECS_ * sampleRate), /* in frames. preferred maximum */
                    (PA_MME_MAX_HOST_BUFFER_BYTES_ / hostOutputFrameSizeBytes),  /* in frames. a hard limit. note truncation due to 
                                                                                 division is intentional here to limit max bytes */
                    hostFramesPerOutputBuffer,
                    hostOutputBufferCount );
            if( result != paNoError )
                goto error;

            if( inputChannelCount > 0 ) /* full duplex */
            {
                /* harmonize hostFramesPerInputBuffer and hostFramesPerOutputBuffer */

                /* ensure that both input and output buffer sizes are the same.
                    if they don't match at this stage, choose the smallest one
                    and use that for input and output and recompute the corresponding
                    buffer count accordingly.
                */

                if( *hostFramesPerOutputBuffer != *hostFramesPerInputBuffer )
                {
                    if( hostFramesPerInputBuffer < hostFramesPerOutputBuffer )
                    {
                        *hostFramesPerOutputBuffer = *hostFramesPerInputBuffer;

                        *hostOutputBufferCount = ComputeHostBufferCountForFixedBufferSizeFrames(
                                (unsigned long)(suggestedOutputLatency * sampleRate), 
                                *hostOutputBufferCount, 
                                PA_MME_MIN_HOST_OUTPUT_BUFFER_COUNT_ );
                    }
                    else
                    {
                        *hostFramesPerInputBuffer = *hostFramesPerOutputBuffer;

                        *hostInputBufferCount = ComputeHostBufferCountForFixedBufferSizeFrames(
                                (unsigned long)(suggestedInputLatency * sampleRate), 
                                *hostFramesPerInputBuffer, 
                                PA_MME_MIN_HOST_INPUT_BUFFER_COUNT_FULL_DUPLEX_ );
                    }
                }   
            }
        }
    }
    else
    {
        *hostFramesPerOutputBuffer = 0;
        *hostOutputBufferCount = 0;
    }

error:
    return result;
}


typedef struct
{
    HANDLE bufferEvent;
    void *waveHandles;
    unsigned int deviceCount;
    /* unsigned int channelCount; */
    WAVEHDR **waveHeaders;                  /* waveHeaders[device][buffer] */
    unsigned int bufferCount;
    unsigned int currentBufferIndex;
    unsigned int framesPerBuffer;
    unsigned int framesUsedInCurrentBuffer;
}PaWinMmeSingleDirectionHandlesAndBuffers;

/* prototypes for functions operating on PaWinMmeSingleDirectionHandlesAndBuffers */

static void InitializeSingleDirectionHandlesAndBuffers( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers );
static PaError InitializeWaveHandles( PaWinMmeHostApiRepresentation *winMmeHostApi,
        PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers,
        unsigned long winMmeSpecificFlags,
        unsigned long bytesPerHostSample,
        double sampleRate, PaWinMmeDeviceAndChannelCount *devices,
        unsigned int deviceCount, PaWinWaveFormatChannelMask channelMask, int isInput );
static PaError TerminateWaveHandles( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers, int isInput, int currentlyProcessingAnError );
static PaError InitializeWaveHeaders( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers,
        unsigned long hostBufferCount,
        PaSampleFormat hostSampleFormat,
        unsigned long framesPerHostBuffer,
        PaWinMmeDeviceAndChannelCount *devices,
        int isInput );
static void TerminateWaveHeaders( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers, int isInput );


static void InitializeSingleDirectionHandlesAndBuffers( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers )
{
    handlesAndBuffers->bufferEvent = 0;
    handlesAndBuffers->waveHandles = 0;
    handlesAndBuffers->deviceCount = 0;
    handlesAndBuffers->waveHeaders = 0;
    handlesAndBuffers->bufferCount = 0;
}    

static PaError InitializeWaveHandles( PaWinMmeHostApiRepresentation *winMmeHostApi,
        PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers,
        unsigned long winMmeSpecificFlags,
        unsigned long bytesPerHostSample,
        double sampleRate, PaWinMmeDeviceAndChannelCount *devices,
        unsigned int deviceCount, PaWinWaveFormatChannelMask channelMask, int isInput )
{
    PaError result;
    MMRESULT mmresult;
    signed int i, j;
    PaSampleFormat sampleFormat;
    int waveFormatTag;

    /* for error cleanup we expect that InitializeSingleDirectionHandlesAndBuffers()
        has already been called to zero some fields */       

    result = CreateEventWithPaError( &handlesAndBuffers->bufferEvent, NULL, FALSE, FALSE, NULL );
    if( result != paNoError ) goto error;

    if( isInput )
        handlesAndBuffers->waveHandles = (void*)PaUtil_AllocateMemory( sizeof(HWAVEIN) * deviceCount );
    else
        handlesAndBuffers->waveHandles = (void*)PaUtil_AllocateMemory( sizeof(HWAVEOUT) * deviceCount );
    if( !handlesAndBuffers->waveHandles )
    {
        result = paInsufficientMemory;
        goto error;
    }

    handlesAndBuffers->deviceCount = deviceCount;

    for( i = 0; i < (signed int)deviceCount; ++i )
    {
        if( isInput )
            ((HWAVEIN*)handlesAndBuffers->waveHandles)[i] = 0;
        else
            ((HWAVEOUT*)handlesAndBuffers->waveHandles)[i] = 0;
    }

    /* @todo at the moment we only use 16 bit sample format */
    sampleFormat = paInt16;
    waveFormatTag = SampleFormatAndWinWmmeSpecificFlagsToLinearWaveFormatTag( sampleFormat, winMmeSpecificFlags );

    for( i = 0; i < (signed int)deviceCount; ++i )
    {
        PaWinWaveFormat waveFormat;
        UINT winMmeDeviceId = LocalDeviceIndexToWinMmeDeviceId( winMmeHostApi, devices[i].device );
    
        /* @todo: consider providing a flag or #define to not try waveformat extensible 
           this could just initialize j to 1 the first time round. */

        for( j = 0; j < 2; ++j )
        {
            switch(j){
                case 0:     
                    /* first, attempt to open the device using WAVEFORMATEXTENSIBLE, 
                        if this fails we fall back to WAVEFORMATEX */

                    PaWin_InitializeWaveFormatExtensible( &waveFormat, devices[i].channelCount, 
                            sampleFormat, waveFormatTag, sampleRate, channelMask );
                    break;
                
                case 1:
                    /* retry with WAVEFORMATEX */

                    PaWin_InitializeWaveFormatEx( &waveFormat, devices[i].channelCount, 
                            sampleFormat, waveFormatTag, sampleRate );
                    break;
            }

            /* REVIEW: consider not firing an event for input when a full duplex
                stream is being used. this would probably depend on the
                neverDropInput flag. */

            if( isInput )
            {
                mmresult = waveInOpen( &((HWAVEIN*)handlesAndBuffers->waveHandles)[i], winMmeDeviceId, 
                                    (WAVEFORMATEX*)&waveFormat,
                               (DWORD_PTR)handlesAndBuffers->bufferEvent, (DWORD_PTR)0, CALLBACK_EVENT );
            }
            else
            {
                mmresult = waveOutOpen( &((HWAVEOUT*)handlesAndBuffers->waveHandles)[i], winMmeDeviceId, 
                                    (WAVEFORMATEX*)&waveFormat,
                                (DWORD_PTR)handlesAndBuffers->bufferEvent, (DWORD_PTR)0, CALLBACK_EVENT );
            }

            if( mmresult == MMSYSERR_NOERROR )
            {
                break; /* success */
            }
            else if( j == 0 )
            {
                continue; /* try again with WAVEFORMATEX */
            }
            else
            {
                switch( mmresult )
                {
                    case MMSYSERR_ALLOCATED:    /* Specified resource is already allocated. */
                        result = paDeviceUnavailable;
                        break;
                    case MMSYSERR_NODRIVER:	    /* No device driver is present. */
                        result = paDeviceUnavailable;
                        break;
                    case MMSYSERR_NOMEM:	    /* Unable to allocate or lock memory. */
                        result = paInsufficientMemory;
                        break;

                    case MMSYSERR_BADDEVICEID:	/* Specified device identifier is out of range. */
                        /* falls through */

                    case WAVERR_BADFORMAT:      /* Attempted to open with an unsupported waveform-audio format. */
                                                    /* This can also occur if we try to open the device with an unsupported
                                                     * number of channels. This is attempted when device*ChannelCountIsKnown is
                                                     * set to 0. 
                                                     */
                        /* falls through */
                    default:
                        result = paUnanticipatedHostError;
                        if( isInput )
                        {
                            PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                        }
                        else
                        {
                            PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                        }
                }
                goto error;
            }
        }
    }

    return result;

error:
    TerminateWaveHandles( handlesAndBuffers, isInput, 1 /* currentlyProcessingAnError */ );

    return result;
}


static PaError TerminateWaveHandles( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers, int isInput, int currentlyProcessingAnError )
{
    PaError result = paNoError;
    MMRESULT mmresult;
    signed int i;
    
    if( handlesAndBuffers->waveHandles )
    {
        for( i = handlesAndBuffers->deviceCount-1; i >= 0; --i )
        {
            if( isInput )
            {
                if( ((HWAVEIN*)handlesAndBuffers->waveHandles)[i] )
                    mmresult = waveInClose( ((HWAVEIN*)handlesAndBuffers->waveHandles)[i] );
                else
                    mmresult = MMSYSERR_NOERROR;
            }
            else
            {
                if( ((HWAVEOUT*)handlesAndBuffers->waveHandles)[i] )
                    mmresult = waveOutClose( ((HWAVEOUT*)handlesAndBuffers->waveHandles)[i] );
                else
                    mmresult = MMSYSERR_NOERROR;
            }

            if( mmresult != MMSYSERR_NOERROR &&
                !currentlyProcessingAnError ) /* don't update the error state if we're already processing an error */
            {
                result = paUnanticipatedHostError;
                if( isInput )
                {
                    PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                }
                else
                {
                    PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                }
                /* note that we don't break here, we try to continue closing devices */
            }
        }

        PaUtil_FreeMemory( handlesAndBuffers->waveHandles );
        handlesAndBuffers->waveHandles = 0;
    }

    if( handlesAndBuffers->bufferEvent )
    {
        result = CloseHandleWithPaError( handlesAndBuffers->bufferEvent );
        handlesAndBuffers->bufferEvent = 0;
    }
    
    return result;
}


static PaError InitializeWaveHeaders( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers,
        unsigned long hostBufferCount,
        PaSampleFormat hostSampleFormat,
        unsigned long framesPerHostBuffer,
        PaWinMmeDeviceAndChannelCount *devices,
        int isInput )
{
    PaError result = paNoError;
    MMRESULT mmresult;
    WAVEHDR *deviceWaveHeaders;
    signed int i, j;

    /* for error cleanup we expect that InitializeSingleDirectionHandlesAndBuffers()
        has already been called to zero some fields */
        

    /* allocate an array of pointers to arrays of wave headers, one array of
        wave headers per device */
    handlesAndBuffers->waveHeaders = (WAVEHDR**)PaUtil_AllocateMemory( sizeof(WAVEHDR*) * handlesAndBuffers->deviceCount );
    if( !handlesAndBuffers->waveHeaders )
    {
        result = paInsufficientMemory;
        goto error;
    }
    
    for( i = 0; i < (signed int)handlesAndBuffers->deviceCount; ++i )
        handlesAndBuffers->waveHeaders[i] = 0;

    handlesAndBuffers->bufferCount = hostBufferCount;

    for( i = 0; i < (signed int)handlesAndBuffers->deviceCount; ++i )
    {
        int bufferBytes = Pa_GetSampleSize( hostSampleFormat ) *
                framesPerHostBuffer * devices[i].channelCount;
        if( bufferBytes < 0 )
        {
            result = paInternalError;
            goto error;
        }

        /* Allocate an array of wave headers for device i */
        deviceWaveHeaders = (WAVEHDR *) PaUtil_AllocateMemory( sizeof(WAVEHDR)*hostBufferCount );
        if( !deviceWaveHeaders )
        {
            result = paInsufficientMemory;
            goto error;
        }

        for( j=0; j < (signed int)hostBufferCount; ++j )
            deviceWaveHeaders[j].lpData = 0;

        handlesAndBuffers->waveHeaders[i] = deviceWaveHeaders;

        /* Allocate a buffer for each wave header */
        for( j=0; j < (signed int)hostBufferCount; ++j )
        {
            deviceWaveHeaders[j].lpData = (char *)PaUtil_AllocateMemory( bufferBytes );
            if( !deviceWaveHeaders[j].lpData )
            {
                result = paInsufficientMemory;
                goto error;
            }
            deviceWaveHeaders[j].dwBufferLength = bufferBytes;
            deviceWaveHeaders[j].dwUser = 0xFFFFFFFF; /* indicates that *PrepareHeader() has not yet been called, for error clean up code */

            if( isInput )
            {
                mmresult = waveInPrepareHeader( ((HWAVEIN*)handlesAndBuffers->waveHandles)[i], &deviceWaveHeaders[j], sizeof(WAVEHDR) );
                if( mmresult != MMSYSERR_NOERROR )
                {
                    result = paUnanticipatedHostError;
                    PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                    goto error;
                }
            }
            else /* output */
            {
                mmresult = waveOutPrepareHeader( ((HWAVEOUT*)handlesAndBuffers->waveHandles)[i], &deviceWaveHeaders[j], sizeof(WAVEHDR) );
                if( mmresult != MMSYSERR_NOERROR )
                {
                    result = paUnanticipatedHostError;
                    PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                    goto error;
                }
            }
            deviceWaveHeaders[j].dwUser = devices[i].channelCount;
        }
    }

    return result;

error:
    TerminateWaveHeaders( handlesAndBuffers, isInput );
    
    return result;
}


static void TerminateWaveHeaders( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers, int isInput )
{
    signed int i, j;
    WAVEHDR *deviceWaveHeaders;
    
    if( handlesAndBuffers->waveHeaders )
    {
        for( i = handlesAndBuffers->deviceCount-1; i >= 0 ; --i )
        {
            deviceWaveHeaders = handlesAndBuffers->waveHeaders[i];  /* wave headers for device i */
            if( deviceWaveHeaders )
            {
                for( j = handlesAndBuffers->bufferCount-1; j >= 0; --j )
                {
                    if( deviceWaveHeaders[j].lpData )
                    {
                        if( deviceWaveHeaders[j].dwUser != 0xFFFFFFFF )
                        {
                            if( isInput )
                                waveInUnprepareHeader( ((HWAVEIN*)handlesAndBuffers->waveHandles)[i], &deviceWaveHeaders[j], sizeof(WAVEHDR) );
                            else
                                waveOutUnprepareHeader( ((HWAVEOUT*)handlesAndBuffers->waveHandles)[i], &deviceWaveHeaders[j], sizeof(WAVEHDR) );
                        }

                        PaUtil_FreeMemory( deviceWaveHeaders[j].lpData );
                    }
                }

                PaUtil_FreeMemory( deviceWaveHeaders );
            }
        }

        PaUtil_FreeMemory( handlesAndBuffers->waveHeaders );
        handlesAndBuffers->waveHeaders = 0;
    }
}



/* PaWinMmeStream - a stream data structure specifically for this implementation */
/* note that struct PaWinMmeStream is typedeffed to PaWinMmeStream above. */
struct PaWinMmeStream
{
    PaUtilStreamRepresentation streamRepresentation;
    PaUtilCpuLoadMeasurer cpuLoadMeasurer;
    PaUtilBufferProcessor bufferProcessor;

    int primeStreamUsingCallback;

    PaWinMmeSingleDirectionHandlesAndBuffers input;
    PaWinMmeSingleDirectionHandlesAndBuffers output;

    /* Processing thread management -------------- */
    HANDLE abortEvent;
    HANDLE processingThread;
    PA_THREAD_ID processingThreadId;

    char throttleProcessingThreadOnOverload; /* 0 -> don't throtte, non-0 -> throttle */
    int processingThreadPriority;
    int highThreadPriority;
    int throttledThreadPriority;
    unsigned long throttledSleepMsecs;

    int isStopped;
    volatile int isActive;
    volatile int stopProcessing; /* stop thread once existing buffers have been returned */
    volatile int abortProcessing; /* stop thread immediately */

    DWORD allBuffersDurationMs; /* used to calculate timeouts */
};

/* updates deviceCount if PaWinMmeUseMultipleDevices is used */

static PaError ValidateWinMmeSpecificStreamInfo(
        const PaStreamParameters *streamParameters,
        const PaWinMmeStreamInfo *streamInfo,
        unsigned long *winMmeSpecificFlags,
        char *throttleProcessingThreadOnOverload,
        unsigned long *deviceCount )
{
    if( streamInfo )
    {
        if( streamInfo->size != sizeof( PaWinMmeStreamInfo )
                || streamInfo->version != 1 )
        {
            return paIncompatibleHostApiSpecificStreamInfo;
        }

        *winMmeSpecificFlags = streamInfo->flags;

        if( streamInfo->flags & paWinMmeDontThrottleOverloadedProcessingThread )
            *throttleProcessingThreadOnOverload = 0;
            
        if( streamInfo->flags & paWinMmeUseMultipleDevices )
        {
            if( streamParameters->device != paUseHostApiSpecificDeviceSpecification )
                return paInvalidDevice;
    
            *deviceCount = streamInfo->deviceCount;
        }	
    }

    return paNoError;
}

static PaError RetrieveDevicesFromStreamParameters(
        struct PaUtilHostApiRepresentation *hostApi,
        const PaStreamParameters *streamParameters,
        const PaWinMmeStreamInfo *streamInfo,
        PaWinMmeDeviceAndChannelCount *devices,
        unsigned long deviceCount )
{
    PaError result = paNoError;
    unsigned int i;
    int totalChannelCount;
    PaDeviceIndex hostApiDevice;
    
    if( streamInfo && streamInfo->flags & paWinMmeUseMultipleDevices )
    {
        totalChannelCount = 0;
        for( i=0; i < deviceCount; ++i )
        {
            /* validate that the device number is within range */
            result = PaUtil_DeviceIndexToHostApiDeviceIndex( &hostApiDevice,
                            streamInfo->devices[i].device, hostApi );
            if( result != paNoError )
                return result;
            
            devices[i].device = hostApiDevice;
            devices[i].channelCount = streamInfo->devices[i].channelCount;
    
            totalChannelCount += devices[i].channelCount;
        }
    
        if( totalChannelCount != streamParameters->channelCount )
        {
            /* channelCount must match total channels specified by multiple devices */
            return paInvalidChannelCount; /* REVIEW use of this error code */
        }
    }	
    else
    {		
        devices[0].device = streamParameters->device;
        devices[0].channelCount = streamParameters->channelCount;
    }

    return result;
}

static PaError ValidateInputChannelCounts(
        struct PaUtilHostApiRepresentation *hostApi,
        PaWinMmeDeviceAndChannelCount *devices,
        unsigned long deviceCount )
{
    unsigned int i;
    PaWinMmeDeviceInfo *inputDeviceInfo;
    PaError paerror;

    for( i=0; i < deviceCount; ++i )
    {
        if( devices[i].channelCount < 1 )
            return paInvalidChannelCount;

        inputDeviceInfo = 
                (PaWinMmeDeviceInfo*)hostApi->deviceInfos[ devices[i].device ];

        paerror = IsInputChannelCountSupported( inputDeviceInfo, devices[i].channelCount );
        if( paerror != paNoError )
            return paerror;
    }

    return paNoError;
}

static PaError ValidateOutputChannelCounts(
        struct PaUtilHostApiRepresentation *hostApi,
        PaWinMmeDeviceAndChannelCount *devices,
        unsigned long deviceCount )
{
    unsigned int i;
    PaWinMmeDeviceInfo *outputDeviceInfo;
    PaError paerror;

    for( i=0; i < deviceCount; ++i )
    {
        if( devices[i].channelCount < 1 )
            return paInvalidChannelCount;

        outputDeviceInfo = 
                (PaWinMmeDeviceInfo*)hostApi->deviceInfos[ devices[i].device ];

        paerror = IsOutputChannelCountSupported( outputDeviceInfo, devices[i].channelCount );
        if( paerror != paNoError )
            return paerror;
    }

    return paNoError;
}


/* the following macros are intended to improve the readability of the following code */
#define PA_IS_INPUT_STREAM_( stream ) ( stream ->input.waveHandles )
#define PA_IS_OUTPUT_STREAM_( stream ) ( stream ->output.waveHandles )
#define PA_IS_FULL_DUPLEX_STREAM_( stream ) ( stream ->input.waveHandles && stream ->output.waveHandles )
#define PA_IS_HALF_DUPLEX_STREAM_( stream ) ( !(stream ->input.waveHandles && stream ->output.waveHandles) )

static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                           PaStream** s,
                           const PaStreamParameters *inputParameters,
                           const PaStreamParameters *outputParameters,
                           double sampleRate,
                           unsigned long framesPerBuffer,
                           PaStreamFlags streamFlags,
                           PaStreamCallback *streamCallback,
                           void *userData )
{
    PaError result;
    PaWinMmeHostApiRepresentation *winMmeHostApi = (PaWinMmeHostApiRepresentation*)hostApi;
    PaWinMmeStream *stream = 0;
    int bufferProcessorIsInitialized = 0;
    int streamRepresentationIsInitialized = 0;
    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
    int inputChannelCount, outputChannelCount;
    PaSampleFormat inputSampleFormat, outputSampleFormat;
    double suggestedInputLatency, suggestedOutputLatency;
    PaWinMmeStreamInfo *inputStreamInfo, *outputStreamInfo;
    PaWinWaveFormatChannelMask inputChannelMask, outputChannelMask;
    unsigned long framesPerHostInputBuffer;
    unsigned long hostInputBufferCount;
    unsigned long framesPerHostOutputBuffer;
    unsigned long hostOutputBufferCount;
    unsigned long framesPerBufferProcessorCall;
    PaWinMmeDeviceAndChannelCount *inputDevices = 0;  /* contains all devices and channel counts as local host api ids, even when PaWinMmeUseMultipleDevices is not used */
    unsigned long winMmeSpecificInputFlags = 0;
    unsigned long inputDeviceCount = 0;            
    PaWinMmeDeviceAndChannelCount *outputDevices = 0;
    unsigned long winMmeSpecificOutputFlags = 0;
    unsigned long outputDeviceCount = 0;                /* contains all devices and channel counts as local host api ids, even when PaWinMmeUseMultipleDevices is not used */
    char throttleProcessingThreadOnOverload = 1;

    
    if( inputParameters )
    {
        inputChannelCount = inputParameters->channelCount;
        inputSampleFormat = inputParameters->sampleFormat;
        suggestedInputLatency = inputParameters->suggestedLatency;

        inputDeviceCount = 1;

        /* validate input hostApiSpecificStreamInfo */
        inputStreamInfo = (PaWinMmeStreamInfo*)inputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinMmeSpecificStreamInfo( inputParameters, inputStreamInfo,
                &winMmeSpecificInputFlags,
                &throttleProcessingThreadOnOverload,
                &inputDeviceCount );
        if( result != paNoError ) return result;

        inputDevices = (PaWinMmeDeviceAndChannelCount*)alloca( sizeof(PaWinMmeDeviceAndChannelCount) * inputDeviceCount );
        if( !inputDevices ) return paInsufficientMemory;

        result = RetrieveDevicesFromStreamParameters( hostApi, inputParameters, inputStreamInfo, inputDevices, inputDeviceCount );
        if( result != paNoError ) return result;

        result = ValidateInputChannelCounts( hostApi, inputDevices, inputDeviceCount );
        if( result != paNoError ) return result;

        hostInputSampleFormat =
            PaUtil_SelectClosestAvailableFormat( paInt16 /* native formats */, inputSampleFormat );

        if( inputDeviceCount != 1 ){
            /* always use direct speakers when using multi-device multichannel mode */
            inputChannelMask = PAWIN_SPEAKER_DIRECTOUT;           
        }
        else
        {
            if( inputStreamInfo && inputStreamInfo->flags & paWinMmeUseChannelMask )
                inputChannelMask = inputStreamInfo->channelMask;
            else
                inputChannelMask = PaWin_DefaultChannelMask( inputDevices[0].channelCount );
        }
    }
    else
    {
        inputChannelCount = 0;
        inputSampleFormat = 0;
        suggestedInputLatency = 0.;
        inputStreamInfo = 0;
        hostInputSampleFormat = 0;
    }


    if( outputParameters )
    {
        outputChannelCount = outputParameters->channelCount;
        outputSampleFormat = outputParameters->sampleFormat;
        suggestedOutputLatency = outputParameters->suggestedLatency;

        outputDeviceCount = 1;

        /* validate output hostApiSpecificStreamInfo */
        outputStreamInfo = (PaWinMmeStreamInfo*)outputParameters->hostApiSpecificStreamInfo;
        result = ValidateWinMmeSpecificStreamInfo( outputParameters, outputStreamInfo,
                &winMmeSpecificOutputFlags,
                &throttleProcessingThreadOnOverload,
                &outputDeviceCount );
        if( result != paNoError ) return result;

        outputDevices = (PaWinMmeDeviceAndChannelCount*)alloca( sizeof(PaWinMmeDeviceAndChannelCount) * outputDeviceCount );
        if( !outputDevices ) return paInsufficientMemory;

        result = RetrieveDevicesFromStreamParameters( hostApi, outputParameters, outputStreamInfo, outputDevices, outputDeviceCount );
        if( result != paNoError ) return result;

        result = ValidateOutputChannelCounts( hostApi, outputDevices, outputDeviceCount );
        if( result != paNoError ) return result;

        hostOutputSampleFormat =
            PaUtil_SelectClosestAvailableFormat( paInt16 /* native formats */, outputSampleFormat );

        if( outputDeviceCount != 1 ){
            /* always use direct speakers when using multi-device multichannel mode */
            outputChannelMask = PAWIN_SPEAKER_DIRECTOUT;           
        }
        else
        {
            if( outputStreamInfo && outputStreamInfo->flags & paWinMmeUseChannelMask )
                outputChannelMask = outputStreamInfo->channelMask;
            else
                outputChannelMask = PaWin_DefaultChannelMask( outputDevices[0].channelCount );
        }
    }
    else
    {
        outputChannelCount = 0;
        outputSampleFormat = 0;
        outputStreamInfo = 0;
        hostOutputSampleFormat = 0;
        suggestedOutputLatency = 0.;
    }


    /*
        IMPLEMENT ME:
            - alter sampleRate to a close allowable rate if possible / necessary
    */


    /* validate platform specific flags */
    if( (streamFlags & paPlatformSpecificFlags) != 0 )
        return paInvalidFlag; /* unexpected platform specific flag */


    /* always disable clipping and dithering if we are outputting a raw spdif stream */
    if( (winMmeSpecificOutputFlags & paWinMmeWaveFormatDolbyAc3Spdif)
            || (winMmeSpecificOutputFlags & paWinMmeWaveFormatWmaSpdif) ){

        streamFlags = streamFlags | paClipOff | paDitherOff;
    }


    result = CalculateBufferSettings( &framesPerHostInputBuffer, &hostInputBufferCount,
                &framesPerHostOutputBuffer, &hostOutputBufferCount,
                inputChannelCount, hostInputSampleFormat, suggestedInputLatency, inputStreamInfo,
                outputChannelCount, hostOutputSampleFormat, suggestedOutputLatency, outputStreamInfo,
                sampleRate, framesPerBuffer );
    if( result != paNoError ) goto error;


    stream = (PaWinMmeStream*)PaUtil_AllocateMemory( sizeof(PaWinMmeStream) );
    if( !stream )
    {
        result = paInsufficientMemory;
        goto error;
    }

    InitializeSingleDirectionHandlesAndBuffers( &stream->input );
    InitializeSingleDirectionHandlesAndBuffers( &stream->output );

    stream->abortEvent = 0;
    stream->processingThread = 0;

    stream->throttleProcessingThreadOnOverload = throttleProcessingThreadOnOverload;

    PaUtil_InitializeStreamRepresentation( &stream->streamRepresentation,
                                           ( (streamCallback)
                                            ? &winMmeHostApi->callbackStreamInterface
                                            : &winMmeHostApi->blockingStreamInterface ),
                                           streamCallback, userData );
    streamRepresentationIsInitialized = 1;

    PaUtil_InitializeCpuLoadMeasurer( &stream->cpuLoadMeasurer, sampleRate );


    if( inputParameters && outputParameters ) /* full duplex */
    {
        if( framesPerHostInputBuffer < framesPerHostOutputBuffer )
        {
            assert( (framesPerHostOutputBuffer % framesPerHostInputBuffer) == 0 ); /* CalculateBufferSettings() should guarantee this condition */

            framesPerBufferProcessorCall = framesPerHostInputBuffer;
        }
        else
        {
            assert( (framesPerHostInputBuffer % framesPerHostOutputBuffer) == 0 ); /* CalculateBufferSettings() should guarantee this condition */
            
            framesPerBufferProcessorCall = framesPerHostOutputBuffer;
        }
    }
    else if( inputParameters )
    {
        framesPerBufferProcessorCall = framesPerHostInputBuffer;
    }
    else if( outputParameters )
    {
        framesPerBufferProcessorCall = framesPerHostOutputBuffer;
    }

    stream->input.framesPerBuffer = framesPerHostInputBuffer;
    stream->output.framesPerBuffer = framesPerHostOutputBuffer;

    result =  PaUtil_InitializeBufferProcessor( &stream->bufferProcessor,
                    inputChannelCount, inputSampleFormat, hostInputSampleFormat,
                    outputChannelCount, outputSampleFormat, hostOutputSampleFormat,
                    sampleRate, streamFlags, framesPerBuffer,
                    framesPerBufferProcessorCall, paUtilFixedHostBufferSize,
                    streamCallback, userData );
    if( result != paNoError ) goto error;
    
    bufferProcessorIsInitialized = 1;

    /* stream info input latency is the minimum buffering latency (unlike suggested and default which are *maximums*) */
    stream->streamRepresentation.streamInfo.inputLatency =
            (double)(PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor)
                + framesPerHostInputBuffer) / sampleRate;
    stream->streamRepresentation.streamInfo.outputLatency =
            (double)(PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor)
                + (framesPerHostOutputBuffer * (hostOutputBufferCount-1))) / sampleRate;
    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;

    stream->primeStreamUsingCallback = ( (streamFlags&paPrimeOutputBuffersUsingStreamCallback) && streamCallback ) ? 1 : 0;

    /* time to sleep when throttling due to >100% cpu usage.
        -a quater of a buffer's duration */
    stream->throttledSleepMsecs =
            (unsigned long)(stream->bufferProcessor.framesPerHostBuffer *
             stream->bufferProcessor.samplePeriod * .25 * 1000);

    stream->isStopped = 1;
    stream->isActive = 0;


    /* for maximum compatibility with multi-device multichannel drivers,
        we first open all devices, then we prepare all buffers, finally
        we start all devices ( in StartStream() ). teardown in reverse order.
    */

    if( inputParameters )
    {
        result = InitializeWaveHandles( winMmeHostApi, &stream->input,
                winMmeSpecificInputFlags,
                stream->bufferProcessor.bytesPerHostInputSample, sampleRate,
                inputDevices, inputDeviceCount, inputChannelMask, 1 /* isInput */ );
        if( result != paNoError ) goto error;
    }
    
    if( outputParameters )
    {
        result = InitializeWaveHandles( winMmeHostApi, &stream->output,
                winMmeSpecificOutputFlags,
                stream->bufferProcessor.bytesPerHostOutputSample, sampleRate,
                outputDevices, outputDeviceCount, outputChannelMask, 0 /* isInput */ );
        if( result != paNoError ) goto error;
    }

    if( inputParameters )
    {
        result = InitializeWaveHeaders( &stream->input, hostInputBufferCount,
                hostInputSampleFormat, framesPerHostInputBuffer, inputDevices, 1 /* isInput */ );
        if( result != paNoError ) goto error;
    }

    if( outputParameters )
    {
        result = InitializeWaveHeaders( &stream->output, hostOutputBufferCount,
                hostOutputSampleFormat, framesPerHostOutputBuffer, outputDevices, 0 /* not isInput */ );
        if( result != paNoError ) goto error;

        stream->allBuffersDurationMs = (DWORD) (1000.0 * (framesPerHostOutputBuffer * stream->output.bufferCount) / sampleRate);
    }
    else
    {
        stream->allBuffersDurationMs = (DWORD) (1000.0 * (framesPerHostInputBuffer * stream->input.bufferCount) / sampleRate);
    }

    
    if( streamCallback )
    {
        /* abort event is only needed for callback streams */
        result = CreateEventWithPaError( &stream->abortEvent, NULL, TRUE, FALSE, NULL );
        if( result != paNoError ) goto error;
    }

    *s = (PaStream*)stream;

    return result;

error:

    if( stream )
    {
        if( stream->abortEvent )
            CloseHandle( stream->abortEvent );
            
        TerminateWaveHeaders( &stream->output, 0 /* not isInput */ );
        TerminateWaveHeaders( &stream->input, 1 /* isInput */ );

        TerminateWaveHandles( &stream->output, 0 /* not isInput */, 1 /* currentlyProcessingAnError */ );
        TerminateWaveHandles( &stream->input, 1 /* isInput */, 1 /* currentlyProcessingAnError */ );

        if( bufferProcessorIsInitialized )
            PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );

        if( streamRepresentationIsInitialized )
            PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );

        PaUtil_FreeMemory( stream );
    }

    return result;
}


/* return non-zero if all current buffers are done */
static int BuffersAreDone( WAVEHDR **waveHeaders, unsigned int deviceCount, int bufferIndex )
{
    unsigned int i;
    
    for( i=0; i < deviceCount; ++i )
    {
        if( !(waveHeaders[i][ bufferIndex ].dwFlags & WHDR_DONE) )
        {
            return 0;
        }         
    }

    return 1;
}

static int CurrentInputBuffersAreDone( PaWinMmeStream *stream )
{
    return BuffersAreDone( stream->input.waveHeaders, stream->input.deviceCount, stream->input.currentBufferIndex );
}

static int CurrentOutputBuffersAreDone( PaWinMmeStream *stream )
{
    return BuffersAreDone( stream->output.waveHeaders, stream->output.deviceCount, stream->output.currentBufferIndex );
}


/* return non-zero if any buffers are queued */
static int NoBuffersAreQueued( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers )
{
    unsigned int i, j;

    if( handlesAndBuffers->waveHandles )
    {
        for( i=0; i < handlesAndBuffers->bufferCount; ++i )
        {
            for( j=0; j < handlesAndBuffers->deviceCount; ++j )
            {
                if( !( handlesAndBuffers->waveHeaders[ j ][ i ].dwFlags & WHDR_DONE) )
                {
                    return 0;
                }
            }
        }
    }

    return 1;
}


#define PA_CIRCULAR_INCREMENT_( current, max )\
    ( (((current) + 1) >= (max)) ? (0) : (current+1) )

#define PA_CIRCULAR_DECREMENT_( current, max )\
    ( ((current) == 0) ? ((max)-1) : (current-1) )
    

static signed long GetAvailableFrames( PaWinMmeSingleDirectionHandlesAndBuffers *handlesAndBuffers )
{
    signed long result = 0;
    unsigned int i;
    
    if( BuffersAreDone( handlesAndBuffers->waveHeaders, handlesAndBuffers->deviceCount, handlesAndBuffers->currentBufferIndex ) )
    {
        /* we could calculate the following in O(1) if we kept track of the
            last done buffer */
        result = handlesAndBuffers->framesPerBuffer - handlesAndBuffers->framesUsedInCurrentBuffer;

        i = PA_CIRCULAR_INCREMENT_( handlesAndBuffers->currentBufferIndex, handlesAndBuffers->bufferCount );
        while( i != handlesAndBuffers->currentBufferIndex )
        {
            if( BuffersAreDone( handlesAndBuffers->waveHeaders, handlesAndBuffers->deviceCount, i ) )
            {
                result += handlesAndBuffers->framesPerBuffer;
                i = PA_CIRCULAR_INCREMENT_( i, handlesAndBuffers->bufferCount );
            }
            else
                break;
        }
    }

    return result;
}


static PaError AdvanceToNextInputBuffer( PaWinMmeStream *stream )
{
    PaError result = paNoError;
    MMRESULT mmresult;
    unsigned int i;

    for( i=0; i < stream->input.deviceCount; ++i )
    {
        stream->input.waveHeaders[i][ stream->input.currentBufferIndex ].dwFlags &= ~WHDR_DONE;
        mmresult = waveInAddBuffer( ((HWAVEIN*)stream->input.waveHandles)[i],
                                    &stream->input.waveHeaders[i][ stream->input.currentBufferIndex ],
                                    sizeof(WAVEHDR) );
        if( mmresult != MMSYSERR_NOERROR )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
        }
    }

    stream->input.currentBufferIndex =
            PA_CIRCULAR_INCREMENT_( stream->input.currentBufferIndex, stream->input.bufferCount );

    stream->input.framesUsedInCurrentBuffer = 0;

    return result;
}


static PaError AdvanceToNextOutputBuffer( PaWinMmeStream *stream )
{
    PaError result = paNoError;
    MMRESULT mmresult;
    unsigned int i;

    for( i=0; i < stream->output.deviceCount; ++i )
    {
        mmresult = waveOutWrite( ((HWAVEOUT*)stream->output.waveHandles)[i],
                                 &stream->output.waveHeaders[i][ stream->output.currentBufferIndex ],
                                 sizeof(WAVEHDR) );
        if( mmresult != MMSYSERR_NOERROR )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
        }
    }

    stream->output.currentBufferIndex =
            PA_CIRCULAR_INCREMENT_( stream->output.currentBufferIndex, stream->output.bufferCount );

    stream->output.framesUsedInCurrentBuffer = 0;
    
    return result;
}


/* requeue all but the most recent input with the driver. Used for catching
    up after a total input buffer underrun */
static PaError CatchUpInputBuffers( PaWinMmeStream *stream )
{
    PaError result = paNoError;
    unsigned int i;
    
    for( i=0; i < stream->input.bufferCount - 1; ++i )
    {
        result = AdvanceToNextInputBuffer( stream );
        if( result != paNoError )
            break;
    }

    return result;
}


/* take the most recent output and duplicate it to all other output buffers
    and requeue them. Used for catching up after a total output buffer underrun.
*/
static PaError CatchUpOutputBuffers( PaWinMmeStream *stream )
{
    PaError result = paNoError;
    unsigned int i, j;
    unsigned int previousBufferIndex =
            PA_CIRCULAR_DECREMENT_( stream->output.currentBufferIndex, stream->output.bufferCount );

    for( i=0; i < stream->output.bufferCount - 1; ++i )
    {
        for( j=0; j < stream->output.deviceCount; ++j )
        {
            if( stream->output.waveHeaders[j][ stream->output.currentBufferIndex ].lpData
                    != stream->output.waveHeaders[j][ previousBufferIndex ].lpData )
            {
                CopyMemory( stream->output.waveHeaders[j][ stream->output.currentBufferIndex ].lpData,
                            stream->output.waveHeaders[j][ previousBufferIndex ].lpData,
                            stream->output.waveHeaders[j][ stream->output.currentBufferIndex ].dwBufferLength );
            }
        }

        result = AdvanceToNextOutputBuffer( stream );
        if( result != paNoError )
            break;
    }

    return result;
}


PA_THREAD_FUNC ProcessingThreadProc( void *pArg )
{
    PaWinMmeStream *stream = (PaWinMmeStream *)pArg;
    HANDLE events[3];
    int eventCount = 0;
    DWORD result = paNoError;
    DWORD waitResult;
    DWORD timeout = (unsigned long)(stream->allBuffersDurationMs * 0.5);
    int hostBuffersAvailable;
    signed int hostInputBufferIndex, hostOutputBufferIndex;
    PaStreamCallbackFlags statusFlags;
    int callbackResult;
    int done = 0;
    unsigned int channel, i;
    unsigned long framesProcessed;
    
    /* prepare event array for call to WaitForMultipleObjects() */
    if( stream->input.bufferEvent )
        events[eventCount++] = stream->input.bufferEvent;
    if( stream->output.bufferEvent )
        events[eventCount++] = stream->output.bufferEvent;
    events[eventCount++] = stream->abortEvent;

    statusFlags = 0; /** @todo support paInputUnderflow, paOutputOverflow and paNeverDropInput */
    
    /* loop until something causes us to stop */
    do{
        /* wait for MME to signal that a buffer is available, or for
            the PA abort event to be signaled.

          When this indicates that one or more buffers are available
          NoBuffersAreQueued() and Current*BuffersAreDone are used below to
          poll for additional done buffers. NoBuffersAreQueued() will fail
          to identify an underrun/overflow if the driver doesn't mark all done
          buffers prior to signalling the event. Some drivers do this
          (eg RME Digi96, and others don't eg VIA PC 97 input). This isn't a
          huge problem, it just means that we won't always be able to detect
          underflow/overflow.
        */
        waitResult = WaitForMultipleObjects( eventCount, events, FALSE /* wait all = FALSE */, timeout );
        if( waitResult == WAIT_FAILED )
        {
            result = paUnanticipatedHostError;
            /** @todo FIXME/REVIEW: can't return host error info from an asyncronous thread. see http://www.portaudio.com/trac/ticket/143 */
            done = 1;
        }
        else if( waitResult == WAIT_TIMEOUT )
        {
            /* if a timeout is encountered, continue */
        }

        if( stream->abortProcessing )
        {
            /* Pa_AbortStream() has been called, stop processing immediately */
            done = 1;
        }
        else if( stream->stopProcessing )
        {
            /* Pa_StopStream() has been called or the user callback returned
                non-zero, processing will continue until all output buffers
                are marked as done. The stream will stop immediately if it
                is input-only.
            */

            if( PA_IS_OUTPUT_STREAM_(stream) )
            {
                if( NoBuffersAreQueued( &stream->output ) )
                    done = 1; /* Will cause thread to return. */
            }
            else
            {
                /* input only stream */
                done = 1; /* Will cause thread to return. */
            }
        }
        else
        {
            hostBuffersAvailable = 1;

            /* process all available host buffers */
            do
            {
                hostInputBufferIndex = -1;
                hostOutputBufferIndex = -1;
                
                if( PA_IS_INPUT_STREAM_(stream) )
                {
                    if( CurrentInputBuffersAreDone( stream ) )
                    {
                        if( NoBuffersAreQueued( &stream->input ) )
                        {
                            /** @todo
                               if all of the other buffers are also ready then
                               we discard all but the most recent. This is an
                               input buffer overflow. FIXME: these buffers should
                               be passed to the callback in a paNeverDropInput
                               stream. http://www.portaudio.com/trac/ticket/142

                               note that it is also possible for an input overflow
                               to happen while the callback is processing a buffer.
                               that is handled further down.
                            */
                            result = CatchUpInputBuffers( stream );
                            if( result != paNoError )
                                done = 1;

                            statusFlags |= paInputOverflow;
                        }

                        hostInputBufferIndex = stream->input.currentBufferIndex;
                    }
                }

                if( PA_IS_OUTPUT_STREAM_(stream) )
                {
                    if( CurrentOutputBuffersAreDone( stream ) )
                    {
                        /* ok, we have an output buffer */
                        
                        if( NoBuffersAreQueued( &stream->output ) )
                        {
                            /*
                            if all of the other buffers are also ready, catch up by copying
                            the most recently generated buffer into all but one of the output
                            buffers.

                            note that this catch up code only handles the case where all
                            buffers have been played out due to this thread not having
                            woken up at all. a more common case occurs when this thread
                            is woken up, processes one buffer, but takes too long, and as
                            a result all the other buffers have become un-queued. that
                            case is handled further down.
                            */

                            result = CatchUpOutputBuffers( stream );
                            if( result != paNoError )
                                done = 1;

                            statusFlags |= paOutputUnderflow;
                        }

                        hostOutputBufferIndex = stream->output.currentBufferIndex;
                    }
                }

               
                if( (PA_IS_FULL_DUPLEX_STREAM_(stream) && hostInputBufferIndex != -1 && hostOutputBufferIndex != -1) ||
                        (PA_IS_HALF_DUPLEX_STREAM_(stream) && ( hostInputBufferIndex != -1 || hostOutputBufferIndex != -1 ) ) )
                {
                    PaStreamCallbackTimeInfo timeInfo = {0,0,0}; /** @todo implement inputBufferAdcTime */


                    if( PA_IS_OUTPUT_STREAM_(stream) )
                    {
                        /* set timeInfo.currentTime and calculate timeInfo.outputBufferDacTime
                            from the current wave out position */
                        MMTIME mmtime;
                        double timeBeforeGetPosition, timeAfterGetPosition;
                        double time;
                        long framesInBufferRing; 		
                        long writePosition;
                        long playbackPosition;
                        HWAVEOUT firstWaveOutDevice = ((HWAVEOUT*)stream->output.waveHandles)[0];
                        
                        mmtime.wType = TIME_SAMPLES;
                        timeBeforeGetPosition = PaUtil_GetTime();
                        waveOutGetPosition( firstWaveOutDevice, &mmtime, sizeof(MMTIME) );
                        timeAfterGetPosition = PaUtil_GetTime();

                        timeInfo.currentTime = timeAfterGetPosition;

                        /* approximate time at which wave out position was measured
                            as half way between timeBeforeGetPosition and timeAfterGetPosition */
                        time = timeBeforeGetPosition + (timeAfterGetPosition - timeBeforeGetPosition) * .5;
                        
                        framesInBufferRing = stream->output.bufferCount * stream->bufferProcessor.framesPerHostBuffer;
                        playbackPosition = mmtime.u.sample % framesInBufferRing;

                        writePosition = stream->output.currentBufferIndex * stream->bufferProcessor.framesPerHostBuffer
                                + stream->output.framesUsedInCurrentBuffer;
                       
                        if( playbackPosition >= writePosition ){
                            timeInfo.outputBufferDacTime =
                                    time + ((double)( writePosition + (framesInBufferRing - playbackPosition) ) * stream->bufferProcessor.samplePeriod );
                        }else{
                            timeInfo.outputBufferDacTime =
                                    time + ((double)( writePosition - playbackPosition ) * stream->bufferProcessor.samplePeriod );
                        }
                    }


                    PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );

                    PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, statusFlags  );

                    /* reset status flags once they have been passed to the buffer processor */
                    statusFlags = 0;

                    if( PA_IS_INPUT_STREAM_(stream) )
                    {
                        PaUtil_SetInputFrameCount( &stream->bufferProcessor, 0 /* default to host buffer size */ );

                        channel = 0;
                        for( i=0; i<stream->input.deviceCount; ++i )
                        {
                             /* we have stored the number of channels in the buffer in dwUser */
                            int channelCount = (int)stream->input.waveHeaders[i][ hostInputBufferIndex ].dwUser;
                            
                            PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor, channel,
                                    stream->input.waveHeaders[i][ hostInputBufferIndex ].lpData +
                                        stream->input.framesUsedInCurrentBuffer * channelCount *
                                        stream->bufferProcessor.bytesPerHostInputSample,
                                    channelCount );
                                    

                            channel += channelCount;
                        }
                    }

                    if( PA_IS_OUTPUT_STREAM_(stream) )
                    {
                        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, 0 /* default to host buffer size */ );
                        
                        channel = 0;
                        for( i=0; i<stream->output.deviceCount; ++i )
                        {
                            /* we have stored the number of channels in the buffer in dwUser */
                            int channelCount = (int)stream->output.waveHeaders[i][ hostOutputBufferIndex ].dwUser;

                            PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, channel,
                                    stream->output.waveHeaders[i][ hostOutputBufferIndex ].lpData +
                                        stream->output.framesUsedInCurrentBuffer * channelCount *
                                        stream->bufferProcessor.bytesPerHostOutputSample,
                                    channelCount );

                            channel += channelCount;
                        }
                    }

                    callbackResult = paContinue;
                    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );

                    stream->input.framesUsedInCurrentBuffer += framesProcessed;
                    stream->output.framesUsedInCurrentBuffer += framesProcessed;

                    PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );

                    if( callbackResult == paContinue )
                    {
                        /* nothing special to do */
                    }
                    else if( callbackResult == paAbort )
                    {
                        stream->abortProcessing = 1;
                        done = 1;
                        /** @todo FIXME: should probably reset the output device immediately once the callback returns paAbort 
                            see: http://www.portaudio.com/trac/ticket/141
                        */
                        result = paNoError;
                    }
                    else
                    {
                        /* User callback has asked us to stop with paComplete or other non-zero value */
                        stream->stopProcessing = 1; /* stop once currently queued audio has finished */
                        result = paNoError;
                    }


                    if( PA_IS_INPUT_STREAM_(stream)
                            && stream->stopProcessing == 0 && stream->abortProcessing == 0
                            && stream->input.framesUsedInCurrentBuffer == stream->input.framesPerBuffer )
                    {
                        if( NoBuffersAreQueued( &stream->input ) )
                        {
                            /** @todo need to handle PaNeverDropInput here where necessary */
                            result = CatchUpInputBuffers( stream );
                            if( result != paNoError )
                                done = 1;

                            statusFlags |= paInputOverflow;
                        }

                        result = AdvanceToNextInputBuffer( stream );
                        if( result != paNoError )
                            done = 1;
                    }

                    
                    if( PA_IS_OUTPUT_STREAM_(stream) && !stream->abortProcessing )
                    {
                        if( stream->stopProcessing &&
                                stream->output.framesUsedInCurrentBuffer < stream->output.framesPerBuffer )
                        {
                            /* zero remaining samples in output output buffer and flush */

                            stream->output.framesUsedInCurrentBuffer += PaUtil_ZeroOutput( &stream->bufferProcessor,
                                    stream->output.framesPerBuffer - stream->output.framesUsedInCurrentBuffer );

                            /* we send the entire buffer to the output devices, but we could
                                just send a partial buffer, rather than zeroing the unused
                                samples.
                            */
                        }

                        if( stream->output.framesUsedInCurrentBuffer == stream->output.framesPerBuffer )
                        {
                            /* check for underflow before enquing the just-generated buffer,
                                but recover from underflow after enquing it. This ensures
                                that the most recent audio segment is repeated */
                            int outputUnderflow = NoBuffersAreQueued( &stream->output );

                            result = AdvanceToNextOutputBuffer( stream );
                            if( result != paNoError )
                                done = 1;

                            if( outputUnderflow && !done && !stream->stopProcessing )
                            {
                                /* Recover from underflow in the case where the
                                    underflow occured while processing the buffer
                                    we just finished */

                                result = CatchUpOutputBuffers( stream );
                                if( result != paNoError )
                                    done = 1;

                                statusFlags |= paOutputUnderflow;
                            }
                        }
                    }
                    
                    if( stream->throttleProcessingThreadOnOverload != 0 )
                    {
                        if( stream->stopProcessing || stream->abortProcessing )
                        {
                            if( stream->processingThreadPriority != stream->highThreadPriority )
                            {
                                SetThreadPriority( stream->processingThread, stream->highThreadPriority );
                                stream->processingThreadPriority = stream->highThreadPriority;
                            }
                        }
                        else if( PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer ) > 1. )
                        {
                            if( stream->processingThreadPriority != stream->throttledThreadPriority )
                            {
                                SetThreadPriority( stream->processingThread, stream->throttledThreadPriority );
                                stream->processingThreadPriority = stream->throttledThreadPriority;
                            }

                            /* sleep to give other processes a go */
                            Sleep( stream->throttledSleepMsecs );
                        }
                        else
                        {
                            if( stream->processingThreadPriority != stream->highThreadPriority )
                            {
                                SetThreadPriority( stream->processingThread, stream->highThreadPriority );
                                stream->processingThreadPriority = stream->highThreadPriority;
                            }
                        }
                    }
                }
                else
                {
                    hostBuffersAvailable = 0;
                }
            }
            while( hostBuffersAvailable &&
                    stream->stopProcessing == 0 &&
                    stream->abortProcessing == 0 &&
                    !done );
        }
    }
    while( !done );

    stream->isActive = 0;

    if( stream->streamRepresentation.streamFinishedCallback != 0 )
        stream->streamRepresentation.streamFinishedCallback( stream->streamRepresentation.userData );

    PaUtil_ResetCpuLoadMeasurer( &stream->cpuLoadMeasurer );
    
    return result;
}


/*
    When CloseStream() is called, the multi-api layer ensures that
    the stream has already been stopped or aborted.
*/
static PaError CloseStream( PaStream* s )
{
    PaError result;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;

    result = CloseHandleWithPaError( stream->abortEvent );
    if( result != paNoError ) goto error;
    
    TerminateWaveHeaders( &stream->output, 0 /* not isInput */ );
    TerminateWaveHeaders( &stream->input, 1 /* isInput */ );

    TerminateWaveHandles( &stream->output, 0 /* not isInput */, 0 /* not currentlyProcessingAnError */ );
    TerminateWaveHandles( &stream->input, 1 /* isInput */, 0 /* not currentlyProcessingAnError */ );
    
    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
    PaUtil_FreeMemory( stream );

error:
    /** @todo REVIEW: what is the best way to clean up a stream if an error is detected? */
    return result;
}


static PaError StartStream( PaStream *s )
{
    PaError result;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    MMRESULT mmresult;
    unsigned int i, j;
    int callbackResult;
    unsigned int channel;
    unsigned long framesProcessed;
    PaStreamCallbackTimeInfo timeInfo = {0,0,0}; /** @todo implement this for stream priming */
    
    PaUtil_ResetBufferProcessor( &stream->bufferProcessor );
    
    if( PA_IS_INPUT_STREAM_(stream) )
    {
        for( i=0; i<stream->input.bufferCount; ++i )
        {
            for( j=0; j<stream->input.deviceCount; ++j )
            {
                stream->input.waveHeaders[j][i].dwFlags &= ~WHDR_DONE;
                mmresult = waveInAddBuffer( ((HWAVEIN*)stream->input.waveHandles)[j], &stream->input.waveHeaders[j][i], sizeof(WAVEHDR) );
                if( mmresult != MMSYSERR_NOERROR )
                {
                    result = paUnanticipatedHostError;
                    PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                    goto error;
                }
            }
        }
        stream->input.currentBufferIndex = 0;
        stream->input.framesUsedInCurrentBuffer = 0;
    }

    if( PA_IS_OUTPUT_STREAM_(stream) )
    {
        for( i=0; i<stream->output.deviceCount; ++i )
        {
            if( (mmresult = waveOutPause( ((HWAVEOUT*)stream->output.waveHandles)[i] )) != MMSYSERR_NOERROR )
            {
                result = paUnanticipatedHostError;
                PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                goto error;
            }
        }

        for( i=0; i<stream->output.bufferCount; ++i )
        {
            if( stream->primeStreamUsingCallback )
            {

                stream->output.framesUsedInCurrentBuffer = 0;
                do{

                    PaUtil_BeginBufferProcessing( &stream->bufferProcessor,
                            &timeInfo,
                            paPrimingOutput | ((stream->input.bufferCount > 0 ) ? paInputUnderflow : 0));

                    if( stream->input.bufferCount > 0 )
                        PaUtil_SetNoInput( &stream->bufferProcessor );

                    PaUtil_SetOutputFrameCount( &stream->bufferProcessor, 0 /* default to host buffer size */ );

                    channel = 0;
                    for( j=0; j<stream->output.deviceCount; ++j )
                    {
                        /* we have stored the number of channels in the buffer in dwUser */
                        int channelCount = (int)stream->output.waveHeaders[j][i].dwUser;

                        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, channel,
                                stream->output.waveHeaders[j][i].lpData +
                                stream->output.framesUsedInCurrentBuffer * channelCount *
                                stream->bufferProcessor.bytesPerHostOutputSample,
                                channelCount );

                        /* we have stored the number of channels in the buffer in dwUser */
                        channel += channelCount;
                    }

                    callbackResult = paContinue;
                    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );
                    stream->output.framesUsedInCurrentBuffer += framesProcessed;

                    if( callbackResult != paContinue )
                    {
                        /** @todo fix this, what do we do if callback result is non-zero during stream
                            priming?

                            for complete: play out primed waveHeaders as usual
                            for abort: clean up immediately.
                       */
                    }

                }while( stream->output.framesUsedInCurrentBuffer != stream->output.framesPerBuffer );

            }
            else
            {
                for( j=0; j<stream->output.deviceCount; ++j )
                {
                    ZeroMemory( stream->output.waveHeaders[j][i].lpData, stream->output.waveHeaders[j][i].dwBufferLength );
                }
            }   

            /* we queue all channels of a single buffer frame (accross all
                devices, because some multidevice multichannel drivers work
                better this way */
            for( j=0; j<stream->output.deviceCount; ++j )
            {
                mmresult = waveOutWrite( ((HWAVEOUT*)stream->output.waveHandles)[j], &stream->output.waveHeaders[j][i], sizeof(WAVEHDR) );
                if( mmresult != MMSYSERR_NOERROR )
                {
                    result = paUnanticipatedHostError;
                    PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                    goto error;
                }
            }
        }
        stream->output.currentBufferIndex = 0;
        stream->output.framesUsedInCurrentBuffer = 0;
    }


    stream->isStopped = 0;
    stream->isActive = 1;
    stream->stopProcessing = 0;
    stream->abortProcessing = 0;

    result = ResetEventWithPaError( stream->input.bufferEvent );
    if( result != paNoError ) goto error;

    result = ResetEventWithPaError( stream->output.bufferEvent );
    if( result != paNoError ) goto error;
    
    
    if( stream->streamRepresentation.streamCallback )
    {
        /* callback stream */

        result = ResetEventWithPaError( stream->abortEvent );
        if( result != paNoError ) goto error;

        /* Create thread that waits for audio buffers to be ready for processing. */
        stream->processingThread = CREATE_THREAD;
        if( !stream->processingThread )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_SYSTEM_ERROR( GetLastError() );
            goto error;
        }

        /** @todo could have mme specific stream parameters to allow the user
            to set the callback thread priorities */
        stream->highThreadPriority = THREAD_PRIORITY_TIME_CRITICAL;
        stream->throttledThreadPriority = THREAD_PRIORITY_NORMAL;

        if( !SetThreadPriority( stream->processingThread, stream->highThreadPriority ) )
        {
            result = paUnanticipatedHostError;
            PA_MME_SET_LAST_SYSTEM_ERROR( GetLastError() );
            goto error;
        }
        stream->processingThreadPriority = stream->highThreadPriority;
    }
    else
    {
        /* blocking read/write stream */

    }

    if( PA_IS_INPUT_STREAM_(stream) )
    {
        for( i=0; i < stream->input.deviceCount; ++i )
        {
            mmresult = waveInStart( ((HWAVEIN*)stream->input.waveHandles)[i] );
            PA_DEBUG(("Pa_StartStream: waveInStart returned = 0x%X.\n", mmresult));
            if( mmresult != MMSYSERR_NOERROR )
            {
                result = paUnanticipatedHostError;
                PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                goto error;
            }
        }
    }

    if( PA_IS_OUTPUT_STREAM_(stream) )
    {
        for( i=0; i < stream->output.deviceCount; ++i )
        {
            if( (mmresult = waveOutRestart( ((HWAVEOUT*)stream->output.waveHandles)[i] )) != MMSYSERR_NOERROR )
            {
                result = paUnanticipatedHostError;
                PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                goto error;
            }
        }
    }

    return result;

error:
    /** @todo FIXME: implement recovery as best we can
    This should involve rolling back to a state as-if this function had never been called
    */
    return result;
}


static PaError StopStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    int timeout;
    DWORD waitResult;
    MMRESULT mmresult;
    signed int hostOutputBufferIndex;
    unsigned int channel, waitCount, i;                  
    
    /** @todo
        REVIEW: the error checking in this function needs review. the basic
        idea is to return from this function in a known state - for example
        there is no point avoiding calling waveInReset just because
        the thread times out.
    */

    if( stream->processingThread )
    {
        /* callback stream */

        /* Tell processing thread to stop generating more data and to let current data play out. */
        stream->stopProcessing = 1;

        /* Calculate timeOut longer than longest time it could take to return all buffers. */
        timeout = (int)(stream->allBuffersDurationMs * 1.5);
        if( timeout < PA_MME_MIN_TIMEOUT_MSEC_ )
            timeout = PA_MME_MIN_TIMEOUT_MSEC_;

        PA_DEBUG(("WinMME StopStream: waiting for background thread.\n"));

        waitResult = WaitForSingleObject( stream->processingThread, timeout );
        if( waitResult == WAIT_TIMEOUT )
        {
            /* try to abort */
            stream->abortProcessing = 1;
            SetEvent( stream->abortEvent );
            waitResult = WaitForSingleObject( stream->processingThread, timeout );
            if( waitResult == WAIT_TIMEOUT )
            {
                PA_DEBUG(("WinMME StopStream: timed out while waiting for background thread to finish.\n"));
                result = paTimedOut;
            }
        }

        CloseHandle( stream->processingThread );
        stream->processingThread = NULL;
    }
    else
    {
        /* blocking read / write stream */

        if( PA_IS_OUTPUT_STREAM_(stream) )
        {
            if( stream->output.framesUsedInCurrentBuffer > 0 )
            {
                /* there are still unqueued frames in the current buffer, so flush them */

                hostOutputBufferIndex = stream->output.currentBufferIndex;

                PaUtil_SetOutputFrameCount( &stream->bufferProcessor,
                        stream->output.framesPerBuffer - stream->output.framesUsedInCurrentBuffer );
                
                channel = 0;
                for( i=0; i<stream->output.deviceCount; ++i )
                {
                    /* we have stored the number of channels in the buffer in dwUser */
                    int channelCount = (int)stream->output.waveHeaders[i][ hostOutputBufferIndex ].dwUser;

                    PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, channel,
                            stream->output.waveHeaders[i][ hostOutputBufferIndex ].lpData +
                                stream->output.framesUsedInCurrentBuffer * channelCount *
                                stream->bufferProcessor.bytesPerHostOutputSample,
                            channelCount );

                    channel += channelCount;
                }

                PaUtil_ZeroOutput( &stream->bufferProcessor,
                        stream->output.framesPerBuffer - stream->output.framesUsedInCurrentBuffer );

                /* we send the entire buffer to the output devices, but we could
                    just send a partial buffer, rather than zeroing the unused
                    samples.
                */
                AdvanceToNextOutputBuffer( stream );
            }
            

            timeout = (stream->allBuffersDurationMs / stream->output.bufferCount) + 1;
            if( timeout < PA_MME_MIN_TIMEOUT_MSEC_ )
                timeout = PA_MME_MIN_TIMEOUT_MSEC_;

            waitCount = 0;
            while( !NoBuffersAreQueued( &stream->output ) && waitCount <= stream->output.bufferCount )
            {
                /* wait for MME to signal that a buffer is available */
                waitResult = WaitForSingleObject( stream->output.bufferEvent, timeout );
                if( waitResult == WAIT_FAILED )
                {
                    break;
                }
                else if( waitResult == WAIT_TIMEOUT )
                {
                    /* keep waiting */
                }

                ++waitCount;
            }
        }
    }

    if( PA_IS_OUTPUT_STREAM_(stream) )
    {
        for( i =0; i < stream->output.deviceCount; ++i )
        {
            mmresult = waveOutReset( ((HWAVEOUT*)stream->output.waveHandles)[i] );
            if( mmresult != MMSYSERR_NOERROR )
            {
                result = paUnanticipatedHostError;
                PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
            }
        }
    }

    if( PA_IS_INPUT_STREAM_(stream) )
    {
        for( i=0; i < stream->input.deviceCount; ++i )
        {
            mmresult = waveInReset( ((HWAVEIN*)stream->input.waveHandles)[i] );
            if( mmresult != MMSYSERR_NOERROR )
            {
                result = paUnanticipatedHostError;
                PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
            }
        }
    }

    stream->isStopped = 1;
    stream->isActive = 0;

    return result;
}


static PaError AbortStream( PaStream *s )
{
    PaError result = paNoError;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    int timeout;
    DWORD waitResult;
    MMRESULT mmresult;
    unsigned int i;
    
    /** @todo
        REVIEW: the error checking in this function needs review. the basic
        idea is to return from this function in a known state - for example
        there is no point avoiding calling waveInReset just because
        the thread times out.
    */

    if( stream->processingThread )
    {
        /* callback stream */
        
        /* Tell processing thread to abort immediately */
        stream->abortProcessing = 1;
        SetEvent( stream->abortEvent );
    }


    if( PA_IS_OUTPUT_STREAM_(stream) )
    {
        for( i =0; i < stream->output.deviceCount; ++i )
        {
            mmresult = waveOutReset( ((HWAVEOUT*)stream->output.waveHandles)[i] );
            if( mmresult != MMSYSERR_NOERROR )
            {
                PA_MME_SET_LAST_WAVEOUT_ERROR( mmresult );
                return paUnanticipatedHostError;
            }
        }
    }

    if( PA_IS_INPUT_STREAM_(stream) )
    {
        for( i=0; i < stream->input.deviceCount; ++i )
        {
            mmresult = waveInReset( ((HWAVEIN*)stream->input.waveHandles)[i] );
            if( mmresult != MMSYSERR_NOERROR )
            {
                PA_MME_SET_LAST_WAVEIN_ERROR( mmresult );
                return paUnanticipatedHostError;
            }
        }
    }


    if( stream->processingThread )
    {
        /* callback stream */
        
        PA_DEBUG(("WinMME AbortStream: waiting for background thread.\n"));

        /* Calculate timeOut longer than longest time it could take to return all buffers. */
        timeout = (int)(stream->allBuffersDurationMs * 1.5);
        if( timeout < PA_MME_MIN_TIMEOUT_MSEC_ )
            timeout = PA_MME_MIN_TIMEOUT_MSEC_;
            
        waitResult = WaitForSingleObject( stream->processingThread, timeout );
        if( waitResult == WAIT_TIMEOUT )
        {
            PA_DEBUG(("WinMME AbortStream: timed out while waiting for background thread to finish.\n"));
            return paTimedOut;
        }

        CloseHandle( stream->processingThread );
        stream->processingThread = NULL;
    }

    stream->isStopped = 1;
    stream->isActive = 0;

    return result;
}


static PaError IsStreamStopped( PaStream *s )
{
    PaWinMmeStream *stream = (PaWinMmeStream*)s;

    return stream->isStopped;
}


static PaError IsStreamActive( PaStream *s )
{
    PaWinMmeStream *stream = (PaWinMmeStream*)s;

    return stream->isActive;
}


static PaTime GetStreamTime( PaStream *s )
{
    (void) s; /* unused parameter */
    
    return PaUtil_GetTime();
}


static double GetStreamCpuLoad( PaStream* s )
{
    PaWinMmeStream *stream = (PaWinMmeStream*)s;

    return PaUtil_GetCpuLoad( &stream->cpuLoadMeasurer );
}


/*
    As separate stream interfaces are used for blocking and callback
    streams, the following functions can be guaranteed to only be called
    for blocking streams.
*/

static PaError ReadStream( PaStream* s,
                           void *buffer,
                           unsigned long frames )
{
    PaError result = paNoError;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    void *userBuffer;
    unsigned long framesRead = 0;
    unsigned long framesProcessed;
    signed int hostInputBufferIndex;
    DWORD waitResult;
    DWORD timeout = (unsigned long)(stream->allBuffersDurationMs * 0.5);
    unsigned int channel, i;
    
    if( PA_IS_INPUT_STREAM_(stream) )
    {
        /* make a local copy of the user buffer pointer(s). this is necessary
            because PaUtil_CopyInput() advances these pointers every time
            it is called.
        */
        if( stream->bufferProcessor.userInputIsInterleaved )
        {
            userBuffer = buffer;
        }
        else
        {
            userBuffer = (void*)alloca( sizeof(void*) * stream->bufferProcessor.inputChannelCount );
            if( !userBuffer )
                return paInsufficientMemory;
            for( i = 0; i<stream->bufferProcessor.inputChannelCount; ++i )
                ((void**)userBuffer)[i] = ((void**)buffer)[i];
        }
        
        do{
            if( CurrentInputBuffersAreDone( stream ) )
            {
                if( NoBuffersAreQueued( &stream->input ) )
                {
                    /** @todo REVIEW: consider what to do if the input overflows.
                        do we requeue all of the buffers? should we be running
                        a thread to make sure they are always queued? 
                        see: http://www.portaudio.com/trac/ticket/117
                        */

                    result = paInputOverflowed;
                }

                hostInputBufferIndex = stream->input.currentBufferIndex;

                PaUtil_SetInputFrameCount( &stream->bufferProcessor,
                        stream->input.framesPerBuffer - stream->input.framesUsedInCurrentBuffer );
                
                channel = 0;
                for( i=0; i<stream->input.deviceCount; ++i )
                {
                    /* we have stored the number of channels in the buffer in dwUser */
                    int channelCount = (int)stream->input.waveHeaders[i][ hostInputBufferIndex ].dwUser;

                    PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor, channel,
                            stream->input.waveHeaders[i][ hostInputBufferIndex ].lpData +
                                stream->input.framesUsedInCurrentBuffer * channelCount *
                                stream->bufferProcessor.bytesPerHostInputSample,
                            channelCount );

                    channel += channelCount;
                }
                
                framesProcessed = PaUtil_CopyInput( &stream->bufferProcessor, &userBuffer, frames - framesRead );

                stream->input.framesUsedInCurrentBuffer += framesProcessed;
                if( stream->input.framesUsedInCurrentBuffer == stream->input.framesPerBuffer )
                {
                    result = AdvanceToNextInputBuffer( stream );
                    if( result != paNoError )
                        break;
                }

                framesRead += framesProcessed;      

            }else{
                /* wait for MME to signal that a buffer is available */
                waitResult = WaitForSingleObject( stream->input.bufferEvent, timeout );
                if( waitResult == WAIT_FAILED )
                {
                    result = paUnanticipatedHostError;
                    break;
                }
                else if( waitResult == WAIT_TIMEOUT )
                {
                    /* if a timeout is encountered, continue,
                        perhaps we should give up eventually
                    */
                }         
            }
        }while( framesRead < frames );
    }
    else
    {
        result = paCanNotReadFromAnOutputOnlyStream;
    }

    return result;
}


static PaError WriteStream( PaStream* s,
                            const void *buffer,
                            unsigned long frames )
{
    PaError result = paNoError;
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    const void *userBuffer;
    unsigned long framesWritten = 0;
    unsigned long framesProcessed;
    signed int hostOutputBufferIndex;
    DWORD waitResult;
    DWORD timeout = (unsigned long)(stream->allBuffersDurationMs * 0.5);
    unsigned int channel, i;

        
    if( PA_IS_OUTPUT_STREAM_(stream) )
    {
        /* make a local copy of the user buffer pointer(s). this is necessary
            because PaUtil_CopyOutput() advances these pointers every time
            it is called.
        */
        if( stream->bufferProcessor.userOutputIsInterleaved )
        {
            userBuffer = buffer;
        }
        else
        {
            userBuffer = (const void*)alloca( sizeof(void*) * stream->bufferProcessor.outputChannelCount );
            if( !userBuffer )
                return paInsufficientMemory;
            for( i = 0; i<stream->bufferProcessor.outputChannelCount; ++i )
                ((const void**)userBuffer)[i] = ((const void**)buffer)[i];
        }

        do{
            if( CurrentOutputBuffersAreDone( stream ) )
            {
                if( NoBuffersAreQueued( &stream->output ) )
                {
                    /** @todo REVIEW: consider what to do if the output
                    underflows. do we requeue all the existing buffers with
                    zeros? should we run a separate thread to keep the buffers
                    enqueued at all times? 
                    see: http://www.portaudio.com/trac/ticket/117
                    */

                    result = paOutputUnderflowed;
                }

                hostOutputBufferIndex = stream->output.currentBufferIndex;

                PaUtil_SetOutputFrameCount( &stream->bufferProcessor,
                        stream->output.framesPerBuffer - stream->output.framesUsedInCurrentBuffer );
                
                channel = 0;
                for( i=0; i<stream->output.deviceCount; ++i )
                {
                    /* we have stored the number of channels in the buffer in dwUser */
                    int channelCount = (int)stream->output.waveHeaders[i][ hostOutputBufferIndex ].dwUser;

                    PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor, channel,
                            stream->output.waveHeaders[i][ hostOutputBufferIndex ].lpData +
                                stream->output.framesUsedInCurrentBuffer * channelCount *
                                stream->bufferProcessor.bytesPerHostOutputSample,
                            channelCount );

                    channel += channelCount;
                }
                
                framesProcessed = PaUtil_CopyOutput( &stream->bufferProcessor, &userBuffer, frames - framesWritten );

                stream->output.framesUsedInCurrentBuffer += framesProcessed;
                if( stream->output.framesUsedInCurrentBuffer == stream->output.framesPerBuffer )
                {
                    result = AdvanceToNextOutputBuffer( stream );
                    if( result != paNoError )
                        break;
                }

                framesWritten += framesProcessed;
            }
            else
            {
                /* wait for MME to signal that a buffer is available */
                waitResult = WaitForSingleObject( stream->output.bufferEvent, timeout );
                if( waitResult == WAIT_FAILED )
                {
                    result = paUnanticipatedHostError;
                    break;
                }
                else if( waitResult == WAIT_TIMEOUT )
                {
                    /* if a timeout is encountered, continue,
                        perhaps we should give up eventually
                    */
                }             
            }        
        }while( framesWritten < frames );
    }
    else
    {
        result = paCanNotWriteToAnInputOnlyStream;
    }
    
    return result;
}


static signed long GetStreamReadAvailable( PaStream* s )
{
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    
    if( PA_IS_INPUT_STREAM_(stream) )
        return GetAvailableFrames( &stream->input );
    else
        return paCanNotReadFromAnOutputOnlyStream;
}


static signed long GetStreamWriteAvailable( PaStream* s )
{
    PaWinMmeStream *stream = (PaWinMmeStream*)s;
    
    if( PA_IS_OUTPUT_STREAM_(stream) )
        return GetAvailableFrames( &stream->output );
    else
        return paCanNotWriteToAnInputOnlyStream;
}


/* NOTE: the following functions are MME-stream specific, and are called directly
    by client code. We need to check for many more error conditions here because
    we don't have the benefit of pa_front.c's parameter checking.
*/

static PaError GetWinMMEStreamPointer( PaWinMmeStream **stream, PaStream *s )
{
    PaError result;
    PaUtilHostApiRepresentation *hostApi;
    PaWinMmeHostApiRepresentation *winMmeHostApi;
    
    result = PaUtil_ValidateStreamPointer( s );
    if( result != paNoError )
        return result;

    result = PaUtil_GetHostApiRepresentation( &hostApi, paMME );
    if( result != paNoError )
        return result;

    winMmeHostApi = (PaWinMmeHostApiRepresentation*)hostApi;
    
    /* note, the following would be easier if there was a generic way of testing
        that a stream belongs to a specific host API */
    
    if( PA_STREAM_REP( s )->streamInterface == &winMmeHostApi->callbackStreamInterface
            || PA_STREAM_REP( s )->streamInterface == &winMmeHostApi->blockingStreamInterface )
    {
        /* s is a WinMME stream */
        *stream = (PaWinMmeStream *)s;
        return paNoError;
    }
    else
    {
        return paIncompatibleStreamHostApi;
    }
}


int PaWinMME_GetStreamInputHandleCount( PaStream* s )
{
    PaWinMmeStream *stream;
    PaError result = GetWinMMEStreamPointer( &stream, s );

    if( result == paNoError )
        return (PA_IS_INPUT_STREAM_(stream)) ? stream->input.deviceCount : 0;
    else
        return result;
}


HWAVEIN PaWinMME_GetStreamInputHandle( PaStream* s, int handleIndex )
{
    PaWinMmeStream *stream;
    PaError result = GetWinMMEStreamPointer( &stream, s );

    if( result == paNoError
            && PA_IS_INPUT_STREAM_(stream)
            && handleIndex >= 0
            && (unsigned int)handleIndex < stream->input.deviceCount )
        return ((HWAVEIN*)stream->input.waveHandles)[handleIndex];
    else
        return 0;
}


int PaWinMME_GetStreamOutputHandleCount( PaStream* s)
{
    PaWinMmeStream *stream;
    PaError result = GetWinMMEStreamPointer( &stream, s );

    if( result == paNoError )
        return (PA_IS_OUTPUT_STREAM_(stream)) ? stream->output.deviceCount : 0;
    else
        return result;
}


HWAVEOUT PaWinMME_GetStreamOutputHandle( PaStream* s, int handleIndex )
{
    PaWinMmeStream *stream;
    PaError result = GetWinMMEStreamPointer( &stream, s );

    if( result == paNoError
            && PA_IS_OUTPUT_STREAM_(stream)
            && handleIndex >= 0
            && (unsigned int)handleIndex < stream->output.deviceCount )
        return ((HWAVEOUT*)stream->output.waveHandles)[handleIndex];
    else
        return 0;
}
#endif
